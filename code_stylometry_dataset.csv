,data,user_id
444,"public class Solution {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        Random random=new Random();
        var numberOfTestCases = sc.nextInt();
        for (int i = 0; i < numberOfTestCases; i++) {
            var N = sc.nextInt();
            int[] array = new int[N];
            for(int j=0;j<N;j++){
                array[j]=sc.nextInt();
            }
            int left=0, right=N-1;
            var served=0;
            int maxSoFar=Integer.MIN_VALUE,choose=0;
            while(left<=right){
                if(array[left]<array[right]){
                    choose=left;
                    left++;
                }else{
                    choose=right;
                    right--;
                }
//                System.out.println(""Choosing ""+ array[choose]);
                if(array[choose]>=maxSoFar) served++;
                maxSoFar=",DEB
724,"class Solution {
    public static void main(String[] args) {
//        provideInput(""2
"" +
//                ""3 3
"" +
//                ""0 10 20
"" +
//                ""0 10 20
"" +
//                ""20 30 30
"" +
//                ""4 3
"" +
//                ""0 10 20
"" +
//                ""0 10 20
"" +
//                ""0 10 20
"" +
//                ""20 30 30
"");

//        provideInput(""2
"" +
//                ""3 3
"" +
//                ""30 10 40
"" +
//                ""20 50 60
"" +
//                ""60 60 50
"" +
//                ""5 2
"" +
//                ""1 1000000000
"" +
//                ""500000000 1000000000
"" +
//                ""1 1000000000
"" +
//                ""500000000 1
"" +
//                ""1 1000000000
"");

        try (Scanner reader = new Scanner(System.in)) {
            if (reader.hasNextLine() && reader.hasNextInt()) {
                int T = Integer.parseInt(reader.nextLine());

                for (int i = 0; i < T; i++) {
                    int N = reader.nextInt();
                    int P = reader.nextInt();

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

                    List<Customer> queue = new ArrayList<>();

                    long count = 0;

                    int currentPressure = 0;

                    for (int j = 0; j < N; j++) {
                        int min = Integer.MAX_VALUE;
                        int max = 0;
                        for (int k = 0; k < P; k++) {
                            int value = reader.nextInt();
                            if (value < min) {
                                min = value;
                            }
                            if (value > max) {
                                max = value;
                            }
                        }

                        queue.add(new Customer(min, max));

                        if (reader.hasNextLine()) {
                            reader.nextLine();
                        }
                    }

                    for (int j = 0; j < N; j++) {
                        Customer c = queue.get(j);
                        int min = c.min;
                        int max = c.max;

                        int deltaMin = Math.abs(currentPressure - min);
                        int deltaMax = Math.abs(currentPressure - max);

                        int delta = max - min;
                        if (deltaMin < deltaMax) {
                            count += deltaMin;
                            count += delta;
                            currentPressure = max;
                        } else if (deltaMin > deltaMax) {
                            count += deltaMax;
                            count += delta;
                            currentPressure = min;
                        } else { // when equal search for next customer that is different if any
                            boolean found = false;
                            int sameCustomerCounter = 0;
                            for (int k = j+1; k < N; k++) {
                                sameCustomerCounter++;
                                Customer c2 = queue.get(k);
                                int min2 = c2.min;
                                int max2 = c2.max;
                                int deltaMin2 = Math.abs(currentPressure - min2);
                                int deltaMax2 = Math.abs(currentPressure - max2);

                                if (deltaMin2 < deltaMax2) {
                                    if (sameCustomerCounter % 2 != 0) {
                                        count += deltaMin;
                                        count += delta;
                                        currentPressure = max;
                                    } else {
                                        count += deltaMax;
                                        count += delta;
                                        currentPressure = min;
                                    }
                                    found = true;
                                } else if (deltaMin2 > deltaMax2) {
                                    if (sameCustomerCounter % 2 == 0) {
                                        count += deltaMin;
                                        count += delta;
                                        currentPressure = max;
                                    } else {
                                        count += deltaMax;
                                        count += delta;
                                        currentPressure = min;
                                    }
                                }

                                if (found) {
                                    break;
                                }
                            }
                            if (!found) { // it is the last one or the rest are all the same, does not matter
                                count += deltaMin;
                                count += delta;
                                currentPressure = max;
                            }
                        }

                    }
                    System.out.printf(""Case #%s: %s%n"", i + 1, count);
//                    System.out.println(""pressure "" + currentPressure);
                }
            }
        }
    }

    private static void provideInput(String data) {
        ByteArrayInputStream testIn;
        testIn = new ByteArrayInputStream(data.getBytes(StandardCharsets.UTF_8));
        System.setIn(testIn);
    }

    static class Customer {

        int min, max;

        public Customer(int min, int max) {
            this.min = min;
            this.max = max;
        }
    }
}
",JanDL
725,"class Solution {
    public static void main(String[] args) {
//        provideInput(""2
"" +
//                ""3 3
"" +
//                ""30 10 40
"" +
//                ""20 50 60
"" +
//                ""60 60 50
"" +
//                ""5 2
"" +
//                ""1 1000000000
"" +
//                ""500000000 1000000000
"" +
//                ""1 1000000000
"" +
//                ""500000000 1
"" +
//                ""1 1000000000
"");

        try (Scanner reader = new Scanner(System.in)) {
            if (reader.hasNextLine() && reader.hasNextInt()) {
                int T = Integer.parseInt(reader.nextLine());

                for (int i = 0; i < T; i++) {
                    int N = reader.nextInt();
                    int P = reader.nextInt();

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

                    List<Customer> queue = new ArrayList<>();

                    long count = 0;

                    int currentPressure = 0;

                    for (int j = 0; j < N; j++) {
                        int min = Integer.MAX_VALUE;
                        int max = 0;
                        for (int k = 0; k < P; k++) {
                            int value = reader.nextInt();
                            if (value < min) {
                                min = value;
                            }
                            if (value > max) {
                                max = value;
                            }
                        }

                        queue.add(new Customer(min, max));

                        if (reader.hasNextLine()) {
                            reader.nextLine();
                        }
                    }

                    for (int j = 0; j < N; j++) {
                        Customer c = queue.get(j);
                        int min = c.min;
                        int max = c.max;

                        int deltaMin = Math.abs(currentPressure - min);
                        int deltaMax = Math.abs(currentPressure - max);

                        int delta = max - min;
                        if (deltaMin < deltaMax) {
                            count += deltaMin;
                            count += delta;
                            currentPressure = max;
                        } else if (deltaMin > deltaMax) {
                            count += deltaMax;
                            count += delta;
                            currentPressure = min;
                        } else { // when equal search for next customer that is different if any
                            boolean found = false;
                            for (int k = j+1; k < N; k++) {
                                Customer c2 = queue.get(k);
                                int min2 = c2.min;
                                int max2 = c2.max;
                                int deltaMin2 = Math.abs(currentPressure - min2);
                                int deltaMax2 = Math.abs(currentPressure - max2);

                                if (deltaMin2 < deltaMax2) {
                                    count += deltaMin;
                                    count += delta;
                                    currentPressure = max;
                                    found = true;
                                } else if (deltaMin2 > deltaMax2) {
                                    count += deltaMax;
                                    count += delta;
                                    currentPressure = min;
                                    found = true;
                                }

                                if (found) {
                                    break;
                                }
                            }
                            if (!found) { // it is the last one or the rest are all the same, does not matter
                                count += deltaMin;
                                count += delta;
                                currentPressure = max;
                            }
                        }

                    }
                    System.out.printf(""Case #%s: %s%n"", i + 1, count);
                }
            }
        }
    }

    private static void provideInput(String data) {
        ByteArrayInputStream testIn;
        testIn = new ByteArrayInputStream(data.getBytes(StandardCharsets.UTF_8));
        System.setIn(testIn);
    }

    static class Customer {

        int min, max;

        public Customer(int min, int max) {
            this.min = min;
            this.max = max;
        }
    }
}
",JanDL
726,"class Solution {
    public static void main(String[] args) {
//        provideInput(""4
"" +
//                ""2
"" +
//                ""1 5
"" +
//                ""4
"" +
//                ""1 4 2 3
"" +
//                ""5
"" +
//                ""10 10 10 10 10
"" +
//                ""4
"" +
//                ""7 1 3 1000000
"");

        try (Scanner reader = new Scanner(System.in)) {
            if (reader.hasNextLine() && reader.hasNextInt()) {
                int T = Integer.parseInt(reader.nextLine());

                for (int i = 0; i < T; i++) {
                    int N = Integer.parseInt(reader.nextLine());

                    List<Integer> pancakes = new ArrayList<>();

                    for (int j = 0; j < N; j++) {
                        pancakes.add(reader.nextInt());
                    }

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

                    int first, last;
                    int count = 0;
                    int lastPaid = 0;
                    for (int j = 0; j < N; j++) {
                        int size = pancakes.size();
                        first = pancakes.get(0);
                        last = pancakes.get(size -1);

                        if (first < lastPaid) {
                            pancakes.remove(0);
                        } else if (last < lastPaid) {
                            pancakes.remove(size - 1);
                        } else if (first <= last) {
                            lastPaid = first;
                            count++;
                            pancakes.remove(0);
                        } else {
                            lastPaid = last;
                            count++;
                            pancakes.remove(size - 1);
                        }
                    }
                    System.out.printf(""Case #%s: %s%n"", i + 1, count);
                }
            }
        }
    }

    private static void provideInput(String data) {
        ByteArrayInputStream testIn;
        testIn = new ByteArrayInputStream(data.getBytes(StandardCharsets.UTF_8));
        System.setIn(testIn);
    }
}
",JanDL
727,"class Solution {
    public static void main(String[] args) {
//        provideInput(""4
"" +
//                ""2
"" +
//                ""1 5
"" +
//                ""4
"" +
//                ""1 4 2 3
"" +
//                ""5
"" +
//                ""10 10 10 10 10
"" +
//                ""4
"" +
//                ""7 1 3 1000000
"");

        try (Scanner reader = new Scanner(System.in)) {
            if (reader.hasNextLine() && reader.hasNextInt()) {
                int T = Integer.parseInt(reader.nextLine());

                for (int i = 0; i < T; i++) {
                    int N = Integer.parseInt(reader.nextLine());

                    List<Integer> pancakes = new ArrayList<>();

                    for (int j = 0; j < N; j++) {
                        pancakes.add(reader.nextInt());
                    }

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

                    int first, last;
                    int count = 0;
                    int lastPaid = 0;
                    for (int j = 0; j < N; j++) {
                        int size = pancakes.size();
                        first = pancakes.get(0);
                        last = pancakes.get(size -1);

                        if ((first <= last || last < lastPaid) && first >= lastPaid) {
                            lastPaid = first;
                            count++;
                            pancakes.remove(0);
                        } else if (last >= lastPaid) {
                            lastPaid = last;
                            count++;
                            pancakes.remove(size - 1);
                        } else {
                            break;
                        }
                    }
                    System.out.printf(""Case #%s: %s%n"", i + 1, count);
                }
            }
        }
    }

    private static void provideInput(String data) {
        ByteArrayInputStream testIn;
        testIn = new ByteArrayInputStream(data.getBytes(StandardCharsets.UTF_8));
        System.setIn(testIn);
    }
}
",JanDL
870,"public class Solution {

    public static void main(String[] args) {
        final Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        final int testQuantity = in.nextInt();

        for (int i = 1; i <= testQuantity; ++i) {
            int pancakesQuantity = in.nextInt();
            LinkedList<Integer> pancakes = new LinkedList<>();
//            while (pancakesQuantity-- > 0) {
            for (int j = 0; j < pancakesQuantity; j++) {
                pancakes.add(in.nextInt());
            }

            int last = 0;
            int left = pancakes.removeFirst();
            int right = pancakes.removeLast();
            int clientsCounter = 0;

            while (true) {

                if (right <= left) {
                    // smaller right
                    if (right >= last) {
                        last = right;
                        clientsCounter++;
                        if (pancakes.isEmpty()) {
                            if (left >= last) {
                                clientsCounter++;
                            }
                            break;
                        }
                        right = pancakes.removeLast();
                        continue;
                    }

                    // greater left
                    if (left >= last) {
                        last = left;
                        clientsCounter++;
                        if (pancakes.isEmpty()) {
                            if (right >= last) {
                                clientsCounter++;
                            }
                            break;
                        }
                        left = pancakes.removeFirst();
                        continue;
                    }
                } else {
                    // smaller left
                    if (left >= last) {
                        last = left;
                        clientsCounter++;
                        if (pancakes.isEmpty()) {
                            if (right >= last) {
                                clientsCounter++;
                            }
                            break;
                        }
                        left = pancakes.removeFirst();
                        continue;
                    }

                    // greater right
                    if (right >= last) {
                        last = right;
                        clientsCounter++;
                        if (pancakes.isEmpty()) {
                            if (left >= last) {
                                clientsCounter++;
                            }
                            break;
                        }
                        right = pancakes.removeLast();
                        continue;
                    }
                }

                break;

            }

            System.out.printf(""Case #%s: %s%n"", i, clientsCounter);
            System.",MikBac
871,"public class Solution {

    public static void main(String[] args) {
        final Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        final int testQuantity = in.nextInt();

        for (int i = 1; i <= testQuantity; ++i) {
            int pancakesQuantity = in.nextInt();
            LinkedList<Integer> pancakes = new LinkedList<>();
            while (pancakesQuantity-- > 0) {
                pancakes.add(in.nextInt());
            }

            int last = 0;
            int left = pancakes.removeFirst();
            int right = pancakes.removeLast();
            int clientsCounter = 0;

            while (true) {

                if (right <= left) {
                    // smaller right
                    if (right >= last) {
                        last = right;
                        clientsCounter++;
                        if (pancakes.isEmpty()) {
                            if (left >= last) {
                                clientsCounter++;
                            }
                            break;
                        }
                        right = pancakes.removeLast();
                        continue;
                    }

                    // greater left
                    if (left >= last) {
                        last = left;
                        clientsCounter++;
                        if (pancakes.isEmpty()) {
                            if (right >= last) {
                                clientsCounter++;
                            }
                            break;
                        }
                        left = pancakes.removeFirst();
                        continue;
                    }
                } else {
                    // smaller left
                    if (left >= last) {
                        last = left;
                        clientsCounter++;
                        if (pancakes.isEmpty()) {
                            if (right >= last) {
                                clientsCounter++;
                            }
                            break;
                        }
                        left = pancakes.removeFirst();
                        continue;
                    }

                    // greater right
                    if (right >= last) {
                        last = right;
                        clientsCounter++;
                        if (pancakes.isEmpty()) {
                            if (left >= last) {
                                clientsCounter++;
                            }
                            break;
                        }
                        right = pancakes.removeLast();
                        continue;
                    }
                }
                
                break;

            }

            System.out.printf(""Case #%s: %s%n"", i, clientsCounter);
            System.",MikBac
872,"public class Solution {

    public static void main(String[] args) {
        final Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        final int testQuantity = in.nextInt();

        for (int i = 1; i <= testQuantity; ++i) {
            int pancakesQuantity = in.nextInt();
            LinkedList<Integer> pancakes = new LinkedList<>();
            while (pancakesQuantity-- > 0) {
                pancakes.add(in.nextInt());
            }

            int last = 0;
            int left = pancakes.removeFirst();
            int right = pancakes.removeLast();
            int clientsCounter = 0;

            while (true) {

                if (right <= left) {
                    // smaller right
                    if (right >= last) {
                        last = right;
                        clientsCounter++;
                        if (pancakes.isEmpty()) {
                            if (left >= last) {
                                clientsCounter++;
                            }
                            break;
                        }
                        right = pancakes.removeLast();
                        continue;
                    }

                    // greater left
                    if (left >= last) {
                        last = left;
                        clientsCounter++;
                        if (pancakes.isEmpty()) {
                            if (right >= last) {
                                clientsCounter++;
                            }
                            break;
                        }
                        left = pancakes.removeFirst();
                        continue;
                    }
                } else {
                    // smaller left
                    if (left >= last) {
                        last = left;
                        clientsCounter++;
                        if (pancakes.isEmpty()) {
                            if (right >= last) {
                                clientsCounter++;
                            }
                            break;
                        }
                        left = pancakes.removeFirst();
                        continue;
                    }

                    // greater right
                    if (right >= last) {
                        last = right;
                        clientsCounter++;
                        if (pancakes.isEmpty()) {
                            if (left >= last) {
                                clientsCounter++;
                            }
                            break;
                        }
                        right = pancakes.removeLast();
                        continue;
                    }
                }

                if (pancakes.isEmpty()) {
                    break;
                }

                if (right <= left) {
                    right = pancakes.removeLast();
                } else {
                    left = pancakes.removeFirst();
                }

            }

            System.out.printf(""Case #%s: %s%n"", i, clientsCounter);
            System.",MikBac
873,"public class Solution {

    public static void main(String[] args) {
        final Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        final int testQuantity = in.nextInt();

        for (int i = 1; i <= testQuantity; ++i) {
            int pancakesQuantity = in.nextInt();
            final LinkedList<Integer> pancakes = new LinkedList();
            while (pancakesQuantity-- > 0) {
                pancakes.add(in.nextInt());
            }

            int last = 0;
            int left = pancakes.removeFirst();
            int right = pancakes.removeLast();
            int clientsCounter = 0;

            while (true) {

                if (right <= left) {
                    // smaller right
                    if (right >= last) {
                        last = right;
                        clientsCounter++;
                        if (pancakes.isEmpty()) {
                            if (left >= last) {
                                clientsCounter++;
                            }
                            break;
                        }
                        right = pancakes.removeLast();
                        continue;
                    }

                    // greater left
                    if (left >= last) {
                        last = left;
                        clientsCounter++;
                        if (pancakes.isEmpty()) {
                            if (right >= last) {
                                clientsCounter++;
                            }
                            break;
                        }
                        left = pancakes.removeFirst();
                        continue;
                    }
                } else {
                    // smaller left
                    if (left >= last) {
                        last = left;
                        clientsCounter++;
                        if (pancakes.isEmpty()) {
                            if (right >= last) {
                                clientsCounter++;
                            }
                            break;
                        }
                        left = pancakes.removeFirst();
                        continue;
                    }

                    // greater right
                    if (right >= last) {
                        last = right;
                        clientsCounter++;
                        if (pancakes.isEmpty()) {
                            if (left >= last) {
                                clientsCounter++;
                            }
                            break;
                        }
                        right = pancakes.removeLast();
                        continue;
                    }
                }

                if (pancakes.isEmpty()) {
                    break;
                }

                if (right <= left) {
                    right = pancakes.removeLast();
                } else {
                    left = pancakes.removeFirst();
                }

            }

            System.",MikBac
874,"public class Solution {

    public static void main(String[] args) {
        final Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        final int testQuantity = in.nextInt();

        for (int i = 1; i <= testQuantity; ++i) {
            int pancakesQuantity = in.nextInt();
            final LinkedList<Integer> pancakes = new LinkedList();
            while (pancakesQuantity-- > 0) {
                pancakes.add(in.nextInt());
            }

            int last = 0;
            int left = pancakes.removeFirst();
            int right = pancakes.removeLast();
            int clientsCounter = 0;

            while (true) {

                if (right <= left) {
                    // smaller right
                    if (right >= last) {
                        last = right;
                        clientsCounter++;
                        if (pancakes.isEmpty()) {
                            if (left >= last) {
                                clientsCounter++;
                            }
                            break;
                        }
                        right = pancakes.removeLast();
                        continue;
                    }

                    // smaller left
                    if (left >= last) {
                        last = left;
                        clientsCounter++;
                        if (pancakes.isEmpty()) {
                            if (right >= last) {
                                clientsCounter++;
                            }
                            break;
                        }
                        left = pancakes.removeFirst();
                        continue;
                    }
                } else {
                    // smaller left
                    if (left >= last) {
                        last = left;
                        clientsCounter++;
                        if (pancakes.isEmpty()) {
                            if (right >= last) {
                                clientsCounter++;
                            }
                            break;
                        }
                        left = pancakes.removeFirst();
                        continue;
                    }

                    // smaller right
                    if (right >= last) {
                        last = right;
                        clientsCounter++;
                        if (pancakes.isEmpty()) {
                            if (left >= last) {
                                clientsCounter++;
                            }
                            break;
                        }
                        right = pancakes.removeLast();
                        continue;
                    }
                }

                break;
            }

            System.",MikBac
875,"public class Solution {

    public static void main(String[] args) {
        final Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        final int testQuantity = in.nextInt();

        for (int i = 1; i <= testQuantity; ++i) {
            int pancakesQuantity = in.nextInt();
            final LinkedList<Integer> pancakes = new LinkedList();
            while (pancakesQuantity-- > 0) {
                pancakes.add(in.nextInt());
            }

            int last = 0;
            int left = pancakes.removeFirst();
            int right = pancakes.removeLast();
            int clientsCounter = 0;

            while (true) {

                // smaller right
                if (left >= right) {
                    if (right >= last) {
                        last = right;
                        clientsCounter++;
                        if (pancakes.isEmpty()) {
                            if (left >= last) {
                                clientsCounter++;
                            }
                            break;
                        }
                        right = pancakes.removeLast();
                        continue;
                    }
                }

                // smaller left
                if (left >= last) {
                    last = left;
                    clientsCounter++;
                    if (pancakes.isEmpty()) {
                        if (right >= last) {
                            clientsCounter++;
                        }
                        break;
                    }
                    left = pancakes.removeFirst();
                    continue;
                }

                // greater right
                if (right >= last) {
                    last = right;
                    clientsCounter++;
                    if (pancakes.isEmpty()) {
                        if (left >= last) {
                            clientsCounter++;
                        }
                        break;
                    }
                    right = pancakes.removeLast();
                    continue;
                }


                if (pancakes.isEmpty()) {
                    break;
                }

                if  (left >= right) {
                    right = pancakes.removeLast();
                } else {
                    left = pancakes.removeFirst();
                }

            }

            System.",MikBac
876,"public class Solution {

    public static void main(String[] args) {
        final Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        final int testQuantity = in.nextInt();

        for (int i = 1; i <= testQuantity; ++i) {
            int pancakesQuantity = in.nextInt();
            final LinkedList<Integer> pancakes = new LinkedList();
            while (pancakesQuantity-- > 0) {
                pancakes.add(in.nextInt());
            }

            int last = 0;
            int left = pancakes.removeFirst();
            int right = pancakes.removeLast();
            int clientsCounter = 0;

            while (true) {

                if (left >= right) {
                    if (right >= last) {
                        last = right;
                        clientsCounter++;
                        if (pancakes.isEmpty()) {
                            if (left >= last) {
                                clientsCounter++;
                            }
                            break;
                        }
                        right = pancakes.removeLast();
                        continue;
                    }
                }

                if (left >= last) {
                    last = left;
                    clientsCounter++;
                    if (pancakes.isEmpty()) {
                        if (right >= last) {
                            clientsCounter++;
                        }
                        break;
                    }
                    left = pancakes.removeFirst();
                    continue;
                } else if (right >= last) {
                    last = right;
                    clientsCounter++;
                    if (pancakes.isEmpty()) {
                        if (left >= last) {
                            clientsCounter++;
                        }
                        break;
                    }
                    right = pancakes.removeLast();
                    continue;
                } else {
                    break;
                }

            }

            System.",MikBac
958,"public class Solution {

	private static void experiment1b3(Scanner in) {
		// TODO Auto-generated method stub

	}



	private static void experiment1b1(Scanner in) {
		int testCases = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.

		for (int i = 1; i <= testCases; ++i) {
			int nPancakes = in.nextInt();
			LinkedBlockingDeque<Integer> pancakeVal = new LinkedBlockingDeque<>(nPancakes);
			for (int j = 0; j < nPancakes; j++) {
				pancakeVal.add(in.nextInt());
			}
			if (nPancakes == 0) {
				System.out.print(""Case #"" + i + "": "");
				System.out.println(0);
				continue;
			}

			int maxLast = 0;
			int counter = 0;
			while (pancakeVal.size() > 0) {
				Integer first = pancakeVal.getFirst();
				Integer last = pancakeVal.getLast();
				int min = Math.min(first, last);
				if (min >= maxLast) {
					maxLast = min;
					counter++;
				}
				if (first < last) {
					pancakeVal.removeFirst();
				} else {
					pancakeVal.removeLast();
				}

			}

			System.out.print(""Case #"" + i + "": "");
			System.out.println(counter);

		}
	}
	
	private static void experiment1b2(Scanner in) {
		int testCases = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		/*2
		3 3
		30 10 40
		20 50 60
		60 60 50*/
		for (int i = 1; i <= testCases; ++i) {
			int nCustomers = in.nextInt();
			int nBalls = in.nextInt();
			long[][] values = new long[nCustomers][nBalls];
			Long[][] maxPairValues = new Long[nCustomers][nCustomers];
			Long[][] minPairValues = new Long[nCustomers][nCustomers];
			long[] minValues = new long[nCustomers];
			long[] maxValues = new long[nCustomers];
			long[] flateValues = new long[nCustomers];
			
			long[] subThing = new long[nBalls];
			long sumFlates = 0;
			for (int j = 0; j < nCustomers; j++) {
				
				for (int j2 = 0; j2 < nBalls; j2++) {
					values[j][j2] =  in.nextInt();
					subThing[j2] =values[j][j2]; 
				}
				Arrays.sort(subThing);
				int counter = 0;
				for (int j2 = 0; j2 < subThing.length-1; j2++) {
					counter += Math.abs(subThing[j2+1]-subThing[j2]);
				}
				flateValues[j] = counter;
				sumFlates += counter;
				minValues[j] = subThing[0];
				maxValues[j] = subThing[subThing.length-1];
			}
			Long[][][] smallest = new Long[4][nCustomers][nCustomers];
			fillSmallest(0,0,1,minValues,maxValues,flateValues,smallest,minPairValues,maxPairValues);
			fillSmallest(1,0,1,minValues,maxValues,flateValues,smallest,minPairValues,maxPairValues);
			fillSmallest(2,0,1,minValues,maxValues,flateValues,smallest,minPairValues,maxPairValues);
			fillSmallest(3,0,1,minValues,maxValues,flateValues,smallest,minPairValues,maxPairValues);

			int maxLast = 0;
			int counter = 0;
			

			System.out.print(""Case #"" + i + "": "");
			System.out.println(counter);

		}
	}

	private static long fillSmallest(int mode,int i, int j, long[] minValues, long[] maxValues, long[] flateValues,
			Long[][][] smallest, Long[][] minPairValues, Long[][] maxPairValues) {
		/*if (j==i) {
			smallest[0][i][j] = flateValues[i];
			smallest[1][i][j] = flateValues[i];
			smallest[2][i][j] = flateValues[i];
			smallest[3][i][j] = flateValues[i];
			minPairValues[i][j] = minValues[i];
			maxPairValues[i][j] = maxValues[i];
			return smallest
		}*/
		if (smallest[mode][i][j]!=null) {
			return smallest[mode][i][j];
		}
		
		if (j==minValues.length-1) {
			long min = Integer.MAX_VALUE;
			if (mode==0) {
				long val = Math.abs(minValues[i]-minValues[j]);
				min = Math.min(val, min);
			}else if(mode==1){
				long val = Math.abs(minValues[i]-maxValues[j]);
				min = Math.min(val, min);
			}else if(mode==2){
				long val = Math.abs(maxValues[i]-minValues[j]);
				min = Math.min(val, min);
			}else if(mode==3){
				long val = Math.abs(maxValues[i]-maxValues[j]);
				min = Math.min(val, min);
			}
			smallest[mode][i][j] = min;
			return min;
		}
		
		if (smallest[mode][i][j]==null) {
			long min = Integer.MAX_VALUE;
			//ff
			long val0 =fillSmallest(0,i+1,i+2,minValues,maxValues,flateValues,smallest,minPairValues,maxPairValues);
			//fr
			long val1 =fillSmallest(1,i+1,i+2,minValues,maxValues,flateValues,smallest,minPairValues,maxPairValues);
			//rf
			long val2 =fillSmallest(2,i+1,i+2,minValues,maxValues,flateValues,smallest,minPairValues,maxPairValues);
			//rr
			long val3 =fillSmallest(3,i+1,i+2,minValues,maxValues,flateValues,smallest,minPairValues,maxPairValues);
			
			if (mode==0) {
				//fff
				min = Math.min(val0, min)+ Math.abs(minValues[i]-minValues[j]);;
				//ffr
				min = Math.min(val1, min)+Math.abs(minValues[i]-maxValues[j]);
			}else if(mode==1){
				//frf
				min = Math.min(val2, min)+ Math.abs(minValues[i]-minValues[j]);;
				//frr
				min = Math.min(val3, min)+ Math.abs(minValues[i]-maxValues[j]);;
				
				
			}else if(mode==2){
				//rff
				min = Math.min(val0, min)+ Math.abs(maxValues[i]-minValues[j]);;
				//rfr
				min = Math.min(val1, min)+ Math.abs(maxValues[i]-maxValues[j]);;
			}else if(mode==3){
				//rrr
				min = Math.min(val3, min)+ Math.abs(maxValues[i]-minValues[j]);;
				//rfr
				min = Math.min(val1, min)+ Math.abs(maxValues[i]-maxValues[j]);;
			}
			smallest[mode][i][j] = min;
			return min;
		}
		return -1;
		
	}

	private static int globalCounter;

	private static void experiment1a3(Scanner in) {
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.

		for (int i = 1; i <= t; ++i) {
			int e = in.nextInt();
			int w = in.nextInt();

			if (e == 0) {
				System.out.print(""Case #"" + i + "": "");
				System.out.println(0);
				continue;
			}
			int[][] weights = new int[e][];
			for (int j = 0; j < e; j++) {
				String line = """";
				while (line.length() == 0)
					line = in.nextLine();
				String[] splitted = line.split("" "");
				int[] weightforExercise = new int[w];
				if (splitted.length == 0)
					weightforExercise[0] = Integer.parseInt(line);
				else {
					weightforExercise = new int[splitted.length];
					for (int k = 0; k < splitted.length; k++) {
						String string = splitted[k];
						weightforExercise[k] = Integer.parseInt(string);
					}
				}
				weights[j] = weightforExercise;
			}

			Long[][] cvalues = new Long[e][e];
			Long[][] mvalues = new Long[e][e];
			for (int j = 0, k = 0; j < e; j++, k++) {

				mvalues[j][k] = 0L;

			}
			long result = recursive(0, e - 1, cvalues, mvalues, weights, w);
			result += getCValue(0, e - 1, cvalues, weights, w);
			result += getCValue(0, e - 1, cvalues, weights, w);

			System.out.print(""Case #"" + i + "": "");
			System.out.println(result);
		}

	}

	private static long recursive(int leftIndex, int rightIndex, Long[][] cvalues, Long[][] mvalues, int[][] weights,
			int w) {
		if (mvalues[leftIndex][rightIndex] != null)
			return mvalues[leftIndex][rightIndex];
		long min = Integer.MAX_VALUE;

		for (int x = leftIndex; x < rightIndex; x++) { // find the split
			long valleft = recursive(leftIndex, x, cvalues, mvalues, weights, w);
			long valright = recursive(x + 1, rightIndex, cvalues, mvalues, weights, w);
			long clx = getCValue(leftIndex, x, cvalues, weights, w);
			long cx1r = getCValue(x + 1, rightIndex, cvalues, weights, w);
			long clr = getCValue(leftIndex, rightIndex, cvalues, weights, w);
			// prestack
			long valloadl = (clx - clr);
			long valloadr = (cx1r - clr);
			long valunloadl = (clx - clr);
			long valunloadr = (cx1r - clr);

			long val = valloadl + valleft + valunloadl + valloadr + valright + valunloadr;
			if (val < min)
				min = val;
		}

		mvalues[leftIndex][rightIndex] = min;
		return min;
	}

	private static long getCValue(int leftIndex, int rightIndex, Long[][] cvalues, int[][] weights, int w) {
		if (cvalues[leftIndex][rightIndex] != null)
			return cvalues[leftIndex][rightIndex];

		int length = rightIndex - leftIndex + 1;
		int[] minWeight = new int[w];
		for (int j = 0; j < minWeight.length; j++) {
			minWeight[j] = Integer.MAX_VALUE;
		}
		for (int j = 0; j < minWeight.length; j++) {
			for (int i = leftIndex; i <= rightIndex; i++) {
				int[] js = weights[i];

				if (js[j] < minWeight[j])
					minWeight[j] = js[j];
			}
		}

		long sum = ",Nibbla
959,"public class Solution {

	private static void experiment1b3(Scanner in) {
		// TODO Auto-generated method stub

	}

	private static void experiment1b2(Scanner in) {
		// TODO Auto-generated method stub

	}

	private static void experiment1b1(Scanner in) {
		int testCases = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.

		for (int i = 1; i <= testCases; ++i) {
			int nPancakes = in.nextInt();
			LinkedBlockingDeque<Integer> pancakeVal = new LinkedBlockingDeque<>(nPancakes);
			for (int j = 0; j < nPancakes; j++) {
				pancakeVal.add(in.nextInt());
			}
			if (nPancakes == 0) {
				System.out.print(""Case #"" + i + "": "");
				System.out.println(0);
				continue;
			}

			int maxLast = 0;
			int counter = 0;
			while (pancakeVal.size() > 0) {
				Integer first = pancakeVal.getFirst();
				Integer last = pancakeVal.getLast();
				int min = Math.min(first, last);
				if (min >= maxLast) {
					maxLast = min;
					counter++;
				}
				if (first < last) {
					pancakeVal.removeFirst();
				} else {
					pancakeVal.removeLast();
				}

			}

			System.out.print(""Case #"" + i + "": "");
			System.out.println(counter);

		}
	}

	private static int globalCounter;

	private static void experiment1a3(Scanner in) {
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.

		for (int i = 1; i <= t; ++i) {
			int e = in.nextInt();
			int w = in.nextInt();

			if (e == 0) {
				System.out.print(""Case #"" + i + "": "");
				System.out.println(0);
				continue;
			}
			int[][] weights = new int[e][];
			for (int j = 0; j < e; j++) {
				String line = """";
				while (line.length() == 0)
					line = in.nextLine();
				String[] splitted = line.split("" "");
				int[] weightforExercise = new int[w];
				if (splitted.length == 0)
					weightforExercise[0] = Integer.parseInt(line);
				else {
					weightforExercise = new int[splitted.length];
					for (int k = 0; k < splitted.length; k++) {
						String string = splitted[k];
						weightforExercise[k] = Integer.parseInt(string);
					}
				}
				weights[j] = weightforExercise;
			}

			Long[][] cvalues = new Long[e][e];
			Long[][] mvalues = new Long[e][e];
			for (int j = 0, k = 0; j < e; j++, k++) {

				mvalues[j][k] = 0L;

			}
			long result = recursive(0, e - 1, cvalues, mvalues, weights, w);
			result += getCValue(0, e - 1, cvalues, weights, w);
			result += getCValue(0, e - 1, cvalues, weights, w);

			System.out.print(""Case #"" + i + "": "");
			System.out.println(result);
		}

	}

	private static long recursive(int leftIndex, int rightIndex, Long[][] cvalues, Long[][] mvalues, int[][] weights,
			int w) {
		if (mvalues[leftIndex][rightIndex] != null)
			return mvalues[leftIndex][rightIndex];
		long min = Integer.MAX_VALUE;

		for (int x = leftIndex; x < rightIndex; x++) { // find the split
			long valleft = recursive(leftIndex, x, cvalues, mvalues, weights, w);
			long valright = recursive(x + 1, rightIndex, cvalues, mvalues, weights, w);
			long clx = getCValue(leftIndex, x, cvalues, weights, w);
			long cx1r = getCValue(x + 1, rightIndex, cvalues, weights, w);
			long clr = getCValue(leftIndex, rightIndex, cvalues, weights, w);
			// prestack
			long valloadl = (clx - clr);
			long valloadr = (cx1r - clr);
			long valunloadl = (clx - clr);
			long valunloadr = (cx1r - clr);

			long val = valloadl + valleft + valunloadl + valloadr + valright + valunloadr;
			if (val < min)
				min = val;
		}

		mvalues[leftIndex][rightIndex] = min;
		return min;
	}

	private static long getCValue(int leftIndex, int rightIndex, Long[][] cvalues, int[][] weights, int w) {
		if (cvalues[leftIndex][rightIndex] != null)
			return cvalues[leftIndex][rightIndex];

		int length = rightIndex - leftIndex + 1;
		int[] minWeight = new int[w];
		for (int j = 0; j < minWeight.length; j++) {
			minWeight[j] = Integer.MAX_VALUE;
		}
		for (int j = 0; j < minWeight.length; j++) {
			for (int i = leftIndex; i <= rightIndex; i++) {
				int[] js = weights[i];

				if (js[j] < minWeight[j])
					minWeight[j] = js[j];
			}
		}

		long sum = 0;
		for (int i : minWeight) {
			sum += i;
		}

		cvalues[leftIndex][rightIndex] = sum;
		return sum;
	}

	private static void experiment1a3b(Scanner in) {
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.

		for (int i = 1; i <= t; ++i) {
			int e = in.nextInt();
			int w = in.nextInt();
			int result = 0;
			if (e == 0) {
				System.out.print(""Case #"" + i + "": "");
				System.out.println(0);
				continue;
			}
			int[][] weights = new int[e][];
			for (int j = 0; j < e; j++) {
				String line = """";
				while (line.length() == 0)
					line = in.nextLine();
				String[] splitted = line.split("" "");
				int[] weightforExercise;
				if (splitted.length == 0)
					weightforExercise = new int[] { Integer.parseInt(line) };
				else {
					weightforExercise = new int[splitted.length];
					for (int k = 0; k < splitted.length; k++) {
						String string = splitted[k];
						weightforExercise[k] = Integer.parseInt(string);
					}
				}
				weights[j] = weightforExercise;
			}

			int upperb = 0;
			int[] minWeight = new int[w];
			for (int j = 0; j < minWeight.length; j++) {
				minWeight[j] = Integer.MAX_VALUE;
			}
			for (int[] js : weights) {
				for (int js2 : js) {
					upperb += js2 * 2;
				}
				for (int j = 0; j < js.length; j++) {
					if (js[j] < minWeight[j])
						minWeight[j] = js[j];
				}
			}
			long[] upperBound = new long[] { upperb };

			LinkedList<Integer> stack = new LinkedList<>();
			int[] weightsOnStack = minWeight;
			for (int j = 0; j < weightsOnStack.length; j++) {
				int j2 = weightsOnStack[j];
				for (int k = 0; k < j2; k++) {
					stack.add(j);
				}

			}
			boolean[] weightsFitForExercise = new boolean[w];
			globalCounter = 0;
			int minStackSize = stack.size();
			long operations = depthFirst(0, stack, weights, weightsOnStack, weightsFitForExercise, minStackSize,
					upperBound, false, minStackSize);
			System.out.print(""Case #"" + i + "": "");
			System.out.println(upperBound[0]);
		}

	}

	private static long depthFirst(int exercise, LinkedList<Integer> stack, int[][] weights, int[] weightsOnStack,
			boolean[] weightsFitForExercise, int currentOperations, long[] upperBound, boolean removePhase,
			int minStackSize) {
		globalCounter++;
		if (globalCounter % 1000 == 0) {
			// System.out.println(globalCounter + "" "" + currentOperations + "" "" +
			// upperBound[0]);
		}
		if (currentOperations + stack.size() >= upperBound[0])
			return Integer.MAX_VALUE;
		if (exercise >= weights.length) {
			if (currentOperations + stack.size() < upperBound[0])
				upperBound[0] = currentOperations + stack.size();
			System.out.println(globalCounter + "" "" + currentOperations + stack.size() + "" "" + upperBound[0]);
			return stack.size();
		}

		int[] currentNeededWeights = weights[exercise];
		if (!stack.isEmpty() && weightsOnStack[stack.getLast()] > currentNeededWeights[stack.getLast()]) {
			weightsOnStack[stack.getLast()]--;
			Integer last = ",Nibbla
1064,"public class Solution {


    private static int N;
    private static int P;
    private static long[][] products;
    private static long[] differences;

    public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int t = Integer.parseInt(in.nextLine());  // Scanner has functions to read ints, longs, strings, chars, etc.
        for (int i = 1; i <= t; ++i) {
            int[] line = lineToInt(in.nextLine());
            N = line[0];
            P = line[1];

            products = new long[N][];
            differences = new long[N];

            for (int j = 0; j < N; j++) {
                products[j] = lineToLong(in.nextLine());
                Arrays.sort(products[j]);
                differences[j] = computeDifferences(products[j]);
            }

            long result = solve();

            System.out.println(String.format(""Case #%d: %d"", i, result));
        }
    }

    private static long computeDifferences(long[] array){
        long total = 0;
        for (int i = 1; i < P; i++) {
            total += array[i] - array[i-1];
        }
        return total;
    }

    private static long solve(){
        long[][] dp = new long[P][N+1];
        for (int j = N-1; j >=0 ; j--) {
            for (int i = 0; i < P; i++) {
                long iVal = j == 0 ? 0 : products[j-1][i];
                long  minimum = Long.MAX_VALUE;
                for (int k = 0; k < P; k++) {
                    minimum = Math.min(minimum(iVal, k, products[j], differences[j]) + dp[k][j+1], minimum);
                }

                dp[i][j] = minimum;
            }
        }
        return dp[0][0];
    }

    private static void reverseArray(long[] arr){
        for( int i = 0; i < arr.length/2; ++i )
        {
            long temp = arr[i];
            arr[i] = arr[arr.length - i - 1];
            arr[arr.length - i - 1] = temp;
        }
    }

    private static long minimum(long iVal, int k, long[] cust, long differenceTot){
        if(iVal < cust[k]) {
            return differenceTot + Math.abs(iVal - cust[0]) + Math.abs(cust[k] - cust[P - 1]);
        } else {
            return differenceTot + Math.abs(iVal - cust[P-1]) + Math.abs(cust[k] - cust[0]);
        }

    }

    public static int[] lineToInt(String line, String regex) {
        return Stream.of(line.split(regex)).mapToInt(Integer::parseInt).toArray();
    }

    public static long[] lineToLong(String line) {
        return Stream.of(line.split("" "")).mapToLong(Long::parseLong).toArray();
    }

    public static int[] lineToInt(String line) {
        return lineToInt(line, "" "");
    }

    public static Stream<String> binaryStrings(int n) {
        return LongStream.range(0, 1L << n).mapToObj(l -> getBinaryString(l, n));
    }

    public static String getBinaryString(long value, int size) {
        return Long.",RicolaNouland
1065,"public class Solution {


    private static int N;
    private static int P;
    private static long[][] products;

    public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int t = Integer.parseInt(in.nextLine());  // Scanner has functions to read ints, longs, strings, chars, etc.
        for (int i = 1; i <= t; ++i) {
            int[] line = lineToInt(in.nextLine());
            N = line[0];
            P = line[1];

            products = new long[N][];

            for (int j = 0; j < N; j++) {
                products[j] = lineToLong(in.nextLine());
            }

            long result = solve();

            System.out.println(String.format(""Case #%d: %d"", i, result));
        }
    }

    private static long solve(){
        long[][] dp = new long[P][N+1];
        for (int j = N-1; j >=0 ; j--) {
            for (int i = 0; i < P; i++) {
                long iVal = j == 0 ? 0 : products[j-1][i];
                long  minimum = Long.MAX_VALUE;
                for (int k = 0; k < P; k++) {
                   minimum = Math.min(minimum(iVal, k, products[j]) + dp[k][j+1], minimum);
                }

                dp[i][j] = minimum;
            }
        }
        return dp[0][0];
    }

    private static void reverseArray(long[] arr){
        for( int i = 0; i < arr.length/2; ++i )
        {
            long temp = arr[i];
            arr[i] = arr[arr.length - i - 1];
            arr[arr.length - i - 1] = temp;
        }
    }

    private static long minimum(long iVal, int k, long[] cust){
        long[] toSort = new long[P-1];
        int index = 0;
        for (int j = 0; j < P; j++) {
            if(j != k){
                toSort[index] = cust[j];
                index++;
            }
        }
        Arrays.sort(toSort);

        if(iVal > cust[k]){
            reverseArray(toSort);
        }

        long count = Math.abs(iVal - toSort[0]);
        for (int i = 1; i < toSort.length; i++) {
            count += Math.abs(toSort[i] - toSort[i-1]);
        }

        count += Math.abs(cust[k] - toSort[toSort.length-1]);

        return count;
    }

    public static int[] lineToInt(String line, String regex) {
        return Stream.of(line.split(regex)).mapToInt(Integer::parseInt).toArray();
    }

    public static long[] lineToLong(String line) {
        return Stream.of(line.split("" "")).mapToLong(Long::parseLong).toArray();
    }

    public static int[] lineToInt(String line) {
        return lineToInt(line, "" "");
    }

    public static Stream<String> binaryStrings(int n) {
        return LongStream.range(0, 1L << n).mapToObj(l -> getBinaryString(l, n));
    }

    public static String getBinaryString(long value, int size) {
        return Long.",RicolaNouland
1066,"public class Solution {


    public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int t = Integer.parseInt(in.nextLine());  // Scanner has functions to read ints, longs, strings, chars, etc.
        for (int i = 1; i <= t; ++i) {
            int N = Integer.parseInt(in.nextLine());
            int[] pancakesInt = lineToInt(in.nextLine());
            LinkedList<Integer> queue = new LinkedList<>();
            for (int i1 : pancakesInt) {
                queue.add(i1);
            }


            System.out.println(String.format(""Case #%d: %d"", i, solve(queue)));
        }
    }

    private static long solve(LinkedList<Integer> queue){
        long paid = 0;
        int mostDelicious = 0;
        while(!queue.isEmpty()){
            int delicious;
            if(queue.peekFirst() < queue.peekLast()){
                delicious = queue.pollFirst();
            } else {
                delicious = queue.pollLast();
            }
            if(delicious >= mostDelicious) {
                paid++;
                mostDelicious = delicious;
            }

        }
        return paid;
    }

    public static int[] lineToInt(String line, String regex) {
        return Stream.of(line.split(regex)).mapToInt(Integer::parseInt).toArray();
    }

    public static int[] lineToInt(String line) {
        return lineToInt(line, "" "");
    }

    public static Stream<String> binaryStrings(int n) {
        return LongStream.range(0, 1L << n).mapToObj(l -> getBinaryString(l, n));
    }

    public static String getBinaryString(long value, int size) {
        return Long.",RicolaNouland
2073,"    public class Solution {
      public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int t = in.nextInt();
        for (int i = 1; i <= t; ++i) {
          int k = in.nextInt();
          ArrayList<Integer> nums = new ArrayList<Integer>();
          for (int p = 0; p < k; ++p){
            int h = in.nextInt();
            nums.add(h);
          }
          System.out.println(""Case #"" + i + "": "" + calc(nums));
        }
      }

      public static int calc(ArrayList<Integer> arr){
        int greatest = Integer.MIN_VALUE;
        int count = 0;
        int lIndex = 0;
        int hIndex = arr.size() - 1;
        for (int i = 0; i < arr.size(); i++){
          if (arr.get(lIndex) <= arr.get(hIndex)){
            if (arr.get(lIndex) >= greatest){
              greatest = arr.get(lIndex);
              count++;
            }
            lIndex++;
          } else {
            if (arr.get(hIndex) >= greatest){
              greatest = arr.get(hIndex);
              count++;
            }
            hIndex--;
          }
        }
        return count;
      }
    }",hhuang8
2794,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        int T = sc.nextInt();
        for(int i = 0; i < T; i++){
            if(!solve()){
                break;
            }
        }
        pw.flush();
    }

    public static boolean solve() {
        System.out.println(""00000000"");
        int N = sc.nextInt();
        int bit = 0;
        for(int i = 1; i < 30000000; i++){
            i = i % 256;
            if((bit ^ i) != 1) continue;
            String s = Integer.toBinaryString(i);
            while(s.length() < 8){
                s = ""0""+s;
            }
            for(int j = 0; j < 1; j++){
                System.out.println(s);
                int now = sc.nextInt();
                if(now == 0){
                    return true;
                }
                if(now == -1){
                    return false;
                }
                if(N > now){
                    bit |= i;
                }else if(N < now){
                    bit &= ~i;
                }else{
                    bit ^= i;
                }
            }
        }
        return false;
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=",shojin_pro
2795,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        int T = sc.nextInt();
        for(int i = 0; i < T; i++){
            if(!solve()){
                break;
            }
        }
        pw.flush();
    }

    public static boolean solve() {
        System.out.println(""00000000"");
        int N = sc.nextInt();
        int bit = 0;
        for(int i = 1; i < 30000000; i++){
            i = i % 256;
            if((bit ^ i) != 255) continue;
            String s = Integer.toBinaryString(i);
            while(s.length() < 8){
                s = ""0""+s;
            }
            for(int j = 0; j < 1; j++){
                System.out.println(s);
                int now = sc.nextInt();
                if(now == 0){
                    return true;
                }
                if(now == -1){
                    return false;
                }
                if(N > now){
                    bit |= i;
                }else if(N < now){
                    bit &= ~i;
                }else{
                    bit ^= i;
                }
            }
        }
        return false;
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=",shojin_pro
2796,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        int T = sc.nextInt();
        for(int i = 0; i < T; i++){
            if(!solve()){
                break;
            }
        }
        pw.flush();
    }

    public static boolean solve() {
        System.out.println(""00000000"");
        int N = sc.nextInt();
        int bit = 0;
        for(int i = 1; i < 3030; i++){
            if((bit & i) > 0) continue;
            String s = Integer.toBinaryString(i%256);
            while(s.length() < 8){
                s = ""0""+s;
            }
            for(int j = 0; j < 15; j++){
                System.out.println(s);
                int now = sc.nextInt();
                if(now == 0){
                    return true;
                }
                if(now == -1){
                    return false;
                }
                if(N > now){
                    bit |= i;
                    break;
                }
            }
        }
        return false;
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = ",shojin_pro
2797,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        int T = sc.nextInt();
        for(int i = 0; i < T; i++){
            if(!solve()){
                break;
            }
        }
        pw.flush();
    }

    public static boolean solve() {
        System.out.println(""00000000"");
        int N = sc.nextInt();
        int bit = 0;
        for(int i = 1; i < 3030; i++){
            if((bit) & i) > 0) continue;
            String s = Integer.toBinaryString(i%256);
            while(s.length() < 8){
                s = ""0""+s;
            }
            for(int j = 0; j < 15; j++){
                System.out.println(s);
                int now = sc.nextInt();
                if(now == 0){
                    return true;
                }
                if(now == -1){
                    return false;
                }
                if(N > now){
                    bit |= i;
                    break;
                }
            }
        }
        return false;
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = ",shojin_pro
2798,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        int T = sc.nextInt();
        for(int i = 0; i < T; i++){
            if(!solve()){
                break;
            }
        }
        pw.flush();
    }

    public static boolean solve() {
        System.out.println(""00000000"");
        int N = sc.nextInt();
        int bit = 0;
        for(int i = 1; i < 3030; i++){
            String s = Integer.toBinaryString(i%256);
            while(s.length() < 8){
                s = ""0""+s;
            }
            for(int j = 0; j < 15; j++){
                System.out.println(s);
                int now = sc.nextInt();
                if(now == 0){
                    return true;
                }
                if(now == -1){
                    return false;
                }
                if(N >= now){
                    break;
                }
            }
        }
        return false;
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = new long[length];
        for(int i=",shojin_pro
2799,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        int T = sc.nextInt();
        for(int i = 0; i < T; i++){
            if(!solve()){
                break;
            }
        }
        pw.flush();
    }

    public static boolean solve() {
        System.out.println(""00000000"");
        int N = sc.nextInt();
        int bit = 0;
        for(int i = 1; i < 3030; i++){
            used[i % 256] = true; 
            String s = Integer.toBinaryString(i%256);
            while(s.length() < 8){
                s = ""0""+s;
            }
            for(int j = 0; j < 15; j++){
                System.out.println(s);
                int now = sc.nextInt();
                if(now == 0){
                    return true;
                }
                if(now == -1){
                    return false;
                }
                if(N >= now){
                    break;
                }
            }
        }
        return false;
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = new long[length];
        for(int i=",shojin_pro
2800,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        int T = sc.nextInt();
        for(int i = 0; i < T; i++){
            if(!solve()){
                break;
            }
        }
        pw.flush();
    }

    public static boolean solve() {
        System.out.println(""00000000"");
        int N = sc.nextInt();
        int bit = 0;
        boolean[] used = new boolean[256];
        for(int i = 1; i < 3030; i++){
            if(used[i % 256]){
                continue;
            }
            used[i % 256] = true; 
            String s = Integer.toBinaryString(i%256);
            while(s.length() < 8){
                s = ""0""+s;
            }
            for(int j = 0; j < 7; j++){
                System.out.println(s);
                int now = sc.nextInt();
                if(now == 0){
                    return true;
                }
                if(now == -1){
                    return false;
                }
                if(N >= now){
                    used[i % 256] = false;
                    N = now;
                    break;
                }
            }
        }
        return false;
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = ",shojin_pro
2801,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        int T = sc.nextInt();
        for(int i = 0; i < T; i++){
            if(!solve()){
                break;
            }
        }
        pw.flush();
    }

    public static boolean solve() {
        System.out.println(""00000000"");
        int N = sc.nextInt();
        int bit = 0;
        boolean[] used = new boolean[N];
        for(int i = 1; i < 3030; i++){
            if(used[i % 256]){
                continue;
            }
            used[i % 256] = true; 
            String s = Integer.toBinaryString(i%256);
            while(s.length() < 8){
                s = ""0""+s;
            }
            for(int j = 0; j < 7; j++){
                System.out.println(s);
                int now = sc.nextInt();
                if(now == 0){
                    return true;
                }
                if(now == -1){
                    return false;
                }
                if(N >= now){
                    used[i % 256] = false;
                    N = now;
                    break;
                }
            }
        }
        return false;
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = ",shojin_pro
2802,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        int T = sc.nextInt();
        for(int i = 0; i < T; i++){
            if(!solve()){
                break;
            }
        }
        pw.flush();
    }

    public static boolean solve() {
        System.out.println(""00000000"");
        int N = sc.nextInt();
        int bit = 0;
        boolean[] used = new boolean[N];
        for(int i = 1; i < 3030; i++){
            if(used[i % 256]){
                continue;
            }
            used[i % 256] = true; 
            String s = Integer.toBinaryString(i%256);
            while(s.length() < 8){
                s = ""0""+s;
            }
            for(int j = 0; j < 7; j++){
                System.out.println(s);
                now = sc.nextInt();
                if(now == 0){
                    return true;
                }
                if(now == -1){
                    return false;
                }
                if(N >= now){
                    used[i % 256] = false;
                    N = now;
                    break;
                }
            }
            
        }
        return false;
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = ",shojin_pro
2803,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        int T = sc.nextInt();
        for(int i = 0; i < T; i++){
            if(!solve()){
                break;
            }
        }
        pw.flush();
    }

    public static boolean solve() {
        System.out.println(""00000000"");
        int N = sc.nextInt();
        for(int i = 1; i < 2000; i++){
            char[] c = ""00000000"".toCharArray();
            c[i % 8] = '1';
            int min = N;
            for(int j = 0; j < 8; j++){
                System.out.println(new String(c));
                int now = sc.nextInt();
                if(now == 0){
                    return true;
                }
                if(now == -1){
                    return false;
                }
                if(now < min){
                    break;
                }
                N = now;
            }
        }
        return false;
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = new long[length];
        for(int i=",shojin_pro
2804,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        int T = sc.nextInt();
        for(int i = 0; i < T; i++){
            if(!solve()){
                break;
            }
        }
        pw.flush();
    }

    public static boolean solve() {
        System.out.println(""00000000"");
        int N = sc.nextInt();
        for(int i = 1; i < 2000; i++){
            char[] c = ""00000000"".toCharArray();
            c[i % 8] = '1';
            int min = N;
            for(int i = 0; i < 8; i++){
                System.out.println(new String(c));
                int now = sc.nextInt();
                if(now == 0){
                    return true;
                }
                if(now == -1){
                    return false;
                }
                if(now < min){
                    break;
                }
                N = now;
            }
        }
        return false;
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = new long[length];
        for(int i=",shojin_pro
2805,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        int T = sc.nextInt();
        for(int i = 0; i < T; i++){
            if(!solve()){
                break;
            }
        }
        pw.flush();
    }

    public static boolean solve() {
        System.out.println(""00000000"");
        int N = sc.nextInt();
        int bit = 0;
        for(int i = 1; i < 2000; i++){
            if((bit & i) > 0) continue;
            String s = Integer.toBinaryString(i%256);
            while(s.length() < 8){
                s = ""0""+s;
            }
            System.out.println(s);
            int now = sc.nextInt();
            if(N < now){
                for(int j = 0; j < 7; j++){
                    System.out.println(s);
                    now = sc.nextInt();
                }
            }else if(N > now){
                bit ^= (i%256);
            }
            if(now == 0){
                return true;
            }
            if(now == -1){
                return false;
            }
            N = now;
        }
        return false;
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=",shojin_pro
2806,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        int T = sc.nextInt();
        for(int i = 0; i < T; i++){
            if(!solve()){
                break;
            }
        }
        pw.flush();
    }

    public static boolean solve() {
        System.out.println(""00000000"");
        int N = sc.nextInt();
        int bit = 0;
        for(int i = 1; i < 30000000; i++){
            i = i % 256;
            if((bit ^ i) != 256) continue;
            String s = Integer.toBinaryString(i);
            while(s.length() < 8){
                s = ""0""+s;
            }
            for(int j = 0; j < 1; j++){
                System.out.println(s);
                int now = sc.nextInt();
                if(now == 0){
                    return true;
                }
                if(now == -1){
                    return false;
                }
                if(N > now){
                    bit |= i;
                }else if(N < now){
                    bit &= ~i;
                }else{
                    bit ^= i;
                }
            }
        }
        return false;
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=",shojin_pro
2807,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        int T = sc.nextInt();
        for(int i = 0; i < T; i++){
            if(!solve()){
                break;
            }
        }
        pw.flush();
    }

    public static boolean solve() {
        System.out.println(""00000000"");
        int N = sc.nextInt();
        int bit = 0;
        for(int i = 1; i < 2000; i++){
            if((bit & i) > 0) continue;
            String s = Integer.toBinaryString(i%256);
            while(s.length() < 8){
                s = ""0""+s;
            }
            System.out.println(s);
            int now = sc.nextInt();
            if(N < now){
                for(int j = 0; j < 8; j++){
                    System.out.println(s);
                    now = sc.nextInt();
                }
            }else if(N > now){
                bit ^= (i%256);
            }
            if(now == 0){
                return true;
            }
            if(now == -1){
                return false;
            }
            N = now;
        }
        return false;
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=",shojin_pro
2808,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        int T = sc.nextInt();
        for(int i = 0; i < T; i++){
            if(!solve()){
                break;
            }
        }
        pw.flush();
    }

    public static boolean solve() {
        System.out.println(""00000000"");
        int N = sc.nextInt();
        int bit = 0;
        for(int i = 1; i < 2000; i++){
            if((bit & i) > 0) continue;
            String s = Integer.toBinaryString(i%256);
            while(s.length() < 8){
                s = ""0""+s;
            }
            System.out.println(s);
            int now = sc.nextInt();
            if(N < now){
                System.out.println(s);
                now = sc.nextInt();
            }else if(N > now){
                bit ^= (i%256);
            }
            if(now == 0){
                return true;
            }
            if(now == -1){
                return false;
            }
            N = now;
        }
        return false;
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = ",shojin_pro
2809,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        int T = sc.nextInt();
        for(int i = 0; i < T; i++){
            if(!solve()){
                break;
            }
        }
        pw.flush();
    }

    public static boolean solve() {
        System.out.println(""00000000"");
        int N = sc.nextInt();
        int bit = 0;
        for(int i = 1; i < 2000; i++){
            if((bit & i) > 0) continue;
            String s = Integer.toBinaryString(i%256);
            while(s.length() < 8){
                s = ""0""+s;
            }
            System.out.println(s);
            int now = sc.nextInt();
            if(N < now){
                System.out.println(s);
                now = sc.nextInt();
            }else{
                bit ^= (i%256);
            }
            if(now == 0){
                return true;
            }
            if(now == -1){
                return false;
            }
            N = now;
        }
        return false;
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = ",shojin_pro
2810,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        int T = sc.nextInt();
        for(int i = 0; i < T; i++){
            if(!solve()){
                break;
            }
        }
        pw.flush();
    }

    public static boolean solve() {
        System.out.println(""00000000"");
        int N = sc.nextInt();
        int bit = 0;
        for(int i = 1; i < 303; i++){
            String s = Integer.toBinaryString(i%256);
            while(s.length() < 8){
                s = ""0""+s;
            }
            System.out.println(s);
            int now = sc.nextInt();
            if(N < now){
                System.out.println(s);
                now = sc.nextInt();
            }
            if(now == 0){
                return true;
            }
            if(now == -1){
                return false;
            }
            N = now;
        }
        return false;
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = new long[length];
        for(int i=",shojin_pro
2811,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        int T = sc.nextInt();
        for(int i = 0; i < T; i++){
            if(!solve()){
                break;
            }
        }
        pw.flush();
    }

    public static boolean solve() {
        System.out.println(""00000000"");
        int N = sc.nextInt();
        int bit = 0;
        for(int i = 1; i < 303; i++){
            String s = Integer.toBinaryString(i%256);
            while(s.length() < 8){
                s = ""0""+s;
            }
            System.out.println(s);
            int now = sc.nextInt();
            while(N < now){
                System.out.println(s);
                now = sc.nextInt();
            }
            if(now == 0){
                return true;
            }
            if(now == -1){
                return false;
            }
            N = now;
        }
        return false;
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = new long[length];
        for(int i=",shojin_pro
2812,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        int T = sc.nextInt();
        for(int i = 0; i < T; i++){
            if(!solve()){
                break;
            }
        }
        pw.flush();
    }

    public static boolean solve() {
        System.out.println(""00000000"");
        int N = sc.nextInt();
        int bit = 0;
        for(int i = 1; i < 303; i++){
            String s = Integer.toBinaryString(i%256);
            while(s.length() < 8){
                s = ""0""+s;
            }
            System.out.println(s);
            int now = sc.nextInt();
            if(N > now){
                System.out.println(s);
                now = sc.nextInt();
            }
            if(now == 0){
                return true;
            }
            if(now == -1){
                return false;
            }
            N = now;
        }
        return false;
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = new long[length];
        for(int i=",shojin_pro
2813,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        int T = sc.nextInt();
        for(int i = 0; i < T; i++){
            if(!solve()){
                break;
            }
        }
        pw.flush();
    }

    public static boolean solve() {
        System.out.println(""00000000"");
        int N = sc.nextInt();
        int bit = 0;
        for(int i = 1; i < 303; i++){
            String s = Integer.toBinaryString(i%256);
            while(s.length() < 8){
                s = ""0""+s;
            }
            System.out.println(s);
            int now = sc.nextInt();
            while(N > now){
                System.out.println(s);
                now = sc.nextInt();
            }
            if(now == 0){
                return true;
            }
            if(now == -1){
                return false;
            }
            N = now;
        }
        return false;
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = new long[length];
        for(int i=",shojin_pro
2814,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        int T = sc.nextInt();
        for(int i = 0; i < T; i++){
            if(!solve()){
                break;
            }
        }
        pw.flush();
    }

    public static boolean solve() {
        System.out.println(""00000000"");
        int N = sc.nextInt();
        int bit = 0;
        for(int i = 1; i < 303; i++){
            String s = Integer.toBinaryString(i%256);
            while(s.length() < 8){
                s = ""0""+s;
            }
            System.out.println(s);
            int now = sc.nextInt();
            while(N > now){
                System.out.println(s);
                now = sc.nextInt();
            }
            if(now == 0){
                return true;
            }
            if(now == -1){
                return false;
            }
            N = now;
        }
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = new long[length];
        for(int i=",shojin_pro
2815,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        int T = sc.nextInt();
        for(int i = 0; i < T; i++){
            if(!solve()){
                break;
            }
        }
        pw.flush();
    }

    public static boolean solve() {
        System.out.println(""00000000"");
        int N = sc.nextInt();
        int bit = 0;
        int i = 0;
        for(int i = 1; i < 303; i++){
            String s = Integer.toBinaryString(i%256);
            while(s.length() < 8){
                s = ""0""+s;
            }
            System.out.println(s);
            int now = sc.nextInt();
            while(N > now){
                System.out.println(s);
                now = sc.nextInt();
            }
            if(now == 0){
                return true;
            }
            if(now == -1){
                return false;
            }
            N = now;
        }
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = new long[length];
        for(int i=",shojin_pro
2816,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        int T = sc.nextInt();
        for(int i = 0; i < T; i++){
            if(!solve()){
                break;
            }
        }
        pw.flush();
    }

    public static boolean solve() {
        System.out.println(""00000000"");
        int N = sc.nextInt();
        int bit = 0;
        for(int i = 1; i < 303; i++){
            String s = Integer.toBinaryString(i%256);
            while(s.length() < 8){
                s = ""0""+s;
            }
            System.out.println(s);
            int now = sc.nextInt();
            if(now == 0){
                return true;
            }
            if(now == -1){
                return false;
            }
            if(N > now){
                bit ^= i;
            }
            N = now;
        }
        return false;
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = new long[length];
        for(int i=",shojin_pro
2817,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        int T = sc.nextInt();
        for(int i = 0; i < T; i++){
            if(!solve()){
                break;
            }
        }
        pw.flush();
    }

    public static boolean solve() {
        System.out.println(""00000000"");
        int N = sc.nextInt();
        int bit = 0;
        for(int i = 1; i < 30000000; i++){
            i = i % 256;
            if((bit & i) > 0) continue;
            String s = Integer.toBinaryString(i%256);
            while(s.length() < 8){
                s = ""0""+s;
            }
            for(int j = 0; j < 1; j++){
                System.out.println(s);
                int now = sc.nextInt();
                if(now == 0){
                    return true;
                }
                if(now == -1){
                    return false;
                }
                if(N > now){
                    bit |= i;
                }else if(N < now){
                    bit &= ~i;
                }else{
                    bit ^= i;
                }
            }
        }
        return false;
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=",shojin_pro
2818,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        int T = sc.nextInt();
        for(int i = 0; i < T; i++){
            if(!solve()){
                break;
            }
        }
        pw.flush();
    }

    public static boolean solve() {
        System.out.println(""00000000"");
        int N = sc.nextInt();
        int bit = 0;
        for(int i = 1; i < 300; i++){
            String s = Integer.toBinaryString(i%256);
            while(s.length() < 8){
                s = ""0""+s;
            }
            System.out.println(s);
            int now = sc.nextInt();
            if(now == 0){
                return;
            }
            if(N > now){
                bit ^= i;
            }
            N = now;
        }
        return true;
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = map.applyAsLong(this.nextLong());
        return array;
    }
    public int[] nextIntArray(int length){
        int[] array = new int[length];
        for(int i=",shojin_pro
2819,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        int T = sc.nextInt();
        for(int i = 0; i < T; i++){
            if(!solve()){
                break;
            }
        }
        pw.flush();
    }

    public static boolean solve() {
        System.out.println(""00000000"");
        int N = sc.nextInt();
        int bit = 0;
        while(N != 0){
            char[] c = ""00000000"".toCharArray();
            c[bit] = '1';
            int min = N;
            int mi = -1;
            for(int i = 0; i < 8; i++){
                System.out.println(new String(c));
                int now = sc.nextInt();
                if(now < 0){
                    return false;
                }else if(now == 0){
                    return true;
                }
                N = now;
                if(now <= min){
                    break;
                }
            }
            bit++;
            bit %= 8;
        }
        return true;
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = ",shojin_pro
2820,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        int T = sc.nextInt();
        for(int i = 0; i < T; i++){
            if(!solve()){
                break;
            }
        }
        pw.flush();
    }

    public static boolean solve() {
        System.out.println(""00000000"");
        int N = sc.nextInt();
        int bit = 0;
        int max = 8;
        while(N != 0){
            char[] c = ""00000000"".toCharArray();
            c[bit] = '1';
            int min = N;
            int mi = -1;
            for(int i = 0; i <= 8; i++){
                System.out.println(new String(c));
                int now = sc.nextInt();
                if(now < 0){
                    return false;
                }else if(now == 0){
                    return true;
                }
                N = now;
                if(now <= min){
                    break;
                }
            }
            bit++;
            bit %= 8;
        }
        return true;
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = ",shojin_pro
2821,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        int T = sc.nextInt();
        for(int i = 0; i < T; i++){
            if(!solve()){
                break;
            }
        }
        pw.flush();
    }

    public static boolean solve() {
        System.out.println(""00000000"");
        int N = sc.nextInt();
        int bit = 0;
        int max = 8;
        while(N != 0){
            char[] c = ""00000000"".toCharArray();
            c[bit] = '1';
            int min = N;
            int mi = -1;
            for(int i = 0; i <= 1; i++){
                System.out.println(new String(c));
                int now = sc.nextInt();
                if(now < 0){
                    return false;
                }else if(now == 0){
                    return true;
                }
                N = now;
                if(now < min){
                    break;
                }
            }
            bit++;
            bit %= 8;
        }
        return true;
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = ",shojin_pro
2822,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        int T = sc.nextInt();
        for(int i = 0; i < T; i++){
            if(!solve()){
                break;
            }
        }
        pw.flush();
    }

    public static boolean solve() {
        System.out.println(""00000000"");
        int N = sc.nextInt();
        int bit = 0;
        int max = 8;
        while(N != 0){
            char[] c = ""00000000"".toCharArray();
            c[bit] = '1';
            int min = N;
            int mi = -1;
            for(int i = 0; i <= max; i++){
                System.out.println(new String(c));
                int now = sc.nextInt();
                if(now < 0){
                    return false;
                }else if(now == 0){
                    return true;
                }
                N = now;
                if(now < min){
                    break;
                }
            }
            bit++;
            bit %= 8;
        }
        return true;
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = ",shojin_pro
2823,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        int T = sc.nextInt();
        for(int i = 0; i < T; i++){
            if(!solve()){
                break;
            }
        }
        pw.flush();
    }

    public static boolean solve() {
        System.out.println(""00000000"");
        int N = sc.nextInt();
        int bit = 0;
        while(N != 0){
            char[] c = ""00000000"".toCharArray();
            c[bit] = '1';
            int min = N;
            int mi = -1;
            for(int i = 0; i <= 15; i++){
                System.out.println(new String(c));
                int now = sc.nextInt();
                if(now < 0){
                    return false;
                }else if(now == 0){
                    return true;
                }
                if(now < min){
                    N = now;
                    break;
                }
            }
            bit++;
            bit %= 8;
        }
        return true;
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = ",shojin_pro
2824,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        int T = sc.nextInt();
        for(int i = 0; i < T; i++){
            if(!solve()){
                break;
            }
        }
        pw.flush();
    }

    public static boolean solve() {
        System.out.println(""00000000"");
        int N = sc.nextInt();
        int bit = 0;
        while(N != 0){
            char[] c = ""00000000"".toCharArray();
            c[bit] = '1';
            int min = N;
            int mi = -1;
            for(int i = 0; i <= 7; i++){
                System.out.println(new String(c));
                int now = sc.nextInt();
                if(now < 0){
                    return false;
                }else if(now == 0){
                    return true;
                }
                if(now < min){
                    N = now;
                    break;
                }
            }
            bit++;
            bit %= 8;
        }
        return true;
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = ",shojin_pro
2825,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        int T = sc.nextInt();
        for(int i = 0; i < T; i++){
            if(!solve()){
                break;
            }
        }
        pw.flush();
    }

    public static boolean solve(int No) {
        System.out.println(""00000000"");
        int N = sc.nextInt();
        int bit = 0;
        while(N != 0){
            char[] c = ""00000000"".toCharArray();
            c[bit] = '1';
            int min = N;
            int mi = -1;
            for(int i = 0; i <= 7; i++){
                System.out.println(new String(c));
                int now = sc.nextInt();
                if(now < 0){
                    return false;
                }else if(now == 0){
                    return true;
                }
                if(now < min){
                    N = now;
                    break;
                }
            }
            bit++;
            bit %= 8;
        }
        return true;
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = ",shojin_pro
2826,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        int T = sc.nextInt();
        for(int i = 0; i < T; i++){
            if(!solve()){
                break;
            }
        }
        pw.flush();
    }

    public static boolean solve(int No) {
        System.out.println(""00000000"");
        int N = sc.nextInt();
        int bit = 0;
        while(N != 0){
            char[] c = ""00000000"".toCharArray();
            c[bit] = '1';
            int min = N;
            int mi = -1;
            for(int i = 0; i <= 7; i++){
                System.out.println(new String(c));
                int now = sc.nextInt();
                if(now < 0){
                    return false;
                }else{
                    return true;
                }
                if(now < min){
                    N = now;
                    break;
                }
            }
            bit++;
            bit %= 8;
        }
        return true;
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = ",shojin_pro
2827,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        int T = sc.nextInt();
        for(int i = 0; i < T; i++){
            if(!solve(1)){
                break;
            }
        }
        pw.flush();
    }

    public static boolean solve(int No) {
        System.out.println(""00000000"");
        int N = sc.nextInt();
        int bit = 0;
        while(N != 0){
            char[] c = ""00000000"".toCharArray();
            c[bit] = '1';
            int min = N;
            int mi = -1;
            for(int i = 0; i <= 7; i++){
                System.out.println(new String(c));
                int now = sc.nextInt();
                if(now < 0){
                    return false;
                }else{
                    return true;
                }
                if(now < min){
                    N = now;
                    break;
                }
            }
            bit++;
            bit %= 8;
        }
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = new long[length];
        for(int i=",shojin_pro
2828,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        int T = sc.nextInt();
        for(int i = 0; i < T; i++){
            if(!solve()){
                break;
            }
        }
        pw.flush();
    }

    public static boolean solve() {
        System.out.println(""00000000"");
        int N = sc.nextInt();
        int bit = 0;
        for(int i = 1; i < 30000000; i++){
            if((bit & i) > 0) continue;
            String s = Integer.toBinaryString(i%256);
            while(s.length() < 8){
                s = ""0""+s;
            }
            for(int j = 0; j < 1; j++){
                System.out.println(s);
                int now = sc.nextInt();
                if(now == 0){
                    return true;
                }
                if(now == -1){
                    return false;
                }
                if(N > now){
                    bit |= i;
                }else if(N < now){
                    bit &= ~i;
                }else{
                    bit ^= i;
                }
            }
        }
        return false;
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=",shojin_pro
2829,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        int T = sc.nextInt();
        for(int i = 0; i < T; i++)solve(1);
        pw.flush();
    }

    public static void solve(int No) {
        System.out.println(""00000000"");
        int N = sc.nextInt();
        int bit = 0;
        while(N != 0){
            char[] c = ""00000000"".toCharArray();
            c[bit] = '1';
            int min = N;
            int mi = -1;
            for(int i = 0; i <= 7; i++){
                System.out.println(new String(c));
                int now = sc.nextInt();
                if(now <= 0){
                    return;
                }
                if(now < min){
                    N = now;
                    break;
                }
            }
            bit++;
            bit %= 8;
        }
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = map.applyAsLong(this.nextLong());
        return array;
    }
    public int[] nextIntArray(int length){
        int[] array = new int[length];
        for(int i=",shojin_pro
2830,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        int T = sc.nextInt();
        for(int i = 0; i < T; i++)solve(1);
        pw.flush();
    }

    public static void solve(int No) {
        System.out.println(""00000000"");
        int N = sc.nextInt();
        int bit = 0;
        while(N != 0){
            char[] c = ""00000000"".toCharArray();
            c[bit] = '1';
            int min = N;
            int mi = -1;
            for(int i = 0; i <= 7; i++){
                System.out.println(new String(c));
                int now = sc.nextInt();
                if(now <= 0){
                    return;
                }
                if(now < min){
                    now = min;
                    mi = i+1;
                }
            }
            for(int i = 0; i < mi; i++){
                System.out.println(new String(c));
                int now = sc.nextInt();
                if(now <= 0){
                    return;
                }
                N = now;
            }
            bit++;
            bit %= 8;
        }
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = ",shojin_pro
2831,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        int T = sc.nextInt();
        for(int i = 0; i < T; i++)solve(1);
        pw.flush();
    }

    public static void solve(int No) {
        System.out.println(""00000000"");
        int N = sc.nextInt();
        int bit = 0;
        while(N != 0){
            char[] c = ""00000000"".toCharArray();
            c[bit] = '1';
            int min = N;
            int mi = -1;
            for(int i = 0; i <= 7; i++){
                System.out.println(new String(c));
                int now = sc.nextInt();
                if(now <= 0){
                    return;
                }
                if(now < min){
                    now = min;
                    mi = i+1;
                }
            }
            for(int i = 0; i < mi; i++){
                System.out.println(new String(c));
                int now = sc.nextInt();
                if(now <= 0){
                    return;
                }
            }
            bit++;
            bit %= 8;
        }
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = ",shojin_pro
2832,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        int T = sc.nextInt();
        for(int i = 0; i < T; i++) solve(1);
        pw.flush();
    }

    public static void solve(int No) {
        int N = 0;
        int bit = 0;
        for(int i = 1; i < 256; i++){
            if((bit & i) != 0){
                continue;
            } 
            String s = Integer.toBinaryString(i);
            while(s.length() < 8){
                s = ""0""+s;
            }
            System.out.println(s);
            int now = sc.nextInt();
            if(now == 0){
                return;
            }
            if(N > now){
                bit ^= i;
            }
            N = now;
        }
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = map.applyAsLong(this.nextLong());
        return array;
    }
    public int[] nextIntArray(int length){
        int[] array = new int[length];
        for(int i=0; i<length; i++) array[i] = this.nextInt();
        return array;
    }
    public int[] nextIntArray(int length, java.util.function.IntUnaryOperator map){
        int[] array = ",shojin_pro
2833,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        solve(1);
        pw.flush();
    }

    public static void solve(int No) {
        int N = sc.nextInt();
        if(N == 0){
            return;
        }
        int bit = 0;
        for(int i = 1; i < 256; i++){
            if((bit & i) != 0){
                continue;
            } 
            String s = Integer.toBinaryString(i);
            while(s.length() < 8){
                s = ""0""+s;
            }
            System.out.println(s);
            int now = sc.nextInt();
            if(now == 0){
                return;
            }
            if(N > now){
                bit ^= i;
            }
            N = now;
        }
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = map.applyAsLong(this.nextLong());
        return array;
    }
    public int[] nextIntArray(int length){
        int[] array = new int[length];
        for(int i=",shojin_pro
2834,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        solve(1);
        pw.flush();
    }

    public static void solve(int No) {
        int N = sc.nextInt();
        if(N == 0){
            return;
        }
        int bit = 0;
        for(int i = 0; i < 256; i++){
            if((bit & i) != 0){
                continue;
            } 
            String s = Integer.toBinaryString(i);
            while(s.length() < 8){
                s = ""0""+s;
            }
            System.out.println(s);
            int now = sc.nextInt();
            if(now == 0){
                return;
            }
            if(N > now){
                bit ^= i;
            }
            N = now;
        }
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = map.applyAsLong(this.nextLong());
        return array;
    }
    public int[] nextIntArray(int length){
        int[] array = new int[length];
        for(int i=",shojin_pro
2835,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        solve(1);
        pw.flush();
    }

    public static void solve(int No) {
        int N = sc.nextInt();
        if(N == 0){
            return;
        }
        int bit = 0;
        for(int i = 0; i < 256; i++){
            if((bit & i) != 0){
                continue;
            } 
            String s = Integer.toBinaryString(i);
            while(s.length() < 8){
                s = ""0""+s;
            }
            System.out.println(s);
            int now = sc.nextInt();
            if(now == 0){
                return;
            }
            if(N > now){
                N = now;
                bit ^= i;
            }
        }
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = map.applyAsLong(this.nextLong());
        return array;
    }
    public int[] nextIntArray(int length){
        int[] array = new int[length];
        for(int i=",shojin_pro
2836,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        solve(1);
        pw.flush();
    }

    public static void solve(int No) {
        int N = sc.nextInt();
        if(N == 0){
            return;
        }
        int bit = 0;
        for(int i = 0; i < 256; i++){
            String s = Integer.toBinaryString(i);
            while(s.length() < 8){
                s = ""0""+s;
            }
            System.out.println(s);
            N = sc.nextInt();
            if(N == 0){
                return;
            }
        }
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = map.applyAsLong(this.nextLong());
        return array;
    }
    public int[] nextIntArray(int length){
        int[] array = new int[length];
        for(int i=0; i<length; i++) array[i] = this.nextInt();
        return array;
    }
    public int[] nextIntArray(int length, java.util.function.IntUnaryOperator map){
        int[] array = new int[length];
        for(int i=0; i<length; i++) array[i] = map.applyAsInt(this.nextInt());
        return array;
    }
    public double[] nextDoubleArray(int length){
        double[] array = ",shojin_pro
2837,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        solve(1);
        pw.flush();
    }

    public static void solve(int No) {
        int N = sc.nextInt();
        if(N == 0){
            return;
        }
        int bit = 0;
        for(int i = 0; i < 256; i++){
            String s = Integer.toBinaryString(i);
            while(s.length() < 8){
                s = ""0""+s;
            }
            System.out.println(s);
            int N = sc.nextInt();
            if(N == 0){
                return;
            }
        }
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = map.applyAsLong(this.nextLong());
        return array;
    }
    public int[] nextIntArray(int length){
        int[] array = new int[length];
        for(int i=0; i<length; i++) array[i] = this.nextInt();
        return array;
    }
    public int[] nextIntArray(int length, java.util.function.IntUnaryOperator map){
        int[] array = new int[length];
        for(int i=0; i<length; i++) array[i] = map.applyAsInt(this.nextInt());
        return array;
    }
    public double[] nextDoubleArray(int length){
        double[] array = ",shojin_pro
2838,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        solve(1);
        pw.flush();
    }

    public static void solve(int No) {
        int N = sc.nextInt();
        int bit = 0;
        int cnt = 1;
        while(N != 0){
            char[] c = ""11111111"".toCharArray();
            for(int i = 0; i < cnt; i++){
                c[(bit+i)%8] = '0';
            }
            int min = N;
            for(int i = 0; i < 8; i++){
                System.out.println(new String(c));
                int now = sc.nextInt();
                if(now <= 0){
                    return;
                }
                if(now < min){
                    N = now;
                    break;
                }
            }
            bit++;
            if(bit >= 8)cnt++;
            bit %= 8;
        }
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = map.applyAsLong(this.nextLong());
        return array;
    }
    public int[] nextIntArray(int length){
        int[] array = new int[length];
        for(int i=",shojin_pro
2839,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        int T = sc.nextInt();
        for(int i = 0; i < T; i++){
            if(!solve()){
                break;
            }
        }
        pw.flush();
    }

    public static boolean solve() {
        System.out.println(""00000000"");
        int N = sc.nextInt();
        int bit = 0;
        for(int i = 1; i < 30000000; i++){
            if((bit & i) > 0) continue;
            String s = Integer.toBinaryString(i%256);
            while(s.length() < 8){
                s = ""0""+s;
            }
            for(int j = 0; j < 1; j++){
                System.out.println(s);
                int now = sc.nextInt();
                if(now == 0){
                    return true;
                }
                if(now == -1){
                    return false;
                }
                if(N > now){
                    bit |= i;
                }else if(N < now){
                    bit ~= -i;
                }else{
                    bit ^= i;
                }
            }
        }
        return false;
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=",shojin_pro
2840,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        solve(1);
        pw.flush();
    }

    public static void solve(int No) {
        int N = sc.nextInt();
        int bit = 0;
        int cnt = 1;
        while(N != 0){
            char[] c = ""00000000"".toCharArray();
            for(int i = 0; i < cnt; i++){
                c[(bit+i)%8] = '1';
            }
            int min = N;
            for(int i = 0; i < 2; i++){
                System.out.println(new String(c));
                int now = sc.nextInt();
                if(now <= 0){
                    return;
                }
                if(now < min){
                    N = now;
                    break;
                }
            }
            bit++;
            if(bit >= 8)cnt++;
            bit %= 8;
        }
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = map.applyAsLong(this.nextLong());
        return array;
    }
    public int[] nextIntArray(int length){
        int[] array = new int[length];
        for(int i=",shojin_pro
2841,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        solve(1);
        pw.flush();
    }

    public static void solve(int No) {
        int N = sc.nextInt();
        int bit = 0;
        int cnt = 1;
        while(N != 0){
            char[] c = ""00000000"".toCharArray();
            for(int i = 0; i < cnt; i++){
                c[(bit+i)%8] = '1';
            }
            int min = N;
            for(int i = 0; i < 2; i++){
                System.out.println(new String(c));
                int now = sc.nextInt();
                if(now <= 0){
                    return;
                }
                if(now < min){
                    N = now;
                    break;
                }
            }
            bit++;
            bit %= 8;
        }
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = map.applyAsLong(this.nextLong());
        return array;
    }
    public int[] nextIntArray(int length){
        int[] array = new int[length];
        for(int i=",shojin_pro
2842,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        solve(1);
        pw.flush();
    }

    public static void solve(int No) {
        int N = sc.nextInt();
        int bit = 0;
        while(N != 0){
            char[] c = ""00000000"".toCharArray();
            c[bit] = '1';
            int min = N;
            for(int i = 0; i < 16; i++){
                System.out.println(new String(c));
                int now = sc.nextInt();
                if(now <= 0){
                    return;
                }
                if(now < min){
                    N = now;
                    break;
                }
            }
            bit++;
            bit %= 8;
        }
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = map.applyAsLong(this.nextLong());
        return array;
    }
    public int[] nextIntArray(int length){
        int[] array = new int[length];
        for(int i=0; i<length; i++) array[i] = this.nextInt();
        return array;
    }
    public int[] nextIntArray(int length, java.util.function.IntUnaryOperator map){
        int[] array = ",shojin_pro
2843,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        solve(1);
        pw.flush();
    }

    public static void solve(int No) {
        int N = sc.nextInt();
        int bit = 0;
        while(N != 0){
            char[] c = ""00000000"".toCharArray();
            c[bit] = '1';
            int min = N;
            for(int i = 0; i < 8; i++){
                System.out.println(new String(c));
                int now = sc.nextInt();
                if(now <= 0){
                    return;
                }
                if(now < min){
                    N = now;
                    break;
                }
            }
            bit++;
            bit %= 8;
        }
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = map.applyAsLong(this.nextLong());
        return array;
    }
    public int[] nextIntArray(int length){
        int[] array = new int[length];
        for(int i=0; i<length; i++) array[i] = this.nextInt();
        return array;
    }
    public int[] nextIntArray(int length, java.util.function.IntUnaryOperator map){
        int[] array = ",shojin_pro
2844,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        solve(1);
        pw.flush();
    }

    public static void solve(int No) {
        int N = sc.nextInt();
        int bit = 0;
        while(N != 0){
            char[] c = ""00000000"".toCharArray();
            c[bit] = '1';
            int min = N;
            for(int i = 0; i < 32; i++){
                System.out.println(new String(c));
                int now = sc.nextInt();
                if(now <= 0){
                    return;
                }
                if(now < min){
                    N = now;
                    break;
                }
            }
            bit++;
            bit %= 8;
        }
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = map.applyAsLong(this.nextLong());
        return array;
    }
    public int[] nextIntArray(int length){
        int[] array = new int[length];
        for(int i=0; i<length; i++) array[i] = this.nextInt();
        return array;
    }
    public int[] nextIntArray(int length, java.util.function.IntUnaryOperator map){
        int[] array = ",shojin_pro
2845,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        solve(1);
        pw.flush();
    }

    public static void solve(int No) {
        int N = sc.nextInt();
        int bit = 0;
        while(N != 0){
            char[] c = ""00000000"".toCharArray();
            c[bit] = '1';
            int min = N;
            for(int i = 0; i < 32; i++){
                System.out.println(new String(c));
                int now = sc.nextInt();
                if(now <= 0){
                    return;
                }
                if(now < min){
                    break;
                }
            }
            N = now;
            bit++;
            bit %= 8;
        }
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = map.applyAsLong(this.nextLong());
        return array;
    }
    public int[] nextIntArray(int length){
        int[] array = new int[length];
        for(int i=0; i<length; i++) array[i] = this.nextInt();
        return array;
    }
    public int[] nextIntArray(int length, java.util.function.IntUnaryOperator map){
        int[] array = ",shojin_pro
2846,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        solve(1);
        pw.flush();
    }

    public static void solve(int No) {
        int N = sc.nextInt();
        int bit = 0;
        while(N != 0){
            char[] c = ""00000000"".toCharArray();
            c[bit] = '1';
            int min = N;
            for(int i = 0; i < 32; i++){
                System.out.println(new String(c));
                int now = sc.nextInt();
                if(now <= 0){
                    return;
                }
                if(now < min){
                    break;
                }
            }
            bit++;
            bit %= 8;
        }
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = map.applyAsLong(this.nextLong());
        return array;
    }
    public int[] nextIntArray(int length){
        int[] array = new int[length];
        for(int i=0; i<length; i++) array[i] = this.nextInt();
        return array;
    }
    public int[] nextIntArray(int length, java.util.function.IntUnaryOperator map){
        int[] array = new int[length];
        for(int i=",shojin_pro
2847,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        solve(1);
        pw.flush();
    }

    public static void solve(int No) {
        int N = sc.nextInt();
        int bit = 0;
        while(N != 0){
            char[] c = ""00000000"".toCharArray();
            c[bit] = '1';
            int min = N;
            for(int i = 0; i < 16; i++){
                System.out.println(new String(c));
                int now = sc.nextInt();
                if(now <= 0){
                    return;
                }
                if(now < min){
                    break;
                }
            }
            bit++;
            bit %= 8;
        }
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = map.applyAsLong(this.nextLong());
        return array;
    }
    public int[] nextIntArray(int length){
        int[] array = new int[length];
        for(int i=0; i<length; i++) array[i] = this.nextInt();
        return array;
    }
    public int[] nextIntArray(int length, java.util.function.IntUnaryOperator map){
        int[] array = new int[length];
        for(int i=",shojin_pro
2848,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        solve(1);
        pw.flush();
    }

    public static void solve(int No) {
        int N = sc.nextInt();
        int bit = 0;
        while(N != 0){
            char[] c = ""00000000"".toCharArray();
            c[bit] = '1';
            int min = N;
            for(int i = 0; i <= 8; i++){
                System.out.println(new String(c));
                int now = sc.nextInt();
                if(now <= 0){
                    return;
                }
                if(now < min){
                    break;
                }
            }
            bit++;
            bit %= 8;
        }
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = map.applyAsLong(this.nextLong());
        return array;
    }
    public int[] nextIntArray(int length){
        int[] array = new int[length];
        for(int i=0; i<length; i++) array[i] = this.nextInt();
        return array;
    }
    public int[] nextIntArray(int length, java.util.function.IntUnaryOperator map){
        int[] array = new int[length];
        for(int i=",shojin_pro
2849,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        solve(1);
        pw.flush();
    }

    public static void solve(int No) {
        int N = sc.nextInt();
        int bit = 0;
        while(N != 0){
            char[] c = ""00000000"".toCharArray();
            c[bit] = '1';
            int min = N;
            int mi = -1;
            for(int i = 0; i <= 15; i++){
                System.out.println(new String(c));
                int now = sc.nextInt();
                if(now <= 0){
                    return;
                }
                if(now < min){
                    now = min;
                    mi = i+1;
                }
            }
            for(int i = 0; i < mi; i++){
                System.out.println(new String(c));
                int now = sc.nextInt();
                if(now <= 0){
                    return;
                }
            }
            bit++;
            bit %= 8;
        }
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = new long[length];
        for(int i=",shojin_pro
2850,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        int T = sc.nextInt();
        for(int i = 0; i < T; i++){
            if(!solve()){
                break;
            }
        }
        pw.flush();
    }

    public static boolean solve() {
        System.out.println(""00000000"");
        int N = sc.nextInt();
        int bit = 0;
        for(int i = 1; i < 30000000; i++){
            if((bit & i) > 0) continue;
            String s = Integer.toBinaryString(i%256);
            while(s.length() < 8){
                s = ""0""+s;
            }
            for(int j = 0; j < 1; j++){
                System.out.println(s);
                int now = sc.nextInt();
                if(now == 0){
                    return true;
                }
                if(now == -1){
                    return false;
                }
                if(N > now){
                    bit |= i;
                }
            }
        }
        return false;
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = new long[length];
        for(int i=",shojin_pro
2851,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        solve(1);
        pw.flush();
    }

    public static void solve(int No) {
        int N = sc.nextInt();
        int bit = 0;
        while(N != 0){
            char[] c = ""00000000"".toCharArray();
            c[bit] = '1';
            int min = N;
            int mi = -1;
            for(int i = 0; i <= 7; i++){
                System.out.println(new String(c));
                int now = sc.nextInt();
                if(now <= 0){
                    return;
                }
                if(now < min){
                    now = min;
                    mi = i+1;
                }
            }
            for(int i = 0; i < mi; i++){
                System.out.println(new String(c));
                int now = sc.nextInt();
                if(now <= 0){
                    return;
                }
            }
            bit++;
            bit %= 8;
        }
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = new long[length];
        for(int i=",shojin_pro
2852,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        solve(1);
        pw.flush();
    }

    public static void solve(int No) {
        int N = sc.nextInt();
        int bit = 0;
        while(N != 0){
            char[] c = ""00000000"".toCharArray();
            c[bit] = '1';
            int min = N;
            int mi = -1;
            for(int i = 0; i <= 7; i++){
                System.out.println(new String(c));
                int now = sc.nextInt();
                if(now <= 0){
                    return;
                }
                if(now < min){
                    now = min;
                    mi = i+1;
                }
            }
            for(int i = 0; i < mi; i++){
                System.out.println(new String(c));
                int now = sc.nextInt();
            }
            bit++;
            bit %= 8;
        }
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = map.applyAsLong(this.nextLong());
        return array;
    }
    public int[] nextIntArray(int length){
        int[] array = ",shojin_pro
2853,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        solve(1);
        pw.flush();
    }

    public static void solve(int No) {
        int N = sc.nextInt();
        int bit = 0;
        while(N != 0){
            char[] c = ""00000000"".toCharArray();
            c[bit] = '1';
            for(int i = 0; i <= 7; i++){
                System.out.println(new String(c));
                int now = sc.nextInt();
                if(now <= 0){
                    return;
                }
            }
            bit++;
            bit %= 8;
        }
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = map.applyAsLong(this.nextLong());
        return array;
    }
    public int[] nextIntArray(int length){
        int[] array = new int[length];
        for(int i=0; i<length; i++) array[i] = this.nextInt();
        return array;
    }
    public int[] nextIntArray(int length, java.util.function.IntUnaryOperator map){
        int[] array = new int[length];
        for(int i=0; i<length; i++) array[i] = map.applyAsInt(this.nextInt());
        return array;
    }
    public double[] nextDoubleArray(int length){
        double[] array = ",shojin_pro
2854,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        solve(1);
        pw.flush();
    }

    public static void solve(int No) {
        int N = sc.nextInt();
        int bit = 0;
        while(N != 0){
            char[] c = ""00000000"".toCharArray();
            c[bit] = '1';
            for(int i = 0; i < 7; i++){
                System.out.println(new String(c));
                int now = sc.nextInt();
                if(now <= 0){
                    return;
                }
            }
            bit++;
            bit %= 8;
        }
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = map.applyAsLong(this.nextLong());
        return array;
    }
    public int[] nextIntArray(int length){
        int[] array = new int[length];
        for(int i=0; i<length; i++) array[i] = this.nextInt();
        return array;
    }
    public int[] nextIntArray(int length, java.util.function.IntUnaryOperator map){
        int[] array = new int[length];
        for(int i=0; i<length; i++) array[i] = map.applyAsInt(this.nextInt());
        return array;
    }
    public double[] nextDoubleArray(int length){
        double[] array = ",shojin_pro
2855,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        int T = sc.nextInt();
        for(int i = 1; i <= T; i++) solve(i);
        pw.flush();
    }

    public static void solve(int No) {
        int N = sc.nextInt();
        int bit = 0;
        while(N != 0){
            char[] c = ""00000000"".toCharArray();
            c[bit] = '1';
            for(int i = 0; i < 7; i++){
                System.out.println(new String(c));
                int now = sc.nextInt();
                if(now <= 0){
                    return;
                }
            }
            bit++;
            bit %= 8;
        }
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = map.applyAsLong(this.nextLong());
        return array;
    }
    public int[] nextIntArray(int length){
        int[] array = new int[length];
        for(int i=0; i<length; i++) array[i] = this.nextInt();
        return array;
    }
    public int[] nextIntArray(int length, java.util.function.IntUnaryOperator map){
        int[] array = new int[length];
        for(int i=0; i<length; i++) array[i] = map.applyAsInt(this.nextInt());
        return array;
    }
    public double[] nextDoubleArray(int length){
        double[] array = ",shojin_pro
2856,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        int T = sc.nextInt();
        for(int i = 1; i <= T; i++) solve(i);
        pw.flush();
    }

    public static void solve(int No) {
        int N = sc.nextInt();
        int bit = 0;
        while(N != 0){
            char[] c = ""00000000"".toCharArray();
            c[bit] = '1';
            for(int i = 0; i < 7; i++){
                System.out.println(new String(c));
                int now = sc.nextInt();
                if(now == 0){
                    return;
                }
            }
            bit++;
            bit %= 8;
        }
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = map.applyAsLong(this.nextLong());
        return array;
    }
    public int[] nextIntArray(int length){
        int[] array = new int[length];
        for(int i=0; i<length; i++) array[i] = this.nextInt();
        return array;
    }
    public int[] nextIntArray(int length, java.util.function.IntUnaryOperator map){
        int[] array = new int[length];
        for(int i=0; i<length; i++) array[i] = map.applyAsInt(this.nextInt());
        return array;
    }
    public double[] nextDoubleArray(int length){
        double[] array = ",shojin_pro
2857,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        int T = sc.nextInt();
        for(int i = 1; i <= T; i++) solve(i);
        pw.flush();
    }

    public static void solve(int No) {
        int N = sc.nextInt();
        int P = sc.nextInt();
        HashMap<Long,Long> map = new HashMap<>();
        map.put(0L,0L);
        for(int i = 0; i < N; i++){
            ArrayList<Long> arr = new ArrayList<>();
            for(int j = 0; j < P; j++){
                arr.add(sc.nextLong());
            }
            Collections.sort(arr);
            HashMap<Long,Long> map2 = new HashMap<>();
            for(Map.Entry<Long,Long> e : map.entrySet()){
                long k = e.getKey();
                long v = e.getValue();
                for(long k2 : arr){
                    long v2 = map2.getOrDefault(k2,Long.MAX_VALUE);
                    if(k <= k2){
                        v2 = Math.min(v2,v+arr.get(P-1)-arr.get(0)+Math.abs(k-arr.get(0))+Math.abs(k2-arr.get(P-1)));
                        map2.put(k2,v2);
                    }else{
                        v2 = Math.min(v2,v+arr.get(P-1)-arr.get(0)+Math.abs(k2-arr.get(0))+Math.abs(k-arr.get(P-1)));
                        map2.put(k2,v2);
                    }
                }
            }
            //pw.println(map2);
            map = map2;
        }
        long ans = Long.MAX_VALUE;
        for(Map.Entry<Long,Long> e : map.entrySet()){
            long v = e.getValue();
            ans = Math.min(ans,v);
        }
        pw.println(""Case #""+No+"": ""+(ans));
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=",shojin_pro
2858,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        int T = sc.nextInt();
        for(int i = 1; i <= T; i++) solve(i);
        pw.flush();
    }

    public static void solve(int No) {
        int N = sc.nextInt();
        Deque<Integer> dq = new ArrayDeque<Integer>();
        for(int i = 0; i < N; i++){
            dq.add(sc.nextInt());
        }
        int ans = 0;
        int prev = 0;
        while(dq.size() > 0){
            int left = dq.pollFirst();
            if(dq.size() != 0){
                int right = dq.pollLast();
                if(left <= right){
                    if(prev <= left){
                        ans++;
                    }
                    prev = Math.max(prev,left);
                    dq.addLast(right);
                }else{
                    if(prev <= right){
                        ans++;
                    }
                    prev = Math.max(prev,right);
                    dq.addFirst(left);
                }
            }else{
                if(prev <= left){
                    ans++;
                }
            }
        }
        pw.println(""Case #""+No+"": ""+(ans));
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=",shojin_pro
2859,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        int T = sc.nextInt();
        for(int i = 0; i < T; i++){
            if(!solve()){
                break;
            }
        }
        pw.flush();
    }

    public static boolean solve() {
        System.out.println(""00000000"");
        int N = sc.nextInt();
        int bit = 0;
        for(int i = 1; i < 3030; i++){
            if((bit & i) > 0) continue;
            String s = Integer.toBinaryString(i%256);
            while(s.length() < 8){
                s = ""0""+s;
            }
            for(int j = 0; j < 1; j++){
                System.out.println(s);
                int now = sc.nextInt();
                if(now == 0){
                    return true;
                }
                if(now == -1){
                    return false;
                }
                if(N > now){
                    bit |= i;
                }
            }
        }
        return false;
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = new long[length];
        for(int i=",shojin_pro
2860,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        int T = sc.nextInt();
        for(int i = 0; i < T; i++){
            if(!solve()){
                break;
            }
        }
        pw.flush();
    }

    public static boolean solve() {
        System.out.println(""00000000"");
        int N = sc.nextInt();
        int bit = 0;
        for(int i = 1; i < 3030; i++){
            if((bit & i) > 0) continue;
            String s = Integer.toBinaryString(i%256);
            while(s.length() < 8){
                s = ""0""+s;
            }
            for(int j = 0; j < 2; j++){
                System.out.println(s);
                int now = sc.nextInt();
                if(now == 0){
                    return true;
                }
                if(now == -1){
                    return false;
                }
                if(N > now){
                    bit |= i;
                    N = now;
                    break;
                }else{
                    N = now;
                }
            }
        }
        return false;
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=",shojin_pro
2861,"public class Solution {
    static ContestScanner sc = new ContestScanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);
    static StringBuilder sb = new StringBuilder();
    static long mod = (long) 1e9 + 7;
    public static void main(String[] args) throws Exception {
        int T = sc.nextInt();
        for(int i = 0; i < T; i++){
            if(!solve()){
                break;
            }
        }
        pw.flush();
    }

    public static boolean solve() {
        System.out.println(""00000000"");
        int N = sc.nextInt();
        int bit = 0;
        for(int i = 1; i < 3030; i++){
            if((bit & i) > 0) continue;
            String s = Integer.toBinaryString(i%256);
            while(s.length() < 8){
                s = ""0""+s;
            }
            for(int j = 0; j < 2; j++){
                System.out.println(s);
                int now = sc.nextInt();
                if(now == 0){
                    return true;
                }
                if(now == -1){
                    return false;
                }
                if(N > now){
                    bit |= i;
                    break;
                }
            }
        }
        return false;
    }

    static class GeekInteger {
        public static void save_sort(int[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static int[] shuffle(int[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                int randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

        public static void save_sort(long[] array) {
            shuffle(array);
            Arrays.sort(array);
        }

        public static long[] shuffle(long[] array) {
            int n = array.length;
            Random random = new Random();
            for (int i = 0, j; i < n; i++) {
                j = i + random.nextInt(n - i);
                long randomElement = array[j];
                array[j] = array[i];
                array[i] = randomElement;
            }
            return array;
        }

    }
}

/**
 * reference : https://github.com/NASU41/AtCoderLibraryForJava/blob/master/ContestIO/ContestScanner.java
 */
class ContestScanner {
    private final java.io.InputStream in;
    private final byte[] buffer = new byte[1024];
    private int ptr = 0;
    private int buflen = 0;

    private static final long LONG_MAX_TENTHS = 922337203685477580L;
    private static final int LONG_MAX_LAST_DIGIT = 7;
    private static final int LONG_MIN_LAST_DIGIT = 8;

    public ContestScanner(java.io.InputStream in){
        this.in = in;
    }
    public ContestScanner(java.io.File file) throws java.io.FileNotFoundException {
        this(new java.io.BufferedInputStream(new java.io.FileInputStream(file)));
    }
    public ContestScanner(){
        this(System.in);
    }
 
    private boolean hasNextByte() {
        if (ptr < buflen) {
            return true;
        }else{
            ptr = 0;
            try {
                buflen = in.read(buffer);
            } catch (java.io.IOException e) {
                e.printStackTrace();
            }
            if (buflen <= 0) {
                return false;
            }
        }
        return true;
    }
    private int readByte() { 
        if (hasNextByte()) return buffer[ptr++]; else return -1;
    }
    private static boolean isPrintableChar(int c) {
        return 33 <= c && c <= 126;
    }
    public boolean hasNext() {
        while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
        return hasNextByte();
    }
    public String next() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        StringBuilder sb = new StringBuilder();
        int b = readByte();
        while(isPrintableChar(b)) {
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }
 
    public long nextLong() {
        if (!hasNext()) throw new java.util.NoSuchElementException();
        long n = 0;
        boolean minus = false;
        int b = readByte();
        if (b == '-') {
            minus = true;
            b = readByte();
        }
        if (b < '0' || '9' < b) {
            throw new NumberFormatException();
        }
        while (true) {
            if ('0' <= b && b <= '9') {
                int digit = b - '0';
                if (n >= LONG_MAX_TENTHS) {
                    if (n == LONG_MAX_TENTHS) {
                        if (minus) {
                            if (digit <= LONG_MIN_LAST_DIGIT) {
                                n = -n * 10 - digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        } else {
                            if (digit <= LONG_MAX_LAST_DIGIT) {
                                n = n * 10 + digit;
                                b = readByte();
                                if (!isPrintableChar(b)) {
                                    return n;
                                } else if (b < '0' || '9' < b) {
                                    throw new NumberFormatException(
                                        String.format(""%d%s... is not number"", n, Character.toString(b))
                                    );
                                }
                            }
                        }
                    }
                    throw new ArithmeticException(
                        String.format(""%s%d%d... overflows long."", minus ? ""-"" : """", n, digit)
                    );
                }
                n = n * 10 + digit;
            }else if(b == -1 || !isPrintableChar(b)){
                return minus ? -n : n;
            }else{
                throw new NumberFormatException();
            }
            b = readByte();
        }
    }
    public int nextInt() {
        long nl = nextLong();
        if (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE) throw new NumberFormatException();
        return (int) nl;
    }
    public double nextDouble() {
        return Double.parseDouble(next());
    }
 
    public long[] nextLongArray(int length){
        long[] array = new long[length];
        for(int i=0; i<length; i++) array[i] = this.nextLong();
        return array;
    }
    public long[] nextLongArray(int length, java.util.function.LongUnaryOperator map){
        long[] array = ",shojin_pro
3522,"public class Solution {


    public static final String IMPOSSIBLE = ""IMPOSSIBLE"";
    private static String[] words;
    private static Deque<String> result;

    public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int t = Integer.parseInt(in.nextLine());  // Scanner has functions to read ints, longs, strings, chars, etc.
        for (int i = 1; i <= t; ++i) {
            in.nextLine();
            words = in.nextLine().split("" "");

            String result = solve();
//            if(!isValid(result)){
//                result = IMPOSSIBLE;
//            }

            System.out.println(String.format(""Case #%d: %s"", i, result));
        }
    }

    private static String solve(){
        Map<Character, String> startWith = new HashMap<>();
        Map<Character, String> endWith = new HashMap<>();
        Map<Character, List<String>> fullWord = new HashMap<>();
        Set<Character> allLetters =  new HashSet<>();
        Set<Character> middles = new HashSet<>();
        for (String word : words) {
            if(!isValid(word)){
                return IMPOSSIBLE;
            }
            char firstLetter = word.charAt(0);
            char lastLetter = word.charAt(word.length()-1);
            allLetters.add(firstLetter);
            if(middles.contains(firstLetter) || middles.contains(lastLetter)) return IMPOSSIBLE;
            allLetters.add(lastLetter);
            if(onlyOne(word)){
                if(fullWord.containsKey(firstLetter)){
                    fullWord.get(firstLetter).add(word);
                } else {
                    ArrayList<String> list = new ArrayList<>();
                    list.add(word);
                    fullWord.put(firstLetter, list);
                }
                continue;
            }
            if(startWith.containsKey(firstLetter)) return IMPOSSIBLE;
            startWith.put(firstLetter, word);
            if(endWith.containsKey(lastLetter)) return IMPOSSIBLE;
            endWith.put(lastLetter, word);

            int start = 0;
            for (; start < word.length(); start++) {
                if(word.charAt(start) != firstLetter) break;
            }
            int end = word.length()-1;
            for (; end >= 0; end--) {
                if(word.charAt(end) != lastLetter) break;
            }
            for (int i = start; i <= end; i++) {
                char middle = word.charAt(i);
                if(allLetters.contains(middle)) return IMPOSSIBLE;
                allLetters.add(middle);
                middles.add(middle);
            }

        }


        // recherche de cycles
        Map<String, Node> map = new HashMap<>();
        for (Map.Entry<Character, String> entry : endWith.entrySet()) {
            String s = entry.getValue();
            Node prev = getNode(map, s);
            String p  = startWith.get(entry.getKey());
            if (p == null) continue;
            Node next = getNode(map, p);
            prev.next = next;
        }

        result = new LinkedList<>();
        for (Node value : map.values()) {
            if(value.status == Status.VISITED) continue;
            if(!visit(value)) return IMPOSSIBLE;
        }


        StringBuilder sb = new StringBuilder();
        for (String s : result) {
            char first = s.charAt(0);
            if(fullWord.containsKey(first)){
                fullWord.get(first).forEach(sb::append);
                fullWord.remove(first);
            }
            sb.append(s);
            char last = s.charAt(s.length() - 1);
            if(fullWord.containsKey(last)){
                fullWord.get(last).forEach(sb::append);
                fullWord.remove(last);
            }
        }

        for (List<String> list : fullWord.values()) {
            list.forEach(sb::append);
        }
        return sb.toString();
    }

    public static boolean visit(Node n) {
        n.status = Status.VISITING;
        Node v = n.next;
        if(v != null) {
            switch (v.status) {
                case VISITING:
                    return false;
                case DEFAULT:
                    if (!visit(v)) return false;
            }
        }
        n.status = Status.VISITED;
        result.addFirst(n.s);
        return true;
    }


    private static Node getNode(Map<String, Node> map, String s) {
        Node node = map.get(s);
        if(node == null) {
            node = new Node(s);
            map.put(s, node);
        }
        return node;
    }

    private static boolean onlyOne(String word){
        Set<Character> set = new HashSet<>();
        for (char c : word.toCharArray()) {
            set.add(c);
        }
        return set.size() ==1;
    }

    private static boolean isValid(String word){
        Set<Character> set = new HashSet<>();
        char prev = 0;
        for (char c : word.toCharArray()) {
            if(c != prev && set.contains(c)) return false;
            prev = c;
            set.add(c);
        }
        return true;
    }

    private static class Node{
        String s;
        Node next;
        Status status = Status.DEFAULT;

        public Node(String s) {
            this.s = s;
        }
    }

    public static int[] lineToInt(String line, String regex) {
        return Stream.of(line.split(regex)).mapToInt(Integer::parseInt).toArray();
    }

    public static int[] lineToInt(String line) {
        return lineToInt(line, "" "");
    }

    public static Stream<String> binaryStrings(int n) {
        return LongStream.range(0, 1L << n).mapToObj(l -> getBinaryString(l, n));
    }

    public static String getBinaryString(long value, int size) {
        return Long.toBinaryString(1L << size | value).substring(1, size + 1);
    }

    private enum Status",RicolaNouland
3523,"public class Solution {


    public static final String IMPOSSIBLE = ""IMPOSSIBLE"";
    private static String[] words;
    private static Deque<String> result;

    public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int t = Integer.parseInt(in.nextLine());  // Scanner has functions to read ints, longs, strings, chars, etc.
        for (int i = 1; i <= t; ++i) {
            in.nextLine();
            words = in.nextLine().split("" "");

            String result = solve();
            if(!isValid(result)){
                result = IMPOSSIBLE;
            }

            System.out.println(String.format(""Case #%d: %s"", i, result));
        }
    }

    private static String solve(){
        Map<Character, String> startWith = new HashMap<>();
        Map<Character, String> endWith = new HashMap<>();
        Map<Character, List<String>> fullWord = new HashMap<>();
        Set<Character> allLetters =  new HashSet<>();
        for (String word : words) {
            if(!isValid(word)){
                return IMPOSSIBLE;
            }
            char firstLetter = word.charAt(0);
            char lastLetter = word.charAt(word.length()-1);
            allLetters.add(firstLetter);
            allLetters.add(lastLetter);
            if(onlyOne(word)){
                if(fullWord.containsKey(firstLetter)){
                    fullWord.get(firstLetter).add(word);
                } else {
                    ArrayList<String> list = new ArrayList<>();
                    list.add(word);
                    fullWord.put(firstLetter, list);
                }
                continue;
            }
            if(startWith.containsKey(firstLetter)) return IMPOSSIBLE;
            startWith.put(firstLetter, word);
            if(endWith.containsKey(lastLetter)) return IMPOSSIBLE;
            endWith.put(lastLetter, word);

            int start = 0;
            for (; start < word.length(); start++) {
                if(word.charAt(start) != firstLetter) break;
            }
            int end = word.length()-1;
            for (; end >= 0; end--) {
                if(word.charAt(end) != lastLetter) break;
            }
            for (int i = start; i <= end; i++) {
                char middle = word.charAt(i);
                if(allLetters.contains(middle)) return IMPOSSIBLE;
                allLetters.add(middle);
            }

        }


        // recherche de cycles
        Map<String, Node> map = new HashMap<>();
        for (Map.Entry<Character, String> entry : endWith.entrySet()) {
            String s = entry.getValue();
            Node prev = getNode(map, s);
            String p  = startWith.get(entry.getKey());
            if (p == null) continue;
            Node next = getNode(map, p);
            prev.next = next;
        }

        result = new LinkedList<>();
        for (Node value : map.values()) {
            if(value.status == Status.VISITED) continue;
            if(!visit(value)) return IMPOSSIBLE;
        }


        StringBuilder sb = new StringBuilder();
        for (String s : result) {
            char first = s.charAt(0);
            if(fullWord.containsKey(first)){
                fullWord.get(first).forEach(sb::append);
                fullWord.remove(first);
            }
            sb.append(s);
            char last = s.charAt(s.length() - 1);
            if(fullWord.containsKey(last)){
                fullWord.get(last).forEach(sb::append);
                fullWord.remove(last);
            }
        }

        for (List<String> list : fullWord.values()) {
            list.forEach(sb::append);
        }
        return sb.toString();
    }

    public static boolean visit(Node n) {
        n.status = Status.VISITING;
        Node v = n.next;
        if(v != null) {
            switch (v.status) {
                case VISITING:
                    return false;
                case DEFAULT:
                    if (!visit(v)) return false;
            }
        }
        n.status = Status.VISITED;
        result.addFirst(n.s);
        return true;
    }


    private static Node getNode(Map<String, Node> map, String s) {
        Node node = map.get(s);
        if(node == null) {
            node = new Node(s);
            map.put(s, node);
        }
        return node;
    }

    private static boolean onlyOne(String word){
        Set<Character> set = new HashSet<>();
        for (char c : word.toCharArray()) {
            set.add(c);
        }
        return set.size() ==1;
    }

    private static boolean isValid(String word){
        Set<Character> set = new HashSet<>();
        char prev = 0;
        for (char c : word.toCharArray()) {
            if(c != prev && set.contains(c)) return false;
            prev = c;
            set.add(c);
        }
        return true;
    }

    private static class Node{
        String s;
        Node next;
        Status status = Status.DEFAULT;

        public Node(String s) {
            this.s = s;
        }
    }

    public static int[] lineToInt(String line, String regex) {
        return Stream.of(line.split(regex)).mapToInt(Integer::parseInt).toArray();
    }

    public static int[] lineToInt(String line) {
        return lineToInt(line, "" "");
    }

    public static Stream<String> binaryStrings(int n) {
        return LongStream.range(0, 1L << n).mapToObj(l -> getBinaryString(l, n));
    }

    public static String getBinaryString(long value, int size) {
        return Long.toBinaryString(1L << size | value).substring(1, size + 1);
    }

    private enum Status",RicolaNouland
3524,"public class Solution {


    public static final String IMPOSSIBLE = ""IMPOSSIBLE"";
    private static String[] words;
    private static Deque<String> result;

    public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int t = Integer.parseInt(in.nextLine());  // Scanner has functions to read ints, longs, strings, chars, etc.
        for (int i = 1; i <= t; ++i) {
            in.nextLine();
            words = in.nextLine().split("" "");

            String result = solveDummy();

            System.out.println(String.format(""Case #%d: %s"", i, result));
        }
    }

    private static String solveDummy(){
        ArrayList<String> results = new ArrayList<>();
        getPemutationsRecursive(words.length, words, results);
        return results.stream().filter(Solution::isValid).findFirst().orElse(IMPOSSIBLE);
    }

    public static void getPemutationsRecursive(int n, String[] elements, List<String> result) {
        if(n == 1) {
            result.add(Arrays.stream(elements).collect(Collectors.joining()));
        } else {
            for(int i = 0; i < n-1; i++) {
                getPemutationsRecursive(n - 1, elements, result);
                if(n % 2 == 0) {
                    swap(elements, i, n-1);
                } else {
                    swap(elements, 0, n-1);
                }
            }
            getPemutationsRecursive(n - 1, elements, result);
        }
    }

    private static void swap(String[] input, int a, int b) {
        String tmp = input[a];
        input[a] = input[b];
        input[b] = tmp;
    }


    private static String solve(){
        Map<Character, String> startWith = new HashMap<>();
        Map<Character, String> endWith = new HashMap<>();
        Map<Character, List<String>> fullWord = new HashMap<>();
        Set<Character> allLetters =  new HashSet<>();
        for (String word : words) {
            if(!isValid(word)){
                return IMPOSSIBLE;
            }
            char firstLetter = word.charAt(0);
            char lastLetter = word.charAt(word.length()-1);
            allLetters.add(firstLetter);
            allLetters.add(lastLetter);
            if(onlyOne(word)){
                if(fullWord.containsKey(firstLetter)){
                    fullWord.get(firstLetter).add(word);
                } else {
                    ArrayList<String> list = new ArrayList<>();
                    list.add(word);
                    fullWord.put(firstLetter, list);
                }
                continue;
            }
            if(startWith.containsKey(firstLetter)) return IMPOSSIBLE;
            startWith.put(firstLetter, word);
            if(endWith.containsKey(lastLetter)) return IMPOSSIBLE;
            endWith.put(lastLetter, word);

            int start = 0;
            for (; start < word.length(); start++) {
                if(word.charAt(start) != firstLetter) break;
            }
            int end = word.length()-1;
            for (; end >= 0; end--) {
                if(word.charAt(end) != lastLetter) break;
            }
            for (int i = start; i <= end; i++) {
                char middle = word.charAt(i);
                if(allLetters.contains(middle)) return IMPOSSIBLE;
                allLetters.add(middle);
            }

        }


        // recherche de cycles
        Map<String, Node> map = new HashMap<>();
        for (Map.Entry<Character, String> entry : endWith.entrySet()) {
            String s = entry.getValue();
            Node prev = getNode(map, s);
            String p  = startWith.get(entry.getKey());
            if (p == null) continue;
            Node next = getNode(map, p);
            prev.next = next;
        }

        result = new LinkedList<>();
        for (Node value : map.values()) {
            if(value.status == Status.VISITED) continue;
            if(!visit(value)) return IMPOSSIBLE;
        }


        StringBuilder sb = new StringBuilder();
        for (String s : result) {
            char first = s.charAt(0);
            if(fullWord.containsKey(first)){
                fullWord.get(first).forEach(sb::append);
                fullWord.remove(first);
            }
            sb.append(s);
            char last = s.charAt(s.length() - 1);
            if(fullWord.containsKey(last)){
                fullWord.get(last).forEach(sb::append);
                fullWord.remove(last);
            }
        }

        for (List<String> list : fullWord.values()) {
            list.forEach(sb::append);
        }
        return sb.toString();
    }

    public static boolean visit(Node n) {
        n.status = Status.VISITING;
        Node v = n.next;
        if(v != null) {
            switch (v.status) {
                case VISITING:
                    return false;
                case DEFAULT:
                    if (!visit(v)) return false;
            }
        }
        n.status = Status.VISITED;
        result.addFirst(n.s);
        return true;
    }


    private static Node getNode(Map<String, Node> map, String s) {
        Node node = map.get(s);
        if(node == null) {
            node = new Node(s);
            map.put(s, node);
        }
        return node;
    }

    private static boolean onlyOne(String word){
        Set<Character> set = new HashSet<>();
        for (char c : word.toCharArray()) {
            set.add(c);
        }
        return set.size() ==1;
    }

    private static boolean isValid(String word){
        Set<Character> set = new HashSet<>();
        char prev = 0;
        for (char c : word.toCharArray()) {
            if(c != prev && set.contains(c)) return false;
            prev = c;
            set.add(c);
        }
        return true;
    }

    private static class Node{
        String s;
        Node next;
        Status status = Status.DEFAULT;

        public Node(String s) {
            this.s = s;
        }
    }

    public static int[] lineToInt(String line, String regex) {
        return Stream.of(line.split(regex)).mapToInt(Integer::parseInt).toArray();
    }

    public static int[] lineToInt(String line) {
        return lineToInt(line, "" "");
    }

    public static Stream<String> binaryStrings(int n) {
        return LongStream.range(0, 1L << n).mapToObj(l -> getBinaryString(l, n));
    }

    public static String getBinaryString(long value, int size) {
        return Long.toBinaryString(1L << size | value).substring(1, size + 1);
    }

    private enum Status",RicolaNouland
3525,"public class Solution {


    public static final String IMPOSSIBLE = ""IMPOSSIBLE"";
    private static String[] words;
    private static Deque<String> result;

    public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int t = Integer.parseInt(in.nextLine());  // Scanner has functions to read ints, longs, strings, chars, etc.
        for (int i = 1; i <= t; ++i) {
            in.nextLine();
            words = in.nextLine().split("" "");

            String result = solve();

            System.out.println(String.format(""Case #%d: %s"", i, result));
        }
    }

    private static String solve(){
        Map<Character, String> startWith = new HashMap<>();
        Map<Character, String> endWith = new HashMap<>();
        Map<Character, List<String>> fullWord = new HashMap<>();
        Set<Character> allLetters =  new HashSet<>();
        for (String word : words) {
            if(!isValid(word)){
                return IMPOSSIBLE;
            }
            char firstLetter = word.charAt(0);
            char lastLetter = word.charAt(word.length()-1);
            allLetters.add(firstLetter);
            allLetters.add(lastLetter);
            if(onlyOne(word)){
                if(fullWord.containsKey(firstLetter)){
                    fullWord.get(firstLetter).add(word);
                } else {
                    ArrayList<String> list = new ArrayList<>();
                    list.add(word);
                    fullWord.put(firstLetter, list);
                }
                continue;
            }
            if(startWith.containsKey(firstLetter)) return IMPOSSIBLE;
            startWith.put(firstLetter, word);
            if(endWith.containsKey(lastLetter)) return IMPOSSIBLE;
            endWith.put(lastLetter, word);

            int start = 0;
            for (; start < word.length(); start++) {
                if(word.charAt(start) != firstLetter) break;
            }
            int end = word.length()-1;
            for (; end >= 0; end--) {
                if(word.charAt(end) != lastLetter) break;
            }
            for (int i = start; i <= end; i++) {
                char middle = word.charAt(i);
                if(allLetters.contains(middle)) return IMPOSSIBLE;
                allLetters.add(middle);
            }

        }


        // recherche de cycles
        Map<String, Node> map = new HashMap<>();
        for (Map.Entry<Character, String> entry : endWith.entrySet()) {
            String s = entry.getValue();
            Node prev = getNode(map, s);
            String p  = startWith.get(entry.getKey());
            if (p == null) continue;
            Node next = getNode(map, p);
            prev.next = next;
        }

        result = new LinkedList<>();
        for (Node value : map.values()) {
            if(value.status == Status.VISITED) continue;
            if(!visit(value)) return IMPOSSIBLE;
        }


        StringBuilder sb = new StringBuilder();
        for (String s : result) {
            char first = s.charAt(0);
            if(fullWord.containsKey(first)){
                fullWord.get(first).forEach(sb::append);
                fullWord.remove(first);
            }
            sb.append(s);
            char last = s.charAt(s.length() - 1);
            if(fullWord.containsKey(last)){
                fullWord.get(last).forEach(sb::append);
                fullWord.remove(last);
            }
        }

        for (List<String> list : fullWord.values()) {
            list.forEach(sb::append);
        }
        return sb.toString();
    }

    public static boolean visit(Node n) {
        n.status = Status.VISITING;
        Node v = n.next;
        if(v != null) {
            switch (v.status) {
                case VISITING:
                    return false;
                case DEFAULT:
                    if (!visit(v)) return false;
            }
        }
        n.status = Status.VISITED;
        result.addFirst(n.s);
        return true;
    }


    private static Node getNode(Map<String, Node> map, String s) {
        Node node = map.get(s);
        if(node == null) {
            node = new Node(s);
            map.put(s, node);
        }
        return node;
    }

    private static boolean onlyOne(String word){
        Set<Character> set = new HashSet<>();
        for (char c : word.toCharArray()) {
            set.add(c);
        }
        return set.size() ==1;
    }

    private static boolean isValid(String word){
        Set<Character> set = new HashSet<>();
        char prev = 0;
        for (char c : word.toCharArray()) {
            if(c != prev && set.contains(c)) return false;
            prev = c;
            set.add(c);
        }
        return true;
    }

    private static class Node{
        String s;
        Node next;
        Status status = Status.DEFAULT;

        public Node(String s) {
            this.s = s;
        }
    }

    public static int[] lineToInt(String line, String regex) {
        return Stream.of(line.split(regex)).mapToInt(Integer::parseInt).toArray();
    }

    public static int[] lineToInt(String line) {
        return lineToInt(line, "" "");
    }

    public static Stream<String> binaryStrings(int n) {
        return LongStream.range(0, 1L << n).mapToObj(l -> getBinaryString(l, n));
    }

    public static String getBinaryString(long value, int size) {
        return Long.toBinaryString(1L << size | value).substring(1, size + 1);
    }

    private enum Status",RicolaNouland
3526,"public class Solution {


    public static final String IMPOSSIBLE = ""IMPOSSIBLE"";
    private static String[] words;
    private static Deque<String> result;

    public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int t = Integer.parseInt(in.nextLine());  // Scanner has functions to read ints, longs, strings, chars, etc.
        for (int i = 1; i <= t; ++i) {
            in.nextLine();
            words = in.nextLine().split("" "");

            String result = solve();

            System.out.println(String.format(""Case #%d: %s"", i, result));
        }
    }

    private static String solve(){
        Map<Character, String> startWith = new HashMap<>();
        Map<Character, String> endWith = new HashMap<>();
        Map<Character, List<String>> fullWord = new HashMap<>();
        Set<Character> allLetters =  new HashSet<>();
        for (String word : words) {
            if(!isValid(word)){
                return IMPOSSIBLE;
            }
            char firstLetter = word.charAt(0);
            char lastLetter = word.charAt(word.length()-1);
            if(onlyOne(word)){
                if(fullWord.containsKey(firstLetter)){
                    fullWord.get(firstLetter).add(word);
                } else {
                    ArrayList<String> list = new ArrayList<>();
                    list.add(word);
                    fullWord.put(firstLetter, list);
                }
                allLetters.add(firstLetter);
                continue;
            }
            if(startWith.containsKey(firstLetter)) return IMPOSSIBLE;
            startWith.put(firstLetter, word);
            if(endWith.containsKey(lastLetter)) return IMPOSSIBLE;
            endWith.put(lastLetter, word);

            int start = 0;
            for (; start < word.length(); start++) {
                if(word.charAt(start) != firstLetter) break;
            }
            int end = word.length()-1;
            for (; end >= 0; end--) {
                if(word.charAt(end) != lastLetter) break;
            }
            for (int i = start; i <= end; i++) {
                char middle = word.charAt(i);
                if(allLetters.contains(middle)) return IMPOSSIBLE;
                allLetters.add(middle);
            }

        }


        // recherche de cycles
        Map<String, Node> map = new HashMap<>();
        for (Map.Entry<Character, String> entry : endWith.entrySet()) {
            String s = entry.getValue();
            Node prev = getNode(map, s);
            String p  = startWith.get(entry.getKey());
            if (p == null) continue;
            Node next = getNode(map, p);
            prev.next = next;
        }

        result = new LinkedList<>();
        for (Node value : map.values()) {
            if(value.status == Status.VISITED) continue;
            if(!visit(value)) return IMPOSSIBLE;
        }


        StringBuilder sb = new StringBuilder();
        for (String s : result) {
            char first = s.charAt(0);
            if(fullWord.containsKey(first)){
                fullWord.get(first).forEach(sb::append);
                fullWord.remove(first);
            }
            sb.append(s);
            char last = s.charAt(s.length() - 1);
            if(fullWord.containsKey(last)){
                fullWord.get(last).forEach(sb::append);
                fullWord.remove(last);
            }
        }

        for (List<String> list : fullWord.values()) {
            list.forEach(sb::append);
        }
        return sb.toString();
    }

    public static boolean visit(Node n) {
        n.status = Status.VISITING;
        Node v = n.next;
        if(v != null) {
            switch (v.status) {
                case VISITING:
                    return false;
                case DEFAULT:
                    if (!visit(v)) return false;
            }
        }
        n.status = Status.VISITED;
        result.addFirst(n.s);
        return true;
    }


    private static Node getNode(Map<String, Node> map, String s) {
        Node node = map.get(s);
        if(node == null) {
            node = new Node(s);
            map.put(s, node);
        }
        return node;
    }

    private static boolean onlyOne(String word){
        Set<Character> set = new HashSet<>();
        for (char c : word.toCharArray()) {
            set.add(c);
        }
        return set.size() ==1;
    }

    private static boolean isValid(String word){
        Set<Character> set = new HashSet<>();
        char prev = 0;
        for (char c : word.toCharArray()) {
            if(c != prev && set.contains(c)) return false;
            prev = c;
            set.add(c);
        }
        return true;
    }

    private static class Node{
        String s;
        Node next;
        Status status = Status.DEFAULT;

        public Node(String s) {
            this.s = s;
        }
    }

    public static int[] lineToInt(String line, String regex) {
        return Stream.of(line.split(regex)).mapToInt(Integer::parseInt).toArray();
    }

    public static int[] lineToInt(String line) {
        return lineToInt(line, "" "");
    }

    public static Stream<String> binaryStrings(int n) {
        return LongStream.range(0, 1L << n).mapToObj(l -> getBinaryString(l, n));
    }

    public static String getBinaryString(long value, int size) {
        return Long.toBinaryString(1L << size | value).substring(1, size + 1);
    }

    private enum Status",RicolaNouland
3876,"public class Solution {
	private static final long INV = -1_000_000_001l;
	private static long sum1;
	private static long sum2;

	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new  InputStreamReader(System.in));
		int T = Integer.parseInt(br.readLine());
		for (int testcase = 1; testcase <=T; testcase++) {
			StringTokenizer st = new StringTokenizer(br.readLine());
			int cnt = Integer.parseInt(st.nextToken());
			int cnt2 = Integer.parseInt(st.nextToken());
			st = new StringTokenizer(br.readLine());
			long[] org_a = new long[cnt];
			for (int i = 0; i < cnt; i++) {
				org_a[i]= Long.parseLong(st.nextToken());
			}
			StringBuilder sb = new StringBuilder();
			long final_answer = INV;
			long[] a = new long[cnt];
			sum1 = 0;
			sum2 = 0;
			for (int i = 0; i < cnt; i++) {
				a[i]= org_a[i];
				sum1+=a[i];
				sum2+=a[i]*a[i];
			}
			for (int j = 0; j < cnt2; j++) {
				if(j!=0) {
					long tmp = -sum1+1;
					sum1+=tmp;
					sum2+=(tmp*tmp);
					sb.append(tmp+"" "");
				}
				long answer=bs();
				if(answer==INV) {
					answer=rbs();
				}
				if(answer!=INV) {
					sb.append(answer);
					final_answer=answer;
					break;
				}
			}
			if(final_answer==INV) {
				System.out.println(""Case #""+testcase+"": IMPOSSIBLE"");
			}else {
				System.out.println(""Case #""+testcase+"": ""+sb);
			}
		}
	}

	private static long bs() {
		long l= -sum1;
		long r= 1_000_000_000l;
		while(l<=r) {
			long mid = (l+r)/2l;
			if((sum1+mid)*(sum1+mid)==sum2+mid*mid) return mid;
			if((sum1+mid)*(sum1+mid)< sum2+mid*mid) l=mid+1l;
			else r=mid-1l;
		}
		return INV;
	}
	private static long rbs() {
		long l= -1_000_000_000l;
		long r= -sum1;
		while(l<=r) {
			long mid = (l+r)/2l;
			if((sum1+mid)*(sum1+mid)==sum2+mid*mid) return mid;
			if((sum1+mid)*(sum1+mid)> sum2+mid*mid) l=mid+1l;
			else r=",namgoi
3877,"public class Solution {
	private static final long INV = -1_000_000_001l;
	private static long sum1;
	private static long sum2;

	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new  InputStreamReader(System.in));
		int T = Integer.parseInt(br.readLine());
		for (int testcase = 1; testcase <=T; testcase++) {
			StringTokenizer st = new StringTokenizer(br.readLine());
			int cnt = Integer.parseInt(st.nextToken());
			int cnt2 = Integer.parseInt(st.nextToken());
			st = new StringTokenizer(br.readLine());
			long[] org_a = new long[cnt];
			for (int i = 0; i < cnt; i++) {
				org_a[i]= Long.parseLong(st.nextToken());
			}
			StringBuilder sb = new StringBuilder();
			long final_answer = INV;
			long[] a = new long[cnt];
			sum1 = 0;
			sum2 = 0;
			for (int i = 0; i < cnt; i++) {
				a[i]= org_a[i];
				sum1+=a[i];
				sum2+=a[i]*a[i];
			}
			for (int j = 0; j < cnt2; j++) {
				if(j!=0) {
					long tmp = -sum1;
					sum1+=tmp;
					sum2+=(tmp*tmp);
					sb.append(tmp+"" "");
				}
				long answer=bs();
				if(answer==INV) {
					answer=rbs();
				}
				if(answer!=INV) {
					sb.append(answer);
					final_answer=answer;
					break;
				}
			}
			if(final_answer==INV) {
				System.out.println(""Case #""+testcase+"": IMPOSSIBLE"");
			}else {
				System.out.println(""Case #""+testcase+"": ""+sb);
			}
		}
	}

	private static long bs() {
		long l= -sum1;
		long r= 1_000_000_000l;
		while(l<=r) {
			long mid = (l+r)/2l;
			if((sum1+mid)*(sum1+mid)==sum2+mid*mid) return mid;
			if((sum1+mid)*(sum1+mid)< sum2+mid*mid) l=mid+1l;
			else r=mid-1l;
		}
		return INV;
	}
	private static long rbs() {
		long l= -1_000_000_000l;
		long r= -sum1;
		while(l<=r) {
			long mid = (l+r)/2l;
			if((sum1+mid)*(sum1+mid)==sum2+mid*mid) return mid;
			if((sum1+mid)*(sum1+mid)> sum2+mid*mid) l=mid+1l;
			else r=",namgoi
3878,"public class Solution {
	private static long sum1;
	private static long sum2;

	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new  InputStreamReader(System.in));
		int T = Integer.parseInt(br.readLine());
		for (int testcase = 1; testcase <=T; testcase++) {
			StringTokenizer st = new StringTokenizer(br.readLine());
			int cnt = Integer.parseInt(st.nextToken());
			int cnt2 = Integer.parseInt(st.nextToken());
			st = new StringTokenizer(br.readLine());
			long[] a = new long[cnt];
			sum1 = 0;
			sum2 = 0;	
			for (int i = 0; i < cnt; i++) {
				a[i]= Long.parseLong(st.nextToken());
				sum1+=a[i];
				sum2+=a[i]*a[i];
			}
			boolean ispossible = false;
			long answer=bs();
			if(answer==-1000000000000000001l) {
				answer=rbs();
			}
			if(answer==-1000000000000000001l) {
				System.out.println(""Case #""+testcase+"": IMPOSSIBLE"");
			}else {
				System.out.println(""Case #""+testcase+"": ""+answer);	
			}
			
		}
	}

	private static long bs() {
		long l= -sum1;
		long r= 100000000000l; 
		while(l<=r) { 
			long mid = (l+r)/2;
			if((sum1+mid)*(sum1+mid)==sum2+mid*mid) return mid;
			if((sum1+mid)*(sum1+mid)< sum2+mid*mid) l=mid+1;
			else r=mid-1;
		}
		return -1000000000000000001l;
	}
	private static long rbs() {
		long l= -100000000000l;
		long r= sum1; 
		while(l<=r) { 
			long mid = (l+r)/2;
			if((sum1+mid)*(sum1+mid)==sum2+mid*mid) return mid;
			if((sum1+mid)*(sum1+mid)< sum2+mid*mid) l=mid+1;
			else r=",namgoi
3879,"public class Solution {
	private static long sum1;
	private static long sum2;

	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new  InputStreamReader(System.in));
		int T = Integer.parseInt(br.readLine());
		for (int testcase = 1; testcase <=T; testcase++) {
			StringTokenizer st = new StringTokenizer(br.readLine());
			int cnt = Integer.parseInt(st.nextToken());
			int cnt2 = Integer.parseInt(st.nextToken());
			st = new StringTokenizer(br.readLine());
			long[] a = new long[cnt];
			sum1 = 0;
			sum2 = 0;	
			for (int i = 0; i < cnt; i++) {
				a[i]= Long.parseLong(st.nextToken());
				sum1+=a[i];
				sum2+=a[i]*a[i];
			}
			boolean ispossible = false;
			long answer=bs();
			if(answer==-1000000000000000001l) {
				answer=rbs();
			}
			if(answer==-1000000000000000001l) {
				System.out.println(""Case #""+testcase+"": IMPOSSIBLE"");
			}else {
				System.out.println(""Case #""+testcase+"": ""+answer);	
			}
			
		}
	}

	private static long bs() {
		long l= -sum1;
		long r= 100000000000l; // 범위 안쪽
		while(l<=r) { // 부등호 주의
			long mid = (l+r)/2;
			if((sum1+mid)*(sum1+mid)==sum2+mid*mid) return mid;
			if((sum1+mid)*(sum1+mid)< sum2+mid*mid) l=mid+1;
			else r=mid-1;
		}
		return -1000000000000000001l;
	}
	private static long rbs() {
		long l= -100000000000l;
		long r= sum1; // 범위 안쪽
		while(l<=r) { // 부등호 주의
			long mid = (l+r)/2;
			if((sum1+mid)*(sum1+mid)==sum2+mid*mid) return mid;
			if((sum1+mid)*(sum1+mid)< sum2+mid*mid) l=mid+1;
			else r=",namgoi
3880,"public class Solution {
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new  InputStreamReader(System.in));
		int T = Integer.parseInt(br.readLine());
		for (int testcase = 1; testcase <=T; testcase++) {
			StringTokenizer st = new StringTokenizer(br.readLine());
			int cnt = Integer.parseInt(st.nextToken());
			int cnt2 = Integer.parseInt(st.nextToken());
			st = new StringTokenizer(br.readLine());
			long[] a = new long[cnt];
			long sum1 = 0;
			long sum2 = 0;	
			for (int i = 0; i < cnt; i++) {
				a[i]= Long.parseLong(st.nextToken());
				sum1+=a[i];
				sum2+=a[i]*a[i];
			}
			boolean ispossible = false;
			long answer=0;
			for (long i = -10000000; i <=10000000; i++) {
				if((sum1+i)*(sum1+i)==sum2+i*i) {
					answer=i;
					ispossible =true;
					break;
				}
			}
			if(ispossible) {
				System.out.println(""Case #""+testcase+"": ""+answer);	
			}else {
				System.",namgoi
3881,"public class Solution {
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new  InputStreamReader(System.in));
		int T = Integer.parseInt(br.readLine());
		for (int testcase = 1; testcase <=T; testcase++) {
			StringTokenizer st = new StringTokenizer(br.readLine());
			int cnt = Integer.parseInt(st.nextToken());
			int cnt2 = Integer.parseInt(st.nextToken());
			st = new StringTokenizer(br.readLine());
			long[] a = new long[cnt];
			long sum1 = 0;
			long sum2 = 0;	
			for (int i = 0; i < cnt; i++) {
				a[i]= Long.parseLong(st.nextToken());
				sum1+=a[i];
				sum2+=a[i]*a[i];
			}
			boolean ispossible = false;
			long answer=0;
			for (long i = -1000; i <=1000; i++) {
				if((sum1+i)*(sum1+i)==sum2+i*i) {
					answer=i;
					ispossible =true;
					break;
				}
			}
			if(ispossible) {
				System.out.println(""Case #""+testcase+"": ""+answer);	
			}else {
				System.",namgoi
3882,"public class Solution {
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new  InputStreamReader(System.in));
		int T = Integer.parseInt(br.readLine());
		for (int testcase = 1; testcase <=T; testcase++) {
			int cnt = Integer.parseInt(br.readLine());
			StringTokenizer st = new StringTokenizer(br.readLine());
			String[] str = new String[cnt];
			boolean[][] charbit = new boolean[cnt][26];
			boolean ispossible = true;
			char[] lchar = new char[cnt];
			char[] rchar = new char[cnt];
			for (int i = 0; i < cnt; i++) {
				str[i] = st.nextToken();
			}
			Arrays.sort(str);
			for (int i = 0; i < cnt; i++) {
				char[] tmp = str[i].toCharArray();
				char prev='0';
				lchar[i]=tmp[0];
				rchar[i]=tmp[tmp.length-1];
				for (char chr : tmp) {
					if(prev !=chr && charbit[i][chr-'A']==true) {
						ispossible=false;
					}
					charbit[i][chr-'A']=true;
					prev=chr;
				}
			}
			StringBuilder answer = new StringBuilder();
			ArrayList<Integer>[] list = new ArrayList[cnt];
			for (int i = 0; i < cnt; i++) {
				list[i]= new ArrayList<Integer>();
			}
			boolean[] usebit = new boolean[26];
			int[] indegree = new int[cnt];
			for (int i = 0; i < cnt; i++) {
				for (int j = i+1; j < cnt; j++) {
					if(rchar[i]==lchar[j]) {
						list[i].add(j);
						indegree[j]++;
					}else if(rchar[j]==lchar[i]) {
						list[j].add(i);
						indegree[i]++;
					}
				}
			}
			if(ispossible==true) {
				int connect=0;
				char topchar = '0';
				boolean[] isuse= new boolean[cnt];
				for (int i = 0; i < cnt; i++) {
					if(isuse[i]) continue;
					if(rchar[i]!=lchar[i]) continue;
					for (int j = 0; j < cnt; j++) {
						int k=(i+j+1)%cnt;
						if(rchar[k]!=lchar[k]) continue;
						if(isuse[k]) continue;
						if(i==k) continue;
//							if(str[i].compareTo(""CODEEEL"")==0 && str[j].compareTo(""JAMMIC"")==0) {
//								System.out.println(""aa"");
//							}
						if(rchar[i]==lchar[k]) {
							str[i] = str[i]+str[k];
							rchar[i]=rchar[k];
//								if(j==2) {
//									System.out.println(str[i]);
//									System.out.println(str[j]);
//								}
							isuse[k]=true;
						}
					}
				}
				for (int z = 0; z < cnt*2; z++) {
					for (int i = 0; i < cnt; i++) {
						if(isuse[i]) continue;
						for (int j = 0; j < cnt; j++) {
							int k=(i+j+1)%cnt;
							if(isuse[k]) continue;
							if(i==k) continue;
//							if(str[i].compareTo(""CODEEEL"")==0 && str[j].compareTo(""JAMMIC"")==0) {
//								System.out.println(""aa"");
//							}
							if(rchar[i]==lchar[k]) {
								str[i] = str[i]+str[k];
								rchar[i]=rchar[k];
//								if(j==2) {
//									System.out.println(str[i]);
//									System.out.println(str[j]);
//								}
								isuse[k]=true;
							}
						}
					}
				}
//				System.out.println(Arrays.toString(str));
//				System.out.println(Arrays.toString(isuse));
				for (int i = 0; i < cnt; i++) {
					if(isuse[i]==false) answer.append(str[i]);
				}
				char[] anschar = answer.toString().toCharArray();
				char prevchar='0';
				for (char chr : anschar) {
					if(prevchar==chr) continue;
					if(usebit[chr-'A']==true) {
						ispossible=false;
					}
					usebit[chr-'A']=true;
					prevchar=chr;
				}
			}
			if(ispossible) {
				System.out.println(""Case #""+testcase+"": ""+answer);	
			}else {
				System.",namgoi
3883,"public class Solution {
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new  InputStreamReader(System.in));
		int T = Integer.parseInt(br.readLine());
		for (int testcase = 1; testcase <=T; testcase++) {
			int cnt = Integer.parseInt(br.readLine());
			StringTokenizer st = new StringTokenizer(br.readLine());
			String[] str = new String[cnt];
			boolean[][] charbit = new boolean[cnt][26];
			boolean ispossible = true;
			char[] lchar = new char[cnt];
			char[] rchar = new char[cnt];
			for (int i = 0; i < cnt; i++) {
				str[i] = st.nextToken();
			}
			Arrays.sort(str);
			for (int i = 0; i < cnt; i++) {
				char[] tmp = str[i].toCharArray();
				char prev='0';
				lchar[i]=tmp[0];
				rchar[i]=tmp[tmp.length-1];
				for (char chr : tmp) {
					if(prev !=chr && charbit[i][chr-'A']==true) {
						ispossible=false;
					}
					charbit[i][chr-'A']=true;
					prev=chr;
				}
			}
			StringBuilder answer = new StringBuilder();
			ArrayList<Integer>[] list = new ArrayList[cnt];
			for (int i = 0; i < cnt; i++) {
				list[i]= new ArrayList<Integer>();
			}
			boolean[] usebit = new boolean[26];
			int[] indegree = new int[cnt];
			for (int i = 0; i < cnt; i++) {
				for (int j = i+1; j < cnt; j++) {
					if(rchar[i]==lchar[j]) {
						list[i].add(j);
						indegree[j]++;
					}else if(rchar[j]==lchar[i]) {
						list[j].add(i);
						indegree[i]++;
					}
				}
			}
			if(ispossible==true) {
				int connect=0;
				char topchar = '0';
				boolean[] isuse= new boolean[cnt];
				for (int z = 0; z < cnt*2; z++) {
					for (int i = 0; i < cnt; i++) {
						if(isuse[i]) continue;
						for (int j = 0; j < cnt; j++) {
							int k=(i+j+1)%cnt;
							if(isuse[k]) continue;
							if(i==k) continue;
//							if(str[i].compareTo(""CODEEEL"")==0 && str[j].compareTo(""JAMMIC"")==0) {
//								System.out.println(""aa"");
//							}
							if(rchar[i]==lchar[k]) {
								str[i] = str[i]+str[k];
								rchar[i]=rchar[k];
//								if(j==2) {
//									System.out.println(str[i]);
//									System.out.println(str[j]);
//								}
								isuse[k]=true;
							}
						}
					}
				}
//				System.out.println(Arrays.toString(str));
//				System.out.println(Arrays.toString(isuse));
				for (int i = 0; i < cnt; i++) {
					if(isuse[i]==false) answer.append(str[i]);
				}
				char[] anschar = answer.toString().toCharArray();
				char prevchar='0';
				for (char chr : anschar) {
					if(prevchar==chr) continue;
					if(usebit[chr-'A']==true) {
						ispossible=false;
					}
					usebit[chr-'A']=true;
					prevchar=chr;
				}
			}
			if(ispossible) {
				System.out.println(""Case #""+testcase+"": ""+answer);	
			}else {
				System.",namgoi
3884,"public class Solution {
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new  InputStreamReader(System.in));
		int T = Integer.parseInt(br.readLine());
		for (int testcase = 1; testcase <=T; testcase++) {
			int cnt = Integer.parseInt(br.readLine());
			StringTokenizer st = new StringTokenizer(br.readLine());
			String[] str = new String[cnt];
			boolean[][] charbit = new boolean[cnt][26];
			boolean ispossible = true;
			char[] lchar = new char[cnt];
			char[] rchar = new char[cnt];
			for (int i = 0; i < cnt; i++) {
				str[i] = st.nextToken();
			}
			Arrays.sort(str);
			for (int i = 0; i < cnt; i++) {
				char[] tmp = str[i].toCharArray();
				char prev='0';
				lchar[i]=tmp[0];
				rchar[i]=tmp[tmp.length-1];
				for (char chr : tmp) {
					if(prev !=chr && charbit[i][chr-'A']==true) {
						ispossible=false;
					}
					charbit[i][chr-'A']=true;
					prev=chr;
				}
			}
			StringBuilder answer = new StringBuilder();
			ArrayList<Integer>[] list = new ArrayList[cnt];
			for (int i = 0; i < cnt; i++) {
				list[i]= new ArrayList<Integer>();
			}
			boolean[] usebit = new boolean[26];
			int[] indegree = new int[cnt];
			for (int i = 0; i < cnt; i++) {
				for (int j = i+1; j < cnt; j++) {
					if(rchar[i]==lchar[j]) {
						list[i].add(j);
						indegree[j]++;
					}else if(rchar[j]==lchar[i]) {
						list[j].add(i);
						indegree[i]++;
					}
				}
			}
			if(ispossible==true) {
				int connect=0;
				char topchar = '0';
				boolean[] isuse= new boolean[cnt];
				for (int z = 0; z < cnt*2; z++) {
					for (int i = 0; i < cnt; i++) {
						if(isuse[i]) continue;
						for (int j = 0; j < cnt; j++) {
							if(isuse[j]) continue;
							if(i==j) continue;
//							if(str[i].compareTo(""CODEEEL"")==0 && str[j].compareTo(""JAMMIC"")==0) {
//								System.out.println(""aa"");
//							}
							if(rchar[i]==lchar[j]) {
								str[i] = str[i]+str[j];
								rchar[i]=rchar[j];
//								if(j==2) {
//									System.out.println(str[i]);
//									System.out.println(str[j]);
//								}
								isuse[j]=true;
							}
						}
					}
				}
//				System.out.println(Arrays.toString(str));
//				System.out.println(Arrays.toString(isuse));
				for (int i = 0; i < cnt; i++) {
					if(isuse[i]==false) answer.append(str[i]);
				}
				char[] anschar = answer.toString().toCharArray();
				char prevchar='0';
				for (char chr : anschar) {
					if(prevchar==chr) continue;
					if(usebit[chr-'A']==true) {
						ispossible=false;
					}
					usebit[chr-'A']=true;
					prevchar=chr;
				}
			}
			if(ispossible) {
				System.out.println(""Case #""+testcase+"": ""+answer);	
			}else {
				System.",namgoi
3885,"public class Solution {
	private static final long INV = -1_000_000_001l;
	private static long sum1;
	private static long sum2;

	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new  InputStreamReader(System.in));
		int T = Integer.parseInt(br.readLine());
		for (int testcase = 1; testcase <=T; testcase++) {
			StringTokenizer st = new StringTokenizer(br.readLine());
			int cnt = Integer.parseInt(st.nextToken());
			int cnt2 = Integer.parseInt(st.nextToken());
			st = new StringTokenizer(br.readLine());
			long[] org_a = new long[cnt];
			for (int i = 0; i < cnt; i++) {
				org_a[i]= Long.parseLong(st.nextToken());
			}
			StringBuilder sb = new StringBuilder();
			long final_answer = INV;
			long[] a = new long[cnt];
			sum1 = 0;
			sum2 = 0;
			for (int i = 0; i < cnt; i++) {
				a[i]= org_a[i];
				sum1+=a[i];
				sum2+=a[i]*a[i];
			}
			for (int j = 0; j < cnt2; j++) {
				if(j!=0) {
					if(sum1>=sum2) {
						sum1+=-1;
						sum2+=1;
						sb.append(""-1 "");
					}else if (sum1<sum2) {
						sum1+=1;
						sum2+=1;
						sb.append(""1 "");
					}
				}
				long answer=bs();
				if(answer==INV) {
					answer=rbs();
				}
				if(answer!=INV) {
					sb.append(answer);
					final_answer=answer;
					break;
				}
			}
			if(final_answer==INV) {
				System.out.println(""Case #""+testcase+"": IMPOSSIBLE"");
			}else {
				System.out.println(""Case #""+testcase+"": ""+sb);
			}
		}
	}

	private static long bs() {
		long l= -sum1;
		long r= 1_000_000_000l;
		while(l<=r) {
			long mid = (l+r)/2l;
			if((sum1+mid)*(sum1+mid)==sum2+mid*mid) return mid;
			if((sum1+mid)*(sum1+mid)< sum2+mid*mid) l=mid+1l;
			else r=mid-1l;
		}
		return INV;
	}
	private static long rbs() {
		long l= -1_000_000_000l;
		long r= -sum1;
		while(l<=r) {
			long mid = (l+r)/2l;
			if((sum1+mid)*(sum1+mid)==sum2+mid*mid) return mid;
			if((sum1+mid)*(sum1+mid)> sum2+mid*mid) l=mid+1l;
			else r=",namgoi
3886,"public class Solution {
	private static final long INV = -1_000_000_001l;
	private static long sum1;
	private static long sum2;

	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new  InputStreamReader(System.in));
		int T = Integer.parseInt(br.readLine());
		for (int testcase = 1; testcase <=T; testcase++) {
			StringTokenizer st = new StringTokenizer(br.readLine());
			int cnt = Integer.parseInt(st.nextToken());
			int cnt2 = Integer.parseInt(st.nextToken());
			st = new StringTokenizer(br.readLine());
			long[] org_a = new long[cnt];
			for (int i = 0; i < cnt; i++) {
				org_a[i]= Long.parseLong(st.nextToken());
			}
			StringBuilder sb = new StringBuilder();
			long final_answer = INV;
			long[] a = new long[cnt];
			sum1 = 0;
			sum2 = 0;
			for (int i = 0; i < cnt; i++) {
				a[i]= org_a[i];
				sum1+=a[i];
				sum2+=a[i]*a[i];
			}
			for (int j = 0; j < cnt2; j++) {
				if(j!=0) {
					if(sum1>=sum2) {
						sum1+=-1;
						sum2+=1;
						sb.append(""-1 "");
					}else if (sum1<sum2) {
						sum1+=-1;
						sum2+=1;
						sb.append(""-1 "");
					}
				}
				long answer=bs();
				if(answer==INV) {
					answer=rbs();
				}
				if(answer!=INV) {
					sb.append(answer);
					final_answer=answer;
					break;
				}
			}
			if(final_answer==INV) {
				System.out.println(""Case #""+testcase+"": IMPOSSIBLE"");
			}else {
				System.out.println(""Case #""+testcase+"": ""+sb);
			}
		}
	}

	private static long bs() {
		long l= -sum1;
		long r= 1_000_000_000l;
		while(l<=r) {
			long mid = (l+r)/2l;
			if((sum1+mid)*(sum1+mid)==sum2+mid*mid) return mid;
			if((sum1+mid)*(sum1+mid)< sum2+mid*mid) l=mid+1l;
			else r=mid-1l;
		}
		return INV;
	}
	private static long rbs() {
		long l= -1_000_000_000l;
		long r= -sum1;
		while(l<=r) {
			long mid = (l+r)/2l;
			if((sum1+mid)*(sum1+mid)==sum2+mid*mid) return mid;
			if((sum1+mid)*(sum1+mid)> sum2+mid*mid) l=mid+1l;
			else r=",namgoi
3887,"public class Solution {
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new  InputStreamReader(System.in));
		int T = Integer.parseInt(br.readLine());
		for (int testcase = 1; testcase <=T; testcase++) {
			int cnt = Integer.parseInt(br.readLine());
			StringTokenizer st = new StringTokenizer(br.readLine());
			String[] str = new String[cnt];
			boolean[][] charbit = new boolean[cnt][26];
			boolean ispossible = true;
			char[] lchar = new char[cnt];
			char[] rchar = new char[cnt];
			for (int i = 0; i < cnt; i++) {
				str[i] = st.nextToken();
			}
			Arrays.sort(str);
			for (int i = 0; i < cnt; i++) {
				char[] tmp = str[i].toCharArray();
				char prev='0';
				lchar[i]=tmp[0];
				rchar[i]=tmp[tmp.length-1];
				for (char chr : tmp) {
					if(prev !=chr && charbit[i][chr-'A']==true) {
						ispossible=false;
					}
					charbit[i][chr-'A']=true;
					prev=chr;
				}
			}
			StringBuilder answer = new StringBuilder();
			ArrayList<Integer>[] list = new ArrayList[cnt];
			for (int i = 0; i < cnt; i++) {
				list[i]= new ArrayList<Integer>();
			}
			boolean[] usebit = new boolean[26];
			int[] indegree = new int[cnt];
			for (int i = 0; i < cnt; i++) {
				for (int j = i+1; j < cnt; j++) {
					if(rchar[i]==lchar[j]) {
						list[i].add(j);
						indegree[j]++;
					}else if(rchar[j]==lchar[i]) {
						list[j].add(i);
						indegree[i]++;
					}
				}
			}
			boolean[] isuse= new boolean[cnt];
			if(ispossible==true) {
				int connect=0;
				char topchar = '0';
				for (int i = 0; i < cnt; i++) {
					if(isuse[i]) continue;
//					if(rchar[i]!=lchar[i]) continue;
					for (int j = 0; j < cnt; j++) {
						int k=(i+j+1)%cnt;
						if(rchar[k]!=lchar[k]) continue;
						if(isuse[k]) continue;
						if(i==k) continue;
//							if(str[i].compareTo(""CODEEEL"")==0 && str[j].compareTo(""JAMMIC"")==0) {
//								System.out.println(""aa"");
//							}
						if(rchar[i]==lchar[k]) {
							str[i] = str[i]+str[k];
							rchar[i]=rchar[k];
//								if(j==2) {
//									System.out.println(str[i]);
//									System.out.println(str[j]);
//								}
							isuse[k]=true;
						}
					}
				}
				for (int z = 0; z < cnt*2; z++) {
					for (int i = 0; i < cnt; i++) {
						if(isuse[i]) continue;
						for (int j = 0; j < cnt; j++) {
							int k=(i+j+1)%cnt;
							if(isuse[k]) continue;
							if(i==k) continue;
//							if(str[i].compareTo(""CODEEEL"")==0 && str[j].compareTo(""JAMMIC"")==0) {
//								System.out.println(""aa"");
//							}
							if(rchar[i]==lchar[k]) {
								str[i] = str[i]+str[k];
								rchar[i]=rchar[k];
//								if(j==2) {
//									System.out.println(str[i]);
//									System.out.println(str[j]);
//								}
								isuse[k]=true;
							}
						}
					}
				}
//				System.out.println(Arrays.toString(str));
//				System.out.println(Arrays.toString(isuse));
				for (int i = 0; i < cnt; i++) {
					if(isuse[i]==false) answer.append(str[i]);
				}
				char[] anschar = answer.toString().toCharArray();
				char prevchar='0';
				for (char chr : anschar) {
					if(prevchar==chr) continue;
					if(usebit[chr-'A']==true) {
						ispossible=false;
					}
					usebit[chr-'A']=true;
					prevchar=chr;
				}
			}
			if(ispossible) {
				System.out.println(""Case #""+testcase+"": ""+answer);	
			}else {
				System.out.println(""Case #""+testcase+"": IMPOSSIBLE"");
			}
//			System.out.println(Arrays.toString(str));
//			System.out.println(Arrays.toString(isuse));
//			System.out.println(answer);
			
		}
	}
}
/*",namgoi
3888,"public class Solution {
	private static final long INV = -1_000_000_001l;
	private static long sum1;
	private static long sum2;

	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new  InputStreamReader(System.in));
		int T = Integer.parseInt(br.readLine());
		for (int testcase = 1; testcase <=T; testcase++) {
			StringTokenizer st = new StringTokenizer(br.readLine());
			int cnt = Integer.parseInt(st.nextToken());
			int cnt2 = Integer.parseInt(st.nextToken());
			st = new StringTokenizer(br.readLine());
			long[] org_a = new long[cnt];
			for (int i = 0; i < cnt; i++) {
				org_a[i]= Long.parseLong(st.nextToken());
			}
			StringBuilder sb = new StringBuilder();
			long final_answer = INV;
			for (int j = 0; j < cnt2; j++) {
				long[] a = new long[cnt];
				sum1 = 0;
				sum2 = 0;
				for (int i = 0; i < cnt; i++) {
					a[i]= org_a[i];
					sum1+=a[i];
					sum2+=a[i]*a[i];
				}
				if(j!=0) {
					sum1+=-1;
					sum2+=1;
					sb.append(""-1 "");	
				}
				long answer=bs();
				if(answer==INV) {
					answer=rbs();
				}
				if(answer!=INV) {
					sb.append(answer);
					final_answer=answer;
					break;
				}
			}
			if(final_answer==INV) {
				System.out.println(""Case #""+testcase+"": IMPOSSIBLE"");
			}else {
				System.out.println(""Case #""+testcase+"": ""+sb);
			}
		}
	}

	private static long bs() {
		long l= -sum1;
		long r= 1_000_000_000l;
		while(l<=r) {
			long mid = (l+r)/2l;
			if((sum1+mid)*(sum1+mid)==sum2+mid*mid) return mid;
			if((sum1+mid)*(sum1+mid)< sum2+mid*mid) l=mid+1l;
			else r=mid-1l;
		}
		return INV;
	}
	private static long rbs() {
		long l= -1_000_000_000l;
		long r= -sum1;
		while(l<=r) {
			long mid = (l+r)/2l;
			if((sum1+mid)*(sum1+mid)==sum2+mid*mid) return mid;
			if((sum1+mid)*(sum1+mid)> sum2+mid*mid) l=mid+1l;
			else r=",namgoi
3889,"public class Solution {
	private static final long INV = -1_000_000_001l;
	private static long sum1;
	private static long sum2;

	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new  InputStreamReader(System.in));
		int T = Integer.parseInt(br.readLine());
		for (int testcase = 1; testcase <=T; testcase++) {
			StringTokenizer st = new StringTokenizer(br.readLine());
			int cnt = Integer.parseInt(st.nextToken());
			int cnt2 = Integer.parseInt(st.nextToken());
			st = new StringTokenizer(br.readLine());
			long[] a = new long[cnt];
			sum1 = 0;
			sum2 = 0;	
			for (int i = 0; i < cnt; i++) {
				a[i]= Long.parseLong(st.nextToken());
				sum1+=a[i];
				sum2+=a[i]*a[i];
			}
			boolean ispossible = false;
			long answer=bs();
			if(answer==INV) {
				answer=rbs();
			}
			if(answer==INV) {
				System.out.println(""Case #""+testcase+"": IMPOSSIBLE"");
			}else {
				System.out.println(""Case #""+testcase+"": ""+answer);	
			}
			
		}
	}

	private static long bs() {
		long l= -sum1;
		long r= 1_000_000_000l;
		while(l<=r) {
			long mid = (l+r)/2l;
			if((sum1+mid)*(sum1+mid)==sum2+mid*mid) return mid;
			if((sum1+mid)*(sum1+mid)< sum2+mid*mid) l=mid+1l;
			else r=mid-1l;
		}
		return INV;
	}
	private static long rbs() {
		long l= -1_000_000_000l;
		long r= -sum1;
		while(l<=r) {
			long mid = (l+r)/2l;
			if((sum1+mid)*(sum1+mid)==sum2+mid*mid) return mid;
			if((sum1+mid)*(sum1+mid)> sum2+mid*mid) l=mid+1l;
			else r=",namgoi
3890,"public class Solution {
	private static final long INV = -1_000_000_001l;
	private static long sum1;
	private static long sum2;

	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new  InputStreamReader(System.in));
		int T = Integer.parseInt(br.readLine());
		for (int testcase = 1; testcase <=T; testcase++) {
			StringTokenizer st = new StringTokenizer(br.readLine());
			int cnt = Integer.parseInt(st.nextToken());
			int cnt2 = Integer.parseInt(st.nextToken());
			st = new StringTokenizer(br.readLine());
			long[] a = new long[cnt];
			sum1 = 0;
			sum2 = 0;	
			for (int i = 0; i < cnt; i++) {
				a[i]= Long.parseLong(st.nextToken());
				sum1+=a[i];
				sum2+=a[i]*a[i];
			}
			boolean ispossible = false;
			long answer=bs();
			if(answer==INV) {
				answer=rbs();
			}
			if(answer==INV) {
				System.out.println(""Case #""+testcase+"": IMPOSSIBLE"");
			}else {
				System.out.println(""Case #""+testcase+"": ""+answer);	
			}
			
		}
	}

	private static long bs() {
		long l= -sum1;
		long r= 1_000_000_000l;
		while(l<=r) {
			long mid = (l+r)/2l;
			if((sum1+mid)*(sum1+mid)==sum2+mid*mid) return mid;
			if((sum1+mid)*(sum1+mid)< sum2+mid*mid) l=mid+1l;
			else r=mid-1l;
		}
		return INV;
	}
	private static long rbs() {
		long l= -1_000_000_000l;
		long r= sum1;
		while(l<=r) {
			long mid = (l+r)/2l;
			if((sum1+mid)*(sum1+mid)==sum2+mid*mid) return mid;
			if((sum1+mid)*(sum1+mid)< sum2+mid*mid) l=mid+1l;
			else r=",namgoi
3891,"public class Solution {
	private static final long INV = -1_000_000_001l;
	private static long sum1;
	private static long sum2;

	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new  InputStreamReader(System.in));
		int T = Integer.parseInt(br.readLine());
		for (int testcase = 1; testcase <=T; testcase++) {
			StringTokenizer st = new StringTokenizer(br.readLine());
			int cnt = Integer.parseInt(st.nextToken());
			int cnt2 = Integer.parseInt(st.nextToken());
			st = new StringTokenizer(br.readLine());
			long[] a = new long[cnt];
			sum1 = 0;
			sum2 = 0;	
			for (int i = 0; i < cnt; i++) {
				a[i]= Long.parseLong(st.nextToken());
				sum1+=a[i];
				sum2+=a[i]*a[i];
			}
			boolean ispossible = false;
			long answer=bs();
			if(answer==INV) {
				answer=rbs();
			}
			if(answer==INV) {
				System.out.println(""Case #""+testcase+"": IMPOSSIBLE"");
			}else {
				System.out.println(""Case #""+testcase+"": ""+answer);	
			}
			
		}
	}

	private static long bs() {
		long l= -sum1;
		long r= 1_000_000_000l;
		while(l<=r) {
			long mid = (l+r)/2;
			if((sum1+mid)*(sum1+mid)==sum2+mid*mid) return mid;
			if((sum1+mid)*(sum1+mid)< sum2+mid*mid) l=mid+1;
			else r=mid-1;
		}
		return INV;
	}
	private static long rbs() {
		long l= -1_000_000_000l;
		long r= sum1;
		while(l<=r) {
			long mid = (l+r)/2;
			if((sum1+mid)*(sum1+mid)==sum2+mid*mid) return mid;
			if((sum1+mid)*(sum1+mid)< sum2+mid*mid) l=mid+1;
			else r=",namgoi
3892,"public class Solution {
	private static long sum1;
	private static long sum2;

	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new  InputStreamReader(System.in));
		int T = Integer.parseInt(br.readLine());
		for (int testcase = 1; testcase <=T; testcase++) {
			StringTokenizer st = new StringTokenizer(br.readLine());
			int cnt = Integer.parseInt(st.nextToken());
			int cnt2 = Integer.parseInt(st.nextToken());
			st = new StringTokenizer(br.readLine());
			long[] a = new long[cnt];
			sum1 = 0;
			sum2 = 0;	
			for (int i = 0; i < cnt; i++) {
				a[i]= Long.parseLong(st.nextToken());
				sum1+=a[i];
				sum2+=a[i]*a[i];
			}
			boolean ispossible = false;
			long answer=bs();
			if(answer==-1_000_000_000_001l) {
				answer=rbs();
			}
			if(answer==-1_000_000_000_001l) {
				System.out.println(""Case #""+testcase+"": IMPOSSIBLE"");
			}else {
				System.out.println(""Case #""+testcase+"": ""+answer);	
			}
			
		}
	}

	private static long bs() {
		long l= -sum1;
		long r= 1_000_000_000_000l;
		while(l<=r) {
			long mid = (l+r)/2;
			if((sum1+mid)*(sum1+mid)==sum2+mid*mid) return mid;
			if((sum1+mid)*(sum1+mid)< sum2+mid*mid) l=mid+1;
			else r=mid-1;
		}
		return -1_000_000_000_001l;
	}
	private static long rbs() {
		long l= -1_000_000_000_000l;
		long r= sum1;
		while(l<=r) {
			long mid = (l+r)/2;
			if((sum1+mid)*(sum1+mid)==sum2+mid*mid) return mid;
			if((sum1+mid)*(sum1+mid)< sum2+mid*mid) l=mid+1;
			else r=",namgoi
4140,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		test: for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt();
			if (N > 10) break;
			Point[] child = new Point[N];
			for (int i = 0;i < N;++ i) child[i] = new Point(fs.nextInt(), fs.nextInt());
			Point[] snack = new Point[N + 1];
			for (int i = 0;i <= N;++ i) snack[i] = new Point(fs.nextInt(), fs.nextInt());
			long[][] dist = new long[N][N + 1];
			for (int i = 0;i < N;++ i) for (int j = 0;j <= N;++ j) dist[i][j] = dist(child[i], snack[j]);

			int[] permutation = new int[N];
			for (int i = 0;i < N;++ i) permutation[i] = i;
			ArrayDeque<String> ans = new ArrayDeque<>();
			do {
				if (dfs(0, 0, permutation, child, snack, dist, ans)) {
					out.println(cases(t) + ""POSSIBLE"");
					for (String s : ans) out.println(s);
					continue test;
				}
			} while(nextPermutation(permutation));
			out.println(cases(t) + ""IMPOSSIBLE"");
		}
	}

	boolean dfs(int i, int use, int[] permutation, Point[] child, Point[] snack, long[][] dist, ArrayDeque<String> ans) {
		int N = permutation.length;
		if (i == N) {
			return (use & 1) == 0;
		}
		int c = permutation[i];
		long minD = Long.MAX_VALUE;
		for (int j = 0;j <= N;++ j) {
			if ((use >> j & 1) == 0) minD = Math.min(minD, dist[c][j]);
		}
		for (int j = 1;j <= N;++ j) {
			if ((use >> j & 1) == 0 && minD == dist[c][j]) {
				use ^= 1 << j;
				if (dfs(i + 1, use, permutation, child, snack, dist, ans)) {
					ans.addFirst(c + 1 + "" "" + (j + 1));
					return true;
				}
				use ^= 1 << j;
			}
		}
		return false;
	}

	long dist(Point p1, Point p2) {
		return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);
	}
	public static void swap(int[] array, int n, int m) {
		int swap = array[n];
		array[n] = array[m];
		array[m] = swap;
	}

	public static boolean nextPermutation(int[] array) {
		if (array == null) return false;
		for (int change = array.length - 2;change >= 0;-- change) {
			if (array[change] < array[change + 1]) {
				int min = change, max = array.length, halfDiff, mid;
				while((halfDiff = max - min >> 1) != 0) if (array[change] < array[mid = min + halfDiff]) min = mid; else max = mid;
				swap(array, change, min);
				for (min = change + 1, max = array.length - 1;min < max;++ min, -- max) swap(array, min, max);
				return true;
			}
		}
		return false;
	}
	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte())) sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char) readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte())) n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do n = n * 10 + b - '0'; while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte())) n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do n = n * 10 + b - '0'; while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
4141,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		test: for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt();
			if (N > 10) break;
			Point[] child = new Point[N];
			for (int i = 0;i < N;++ i) child[i] = new Point(fs.nextInt(), fs.nextInt());
			Point[] snack = new Point[N + 1];
			for (int i = 0;i <= N;++ i) snack[i] = new Point(fs.nextInt(), fs.nextInt());
			long[][] dist = new long[N][N + 1];
			for (int i = 0;i < N;++ i) for (int j = 0;j <= N;++ j) dist[i][j] = dist(child[i], snack[j]);

			int[] permutation = new int[N];
			for (int i = 0;i < N;++ i) permutation[i] = i;
			ArrayDeque<String> ans = new ArrayDeque<>();
			do {
				if (dfs(0, 0, permutation, child, snack, dist, ans)) {
					out.println(cases(t) + ""POSSIBLE"");
					for (String s : ans) out.println(s);
					continue test;
				}
			} while(nextPermutation(permutation));
			out.println(cases(t) + ""IMPOSSIBLE"");
		}
	}

	boolean dfs(int i, int use, int[] permutation, Point[] child, Point[] snack, long[][] dist, ArrayDeque<String> ans) {
		int N = permutation.length;
		if (i == N) {
			return (use & 1) == 0;
		}
		int c = permutation[i];
		long minD = Long.MAX_VALUE;
		for (int j = 0;j <= N;++ j) {
			if ((use >> j & 1) == 0) minD = Math.min(minD, dist[c][j]);
		}
		for (int j = 0;j <= N;++ j) {
			if ((use >> j & 1) == 0 && minD == dist[c][j]) {
				use ^= 1 << j;
				if (dfs(i + 1, use, permutation, child, snack, dist, ans)) {
					ans.addFirst(c + 1 + "" "" + (j + 1));
					return true;
				}
				use ^= 1 << j;
			}
		}
		return false;
	}

	long dist(Point p1, Point p2) {
		return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);
	}
	public static void swap(int[] array, int n, int m) {
		int swap = array[n];
		array[n] = array[m];
		array[m] = swap;
	}

	public static boolean nextPermutation(int[] array) {
		if (array == null) return false;
		for (int change = array.length - 2;change >= 0;-- change) {
			if (array[change] < array[change + 1]) {
				int min = change, max = array.length, halfDiff, mid;
				while((halfDiff = max - min >> 1) != 0) if (array[change] < array[mid = min + halfDiff]) min = mid; else max = mid;
				swap(array, change, min);
				for (min = change + 1, max = array.length - 1;min < max;++ min, -- max) swap(array, min, max);
				return true;
			}
		}
		return false;
	}
	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte())) sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char) readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte())) n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do n = n * 10 + b - '0'; while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte())) n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do n = n * 10 + b - '0'; while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
4142,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		test: for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt();
			if (N > 10) break;
			Point[] child = new Point[N];
			for (int i = 0;i < N;++ i) child[i] = new Point(fs.nextInt(), fs.nextInt());
			Point[] snack = new Point[N + 1];
			for (int i = 0;i <= N;++ i) snack[i] = new Point(fs.nextInt(), fs.nextInt());
			long[][] dist = new long[N][N + 1];
			for (int i = 0;i < N;++ i) for (int j = 0;j <= N;++ j) dist[i][j] = dist(child[i], snack[j]);

			int[] permutation = new int[N];
			for (int i = 0;i < N;++ i) permutation[i] = i;
			ArrayList<String> ans = new ArrayList<>();
			do {
				if (dfs(0, 0, permutation, child, snack, dist, ans)) {
					out.println(cases(t) + ""POSSIBLE"");
					for (String s : ans) out.println(s);
					continue test;
				}
			} while(nextPermutation(permutation));
			out.println(cases(t) + ""IMPOSSIBLE"");
		}
	}

	boolean dfs(int i, int use, int[] permutation, Point[] child, Point[] snack, long[][] dist, ArrayList<String> ans) {
		int N = permutation.length;
		if (i == N) {
			return (use & 1) == 0;
		}
		int c = permutation[i];
		long minD = Long.MAX_VALUE;
		for (int j = 0;j <= N;++ j) {
			if ((use >> j & 1) == 0) minD = Math.min(minD, dist[c][j]);
		}
		for (int j = 0;j <= N;++ j) {
			if ((use >> j & 1) == 0 && minD == dist[c][j]) {
				use ^= 1 << j;
				if (dfs(i + 1, use, permutation, child, snack, dist, ans)) {
					ans.add(c + 1 + "" "" + (j + 1));
					return true;
				}
				use ^= 1 << j;
			}
		}
		return false;
	}

	long dist(Point p1, Point p2) {
		return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);
	}
	public static void swap(int[] array, int n, int m) {
		int swap = array[n];
		array[n] = array[m];
		array[m] = swap;
	}

	public static boolean nextPermutation(int[] array) {
		if (array == null) return false;
		for (int change = array.length - 2;change >= 0;-- change) {
			if (array[change] < array[change + 1]) {
				int min = change, max = array.length, halfDiff, mid;
				while((halfDiff = max - min >> 1) != 0) if (array[change] < array[mid = min + halfDiff]) min = mid; else max = mid;
				swap(array, change, min);
				for (min = change + 1, max = array.length - 1;min < max;++ min, -- max) swap(array, min, max);
				return true;
			}
		}
		return false;
	}
	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte())) sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char) readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte())) n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do n = n * 10 + b - '0'; while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte())) n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do n = n * 10 + b - '0'; while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
4143,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		test: for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt();
			if (N > 10) break;
			Point[] child = new Point[N];
			for (int i = 0;i < N;++ i) child[i] = new Point(fs.nextInt(), fs.nextInt());
			Point[] snack = new Point[N + 1];
			for (int i = 0;i <= N;++ i) snack[i] = new Point(fs.nextInt(), fs.nextInt());

			int[][] list = new int[N][N + 1];
			for (int i = 0;i < N;++ i) {
				final int nowC = i;
				PriorityQueue<Integer> pq = new PriorityQueue<>((l, r) ->
					Long.compare(dist(child[nowC],  snack[l]), dist(child[nowC], snack[r])));
				for (int j = 0;j <= N;++ j) pq.add(j);
				for (int j = 0;j <= N;++ j) list[nowC][j] = pq.poll();
			}

			int[] permutation = new int[N];
			for (int i = 0;i < N;++ i) permutation[i] = i;
			do {
				int use = 0;
				for (int i = 0;i < N;++ i) {
					int c = permutation[i];
					for (int j : list[c]) {
						if ((use >> j & 1) != 0) continue;
						use |= 1 << j;
						break;
					}
				}
				if ((use & 1) == 0) {
					out.println(cases(t) + ""POSSIBLE"");
					use = 0;
					for (int i = 0;i < N;++ i) {
						int c = permutation[i];
						for (int j : list[c]) {
							if ((use >> j & 1) != 0) continue;
							use |= 1 << j;
							out.println(c + 1 + "" "" + (j + 1));
							break;
						}
					}
					continue test;
				}
			} while(nextPermutation(permutation));
			out.println(cases(t) + ""IMPOSSIBLE"");
		}
	}

	long dist(Point p1, Point p2) {
		return (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);
	}
	public static void swap(int[] array, int n, int m) {
		int swap = array[n];
		array[n] = array[m];
		array[m] = swap;
	}

	public static boolean nextPermutation(int[] array) {
		if (array == null) return false;
		for (int change = array.length - 2;change >= 0;-- change) {
			if (array[change] < array[change + 1]) {
				int min = change, max = array.length, halfDiff, mid;
				while((halfDiff = max - min >> 1) != 0) if (array[change] < array[mid = min + halfDiff]) min = mid; else max = mid;
				swap(array, change, min);
				for (min = change + 1, max = array.length - 1;min < max;++ min, -- max) swap(array, min, max);
				return true;
			}
		}
		return false;
	}
	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte())) sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char) readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte())) n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do n = n * 10 + b - '0'; while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte())) n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do n = n * 10 + b - '0'; while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
4144,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		for (int t = 1;t <= T;++ t) {
			int R = fs.nextInt();
			out.println(cases(t) + ans(R));
		}
	}

	long ans(int R) {
		return draw_circle_filled(R) - draw_circle_filled_wrong(R);
	}

	long draw_circle_filled(int R) {
		long count = 0;
		for (int x = -R; x <= R; ++x) {
			for (int y = -R; y <= R; ++y) {
				if (Math.round(Math.sqrt(x * x + y * y)) <= R) {
					++count;
				}
			}
		}
		return count;
	}

	long draw_circle_filled_wrong(int R) {
		HashSet<Integer> set = new HashSet<>();
		final int SHIFT = 1000000;
		for (int r = 0;r <= R;++ r) {
			for (int x = -r;x <= r;++ x) {
				int y = (int)Math.round(Math.sqrt(r * r - x * x));
				set.add(x * SHIFT + y);
				set.add(x * SHIFT - y);
				set.add(y * SHIFT + x);
				set.add(-y * SHIFT + x);
			}
		}
		return set.size();
	}
	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte())) sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char) readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte())) n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do n = n * 10 + b - '0'; while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte())) n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do n = n * 10 + b - '0'; while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
4145,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			if (K < N - 1 || K % 2 != 0) {
				out.println(cases(t) + ""IMPOSSIBLE"");
				continue;
			}
			int[][] grid = new int[N][N];
			{
				int dx = 1, dy = 0;
				int x = 0, y = 0;
				for (int i = 1;i <= N * N;++ i) {
					grid[y][x] = i;
					x += dx;
					y += dy;
					if (x < 0 || x >= N || y < 0 || y >= N || grid[y][x] != 0) {
						x -= dx;
						y -= dy;
						int swap = dx;
						dx = -dy;
						dy = swap;
						x += dx;
						y += dy;
					}
				}
			}
			ArrayList<String> ans = new ArrayList<>();
			{
				int dx = 1, dy = 0;
				int x = 0, y = 0;
				while (Math.abs(x - N / 2) + Math.abs(y - N / 2) < K) {
					int last = grid[y][x];
					x += dx;
					y += dy;
					if (x < 0 || x >= N || y < 0 || y >= N || grid[y][x] != last + 1) {
						x -= dx;
						y -= dy;
						int swap = dx;
						dx = -dy;
						dy = swap;
						x += dx;
						y += dy;
					}
					-- K;
				}
				int[] around = {0, 1, 0, -1, 0};
				while(K > 0) {
					int maxV = 0, max = 0;
					for (int r = 0;r < 4;++ r) {
						int nx = x + around[r], ny = y + around[r + 1];
						if (nx < 0 || nx >= N || ny < 0 || ny >= N || grid[y][x] >= grid[ny][nx]) continue;
						if (maxV < grid[ny][nx]) {
							maxV = grid[ny][nx];
							max = r;
						}
					}
					int nx = x + around[max], ny = y + around[max + 1];
					if (grid[ny][nx] - grid[y][x] > 1) {
						ans.add(grid[y][x] + "" "" + grid[ny][nx]);
					}
					y = ny;
					x = nx;
					-- K;
				}
			}
			out.println(cases(t) + ans.size());
			for (String s : ans) out.println(s);
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
4146,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			if (K < N - 1 || K % 2 != 0) {
				out.println(cases(t) + ""IMPOSSIBLE"");
				continue;
			}
			int[][] grid = new int[N][N];
			{
				int dx = 1, dy = 0;
				int x = 0, y = 0;
				for (int i = 1;i <= N * N;++ i) {
					grid[y][x] = i;
					x += dx;
					y += dy;
					if (x < 0 || x >= N || y < 0 || y >= N || grid[y][x] != 0) {
						x -= dx;
						y -= dy;
						int swap = dx;
						dx = -dy;
						dy = swap;
						x += dx;
						y += dy;
					}
				}
			}
			ArrayList<String> ans = new ArrayList<>();
			{
				int dx = 1, dy = 0;
				int x = 0, y = 0;
				while (Math.abs(x - N / 2) + Math.abs(y - N / 2) < K) {
					int last = grid[y][x];
					x += dx;
					y += dy;
					if (x < 0 || x >= N || y < 0 || y >= N || grid[y][x] != last + 1) {
						x -= dx;
						y -= dy;
						int swap = dx;
						dx = -dy;
						dy = swap;
						x += dx;
						y += dy;
					}
					-- K;
				}
				int[] around = {0, 1, 0, -1, 0};
				while(K > 0) {
					for (int r = 0;r < 4;++ r) {
						int nx = x + around[r], ny = y + around[r + 1];
						if (nx < 0 || nx >= N || ny < 0 || ny >= N || grid[y][x] >= grid[ny][nx]) continue;
						if (grid[ny][nx] - grid[y][x] > 1) {
							ans.add(grid[y][x] + "" "" + grid[ny][nx]);
						}
						y = ny;
						x = nx;
						break;
					}
					-- K;
				}
			}
			out.println(cases(t) + ans.size());
			for (String s : ans) out.println(s);
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
4314,"public class Solution {

	private static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = Integer.parseInt(in.nextLine()); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			String input = in.nextLine();

			String answer = getAnswer(input);
			System.out.println(""Case #"" + i + "": "" + answer);
		}
	}

	private static String getAnswer(String input) {// IMPOSSIBLE
		int rr = Integer.parseInt(input);

		boolean[][] map = new boolean[rr + 1][rr + 1];
		for (int r = 1; r <= rr; r++) {
			for (int x = 0; x <= r; x++) {
				for (int y = 0; y <= r; y++) {
					if (Math.round((Math.sqrt(x*x + y*y))) <= r)
						map[x][y] = true;
				}
			}
		}
		boolean[][] map0 = new boolean[rr + 1][rr + 1];
		for (int r = 1; r <= rr; r++) {
			for (int x = 0; x <= r; x++) {
				int y = (int)Math.round((Math.sqrt(r*r - x*x)));
				map0[x][y] = true;
				map0[y][x] = true; 
			}
		}
		
		long count = 0;
		for (int x = 1; x <= rr; x++) {
			for (int y = 1; y <= rr; y++) {
				if (map[x][y] && !map0[x][y])
					count++;
			}
		}
		return """" + count * 4;
	}
}",mokazaki923
4315,"public class Solution {

	private static Scanner in;
	static List<String> lineList = new ArrayList<>();

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = Integer.parseInt(in.nextLine()); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			String input = in.nextLine();

			lineList.clear();
			String answer = getAnswer(input);
			System.out.println(""Case #"" + i + "": "" + answer);
			for (String line : lineList) {
				System.out.println(line);
			}
		}
	}

	private static String getAnswer(String input) {// IMPOSSIBLE
		String[] parts = input.split("" "");
		int n = Integer.parseInt(parts[0]);
		int k = Integer.parseInt(parts[1]);
		if (k % 2 == 1)
			return ""IMPOSSIBLE"";
		
		int shortcutSum = n * n - 1 - k;// 20 for #1
		int maxShortcut = 6;
		int shortcut = 6;
		for (int i = 0; i < (n - 3) / 2; i++) {
			shortcut += 8;// 14
			maxShortcut += shortcut;
		}
		if (shortcutSum > maxShortcut)
			return ""IMPOSSIBLE"";

		// possible
		List<Integer> unableShortcutNumberList = new ArrayList<>();
		int uNumber = n * n;
		int diff = 1;
		while(true) {
			uNumber -= diff;
			if (uNumber == 0)
				break;
			unableShortcutNumberList.add(uNumber);
			uNumber -= diff;
			unableShortcutNumberList.add(uNumber);
			diff++;
		}
		
		int shortcutNumber = 6 + (n - 3) / 2 * 8;// 14 for 5x5
		int number = 1;
		while(shortcutSum > 0) {
			if (unableShortcutNumberList.contains(number)) {// unable to shortcut
				number++;
				shortcutNumber -= 2;
				continue;
			}
			
			if (shortcutSum >= shortcutNumber) {
				lineList.add(number + "" "" + (number + shortcutNumber + 1));
				shortcutSum -= shortcutNumber;
				number += shortcutNumber + 1;// + 15, 1 -> 16
				shortcutNumber -= 8;
				if (unableShortcutNumberList.contains(number))
					number++;
				continue;
			}
			
			number++;
		}
		return """" + lineList.",mokazaki923
5521,"public class Solution {

    public static void main(String[] args) {
////        System.out.println(""Enter"");
        Scanner sc = new Scanner(System.in);
        Random random=new Random();
        var numberOfTestCases = sc.nextInt();
        for (int i = 0; i < numberOfTestCases; i++) {
            var N = sc.nextInt();
            int[] array = new int[2*N];
            StringBuilder sb = new StringBuilder();
            for(int j=0;j<N;j++){
                array[j]=1+random.nextInt(1000000000);
                if(j>0) System.out.print("" "");
                System.out.print(array[j]);
            }

            System.out.println();

            for(int j=0;j<N;j++){
                array[N+j]=sc.nextInt();
            }
            findHalf(array);
        }
        sc.close();

    }

    private static void findHalf(int[] array) {
        Arrays.sort(array);
        long sum=0;
        for (int i : array) {
            sum+=i;
        }
        ArrayList<Integer> result = new ArrayList<>();
        findHalfHelper(array, array.length-1, result, sum/2,0);
        StringBuilder sb = new StringBuilder();
        result.forEach(r -> sb.append(r).append("" -1""));
        System.out.println(sb.toString().trim());
    }

    private static boolean findHalfHelper(int[] array, int startWith, ArrayList<Integer> result, long targetHalfSum, long sumSoFar) {
        if(startWith<0) {
            return false;
        }

        int i=startWith;
        long currentSum=0;
        for (; i >=0 ; i--) {
            currentSum = sumSoFar + array[i];
            if(currentSum <= targetHalfSum) break;
        }

        if(currentSum == targetHalfSum) {
            result.add(array[i]);
            return true;
        }


        boolean halfHelperResult = ",DEB
5522,"public class Solution {

    public static void main(String[] args) {
////        System.out.println(""Enter"");
        Scanner sc = new Scanner(System.in);
        Random random=new Random();
        var numberOfTestCases = sc.nextInt();
        for (int i = 0; i < numberOfTestCases; i++) {
            var N = sc.nextInt();
            int[] array = new int[2*N];
            StringBuilder sb = new StringBuilder();
            for(int j=0;j<N;j++){
                array[j]=1+random.nextInt(1000000000);
                sb.append(array[j]).append("" "");
            }

            System.out.println(sb.toString().trim());

            for(int j=0;j<N;j++){
                array[N+j]=sc.nextInt();
            }
            findHalf(array);
        }
        sc.close();

    }

    private static void findHalf(int[] array) {
        Arrays.sort(array);
        long sum=0;
        // for (int i : array) {
        //     sum+=i;
        // }
        ArrayList<Integer> result = new ArrayList<>();
        // findHalfHelper(array, array.length-1, result, sum/2,0);
        System.out.println(result);
    }

    private static boolean findHalfHelper(int[] array, int startWith, ArrayList<Integer> result, long targetHalfSum, long sumSoFar) {
        if(startWith<0) {
            return false;
        }

        int i=startWith;
        long currentSum=0;
        // for (; i >=0 ; i--) {
        //     currentSum = sumSoFar + array[i];
        //     if(currentSum <= targetHalfSum) break;
        // }

        // if(currentSum == targetHalfSum) {
        //     result.add(array[i]);
        //     return true;
        // }


        boolean halfHelperResult = ",DEB
5523,"public class Solution {

    public static void main(String[] args) {
////        System.out.println(""Enter"");
        Scanner sc = new Scanner(System.in);
        Random random=new Random();
        var numberOfTestCases = sc.nextInt();
        for (int i = 0; i < numberOfTestCases; i++) {
            var N = sc.nextInt();
            int[] array = new int[2*N];
            StringBuilder sb = new StringBuilder();
            for(int j=0;j<N;j++){
                array[j]=1+random.nextInt(1000000000);
                sb.append(array[j]).append("" "");
            }

            System.out.println(sb.toString().trim());

            for(int j=0;j<N;j++){
                array[N+j]=sc.nextInt();
            }
            findHalf(array);
        }
        sc.close();

    }

    private static void findHalf(int[] array) {
        Arrays.sort(array);
        long sum=0;
        // for (int i : array) {
        //     sum+=i;
        // }
        ArrayList<Integer> result = new ArrayList<>();
        findHalfHelper(array, array.length-1, result, sum/2,0);
        System.out.println(result);
    }

    private static boolean findHalfHelper(int[] array, int startWith, ArrayList<Integer> result, long targetHalfSum, long sumSoFar) {
        if(startWith<0) {
            return false;
        }

        int i=startWith;
        long currentSum=0;
        // for (; i >=0 ; i--) {
        //     currentSum = sumSoFar + array[i];
        //     if(currentSum <= targetHalfSum) break;
        // }

        // if(currentSum == targetHalfSum) {
        //     result.add(array[i]);
        //     return true;
        // }


        boolean halfHelperResult = ",DEB
5524,"public class Solution {

    public static void main(String[] args) {
////        System.out.println(""Enter"");
        Scanner sc = new Scanner(System.in);
        Random random=new Random();
        var numberOfTestCases = sc.nextInt();
        for (int i = 0; i < numberOfTestCases; i++) {
            var N = sc.nextInt();
            int[] array = new int[2*N];
            StringBuilder sb = new StringBuilder();
            for(int j=0;j<N;j++){
                array[j]=1+random.nextInt(1000000000);
                sb.append(array[j]).append("" "");
            }

            System.out.println(sb.toString().trim());

            for(int j=0;j<N;j++){
                array[N+j]=sc.nextInt();
            }
            findHalf(array);
        }
        sc.close();

    }

    private static void findHalf(int[] array) {
        Arrays.sort(array);
        long sum=0;
        // for (int i : array) {
        //     sum+=i;
        // }
        ArrayList<Integer> result = new ArrayList<>();
        findHalfHelper(array, array.length-1, result, sum/2,0);
        System.out.println(result);
    }

    private static boolean findHalfHelper(int[] array, int startWith, ArrayList<Integer> result, long targetHalfSum, long sumSoFar) {
        if(startWith<0) {
            return false;
        }

        int i=startWith;
        long currentSum=0;
        for (; i >=0 ; i--) {
            currentSum = sumSoFar + array[i];
            if(currentSum <= targetHalfSum) break;
        }

        if(currentSum == targetHalfSum) {
            result.add(array[i]);
            return true;
        }


        boolean halfHelperResult = ",DEB
5526,"public class Solution {

    public static void main(String[] args) {
////        System.out.println(""Enter"");
        Scanner sc = new Scanner(System.in);
        Random random=new Random();
        var numberOfTestCases = sc.nextInt();
        for (int i = 0; i < numberOfTestCases; i++) {
            var N = sc.nextInt();
            int[] array = new int[2*N];
            StringBuilder sb = new StringBuilder();
            for(int j=0;j<N;j++){
                array[j]=1+random.nextInt(1000000000);
                sb.append(array[j]).append("" "");
            }

            System.out.println(sb.toString().trim());

            for(int j=0;j<N;j++){
                array[N+j]=sc.nextInt();
            }
            // findHalf(array);
        }
        sc.close();

    }

    private static void findHalf(int[] array) {
        Arrays.sort(array);
        long sum=0;
        for (int i : array) {
            sum+=i;
        }
        ArrayList<Integer> result = new ArrayList<>();
        findHalfHelper(array, array.length-1, result, sum/2,0);
        System.out.println(result);
    }

    private static boolean findHalfHelper(int[] array, int startWith, ArrayList<Integer> result, long targetHalfSum, long sumSoFar) {
        if(startWith<0) {
            return false;
        }

        int i=startWith;
        long currentSum=0;
        for (; i >=0 ; i--) {
            currentSum = sumSoFar + array[i];
            if(currentSum <= targetHalfSum) break;
        }

        if(currentSum == targetHalfSum) {
            result.add(array[i]);
            return true;
        }


        boolean halfHelperResult = ",DEB
5527,"public class Solution {

    public static void main(String[] args) {
////        System.out.println(""Enter"");
        Scanner sc = new Scanner(System.in);
        Random random=new Random();
        var numberOfTestCases = sc.nextInt();
        for (int i = 0; i < numberOfTestCases; i++) {
            var N = sc.nextInt();
            int[] array = new int[2*N];
            StringBuilder sb = new StringBuilder();
            for(int j=0;j<N;j++){
                array[j]=1+random.nextInt(1000000000);
                sb.append(array[j]).append("" "");
            }

            System.out.println(sb.toString().trim());

            for(int j=0;j<N;j++){
                array[N+j]=sc.nextInt();
            }
            findHalf(array);
        }
        sc.close();

    }

    private static void findHalf(int[] array) {
        Arrays.sort(array);
        long sum=0;
        for (int i : array) {
            sum+=i;
        }
        ArrayList<Integer> result = new ArrayList<>();
        findHalfHelper(array, array.length-1, result, sum/2,0);
        System.out.println(result);
    }

    private static boolean findHalfHelper(int[] array, int startWith, ArrayList<Integer> result, long targetHalfSum, long sumSoFar) {
        if(startWith<0) {
            return false;
        }

        int i=startWith;
        long currentSum=0;
        for (; i >=0 ; i--) {
            currentSum = sumSoFar + array[i];
            if(currentSum <= targetHalfSum) break;
        }

        if(currentSum == targetHalfSum) {
            result.add(array[i]);
            return true;
        }


        boolean halfHelperResult = ",DEB
5528,"public class Solution {

    public static void main(String[] args) {
////        System.out.println(""Enter"");
        Scanner sc = new Scanner(System.in);
        Random random=new Random();
        var numberOfTestCases = sc.nextInt();
        for (int i = 0; i < numberOfTestCases; i++) {
            var N = sc.nextInt();
            int[] array = new int[2*N];
            StringBuilder sb = new StringBuilder();
            for(int j=0;j<N;j++){
                array[j]=1+random.nextInt(1000000000);
                sb.append(array[j]).append("" "");
            }

            System.out.println(sb.toString().trim());

            for(int j=0;j<N;j++){
                array[N+j]=sc.nextInt();
            }
            findHalf(array);
        }
        sc.close();

    }

    private static void findHalf(int[] array) {
        Arrays.sort(array);
        long sum=0;
        for (int i : array) {
            sum+=i;
        }
        ArrayList<Integer> result = new ArrayList<>();
        findHalfHelper(array, array.length-1, result, sum/2,0);
        System.out.println(""r: ""+result);
    }

    private static boolean findHalfHelper(int[] array, int startWith, ArrayList<Integer> result, long targetHalfSum, long sumSoFar) {
        if(startWith<0) {
            return false;
        }

        int i=startWith;
        long currentSum=0;
        for (; i >=0 ; i--) {
            currentSum = sumSoFar + array[i];
            if(currentSum <= targetHalfSum) break;
        }

        if(currentSum == targetHalfSum) {
            result.add(array[i]);
            return true;
        }


        boolean halfHelperResult = ",DEB
5529,"public class Solution {

    public static void main(String[] args) {
//        System.out.println(""Enter"");
        Scanner sc = new Scanner(System.in);
        var numberOfTestCases = sc.nextInt();
        for (int i = 0; i < numberOfTestCases; i++) {
            var input = sc.next();
            StringBuilder sb = new StringBuilder();
            HashSet<Character> visited = new HashSet<>();
            boolean hasLargeOnRight = false;
            sb.append(input.charAt(input.length()-1));
            for (int j = input.length()-2;j>=0; j--) {
                sb.append(input.charAt(j));
                visited.add(input.charAt(j));
                if(input.charAt(j) < input.charAt(j+1)){
                    hasLargeOnRight=true;
                    sb.append(input.charAt(j));
                }else if(input.charAt(j) == input.charAt(j+1) && hasLargeOnRight){
                    sb.append(input.charAt(j));
                }else{
                    hasLargeOnRight = false;
                }
            }
            System.out.println(""Case #""+(i+1)+"": ""+
                    sb.reverse() );
        }
        sc.",DEB
5530,"public class Solution {

    public static void main(String[] args) {
//        System.out.println(""Enter"");
        Scanner sc = new Scanner(System.in);
        var numberOfTestCases = sc.nextInt();
        for (int i = 0; i < numberOfTestCases; i++) {
            var input = sc.next();
            StringBuilder sb = new StringBuilder();
            HashSet<Character> visited = new HashSet<>();
            for (int j = 0; j < input.length()-1 ; j++) {
                sb.append(input.charAt(j));
                visited.add(input.charAt(j));
                if(input.charAt(j) < input.charAt(j+1)){
                    sb.append(input.charAt(j));
                }else if(input.charAt(j) == input.charAt(j+1)
                        && (j>0 && input.charAt(j-1) != input.charAt(j))
                        ){
                    sb.append(input.charAt(j));
                }
            }
            sb.append(input.charAt(input.length()-1));
            System.out.println(""Case #""+(i+1)+"": ""+
                    (input.compareTo(sb.toString())<0? input : sb) );
        }
        sc.",DEB
5531,"public class Solution {

    public static void main(String[] args) {
//        System.out.println(""Enter"");
        Scanner sc = new Scanner(System.in);
        var numberOfTestCases = sc.nextInt();
        for (int i = 0; i < numberOfTestCases; i++) {
            var input = sc.next();
            StringBuilder sb = new StringBuilder();
            HashSet<Character> visited = new HashSet<>();
            for (int j = 0; j < input.length()-1 ; j++) {
                sb.append(input.charAt(j));
                visited.add(input.charAt(j));
                if(input.charAt(j) <= input.charAt(j+1)){
                    sb.append(input.charAt(j));
                }
            }
            sb.append(input.charAt(input.length()-1));
            System.out.println(""Case #""+(i+1)+"": ""+
                    (input.compareTo(sb.toString())<0? input : sb) );
        }
        sc.",DEB
5532,"public class Solution {

    public static void main(String[] args) {
////        System.out.println(""Enter"");
        Scanner sc = new Scanner(System.in);
        Random random=new Random();
        var numberOfTestCases = sc.nextInt();
        for (int i = 0; i < numberOfTestCases; i++) {
            var N = sc.nextInt();
            int[] array = new int[2*N];
            StringBuilder sb = new StringBuilder();
            for(int j=0;j<N;j++){
                array[j]=1+random.nextInt(1000000000);
                sb.append(array[j]).append("" "");
            }

            System.out.println(sb.toString().trim());

            for(int j=0;j<N;j++){
                array[N+j]=sc.nextInt();
            }
            findHalf(array);
            System.out.println(sb.toString().trim());

        }
        sc.close();

    }

    private static void findHalf(int[] array) {
        Arrays.sort(array);
        long sum=0;
        for (int i : array) {
            sum+=i;
        }
        ArrayList<Integer> result = new ArrayList<>();
        findHalfHelper(array, array.length-1, result, sum/2,0);
        StringBuilder sb = new StringBuilder();
        result.forEach(r -> sb.append(r).append("" ""));
        System.out.println(sb.toString().trim());
    }

    private static boolean findHalfHelper(int[] array, int startWith, ArrayList<Integer> result, long targetHalfSum, long sumSoFar) {
        if(startWith<0) {
            return false;
        }

        int i=startWith;
        long currentSum=0;
        for (; i >=0 ; i--) {
            currentSum = sumSoFar + array[i];
            if(currentSum <= targetHalfSum) break;
        }

        if(currentSum == targetHalfSum) {
            result.add(array[i]);
            return true;
        }


        boolean halfHelperResult = ",DEB
5533,"public class Solution {

    public static void main(String[] args) {
//        System.out.println(""Enter"");
        Scanner sc = new Scanner(System.in);
        var numberOfTestCases = sc.nextInt();
        for (int i = 0; i < numberOfTestCases; i++) {
            var input = sc.next();
            StringBuilder sb = new StringBuilder();
            HashSet<Character> visited = new HashSet<>();
            for (int j = 0; j < input.length()-1 ; j++) {
                sb.append(input.charAt(j));
                visited.add(input.charAt(j));
                if(input.charAt(j) <= input.charAt(j+1)){
                    sb.append(input.charAt(j));
                }
            }
            sb.append(input.charAt(input.length()-1));
            System.out.println(""Case #""+(i+1)+"": ""+
                    (visited.size()==1? input : sb) );
        }
        sc.",DEB
5534,"public class Solution {

    public static void main(String[] args) {
//        System.out.println(""Enter"");
        Scanner sc = new Scanner(System.in);
        var numberOfTestCases = sc.nextInt();
        for (int i = 0; i < numberOfTestCases; i++) {
            var input = sc.next();
            StringBuilder sb = new StringBuilder();
            for (int j = 0; j < input.length()-1 ; j++) {
                sb.append(input.charAt(j));
                if(input.charAt(j) <= input.charAt(j+1)){
                    sb.append(input.charAt(j));
                }
            }
            sb.append(input.charAt(input.length()-1));
            System.out.println(""Case #""+(i+1)+"": ""+ sb);
        }
        sc.",DEB
5535,"public class Solution {

    public static void main(String[] args) {
////        System.out.println(""Enter"");
        Scanner sc = new Scanner(System.in);
        Random random=new Random();
        var numberOfTestCases = sc.nextInt();
        for (int i = 0; i < numberOfTestCases; i++) {
            var N = sc.nextInt();
            int[] array = new int[2*N];
            StringBuilder sb = new StringBuilder();
            for(int j=0;j<N;j++){
                array[j]=1+random.nextInt(1000000000);
                sb.append(array[j]).append("" "");
            }

            System.out.println(sb.toString().trim());

            for(int j=0;j<N;j++){
                array[N+j]=sc.nextInt();
            }
            findHalf(array);
            System.out.println(sb.toString().trim());

        }
        sc.close();

    }

    private static void findHalf(int[] array) {
        Arrays.sort(array);
        long sum=0;
        for (int i : array) {
            sum+=i;
        }
        ArrayList<Integer> result = new ArrayList<>();
        findHalfHelper(array, array.length-1, result, sum/2,0);
        if(result.isEmpty()) System.out.println(""-1"");
        else
        System.out.println(result);
    }

    private static boolean findHalfHelper(int[] array, int startWith, ArrayList<Integer> result, long targetHalfSum, long sumSoFar) {
        if(startWith<0) {
            return false;
        }

        int i=startWith;
        long currentSum=0;
        for (; i >=0 ; i--) {
            currentSum = sumSoFar + array[i];
            if(currentSum <= targetHalfSum) break;
        }

        if(currentSum == targetHalfSum) {
            result.add(array[i]);
            return true;
        }


        boolean halfHelperResult = ",DEB
5536,"public class Solution {

    public static void main(String[] args) {
////        System.out.println(""Enter"");
        Scanner sc = new Scanner(System.in);
        Random random=new Random();
        var numberOfTestCases = sc.nextInt();
        for (int i = 0; i < numberOfTestCases; i++) {
            var N = sc.nextInt();
            int[] array = new int[2*N];
            StringBuilder sb = new StringBuilder();
            for(int j=0;j<N;j++){
                array[j]=1+random.nextInt(1000000000);
                sb.append(array[j]).append("" "");
            }

            System.out.println(sb.toString().trim());

            for(int j=0;j<N;j++){
                array[N+j]=sc.nextInt();
            }
            findHalf(array);
            System.out.println(sb.toString().trim());

        }
        sc.close();

    }

    private static void findHalf(int[] array) {
        Arrays.sort(array);
        long sum=0;
        for (int i : array) {
            sum+=i;
        }
        ArrayList<Integer> result = new ArrayList<>();
        findHalfHelper(array, array.length-1, result, sum/2,0);
        if(result.isEmpty()) System.out.println("""");
        else
        System.out.println(result);
    }

    private static boolean findHalfHelper(int[] array, int startWith, ArrayList<Integer> result, long targetHalfSum, long sumSoFar) {
        if(startWith<0) {
            return false;
        }

        int i=startWith;
        long currentSum=0;
        for (; i >=0 ; i--) {
            currentSum = sumSoFar + array[i];
            if(currentSum <= targetHalfSum) break;
        }

        if(currentSum == targetHalfSum) {
            result.add(array[i]);
            return true;
        }


        boolean halfHelperResult = ",DEB
5537,"public class Solution {

    public static void main(String[] args) {
////        System.out.println(""Enter"");
        Scanner sc = new Scanner(System.in);
        Random random=new Random();
        var numberOfTestCases = sc.nextInt();
        for (int i = 0; i < numberOfTestCases; i++) {
            var N = sc.nextInt();
            int[] array = new int[2*N];
            StringBuilder sb = new StringBuilder();
            for(int j=0;j<N;j++){
                array[j]=1+random.nextInt(1000000000);
                sb.append(array[j]).append("" "");
            }

            System.out.println(sb.toString().trim());

            for(int j=0;j<N;j++){
                array[N+j]=sc.nextInt();
            }
            findHalf(array);
            System.out.println(sb.toString().trim());

        }
        sc.close();

    }

    private static void findHalf(int[] array) {
        Arrays.sort(array);
        long sum=0;
        for (int i : array) {
            sum+=i;
        }
        ArrayList<Integer> result = new ArrayList<>();
        findHalfHelper(array, array.length-1, result, sum/2,0);
        // System.out.println(result);
    }

    private static boolean findHalfHelper(int[] array, int startWith, ArrayList<Integer> result, long targetHalfSum, long sumSoFar) {
        if(startWith<0) {
            return false;
        }

        int i=startWith;
        long currentSum=0;
        for (; i >=0 ; i--) {
            currentSum = sumSoFar + array[i];
            if(currentSum <= targetHalfSum) break;
        }

        if(currentSum == targetHalfSum) {
            result.add(array[i]);
            return true;
        }


        boolean halfHelperResult = ",DEB
5538,"public class Solution {

    public static void main(String[] args) {
////        System.out.println(""Enter"");
        Scanner sc = new Scanner(System.in);
        Random random=new Random();
        var numberOfTestCases = sc.nextInt();
        for (int i = 0; i < numberOfTestCases; i++) {
            var N = sc.nextInt();
            int[] array = new int[2*N];
            StringBuilder sb = new StringBuilder();
            for(int j=0;j<N;j++){
                array[j]=1+random.nextInt(1000000000);
                sb.append(array[j]).append("" "");
            }

            System.out.println(sb.toString().trim());

            for(int j=0;j<N;j++){
                array[N+j]=sc.nextInt();
            }
            // System.out.println(sb.toString().trim());
            findHalf(array);
        }
        sc.close();

    }

    private static void findHalf(int[] array) {
        Arrays.sort(array);
        long sum=0;
        for (int i : array) {
            sum+=i;
        }
        ArrayList<Integer> result = new ArrayList<>();
        findHalfHelper(array, array.length-1, result, sum/2,0);
        System.out.println(result);
    }

    private static boolean findHalfHelper(int[] array, int startWith, ArrayList<Integer> result, long targetHalfSum, long sumSoFar) {
        if(startWith<0) {
            return false;
        }

        int i=startWith;
        long currentSum=0;
        for (; i >=0 ; i--) {
            currentSum = sumSoFar + array[i];
            if(currentSum <= targetHalfSum) break;
        }

        if(currentSum == targetHalfSum) {
            result.add(array[i]);
            return true;
        }


        boolean halfHelperResult = ",DEB
5539,"public class Solution {

    public static void main(String[] args) {
////        System.out.println(""Enter"");
        Scanner sc = new Scanner(System.in);
        Random random=new Random();
        var numberOfTestCases = sc.nextInt();
        for (int i = 0; i < numberOfTestCases; i++) {
            var N = sc.nextInt();
            int[] array = new int[2*N];
            StringBuilder sb = new StringBuilder();
            for(int j=0;j<N;j++){
                array[j]=1+random.nextInt(1000000000);
                sb.append(array[j]).append("" "");
            }

            System.out.println(sb.toString().trim());

            for(int j=0;j<N;j++){
                array[N+j]=sc.nextInt();
            }
            System.out.println(sb.toString().trim());
            // findHalf(array);
        }
        sc.close();

    }

    private static void findHalf(int[] array) {
        // Arrays.sort(array);
        long sum=0;
        // for (int i : array) {
        //     sum+=i;
        // }
        ArrayList<Integer> result = new ArrayList<>();
        // findHalfHelper(array, array.length-1, result, sum/2,0);
        System.out.println(result);
    }

    private static boolean findHalfHelper(int[] array, int startWith, ArrayList<Integer> result, long targetHalfSum, long sumSoFar) {
        if(startWith<0) {
            return false;
        }

        int i=startWith;
        long currentSum=0;
        // for (; i >=0 ; i--) {
        //     currentSum = sumSoFar + array[i];
        //     if(currentSum <= targetHalfSum) break;
        // }

        // if(currentSum == targetHalfSum) {
        //     result.add(array[i]);
        //     return true;
        // }


        boolean halfHelperResult = ",DEB
5540,"public class Solution {

    public static void main(String[] args) {
////        System.out.println(""Enter"");
        Scanner sc = new Scanner(System.in);
        Random random=new Random();
        var numberOfTestCases = sc.nextInt();
        for (int i = 0; i < numberOfTestCases; i++) {
            var N = sc.nextInt();
            int[] array = new int[2*N];
            StringBuilder sb = new StringBuilder();
            for(int j=0;j<N;j++){
                array[j]=1+random.nextInt(1000000000);
                sb.append(array[j]).append("" "");
            }

            System.out.println(sb.toString().trim());

            for(int j=0;j<N;j++){
                array[N+j]=sc.nextInt();
            }
            // findHalf(array);
        }
        sc.close();

    }

    private static void findHalf(int[] array) {
        // Arrays.sort(array);
        long sum=0;
        // for (int i : array) {
        //     sum+=i;
        // }
        ArrayList<Integer> result = new ArrayList<>();
        // findHalfHelper(array, array.length-1, result, sum/2,0);
        System.out.println(result);
    }

    private static boolean findHalfHelper(int[] array, int startWith, ArrayList<Integer> result, long targetHalfSum, long sumSoFar) {
        if(startWith<0) {
            return false;
        }

        int i=startWith;
        long currentSum=0;
        // for (; i >=0 ; i--) {
        //     currentSum = sumSoFar + array[i];
        //     if(currentSum <= targetHalfSum) break;
        // }

        // if(currentSum == targetHalfSum) {
        //     result.add(array[i]);
        //     return true;
        // }


        boolean halfHelperResult = ",DEB
5541,"public class Solution {

    public static void main(String[] args) {
////        System.out.println(""Enter"");
        Scanner sc = new Scanner(System.in);
        Random random=new Random();
        var numberOfTestCases = sc.nextInt();
        for (int i = 0; i < numberOfTestCases; i++) {
            var N = sc.nextInt();
            int[] array = new int[2*N];
            StringBuilder sb = new StringBuilder();
            for(int j=0;j<N;j++){
                array[j]=1+random.nextInt(1000000000);
                sb.append(array[j]).append("" "");
            }

            System.out.println(sb.toString().trim());

            for(int j=0;j<N;j++){
                array[N+j]=sc.nextInt();
            }
            findHalf(array);
        }
        sc.close();

    }

    private static void findHalf(int[] array) {
        // Arrays.sort(array);
        long sum=0;
        // for (int i : array) {
        //     sum+=i;
        // }
        ArrayList<Integer> result = new ArrayList<>();
        // findHalfHelper(array, array.length-1, result, sum/2,0);
        System.out.println(result);
    }

    private static boolean findHalfHelper(int[] array, int startWith, ArrayList<Integer> result, long targetHalfSum, long sumSoFar) {
        if(startWith<0) {
            return false;
        }

        int i=startWith;
        long currentSum=0;
        // for (; i >=0 ; i--) {
        //     currentSum = sumSoFar + array[i];
        //     if(currentSum <= targetHalfSum) break;
        // }

        // if(currentSum == targetHalfSum) {
        //     result.add(array[i]);
        //     return true;
        // }


        boolean halfHelperResult = ",DEB
5697,"class Solution {
    public static void main(String[] args) {
//        provideInput(""3
"" +
//                ""PEEL
"" +
//                ""AAAAAAAAAA
"" +
//                ""CODEJAMDAY
"");

        try (Scanner reader = new Scanner(System.in)) {
            if (reader.hasNextLine() && reader.hasNextInt()) {
                int T = Integer.parseInt(reader.nextLine());

                for (int i = 0; i < T; i++) {
                    StringBuilder string = new StringBuilder("""");

                    String word = reader.nextLine();

                    int length = word.length();
                    for (int j = 0; j < length; j++) {
                        char c1 = word.charAt(j);
                        string.append(c1);
                        if (j != length - 1 && c1 < word.charAt(j + 1)) {
                            string.append(c1);
                        }
                    }
                    System.out.printf(""Case #%s: %s%n"", i + 1, string);
                }
            }
        }
    }

    private static void provideInput(String data) {
        ByteArrayInputStream testIn;
        testIn = new ByteArrayInputStream(data.getBytes(StandardCharsets.UTF_8));
        System.setIn(testIn);
    }
}
",JanDL
5836,"public class Solution {
	
	private static void experiment1a3(Scanner in) {
		// TODO Auto-generated method stub
		
	}

	private static void experiment1a2(Scanner in) {
		// TODO Auto-generated method stub
		
	}

	private static void experiment1a1(Scanner in) {
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.

		for (int i = 1; i <= t; ++i) {
			StringBuilder text = new StringBuilder();
			StringBuilder textpath1 = new StringBuilder();
			StringBuilder textpath2 = new StringBuilder();
			
			
			String word = in.next();
			char[] c = word.toCharArray();
			
			text.append(word);
			
			int counter = 0;
			for (int j = 0; j < word.length(); j++) {
				textpath1 = new StringBuilder(text);
				textpath2 = new StringBuilder(text);
				
				
				textpath2.insert(counter, c[j]);
				
				
				if (textpath1.toString().compareTo(textpath2.toString())<0) {
					text=textpath1;
					counter++;
				}else {
					text=textpath2;
					counter+=2;
				}
			}
			

			System.out.print(""Case #"" + i + "": "");
			System.out.println(text.toString());
		}
		
	}
	
	private static void experiment1a1a(Scanner in) {
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.

		for (int i = 1; i <= t; ++i) {
			StringBuilder text = new StringBuilder();
			
			String word = in.next();
			char[] c = word.toCharArray();
			boolean chainBroken = false;
			text.append(c[c.length-1]);
			char lastChar = c[c.length-1];
			for (int j = c.length-1; j > 0; j--) {
				if (c[j]!=lastChar)chainBroken=true;
				if (c[j-1]<c[j]) {
					text.insert(0,c[j-1]);
					text.insert(0,c[j-1]);
				}else {
					if (c[j-1]==c[j] &&chainBroken) {
						text.insert(0,c[j-1]);
						text.insert(0,c[j-1]);
					}else
						text.insert(0,c[j-1]);
						
				}
			}
			

			System.out.print(""Case #"" + i + "": "");
			System.out.println(text.toString());
		}
		
	}

	
	
	private static boolean extracted(Room currentRoom, long passageSizes, long checkedRoomsCount) {
		boolean check =(currentRoom.maxPassages > 48 ||currentRoom.maxPassages > passageSizes*4/checkedRoomsCount);
		//to transport if in hub
		//currentRoom.maxPassages > 6 &&
		return check;
	}

	private static long extracted2(long countUnvisited, long passagesInVisited, double average) {
		long totalRooms = (long) Math.round(1.0*(passagesInVisited + countUnvisited*average)/2.);
		return totalRooms;
	}	
	
	public static void main(String[] args) {
		Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int phase = 2;
		int problem = 1;
		if (phase==1) {
		switch (problem) {
		case 1:
			experiment1(in);
			break;
		case 2:
			experiment2(in);
			break;
		case 3:
			experiment3(in);
			break;
		case 4:
			experiment4(in);
			break;
		case 5:
			experiment5(in);
			break;
		default:
			break;
		}}
		if (phase==2) {
			switch (problem) {
			case 1:
				experiment1a1(in);
				break;
			case 2:
				experiment1a2(in);
				break;
			case 3:
				experiment1a3(in);
				break;
			
			default:
				break;
			}
		}

	}


	private static class Room{
		
		public Room(int i,int mp) {
			
			id = i;
			maxPassages = mp;
		}
		
		final int id;
		int minPassages = 1;
		int maxPassages;
		public int visitedConnections = 0;
		public boolean hasBeenVisited = false;
		public int[] visit(int krp) {
			int delta1 = maxPassages-krp;
			int delta0 = krp-minPassages;
			maxPassages = krp;
			minPassages = krp;
			hasBeenVisited = true;
			return new int[] {delta0,delta1};
			
		}
	}
	private static class Request{

		public boolean isWalk;

		public void print() {
			// TODO Auto-generated method stub
			
		}
		
	}
	private static class BelieveState{

		private Room[] rooms;
		//private int[][] connections; //0 means unknown; -1 means not; 1 means excists;
		private boolean certain = false;
		//private int minConnectionsTimes2;
	//	private int maxConnectionsTimes2;
		//private int maxConnections;
		public BelieveState(int n) {
			rooms = new Room[n+1];
			//connections = new int[n][n];
		//	minConnectionsTimes2 = (int) n;
			//maxConnectionsTimes2 = (int)(n*(n-1)/2);
			//maxConnections = (int)(n*(n-1)/2);
			for (int i = 1; i <= n; i++) {
				rooms[i] = new Room(i,n-1);
			}
		}
		public void update(int kri, int krp) {
			Room r = rooms[kri];
			if (!r.hasBeenVisited) {
				int[] changedPassages = r.visit(krp);
				//maxConnectionsTimes2-=changedPassages[1];
				//minConnectionsTimes2-=changedPassages[0];
			}
			
		}
		public Request getBestRequest() {
			return null;
			// TODO Auto-generated method stub
			
		}
		public int guess() {
			// TODO Auto-generated method stub
			return 0;
		}
		/*public void addConnection(Room currentRoom, Room nextRoom) {
			if (connections[currentRoom.id][nextRoom.id]==0) {
				currentRoom.visitedConnections++;
				nextRoom.visitedConnections++;
			}
			connections[currentRoom.id][nextRoom.id] = 1;
			connections[nextRoom.id][currentRoom.id] = 1;
			
		}*/
		
		
	}
	private static int nextInt(boolean fj, Scanner in ,boolean[][] conn, int room, boolean b) {
		if (!fj)return in.nextInt();
		if (b) {
			System.out.print(room + "" "");
			return room;
		}
		else {
			int counter = 0;
			boolean[] list = conn[room-1];
			for (int i = 0; i < list.length; i++) {
				if (list[i])counter++;
			}
			System.out.println(counter);
			return counter;
		}
		
		
	}
	private static void experiment5(Scanner in) {
		long startTime = System.currentTimeMillis();
		boolean useFakeJudge = false;
		
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		boolean[][] connections = null;
		
		
		for (int i = 1; i <= t; ++i) {
		
			int n = in.nextInt();
			boolean[] checkedRooms = new boolean[n+1];
			boolean[] walkedRooms = new boolean[n+1];
			int k = in.nextInt();
			//BelieveState bs2;
			if (useFakeJudge) {
				connections = new boolean[n][n];
				int max = n*(n-1)/2;
				double chance = (1/4.);
				for (int j = 0; j < connections.length; j++) {
					int rj = (int) (Math.random()*n);
					connections[j][rj] = true;
					connections[rj][j] = true;
					for (int j2 = j+1; j2 < connections.length; j2++) {
						if (Math.random()<chance) {
							connections[j][j2] = true;
							connections[j2][j] = true;
						}
					}
				}
			};
			BelieveState bs = new BelieveState(n);
			int kri = in.nextInt();
			checkedRooms[kri] = true;
			int krp = in.nextInt();
			bs.update(kri,krp);
			Room currentRoom = bs.rooms[kri];
			ArrayList<Integer> grabBag = new ArrayList<>();
			for (int j = ",Nibbla
5837,"public class Solution {
	
	private static void experiment1a3(Scanner in) {
		// TODO Auto-generated method stub
		
	}

	private static void experiment1a2(Scanner in) {
		// TODO Auto-generated method stub
		
	}

	private static void experiment1a1(Scanner in) {
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.

		for (int i = 1; i <= t; ++i) {
			StringBuilder text = new StringBuilder();
			
			String word = in.next();
			char[] c = word.toCharArray();
			boolean chainBroken = false;
			text.append(c[c.length-1]);
			char lastChar = c[c.length-1];
			for (int j = c.length-1; j > 0; j--) {
				if (c[j]!=lastChar)chainBroken=true;
				if (c[j-1]<c[j]) {
					text.insert(0,c[j-1]);
					text.insert(0,c[j-1]);
				}else {
					if (c[j-1]==c[j] &&chainBroken) {
						text.insert(0,c[j-1]);
						text.insert(0,c[j-1]);
					}else
						text.insert(0,c[j-1]);
						
				}
			}
			

			System.out.print(""Case #"" + i + "": "");
			System.out.println(text.toString());
		}
		
	}

	
	
	private static boolean extracted(Room currentRoom, long passageSizes, long checkedRoomsCount) {
		boolean check =(currentRoom.maxPassages > 48 ||currentRoom.maxPassages > passageSizes*4/checkedRoomsCount);
		//to transport if in hub
		//currentRoom.maxPassages > 6 &&
		return check;
	}

	private static long extracted2(long countUnvisited, long passagesInVisited, double average) {
		long totalRooms = (long) Math.round(1.0*(passagesInVisited + countUnvisited*average)/2.);
		return totalRooms;
	}	
	
	public static void main(String[] args) {
		Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int phase = 2;
		int problem = 1;
		if (phase==1) {
		switch (problem) {
		case 1:
			experiment1(in);
			break;
		case 2:
			experiment2(in);
			break;
		case 3:
			experiment3(in);
			break;
		case 4:
			experiment4(in);
			break;
		case 5:
			experiment5(in);
			break;
		default:
			break;
		}}
		if (phase==2) {
			switch (problem) {
			case 1:
				experiment1a1(in);
				break;
			case 2:
				experiment1a2(in);
				break;
			case 3:
				experiment1a3(in);
				break;
			
			default:
				break;
			}
		}

	}


	private static class Room{
		
		public Room(int i,int mp) {
			
			id = i;
			maxPassages = mp;
		}
		
		final int id;
		int minPassages = 1;
		int maxPassages;
		public int visitedConnections = 0;
		public boolean hasBeenVisited = false;
		public int[] visit(int krp) {
			int delta1 = maxPassages-krp;
			int delta0 = krp-minPassages;
			maxPassages = krp;
			minPassages = krp;
			hasBeenVisited = true;
			return new int[] {delta0,delta1};
			
		}
	}
	private static class Request{

		public boolean isWalk;

		public void print() {
			// TODO Auto-generated method stub
			
		}
		
	}
	private static class BelieveState{

		private Room[] rooms;
		//private int[][] connections; //0 means unknown; -1 means not; 1 means excists;
		private boolean certain = false;
		//private int minConnectionsTimes2;
	//	private int maxConnectionsTimes2;
		//private int maxConnections;
		public BelieveState(int n) {
			rooms = new Room[n+1];
			//connections = new int[n][n];
		//	minConnectionsTimes2 = (int) n;
			//maxConnectionsTimes2 = (int)(n*(n-1)/2);
			//maxConnections = (int)(n*(n-1)/2);
			for (int i = 1; i <= n; i++) {
				rooms[i] = new Room(i,n-1);
			}
		}
		public void update(int kri, int krp) {
			Room r = rooms[kri];
			if (!r.hasBeenVisited) {
				int[] changedPassages = r.visit(krp);
				//maxConnectionsTimes2-=changedPassages[1];
				//minConnectionsTimes2-=changedPassages[0];
			}
			
		}
		public Request getBestRequest() {
			return null;
			// TODO Auto-generated method stub
			
		}
		public int guess() {
			// TODO Auto-generated method stub
			return 0;
		}
		/*public void addConnection(Room currentRoom, Room nextRoom) {
			if (connections[currentRoom.id][nextRoom.id]==0) {
				currentRoom.visitedConnections++;
				nextRoom.visitedConnections++;
			}
			connections[currentRoom.id][nextRoom.id] = 1;
			connections[nextRoom.id][currentRoom.id] = 1;
			
		}*/
		
		
	}
	private static int nextInt(boolean fj, Scanner in ,boolean[][] conn, int room, boolean b) {
		if (!fj)return in.nextInt();
		if (b) {
			System.out.print(room + "" "");
			return room;
		}
		else {
			int counter = 0;
			boolean[] list = conn[room-1];
			for (int i = 0; i < list.length; i++) {
				if (list[i])counter++;
			}
			System.out.println(counter);
			return counter;
		}
		
		
	}
	private static void experiment5(Scanner in) {
		long startTime = System.currentTimeMillis();
		boolean useFakeJudge = false;
		
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		boolean[][] connections = null;
		
		
		for (int i = 1; i <= t; ++i) {
		
			int n = in.nextInt();
			boolean[] checkedRooms = new boolean[n+1];
			boolean[] walkedRooms = new boolean[n+1];
			int k = in.nextInt();
			//BelieveState bs2;
			if (useFakeJudge) {
				connections = new boolean[n][n];
				int max = n*(n-1)/2;
				double chance = (1/4.);
				for (int j = 0; j < connections.length; j++) {
					int rj = (int) (Math.random()*n);
					connections[j][rj] = true;
					connections[rj][j] = true;
					for (int j2 = j+1; j2 < connections.length; j2++) {
						if (Math.random()<chance) {
							connections[j][j2] = true;
							connections[j2][j] = true;
						}
					}
				}
			};
			BelieveState bs = new BelieveState(n);
			int kri = in.nextInt();
			checkedRooms[kri] = true;
			int krp = in.nextInt();
			bs.update(kri,krp);
			Room currentRoom = bs.rooms[kri];
			ArrayList<Integer> grabBag = new ArrayList<>();
			for (int j = 1; j <= n; j++) {
				if (j == kri)continue;
				grabBag.add(j);
			}
			Collections.shuffle(grabBag);
			int counter = 0;
			Room nextRoom = null;
			long passageSizes = krp;
			long checkedRoomsCount = 1;
			
			long passageSizesT = krp;
			double checkedRoomsCountT = 1;
			long transportPasages = krp;
			long transportCount = 1;
			long afterwalkPasages = 0;
			long afterwalkCount = 0;
			checkedRooms[kri] = true;
			while(k>0&&counter<grabBag.size()) {
				
				//Request r = bs.getBestRequest();
				//r.print();
				int room = 1;
				//if (k % 2 == 0) {
				boolean trasnported = false;
				boolean check = extracted(currentRoom, passageSizes, checkedRoomsCount);
				if (walkedRooms[kri]) {
					room = grabBag.get((counter++)%grabBag.size());
					if (checkedRooms[room])continue;
					System.out.println(""T "" + room);
					trasnported = ",Nibbla
7172,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			HashMap<Integer, HashSet<Integer>> edge = new HashMap<>(K);
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				int last = R;
				long sum = 0;
				int count = 0;
				int query = 0;
				final int CHECK = 3;
				while(query + CHECK <= K) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						++ query;
						degree[R] = P;
						if (notFind.remove(R)) {
							++ count;
							sum += P;
						}
						final int l = last, r = R;
						edge.compute(last, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(r);
							return v;
						});
						edge.compute(R, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(l);
							return v;
						});
						last = R;
						if (degree[R] == edge.get(R).size()) break;
					}
					int next = 1;
					while(!notFind.contains(next)) next = rnd.nextInt(N) + 1;
					out.println(""T "" + next);
					R = fs.nextInt();
					P = fs.nextInt();
					++ query;
					degree[R] = P;
					if (notFind.remove(R)) {
						++ count;
						sum += P;
					}
					last = R;
				}
				sum *= N;
				sum /= count;
				sum = sum * 11 / 10;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7173,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			HashMap<Integer, HashSet<Integer>> edge = new HashMap<>(K);
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				int last = R;
				long sum = 0;
				int count = 0;
				int query = 0;
				final int CHECK = 2;
				while(query + CHECK <= K) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						++ query;
						degree[R] = P;
						if (notFind.remove(R)) {
							++ count;
							sum += P;
						}
						final int l = last, r = R;
						edge.compute(last, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(r);
							return v;
						});
						edge.compute(R, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(l);
							return v;
						});
						last = R;
						if (degree[R] == edge.get(R).size()) break;
					}
					int next = 1;
					while(!notFind.contains(next)) next = rnd.nextInt(N) + 1;
					out.println(""T "" + next);
					R = fs.nextInt();
					P = fs.nextInt();
					++ query;
					degree[R] = P;
					if (notFind.remove(R)) {
						++ count;
						sum += P;
					}
					last = R;
				}
				sum *= N;
				sum /= count;
				sum = sum * 7 / 10;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7174,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			HashMap<Integer, HashSet<Integer>> edge = new HashMap<>(K);
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				int last = R;
				long sum = 0;
				int count = 0;
				int query = 0;
				final int CHECK = 4;
				while(query + CHECK <= K) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						++ query;
						degree[R] = P;
						if (notFind.remove(R)) {
							++ count;
							sum += P;
						}
						final int l = last, r = R;
						edge.compute(last, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(r);
							return v;
						});
						edge.compute(R, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(l);
							return v;
						});
						last = R;
						if (degree[R] == edge.get(R).size()) break;
					}
					int next = 1;
					while(!notFind.contains(next)) next = rnd.nextInt(N) + 1;
					out.println(""T "" + next);
					R = fs.nextInt();
					P = fs.nextInt();
					++ query;
					degree[R] = P;
					if (notFind.remove(R)) {
						++ count;
						sum += P;
					}
					last = R;
				}
				sum *= N;
				sum /= count;
				sum = sum * 7 / 10;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7175,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			HashMap<Integer, HashSet<Integer>> edge = new HashMap<>(K);
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				int last = R;
				long sum = 0;
				int count = 0;
				int query = 0;
				final int CHECK = 7;
				while(query + CHECK <= K) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						++ query;
						degree[R] = P;
						if (notFind.remove(R)) {
							++ count;
							sum += P;
						}
						final int l = last, r = R;
						edge.compute(last, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(r);
							return v;
						});
						edge.compute(R, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(l);
							return v;
						});
						last = R;
						if (degree[R] == edge.get(R).size()) break;
					}
					int next = 1;
					while(!notFind.contains(next)) next = rnd.nextInt(N) + 1;
					out.println(""T "" + next);
					R = fs.nextInt();
					P = fs.nextInt();
					++ query;
					degree[R] = P;
					if (notFind.remove(R)) {
						++ count;
						sum += P;
					}
					last = R;
				}
				sum *= N;
				sum /= count;
				sum = sum * 7 / 10;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7176,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			HashMap<Integer, HashSet<Integer>> edge = new HashMap<>(K);
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				int last = R;
				long sum = 0;
				int count = 0;
				int query = 0;
				final int CHECK = 10;
				while(query + CHECK <= K) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						++ query;
						degree[R] = P;
						if (notFind.remove(R)) {
							++ count;
							sum += P;
						}
						final int l = last, r = R;
						edge.compute(last, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(r);
							return v;
						});
						edge.compute(R, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(l);
							return v;
						});
						last = R;
						if (degree[R] == edge.get(R).size()) break;
					}
					int next = 1;
					while(!notFind.contains(next)) next = rnd.nextInt(N) + 1;
					out.println(""T "" + next);
					R = fs.nextInt();
					P = fs.nextInt();
					++ query;
					degree[R] = P;
					if (notFind.remove(R)) {
						++ count;
						sum += P;
					}
					last = R;
				}
				sum *= N;
				sum /= count;
				sum = sum * 7 / 10;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7177,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			HashMap<Integer, HashSet<Integer>> edge = new HashMap<>(K);
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				int last = R;
				long sum = 0;
				int count = 0;
				int query = 0;
				final int CHECK = 15;
				while(query + CHECK <= K) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						++ query;
						degree[R] = P;
						if (notFind.remove(R)) {
							++ count;
							sum += P;
						}
						final int l = last, r = R;
						edge.compute(last, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(r);
							return v;
						});
						edge.compute(R, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(l);
							return v;
						});
						last = R;
						if (degree[R] == edge.get(R).size()) break;
					}
					int next = 1;
					while(!notFind.contains(next)) next = rnd.nextInt(N) + 1;
					out.println(""T "" + next);
					R = fs.nextInt();
					P = fs.nextInt();
					++ query;
					degree[R] = P;
					if (notFind.remove(R)) {
						++ count;
						sum += P;
					}
					last = R;
				}
				sum *= N;
				sum /= count;
				sum = sum * 7 / 10;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7178,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			HashMap<Integer, HashSet<Integer>> edge = new HashMap<>(K);
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				int last = R;
				long sum = 0;
				int count = 0;
				int query = 0;
				final int CHECK = 20;
				while(query + CHECK <= K) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						++ query;
						degree[R] = P;
						if (notFind.remove(R)) {
							++ count;
							sum += P;
						}
						final int l = last, r = R;
						edge.compute(last, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(r);
							return v;
						});
						edge.compute(R, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(l);
							return v;
						});
						last = R;
						if (degree[R] == edge.get(R).size()) break;
					}
					int next = 1;
					while(!notFind.contains(next)) next = rnd.nextInt(N) + 1;
					out.println(""T "" + next);
					R = fs.nextInt();
					P = fs.nextInt();
					++ query;
					degree[R] = P;
					if (notFind.remove(R)) {
						++ count;
						sum += P;
					}
					last = R;
				}
				sum *= N;
				sum /= count;
				sum = sum * 7 / 10;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7179,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			HashMap<Integer, HashSet<Integer>> edge = new HashMap<>(K);
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				int last = R;
				long sum = 0;
				int count = 0;
				int query = 0;
				final int CHECK = 20;
				while(query + CHECK <= K) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						++ query;
						degree[R] = P;
						if (notFind.remove(R)) {
							++ count;
							sum += P;
						}
						final int l = last, r = R;
						edge.compute(last, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(r);
							return v;
						});
						edge.compute(R, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(l);
							return v;
						});
						last = R;
						if (degree[R] == edge.get(R).size()) break;
					}
					int next = 1;
					while(!notFind.contains(next)) next = rnd.nextInt(N) + 1;
					out.println(""T "" + next);
					R = fs.nextInt();
					P = fs.nextInt();
					++ query;
					degree[R] = P;
					if (notFind.remove(R)) {
						++ count;
						sum += P;
					}
					last = R;
				}
				sum *= N;
				sum /= count;
				sum = sum * 8 / 10;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7180,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			HashMap<Integer, HashSet<Integer>> edge = new HashMap<>(K);
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				int last = R;
				long sum = 0;
				int count = 0;
				int query = 0;
				final int CHECK = 15;
				while(query + CHECK <= K) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						++ query;
						degree[R] = P;
						if (notFind.remove(R)) {
							++ count;
							sum += P;
						}
						final int l = last, r = R;
						edge.compute(last, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(r);
							return v;
						});
						edge.compute(R, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(l);
							return v;
						});
						last = R;
						if (degree[R] == edge.get(R).size()) break;
					}
					int next = 1;
					while(!notFind.contains(next)) next = rnd.nextInt(N) + 1;
					out.println(""T "" + next);
					R = fs.nextInt();
					P = fs.nextInt();
					++ query;
					degree[R] = P;
					if (notFind.remove(R)) {
						++ count;
						sum += P;
					}
					last = R;
				}
				sum *= N;
				sum /= count;
				sum = sum * 8 / 10;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7181,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			HashMap<Integer, HashSet<Integer>> edge = new HashMap<>(K);
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				int last = R;
				long sum = 0;
				int count = 0;
				int query = 0;
				final int CHECK = 12;
				while(query + CHECK <= K) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						++ query;
						degree[R] = P;
						if (notFind.remove(R)) {
							++ count;
							sum += P;
						}
						final int l = last, r = R;
						edge.compute(last, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(r);
							return v;
						});
						edge.compute(R, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(l);
							return v;
						});
						last = R;
						if (degree[R] == edge.get(R).size()) break;
					}
					int next = 1;
					while(!notFind.contains(next)) next = rnd.nextInt(N) + 1;
					out.println(""T "" + next);
					R = fs.nextInt();
					P = fs.nextInt();
					++ query;
					degree[R] = P;
					if (notFind.remove(R)) {
						++ count;
						sum += P;
					}
					last = R;
				}
				sum *= N;
				sum /= count;
				sum = sum * 8 / 10;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7182,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			HashMap<Integer, HashSet<Integer>> edge = new HashMap<>(K);
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				int last = R;
				long sum = 0;
				int count = 0;
				int query = 0;
				final int CHECK = 9;
				while(query + CHECK <= K) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						++ query;
						degree[R] = P;
						if (notFind.remove(R)) {
							++ count;
							sum += P;
						}
						final int l = last, r = R;
						edge.compute(last, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(r);
							return v;
						});
						edge.compute(R, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(l);
							return v;
						});
						last = R;
						if (degree[R] == edge.get(R).size()) break;
					}
					int next = 1;
					while(!notFind.contains(next)) next = rnd.nextInt(N) + 1;
					out.println(""T "" + next);
					R = fs.nextInt();
					P = fs.nextInt();
					++ query;
					degree[R] = P;
					if (notFind.remove(R)) {
						++ count;
						sum += P;
					}
					last = R;
				}
				sum *= N;
				sum /= count;
				sum = sum * 8 / 10;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7183,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			HashMap<Integer, HashSet<Integer>> edge = new HashMap<>(K);
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				int last = R;
				long sum = 0;
				int count = 0;
				int query = 0;
				final int CHECK = 8;
				while(query + CHECK <= K) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						++ query;
						degree[R] = P;
						if (notFind.remove(R)) {
							++ count;
							sum += P;
						}
						final int l = last, r = R;
						edge.compute(last, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(r);
							return v;
						});
						edge.compute(R, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(l);
							return v;
						});
						last = R;
						if (degree[R] == edge.get(R).size()) break;
					}
					int next = 1;
					while(!notFind.contains(next)) next = rnd.nextInt(N) + 1;
					out.println(""T "" + next);
					R = fs.nextInt();
					P = fs.nextInt();
					++ query;
					degree[R] = P;
					if (notFind.remove(R)) {
						++ count;
						sum += P;
					}
					last = R;
				}
				sum *= N;
				sum /= count;
				sum = sum * 8 / 10;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7184,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			HashMap<Integer, HashSet<Integer>> edge = new HashMap<>(K);
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				int last = R;
				long sum = 0;
				int count = 0;
				int query = 0;
				final int CHECK = 7;
				while(query + CHECK <= K) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						++ query;
						degree[R] = P;
						if (notFind.remove(R)) {
							++ count;
							sum += P;
						}
						final int l = last, r = R;
						edge.compute(last, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(r);
							return v;
						});
						edge.compute(R, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(l);
							return v;
						});
						last = R;
						if (degree[R] == edge.get(R).size()) break;
					}
					int next = 1;
					while(!notFind.contains(next)) next = rnd.nextInt(N) + 1;
					out.println(""T "" + next);
					R = fs.nextInt();
					P = fs.nextInt();
					++ query;
					degree[R] = P;
					if (notFind.remove(R)) {
						++ count;
						sum += P;
					}
					last = R;
				}
				sum *= N;
				sum /= count;
				sum = sum * 8 / 10;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7185,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			HashMap<Integer, HashSet<Integer>> edge = new HashMap<>(K);
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				int last = R;
				long sum = 0;
				int count = 0;
				int query = 0;
				final int CHECK = 6;
				while(query + CHECK <= K) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						++ query;
						degree[R] = P;
						if (notFind.remove(R)) {
							++ count;
							sum += P;
						}
						final int l = last, r = R;
						edge.compute(last, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(r);
							return v;
						});
						edge.compute(R, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(l);
							return v;
						});
						last = R;
						if (degree[R] == edge.get(R).size()) break;
					}
					int next = 1;
					while(!notFind.contains(next)) next = rnd.nextInt(N) + 1;
					out.println(""T "" + next);
					R = fs.nextInt();
					P = fs.nextInt();
					++ query;
					degree[R] = P;
					if (notFind.remove(R)) {
						++ count;
						sum += P;
					}
					last = R;
				}
				sum *= N;
				sum /= count;
				sum = sum * 8 / 10;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7186,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			HashMap<Integer, HashSet<Integer>> edge = new HashMap<>(K);
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				int last = R;
				long sum = 0;
				int count = 0;
				int query = 0;
				final int CHECK = 5;
				while(query + CHECK <= K) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						++ query;
						degree[R] = P;
						if (notFind.remove(R)) {
							++ count;
							sum += P;
						}
						final int l = last, r = R;
						edge.compute(last, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(r);
							return v;
						});
						edge.compute(R, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(l);
							return v;
						});
						last = R;
						if (degree[R] == edge.get(R).size()) break;
					}
					int next = 1;
					while(!notFind.contains(next)) next = rnd.nextInt(N) + 1;
					out.println(""T "" + next);
					R = fs.nextInt();
					P = fs.nextInt();
					++ query;
					degree[R] = P;
					if (notFind.remove(R)) {
						++ count;
						sum += P;
					}
					last = R;
				}
				sum *= N;
				sum /= count;
				sum = sum * 8 / 10;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7187,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			HashMap<Integer, HashSet<Integer>> edge = new HashMap<>(K);
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				int last = R;
				long sum = 0;
				int count = 0;
				int query = 0;
				final int CHECK = 4;
				while(query + CHECK <= K) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						++ query;
						degree[R] = P;
						if (notFind.remove(R)) {
							++ count;
							sum += P;
						}
						final int l = last, r = R;
						edge.compute(last, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(r);
							return v;
						});
						edge.compute(R, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(l);
							return v;
						});
						last = R;
						if (degree[R] == edge.get(R).size()) break;
					}
					int next = 1;
					while(!notFind.contains(next)) next = rnd.nextInt(N) + 1;
					out.println(""T "" + next);
					R = fs.nextInt();
					P = fs.nextInt();
					++ query;
					degree[R] = P;
					if (notFind.remove(R)) {
						++ count;
						sum += P;
					}
					last = R;
				}
				sum *= N;
				sum /= count;
				sum = sum * 8 / 10;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7188,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			HashMap<Integer, HashSet<Integer>> edge = new HashMap<>(K);
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				int last = R;
				long sum = 0;
				int count = 0;
				int query = 0;
				final int CHECK = 3;
				while(query + CHECK <= K) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						++ query;
						degree[R] = P;
						if (notFind.remove(R)) {
							++ count;
							sum += P;
						}
						final int l = last, r = R;
						edge.compute(last, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(r);
							return v;
						});
						edge.compute(R, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(l);
							return v;
						});
						last = R;
						if (degree[R] == edge.get(R).size()) break;
					}
					int next = 1;
					while(!notFind.contains(next)) next = rnd.nextInt(N) + 1;
					out.println(""T "" + next);
					R = fs.nextInt();
					P = fs.nextInt();
					++ query;
					degree[R] = P;
					if (notFind.remove(R)) {
						++ count;
						sum += P;
					}
					last = R;
				}
				sum *= N;
				sum /= count;
				sum = sum * 8 / 10;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7189,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			HashMap<Integer, HashSet<Integer>> edge = new HashMap<>(K);
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				int last = R;
				long sum = 0;
				int count = 0;
				int query = 0;
				final int CHECK = 2;
				while(query + CHECK <= K) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						++ query;
						degree[R] = P;
						if (notFind.remove(R)) {
							++ count;
							sum += P;
						}
						final int l = last, r = R;
						edge.compute(last, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(r);
							return v;
						});
						edge.compute(R, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(l);
							return v;
						});
						last = R;
						if (degree[R] == edge.get(R).size()) break;
					}
					int next = 1;
					while(!notFind.contains(next)) next = rnd.nextInt(N) + 1;
					out.println(""T "" + next);
					R = fs.nextInt();
					P = fs.nextInt();
					++ query;
					degree[R] = P;
					if (notFind.remove(R)) {
						++ count;
						sum += P;
					}
					last = R;
				}
				sum *= N;
				sum /= count;
				sum = sum * 8 / 10;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7190,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			HashMap<Integer, HashSet<Integer>> edge = new HashMap<>(K);
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				int last = R;
				long sum = 0;
				int count = 0;
				int query = 0;
				final int CHECK = 20;
				while(query + CHECK <= K) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						++ query;
						degree[R] = P;
						if (notFind.remove(R)) {
							++ count;
							sum += P;
						}
						final int l = last, r = R;
						edge.compute(last, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(r);
							return v;
						});
						edge.compute(R, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(l);
							return v;
						});
						last = R;
						if (degree[R] == edge.get(R).size()) break;
						if (degree[R] >= 200) break;
					}
					int next = 1;
					while(!notFind.contains(next)) next = rnd.nextInt(N) + 1;
					out.println(""T "" + next);
					R = fs.nextInt();
					P = fs.nextInt();
					++ query;
					degree[R] = P;
					if (notFind.remove(R)) {
						++ count;
						sum += P;
					}
					last = R;
				}
				sum *= N;
				sum /= count;
				sum = sum * 9 / 10;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7191,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			HashMap<Integer, HashSet<Integer>> edge = new HashMap<>(K);
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				int last = R;
				long sum = 0;
				int count = 0;
				int query = 0;
				final int CHECK = 20;
				while(query + CHECK <= K) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						++ query;
						degree[R] = P;
						if (notFind.remove(R)) {
							++ count;
							sum += P;
						}
						final int l = last, r = R;
						edge.compute(last, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(r);
							return v;
						});
						edge.compute(R, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(l);
							return v;
						});
						last = R;
						if (degree[R] == edge.get(R).size()) break;
						if (degree[R] >= 100) break;
					}
					int next = 1;
					while(!notFind.contains(next)) next = rnd.nextInt(N) + 1;
					out.println(""T "" + next);
					R = fs.nextInt();
					P = fs.nextInt();
					++ query;
					degree[R] = P;
					if (notFind.remove(R)) {
						++ count;
						sum += P;
					}
					last = R;
				}
				sum *= N;
				sum /= count;
				sum = sum * 9 / 10;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7192,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			HashMap<Integer, HashSet<Integer>> edge = new HashMap<>(K);
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				int last = R;
				long sum = 0;
				int count = 0;
				int query = 0;
				final int CHECK = 20;
				while(query + CHECK <= K) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						++ query;
						degree[R] = P;
						if (notFind.remove(R)) {
							++ count;
							sum += P;
						}
						final int l = last, r = R;
						edge.compute(last, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(r);
							return v;
						});
						edge.compute(R, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(l);
							return v;
						});
						last = R;
						if (degree[R] == edge.get(R).size()) break;
						if (degree[R] >= 50) break;
					}
					int next = 1;
					while(!notFind.contains(next)) next = rnd.nextInt(N) + 1;
					out.println(""T "" + next);
					R = fs.nextInt();
					P = fs.nextInt();
					++ query;
					degree[R] = P;
					if (notFind.remove(R)) {
						++ count;
						sum += P;
					}
					last = R;
				}
				sum *= N;
				sum /= count;
				sum = sum * 9 / 10;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7193,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			HashMap<Integer, HashSet<Integer>> edge = new HashMap<>(K);
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				int last = R;
				long sum = 0;
				int count = 0;
				int query = 0;
				final int CHECK = 20;
				while(query + CHECK <= K) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						++ query;
						degree[R] = P;
						if (notFind.remove(R)) {
							++ count;
							sum += P;
						}
						final int l = last, r = R;
						edge.compute(last, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(r);
							return v;
						});
						edge.compute(R, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(l);
							return v;
						});
						last = R;
						if (degree[R] == edge.get(R).size()) break;
						if (degree[R] >= 30) break;
					}
					int next = 1;
					while(!notFind.contains(next)) next = rnd.nextInt(N) + 1;
					out.println(""T "" + next);
					R = fs.nextInt();
					P = fs.nextInt();
					++ query;
					degree[R] = P;
					if (notFind.remove(R)) {
						++ count;
						sum += P;
					}
					last = R;
				}
				sum *= N;
				sum /= count;
				sum = sum * 9 / 10;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7194,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			HashMap<Integer, HashSet<Integer>> edge = new HashMap<>(K);
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				int last = R;
				long sum = 0;
				int count = 0;
				int query = 0;
				final int CHECK = 9;
				while(query + CHECK <= K) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						++ query;
						degree[R] = P;
						if (notFind.remove(R)) {
							++ count;
							sum += P;
						}
						final int l = last, r = R;
						edge.compute(last, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(r);
							return v;
						});
						edge.compute(R, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(l);
							return v;
						});
						last = R;
						if (degree[R] == edge.get(R).size()) break;
					}
					int next = 1;
					while(!notFind.contains(next)) next = rnd.nextInt(N) + 1;
					out.println(""T "" + next);
					R = fs.nextInt();
					P = fs.nextInt();
					++ query;
					degree[R] = P;
					if (notFind.remove(R)) {
						++ count;
						sum += P;
					}
					last = R;
				}
				sum *= N;
				sum /= count;
				sum = sum * 9 / 10;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7195,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			HashMap<Integer, HashSet<Integer>> edge = new HashMap<>(K);
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				int last = R;
				long sum = 0;
				int count = 0;
				int query = 0;
				final int CHECK = 8;
				while(query + CHECK <= K) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						++ query;
						degree[R] = P;
						if (notFind.remove(R)) {
							++ count;
							sum += P;
						}
						final int l = last, r = R;
						edge.compute(last, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(r);
							return v;
						});
						edge.compute(R, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(l);
							return v;
						});
						last = R;
						if (degree[R] == edge.get(R).size()) break;
					}
					int next = 1;
					while(!notFind.contains(next)) next = rnd.nextInt(N) + 1;
					out.println(""T "" + next);
					R = fs.nextInt();
					P = fs.nextInt();
					++ query;
					degree[R] = P;
					if (notFind.remove(R)) {
						++ count;
						sum += P;
					}
					last = R;
				}
				sum *= N;
				sum /= count;
				sum = sum * 9 / 10;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7196,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			HashMap<Integer, HashSet<Integer>> edge = new HashMap<>(K);
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				int last = R;
				long sum = 0;
				int count = 0;
				int query = 0;
				final int CHECK = 7;
				while(query + CHECK <= K) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						++ query;
						degree[R] = P;
						if (notFind.remove(R)) {
							++ count;
							sum += P;
						}
						final int l = last, r = R;
						edge.compute(last, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(r);
							return v;
						});
						edge.compute(R, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(l);
							return v;
						});
						last = R;
						if (degree[R] == edge.get(R).size()) break;
					}
					int next = 1;
					while(!notFind.contains(next)) next = rnd.nextInt(N) + 1;
					out.println(""T "" + next);
					R = fs.nextInt();
					P = fs.nextInt();
					++ query;
					degree[R] = P;
					if (notFind.remove(R)) {
						++ count;
						sum += P;
					}
					last = R;
				}
				sum *= N;
				sum /= count;
				sum = sum * 9 / 10;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7197,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			HashMap<Integer, HashSet<Integer>> edge = new HashMap<>(K);
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				int last = R;
				long sum = 0;
				int count = 0;
				int query = 0;
				final int CHECK = 6;
				while(query + CHECK <= K) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						++ query;
						degree[R] = P;
						if (notFind.remove(R)) {
							++ count;
							sum += P;
						}
						final int l = last, r = R;
						edge.compute(last, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(r);
							return v;
						});
						edge.compute(R, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(l);
							return v;
						});
						last = R;
						if (degree[R] == edge.get(R).size()) break;
					}
					int next = 1;
					while(!notFind.contains(next)) next = rnd.nextInt(N) + 1;
					out.println(""T "" + next);
					R = fs.nextInt();
					P = fs.nextInt();
					++ query;
					degree[R] = P;
					if (notFind.remove(R)) {
						++ count;
						sum += P;
					}
					last = R;
				}
				sum *= N;
				sum /= count;
				sum = sum * 9 / 10;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7198,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			HashMap<Integer, HashSet<Integer>> edge = new HashMap<>(K);
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				int last = R;
				long sum = 0;
				int count = 0;
				int query = 0;
				final int CHECK = 5;
				while(query + CHECK <= K) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						++ query;
						degree[R] = P;
						if (notFind.remove(R)) {
							++ count;
							sum += P;
						}
						final int l = last, r = R;
						edge.compute(last, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(r);
							return v;
						});
						edge.compute(R, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(l);
							return v;
						});
						last = R;
						if (degree[R] == edge.get(R).size()) break;
					}
					int next = 1;
					while(!notFind.contains(next)) next = rnd.nextInt(N) + 1;
					out.println(""T "" + next);
					R = fs.nextInt();
					P = fs.nextInt();
					++ query;
					degree[R] = P;
					if (notFind.remove(R)) {
						++ count;
						sum += P;
					}
					last = R;
				}
				sum *= N;
				sum /= count;
				sum = sum * 9 / 10;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7199,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			HashMap<Integer, HashSet<Integer>> edge = new HashMap<>(K);
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				int last = R;
				long sum = 0;
				int count = 0;
				int query = 0;
				final int CHECK = 4;
				while(query + CHECK <= K) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						++ query;
						degree[R] = P;
						if (notFind.remove(R)) {
							++ count;
							sum += P;
						}
						final int l = last, r = R;
						edge.compute(last, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(r);
							return v;
						});
						edge.compute(R, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(l);
							return v;
						});
						last = R;
						if (degree[R] == edge.get(R).size()) break;
					}
					int next = 1;
					while(!notFind.contains(next)) next = rnd.nextInt(N) + 1;
					out.println(""T "" + next);
					R = fs.nextInt();
					P = fs.nextInt();
					++ query;
					degree[R] = P;
					if (notFind.remove(R)) {
						++ count;
						sum += P;
					}
					last = R;
				}
				sum *= N;
				sum /= count;
				sum = sum * 9 / 10;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7200,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			HashMap<Integer, HashSet<Integer>> edge = new HashMap<>(K);
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				int last = R;
				long sum = 0;
				int count = 0;
				int query = 0;
				final int CHECK = 3;
				while(query + CHECK <= K) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						++ query;
						degree[R] = P;
						if (notFind.remove(R)) {
							++ count;
							sum += P;
						}
						final int l = last, r = R;
						edge.compute(last, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(r);
							return v;
						});
						edge.compute(R, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(l);
							return v;
						});
						last = R;
						if (degree[R] == edge.get(R).size()) break;
					}
					int next = 1;
					while(!notFind.contains(next)) next = rnd.nextInt(N) + 1;
					out.println(""T "" + next);
					R = fs.nextInt();
					P = fs.nextInt();
					++ query;
					degree[R] = P;
					if (notFind.remove(R)) {
						++ count;
						sum += P;
					}
					last = R;
				}
				sum *= N;
				sum /= count;
				sum = sum * 9 / 10;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7202,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			HashMap<Integer, HashSet<Integer>> edge = new HashMap<>(K);
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				int last = R;
				long sum = 0;
				int count = 0;
				int query = 0;
				final int CHECK = 20;
				int doubleCount = 0;
				while(query + CHECK <= K) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						++ query;
						degree[R] = P;
						if (notFind.remove(R)) {
							++ count;
							sum += P;
							++ doubleCount;
						}
						final int l = last, r = R;
						edge.compute(last, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(r);
							return v;
						});
						edge.compute(R, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(l);
							return v;
						});
						last = R;
						if (degree[R] == edge.get(R).size()) break;
					}
					int next = 1;
					while(!notFind.contains(next)) next = rnd.nextInt(N) + 1;
					out.println(""T "" + next);
					R = fs.nextInt();
					P = fs.nextInt();
					++ query;
					degree[R] = P;
					if (notFind.remove(R)) {
						++ count;
						sum += P;
					}
					last = R;
				}
				sum -= doubleCount;
				sum *= N;
				sum /= count;
				// sum = sum * 8 / 10;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7203,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			HashMap<Integer, HashSet<Integer>> edge = new HashMap<>(K);
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				int last = R;
				long sum = 0;
				int count = 0;
				int query = 0;
				final int CHECK = 10;
				while(query + CHECK <= K) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						++ query;
						degree[R] = P;
						if (notFind.remove(R)) {
							++ count;
							sum += P;
						}
						final int l = last, r = R;
						edge.compute(last, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(r);
							return v;
						});
						edge.compute(R, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(l);
							return v;
						});
						last = R;
						if (degree[R] == edge.get(R).size()) break;
					}
					int next = 1;
					while(!notFind.contains(next)) next = rnd.nextInt(N) + 1;
					out.println(""T "" + next);
					R = fs.nextInt();
					P = fs.nextInt();
					++ query;
					degree[R] = P;
					if (notFind.remove(R)) {
						++ count;
						sum += P;
					}
					last = R;
				}
				sum *= N;
				sum /= count;
				sum = sum * 8 / 10;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7205,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			HashMap<Integer, HashSet<Integer>> edge = new HashMap<>(K);
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				int last = R;
				long sum = 0;
				int count = 0;
				int query = 0;
				final int CHECK = 25;
				while(query + CHECK <= K) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						++ query;
						degree[R] = P;
						if (notFind.remove(R)) {
							++ count;
							sum += P;
						}
						final int l = last, r = R;
						edge.compute(last, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(r);
							return v;
						});
						edge.compute(R, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(l);
							return v;
						});
						last = R;
						if (degree[R] == edge.get(R).size()) break;
					}
					int next = 1;
					while(!notFind.contains(next)) next = rnd.nextInt(N) + 1;
					out.println(""T "" + next);
					R = fs.nextInt();
					P = fs.nextInt();
					++ query;
					degree[R] = P;
					if (notFind.remove(R)) {
						++ count;
						sum += P;
					}
					last = R;
				}
				sum *= N;
				sum /= count;
				sum = sum * 8 / 10;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7207,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			HashMap<Integer, HashSet<Integer>> edge = new HashMap<>(K);
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				int last = R;
				long sum = 0;
				int count = 0;
				int query = 0;
				final int CHECK = 20;
				while(query + CHECK <= K) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						++ query;
						degree[R] = P;
						if (notFind.remove(R)) {
							++ count;
							sum += P;
						}
						final int l = last, r = R;
						edge.compute(last, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(r);
							return v;
						});
						edge.compute(R, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(l);
							return v;
						});
						last = R;
						if (degree[R] == edge.get(R).size()) break;
					}
					int next = 1;
					while(!notFind.contains(next)) next = rnd.nextInt(N) + 1;
					out.println(""T "" + next);
					R = fs.nextInt();
					P = fs.nextInt();
					++ query;
					degree[R] = P;
					if (notFind.remove(R)) {
						++ count;
						sum += P;
					}
					last = R;
				}
				sum *= N;
				sum /= count;
				// sum = sum * 9 / 10;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7208,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			HashMap<Integer, HashSet<Integer>> edge = new HashMap<>(K);
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				int last = R;
				long sum = 0;
				int count = 0;
				int query = 0;
				final int CHECK = 15;
				while(query + CHECK <= K) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						++ query;
						degree[R] = P;
						if (notFind.remove(R)) {
							++ count;
							sum += P;
						}
						final int l = last, r = R;
						edge.compute(last, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(r);
							return v;
						});
						edge.compute(R, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(l);
							return v;
						});
						last = R;
						if (degree[R] == edge.get(R).size()) break;
					}
					int next = 1;
					while(!notFind.contains(next)) next = rnd.nextInt(N) + 1;
					out.println(""T "" + next);
					R = fs.nextInt();
					P = fs.nextInt();
					++ query;
					degree[R] = P;
					if (notFind.remove(R)) {
						++ count;
						sum += P;
					}
					last = R;
				}
				sum *= N;
				sum /= count;
				// sum = sum * 9 / 10;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7209,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			HashMap<Integer, HashSet<Integer>> edge = new HashMap<>(K);
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				int last = R;
				long sum = 0;
				int count = 0;
				int query = 0;
				final int CHECK = 15
				while(query + CHECK <= K) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						++ query;
						degree[R] = P;
						if (notFind.remove(R)) {
							++ count;
							sum += P;
						}
						final int l = last, r = R;
						edge.compute(last, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(r);
							return v;
						});
						edge.compute(R, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(l);
							return v;
						});
						last = R;
						if (degree[R] == edge.get(R).size()) break;
					}
					int next = 1;
					while(!notFind.contains(next)) next = rnd.nextInt(N) + 1;
					out.println(""T "" + next);
					R = fs.nextInt();
					P = fs.nextInt();
					++ query;
					degree[R] = P;
					if (notFind.remove(R)) {
						++ count;
						sum += P;
					}
					last = R;
				}
				sum *= N;
				sum /= count;
				// sum = sum * 9 / 10;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7211,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			HashMap<Integer, HashSet<Integer>> edge = new HashMap<>(K);
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				int last = R;
				long sum = 0;
				int count = 0;
				int query = 0;
				final int CHECK = 25;
				while(query + CHECK <= K) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						++ query;
						degree[R] = P;
						if (notFind.remove(R)) {
							++ count;
							sum += P;
						}
						final int l = last, r = R;
						edge.compute(last, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(r);
							return v;
						});
						edge.compute(R, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(l);
							return v;
						});
						last = R;
						if (degree[R] == edge.get(R).size()) break;
					}
					int next = 1;
					while(!notFind.contains(next)) next = rnd.nextInt(N) + 1;
					out.println(""T "" + next);
					R = fs.nextInt();
					P = fs.nextInt();
					++ query;
					degree[R] = P;
					if (notFind.remove(R)) {
						++ count;
						sum += P;
					}
					last = R;
				}
				sum *= N;
				sum /= count;
				// sum = sum * 9 / 10;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7212,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			HashMap<Integer, HashSet<Integer>> edge = new HashMap<>(K);
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				int last = R;
				long sum = 0;
				int count = 0;
				int query = 0;
				final int CHECK = 25;
				while(query + CHECK <= K) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						++ query;
						degree[R] = P;
						if (notFind.remove(R)) {
							++ count;
							sum += P;
						}
						final int l = last, r = R;
						edge.compute(last, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(r);
							return v;
						});
						edge.compute(R, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(l);
							return v;
						});
						last = R;
						if (degree[R] == edge.get(R).size()) break;
					}
					int next = 1;
					while(!notFind.contains(next)) next = rnd.nextInt(N) + 1;
					out.println(""T "" + next);
					R = fs.nextInt();
					P = fs.nextInt();
					++ query;
					degree[R] = P;
					if (notFind.remove(R)) {
						++ count;
						sum += P;
					}
					last = R;
				}
				sum *= N;
				sum /= count;
				sum = sum * 9 / 10;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7213,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			HashMap<Integer, HashSet<Integer>> edge = new HashMap<>(K);
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				int last = R;
				long sum = 0;
				int count = 0;
				int query = 0;
				final int CHECK = 20;
				while(query + CHECK <= K) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						++ query;
						degree[R] = P;
						if (notFind.remove(R)) {
							++ count;
							sum += P;
						}
						final int l = last, r = R;
						edge.compute(last, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(r);
							return v;
						});
						edge.compute(R, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(l);
							return v;
						});
						last = R;
						if (degree[R] == edge.get(R).size()) break;
					}
					int next = 1;
					while(!notFind.contains(next)) next = rnd.nextInt(N) + 1;
					out.println(""T "" + next);
					R = fs.nextInt();
					P = fs.nextInt();
					++ query;
					degree[R] = P;
					if (notFind.remove(R)) {
						++ count;
						sum += P;
					}
					last = R;
				}
				sum *= N;
				sum /= count;
				sum = sum * 9 / 10;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7214,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			HashMap<Integer, HashSet<Integer>> edge = new HashMap<>(K);
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				int last = R;
				long sum = 0;
				int count = 0;
				int query = 0;
				final int CHECK = 16;
				while(query + CHECK <= K) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						++ query;
						degree[R] = P;
						if (notFind.remove(R)) {
							++ count;
							sum += P;
						}
						final int l = last, r = R;
						edge.compute(last, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(r);
							return v;
						});
						edge.compute(R, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(l);
							return v;
						});
						last = R;
						if (degree[R] == edge.get(R).size()) break;
					}
					int next = 1;
					while(!notFind.contains(next)) next = rnd.nextInt(N) + 1;
					out.println(""T "" + next);
					R = fs.nextInt();
					P = fs.nextInt();
					++ query;
					degree[R] = P;
					if (notFind.remove(R)) {
						++ count;
						sum += P;
					}
					last = R;
				}
				sum *= N;
				sum /= count;
				sum = sum * 9 / 10;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7215,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			HashMap<Integer, HashSet<Integer>> edge = new HashMap<>(K);
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				int last = R;
				long sum = 0;
				int count = 0;
				final int CHECK = 16;
				while(count + CHECK <= K) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						degree[R] = P;
						if (notFind.remove(R)) {
							++ count;
							sum += P;
						}
						final int l = last, r = R;
						edge.compute(last, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(r);
							return v;
						});
						edge.compute(R, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(l);
							return v;
						});
						last = R;
						if (degree[R] == edge.get(R).size()) break;
					}
					int next = 1;
					while(!notFind.contains(next)) next = rnd.nextInt(N) + 1;
					out.println(""T "" + next);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
					if (notFind.remove(R)) {
						++ count;
						sum += P;
					}
					last = R;
				}
				sum *= N;
				sum /= count;
				sum = sum * 9 / 10;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7216,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				long sum = 0;
				int count = 0;
				final int CHECK = 16;
				for (int i = 0;i < K / CHECK;++ i) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						if (notFind.remove(R)) {
							++ count;
							sum += P;
						}
					}
					int next = 1;
					while(!notFind.contains(next)) next = rnd.nextInt(N) + 1;
					out.println(""T "" + next);
					R = fs.nextInt();
					P = fs.nextInt();
					if (notFind.remove(R)) {
						++ count;
						sum += P;
					}
				}
				sum *= N;
				sum /= count;
				sum = sum * 9 / 10;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7217,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				long sum = 0;
				final int CHECK = 20;
				for (int i = 0;i < K / CHECK;++ i) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						sum += P;
					}
					out.println(""T "" + (rnd.nextInt(N) + 1));
					R = fs.nextInt();
					P = fs.nextInt();
					sum += P;
				}
				sum *= N;
				sum /= K / CHECK * CHECK;
				sum = sum * 7 / 10;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7218,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				long sum = 0;
				final int CHECK = 20;
				for (int i = 0;i < K / CHECK;++ i) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						sum += P;
					}
					out.println(""T "" + (rnd.nextInt(N) + 1));
					R = fs.nextInt();
					P = fs.nextInt();
					sum += P;
				}
				sum *= N;
				sum /= K / CHECK * CHECK;
				sum = sum * 8 / 10;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7219,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				long sum = 0;
				final int CHECK = 20;
				for (int i = 0;i < K / CHECK;++ i) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						sum += P;
					}
					out.println(""T "" + (rnd.nextInt(N) + 1));
					R = fs.nextInt();
					P = fs.nextInt();
					sum += P;
				}
				sum *= N;
				sum /= K / CHECK * CHECK;
				sum = sum * 9 / 10;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7220,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			/*if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {*/
				long sum = 0;
				final int CHECK = 20;
				for (int i = 0;i < K / CHECK;++ i) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						sum += P;
					}
					out.println(""T "" + (rnd.nextInt(N) + 1));
					R = fs.nextInt();
					P = fs.nextInt();
					sum += P;
				}
				sum *= N;
				sum /= K / CHECK * CHECK;
				out.println(""E "" + sum / 2);
			//}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7221,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				long sum = 0;
				final int CHECK = 19;
				for (int i = 0;i < K / CHECK;++ i) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						sum += P;
					}
					out.println(""T "" + (rnd.nextInt(N) + 1));
					R = fs.nextInt();
					P = fs.nextInt();
					sum += P;
				}
				sum *= N;
				sum /= K / CHECK * CHECK;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7222,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				long sum = 0;
				final int CHECK = 18;
				for (int i = 0;i < K / CHECK;++ i) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						sum += P;
					}
					out.println(""T "" + (rnd.nextInt(N) + 1));
					R = fs.nextInt();
					P = fs.nextInt();
					sum += P;
				}
				sum *= N;
				sum /= K / CHECK * CHECK;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7223,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				long sum = 0;
				final int CHECK = 17;
				for (int i = 0;i < K / CHECK;++ i) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						sum += P;
					}
					out.println(""T "" + (rnd.nextInt(N) + 1));
					R = fs.nextInt();
					P = fs.nextInt();
					sum += P;
				}
				sum *= N;
				sum /= K / CHECK * CHECK;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7224,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				long sum = 0;
				final int CHECK = 16;
				for (int i = 0;i < K / CHECK;++ i) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						sum += P;
					}
					out.println(""T "" + (rnd.nextInt(N) + 1));
					R = fs.nextInt();
					P = fs.nextInt();
					sum += P;
				}
				sum *= N;
				sum /= K / CHECK * CHECK;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7225,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				long sum = 0;
				final int CHECK = 15;
				for (int i = 0;i < K / CHECK;++ i) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						sum += P;
					}
					out.println(""T "" + (rnd.nextInt(N) + 1));
					R = fs.nextInt();
					P = fs.nextInt();
					sum += P;
				}
				sum *= N;
				sum /= K / CHECK * CHECK;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7226,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				long sum = 0;
				final int CHECK = 14;
				for (int i = 0;i < K / CHECK;++ i) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						sum += P;
					}
					out.println(""T "" + (rnd.nextInt(N) + 1));
					R = fs.nextInt();
					P = fs.nextInt();
					sum += P;
				}
				sum *= N;
				sum /= K / CHECK * CHECK;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7227,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				long sum = 0;
				final int CHECK = 13;
				for (int i = 0;i < K / CHECK;++ i) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						sum += P;
					}
					out.println(""T "" + (rnd.nextInt(N) + 1));
					R = fs.nextInt();
					P = fs.nextInt();
					sum += P;
				}
				sum *= N;
				sum /= K / CHECK * CHECK;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7228,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				long sum = 0;
				final int CHECK = 12;
				for (int i = 0;i < K / CHECK;++ i) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						sum += P;
					}
					out.println(""T "" + (rnd.nextInt(N) + 1));
					R = fs.nextInt();
					P = fs.nextInt();
					sum += P;
				}
				sum *= N;
				sum /= K / CHECK * CHECK;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7229,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				long sum = 0;
				final int CHECK = 11;
				for (int i = 0;i < K / CHECK;++ i) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						sum += P;
					}
					out.println(""T "" + (rnd.nextInt(N) + 1));
					R = fs.nextInt();
					P = fs.nextInt();
					sum += P;
				}
				sum *= N;
				sum /= K / CHECK * CHECK;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7230,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				long sum = 0;
				final int CHECK = 10;
				for (int i = 0;i < K / CHECK;++ i) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						sum += P;
					}
					out.println(""T "" + (rnd.nextInt(N) + 1));
					R = fs.nextInt();
					P = fs.nextInt();
					sum += P;
				}
				sum *= N;
				sum /= K / CHECK * CHECK;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7232,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			HashMap<Integer, HashSet<Integer>> edge = new HashMap<>(K);
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				int last = R;
				long sum = 0;
				int count = 0;
				int query = 0;
				final int CHECK = 12;
				while(query + CHECK <= K) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						++ query;
						degree[R] = P;
						if (notFind.remove(R)) {
							++ count;
							sum += P;
						}
						final int l = last, r = R;
						edge.compute(last, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(r);
							return v;
						});
						edge.compute(R, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(l);
							return v;
						});
						last = R;
						if (degree[R] == edge.get(R).size()) break;
					}
					int next = 1;
					while(!notFind.contains(next)) next = rnd.nextInt(N) + 1;
					out.println(""T "" + next);
					R = fs.nextInt();
					P = fs.nextInt();
					++ query;
					degree[R] = P;
					if (notFind.remove(R)) {
						++ count;
						sum += P;
					}
					last = R;
				}
				sum *= N;
				sum /= count;
				sum = sum * 11 / 10;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7233,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				long sum = 0;
				final int CHECK = 30;
				for (int i = 0;i < K / CHECK;++ i) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						sum += P;
					}
					out.println(""T "" + (rnd.nextInt(N) + 1));
					R = fs.nextInt();
					P = fs.nextInt();
					sum += P;
				}
				sum *= N;
				sum /= K / CHECK * CHECK;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7235,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				long sum = 0;
				final int CHECK = 16;
				for (int i = 0;i < K / CHECK;++ i) {
					for (int j = 0;j < CHECK;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						sum += P;
					}
					out.println(""T "" + (rnd.nextInt(N) + 1));
					R = fs.nextInt();
					P = fs.nextInt();
					sum += P;
				}
				sum *= N;
				sum /= K / CHECK * CHECK;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7236,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				long sum = 0;
				final int CHECK = 30;
				for (int i = 0;i < K / CHECK;++ i) {
					for (int j = 0;j < CHECK;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						sum += P;
					}
					out.println(""T "" + (rnd.nextInt(N) + 1));
					R = fs.nextInt();
					P = fs.nextInt();
					sum += P;
				}
				sum *= N;
				sum /= K / CHECK * CHECK;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7237,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				long sum = 0;
				for (int i = 0;i < K / 20;++ i) {
					for (int j = 0;j < 19;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						sum += P;
					}
					out.println(""T "" + (rnd.nextInt(N) + 1));
					R = fs.nextInt();
					P = fs.nextInt();
					sum += P;
				}
				sum *= N;
				sum /= K;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7238,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashMap<Integer, HashSet<Integer>> edge = new HashMap<>(K);
			HashSet<Integer> notFind = new HashSet<>();
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (N <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				long sum = 0;
				for (int i = 0;i < 400;++ i) {
					for (int j = 0;j < 19;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						sum += P;
					}
					out.println(""T "" + (rnd.nextInt(N) + 1));
					P = fs.nextInt();
					sum += P;
				}
				sum *= N;
				sum /= K;
				sum = Math.max(sum, (N - 1) * 4 / 3);
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7239,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt();
			int[] F = IntStream.range(0, N + 1).map(i -> i == 0 ? 0 : fs.nextInt()).toArray();
			ArrayList<ArrayList<Integer>> graph = new ArrayList<>(N + 1);
			for (int i = 0;i <= N;++ i) graph.add(new ArrayList<>());
			for (int i = 1;i <= N;++ i) {
				int P = fs.nextInt();
				graph.get(P).add(i);
			}
			out.println(cases(t) + dp(0, graph, F)[0]);
		}
	}

	long[] dp(int from, ArrayList<ArrayList<Integer>> graph, int[] F) {
		long[] ans = {0, Integer.MAX_VALUE};
		for (int to : graph.get(from)) {
			long[] dp = dp(to, graph, F);
			ans[0] += dp[0];
			ans[1] = Math.min(ans[1], dp[1]);
		}
		if (graph.get(from).isEmpty()) ans[1] = 0;
		ans[0] += Math.max(0, F[from] - ans[1]);
		ans[1] = Math.max(ans[1], F[from]);
//		System.out.println(from + "":"" + ans[0] + "","" + ans[1]);
		return ans;
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7240,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt();
			int[] F = IntStream.range(0, N + 1).map(i -> i == 0 ? 0 : fs.nextInt()).toArray();
			ArrayList<ArrayList<Integer>> graph = new ArrayList<>(N + 1);
			for (int i = 0;i <= N;++ i) graph.add(new ArrayList<>());
			for (int i = 1;i <= N;++ i) {
				int P = fs.nextInt();
				graph.get(P).add(i);
			}
			out.println(cases(t) + dp(0, graph, F));
		}
	}

	long dp(int from, ArrayList<ArrayList<Integer>> graph, int[] F) {
		long ans = graph.get(from).isEmpty() ? F[from] : 0, max = 0;
		for (int to : graph.get(from)) {
			long dp = dp(to, graph, F);
			ans += dp;
			max = Math.max(max, F[from] - dp);
		}
		return ans + max;
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7241,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt();
			int[] S = IntStream.range(0, N).map(i -> fs.nextInt()).toArray();
			Arrays.sort(S);
			int line = 0;
			for (int i : S) {
				if (i >= line + 1) ++ line;
			}
			out.println(cases(t) + line);
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7242,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		for (int t = 1;t <= T;++ t) {
			out.print(cases(t));
			int[] color = IntStream.range(0, 4).map(i -> Integer.MAX_VALUE).toArray();
			for (int i = 0;i < 12;++ i) color[i % 4] = Math.min(color[i % 4], fs.nextInt());
			int sum = Arrays.stream(color).sum();
			if (sum < 1000000) {
				out.println(""IMPOSSIBLE"");
			} else {
				for (int i = 0;i < 4;++ i) {
					int diff = Math.max(0, Math.min(sum - 1000000, color[i]));
					color[i] -= diff;
					sum -= diff;
					if (i != 0) out.print(' ');
					out.print(color[i]);
				}
				out.println();
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7243,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			HashMap<Integer, HashSet<Integer>> edge = new HashMap<>(K);
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				int last = R;
				long sum = 0;
				int count = 0;
				int query = 0;
				final int CHECK = 8;
				while(query + CHECK <= K) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						++ query;
						degree[R] = P;
						if (notFind.remove(R)) {
							++ count;
							sum += P;
						}
						final int l = last, r = R;
						edge.compute(last, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(r);
							return v;
						});
						edge.compute(R, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(l);
							return v;
						});
						last = R;
						if (degree[R] == edge.get(R).size()) break;
					}
					int next = 1;
					while(!notFind.contains(next)) next = rnd.nextInt(N) + 1;
					out.println(""T "" + next);
					R = fs.nextInt();
					P = fs.nextInt();
					++ query;
					degree[R] = P;
					if (notFind.remove(R)) {
						++ count;
						sum += P;
					}
					last = R;
				}
				sum *= N;
				sum /= count;
				sum = sum * 11 / 10;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7244,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		for (int t = 1;t <= T;++ t) {
			out.println(cases(t));
			int R = fs.nextInt(), C = fs.nextInt();
			char[][] patturn = {{'+', '-'}, {'|', '.'}};
			for (int r = 0;r <= 2 * R;++ r) {
				for (int c = 0;c <= 2 * C;++ c) {
					if (r <= 1 && c <= 1) out.print('.');
					else out.print(patturn[r & 1][c & 1]);
				}
				out.println();
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
7245,"public class Solution {

	public static void main(String[] args) {
		new Solution();
	}

	public Solution() {
		FastScanner fs = new FastScanner();
		java.io.PrintWriter out = new java.io.PrintWriter(System.out, true);
		solve(fs, out);
		out.flush();
	}

	public void solve(FastScanner fs, java.io.PrintWriter out) {
		int T = fs.nextInt();
		Random rnd = new Random();
		for (int t = 1;t <= T;++ t) {
			int N = fs.nextInt(), K = fs.nextInt();
			int[] degree = new int[N + 1];
			HashSet<Integer> notFind = new HashSet<>();
			HashMap<Integer, HashSet<Integer>> edge = new HashMap<>(K);
			for (int i = 1;i <= N;++ i) notFind.add(i);
			int R = fs.nextInt(), P = fs.nextInt();
			degree[R] = P;
			notFind.remove(R);
			if (notFind.size() <= K) {
				for (int i : notFind) {
					out.println(""T "" + i);
					R = fs.nextInt();
					P = fs.nextInt();
					degree[R] = P;
				}
				out.println(""E "" + Arrays.stream(degree).mapToLong(i -> i).sum() / 2);
			} else {
				int last = R;
				long sum = 0;
				int count = 0;
				int query = 0;
				final int CHECK = 5;
				while(query + CHECK <= K) {
					for (int j = 0;j < CHECK - 1;++ j) {
						out.println('W');
						R = fs.nextInt();
						P = fs.nextInt();
						++ query;
						degree[R] = P;
						if (notFind.remove(R)) {
							++ count;
							sum += P;
						}
						final int l = last, r = R;
						edge.compute(last, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(r);
							return v;
						});
						edge.compute(R, (k, v) -> {
							if (v == null) v = new HashSet<>();
							v.add(l);
							return v;
						});
						last = R;
						if (degree[R] == edge.get(R).size()) break;
					}
					int next = 1;
					while(!notFind.contains(next)) next = rnd.nextInt(N) + 1;
					out.println(""T "" + next);
					R = fs.nextInt();
					P = fs.nextInt();
					++ query;
					degree[R] = P;
					if (notFind.remove(R)) {
						++ count;
						sum += P;
					}
					last = R;
				}
				sum *= N;
				sum /= count;
				sum = sum * 11 / 10;
				out.println(""E "" + sum / 2);
			}
		}
	}

	private String cases(int t) {
		return ""Case #"" + t + "": "";
	}
}

class FastScanner {

	private final java.io.InputStream in = System.in;
	private final byte[] buffer = new byte[8192];
	private int ptr = 0;
	private int buflen = 0;

	private boolean hasNextByte() {
		if (ptr < buflen) return true;
		ptr = 0;
		try {
			buflen = in.read(buffer);
		} catch (java.io.IOException e) {
			e.printStackTrace();
		}
		return buflen > 0;
	}

	private byte readByte() {
		return hasNextByte() ? buffer[ptr++ ] : -1;
	}

	private static boolean isPrintableChar(byte c) {
		return 32 < c || c < 0;
	}

	private static boolean isNumber(int c) {
		return '0' <= c && c <= '9';
	}

	public boolean hasNext() {
		while (hasNextByte() && !isPrintableChar(buffer[ptr]))
			ptr++ ;
		return hasNextByte();
	}

	public String next() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		StringBuilder sb = new StringBuilder();
		byte b;
		while (isPrintableChar(b = readByte()))
			sb.appendCodePoint(b);
		return sb.toString();
	}

	public final char nextChar() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		return (char)readByte();
	}

	public final long nextLong() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		long n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public final int nextInt() {
		if (!hasNext()) throw new java.util.NoSuchElementException();
		int n = 0;
		try {
			byte b = readByte();
			if (b == '-') {
				while (isNumber(b = readByte()))
					n = n * 10 + '0' - b;
				return n;
			} else if (!isNumber(b)) throw new NumberFormatException();
			do
				n = n * 10 + b - '0';
			while (isNumber(b = readByte()));
		} catch (java.util.NoSuchElementException e) {}
		return n;
	}

	public double nextDouble() {
		return Double.",31536000
8179,"public class Solution {
    public static void main(String[] args) {
        Scanner sc= new Scanner(System.in);
        var numberOfTestCases = sc.nextInt();
        for (int i = 0; i < numberOfTestCases; i++) {
            int r = sc.nextInt();
            int c = sc.nextInt();
            var actualRow = r + (r+1);
            System.out.println(""Case #""+(i+1)+"":"");
            var actualCol = c + (c+1);
            for (int i1 = 0; i1 < r; i1++) {

                for (int i2 = 0; i2 < actualCol; i2++) {
                    if(i1==0 && i2<=1) System.out.printf(""."");
                    else {
                        if(i2%2==0) System.out.printf(""+"");
                        else System.out.printf(""-"");
                    }
                }
                System.out.println();

                for (int i2 = 0; i2 < actualCol; i2++) {
                    if(i1==0 && i2<=1) System.out.printf(""."");
                    else {
                        if(i2%2==0) System.out.printf(""|"");
                        else System.out.printf(""."");
                    }
                }
                System.out.println();
            }
            for (int i2 = 0; i2 < actualCol; i2++) {
                if(i2%2==0) System.out.printf(""+"");
                else System.out.printf(""-"");
            }
            System.out.println();
        }
        sc.",DEB
8180,"public class Solution {
    public static void main(String[] args) {
        Scanner sc= new Scanner(System.in);
        var numberOfTestCases = sc.nextInt();
        int[] diceLookup = new int[1000000+2];
        for (int i = 0; i < numberOfTestCases; i++) {
            int numberOfDice = sc.nextInt();
            var min=Integer.MAX_VALUE;
            var max=Integer.MIN_VALUE;
                        long result =0;

            Arrays.fill(diceLookup,0);
            
            for (int i1 = 0; i1 < numberOfDice; i1++) {
                int currentNumber = sc.nextInt();
                diceLookup[currentNumber]++;
                min = Math.min(min, currentNumber);
                max = Math.max(max, currentNumber);
            
            }
            
        
            for (int j = min; j <=max ; j++) {
                result+=Math.min(diceLookup[j],j-result);
            }
        
            System.out.println(""Case #""+(i+1)+"": ""+result);
        }
        sc.",DEB
8181,"public class Solution {
    public static void main(String[] args) {
        Scanner sc= new Scanner(System.in);
        var numberOfTestCases = sc.nextInt();
        int[] diceLookup = new int[1000000+2];
        for (int i = 0; i < numberOfTestCases; i++) {
            int numberOfDice = sc.nextInt();
            var min=Integer.MAX_VALUE;
            var max=Integer.MIN_VALUE;
                        long result =0;

            Arrays.fill(diceLookup,0);
            
            for (int i1 = 0; i1 < numberOfDice; i1++) {
                int currentNumber = sc.nextInt();
                diceLookup[currentNumber]++;
                min = Math.min(min, currentNumber);
                max = Math.max(max, currentNumber);
            
            }
            
            if(numberOfDice<=10) {
    
                for (int j = min; j <=max ; j++) {
                    result+=Math.min(diceLookup[j],j-result);
                }
            }
            System.out.println(""Case #""+(i+1)+"": ""+result);
        }
        sc.",DEB
8182,"public class Solution {
    public static void main(String[] args) {
        Scanner sc= new Scanner(System.in);
        var numberOfTestCases = sc.nextInt();
        int[] diceLookup = new int[1000000+2];
        for (int i = 0; i < numberOfTestCases; i++) {
            int numberOfDice = sc.nextInt();
            var min=Integer.MAX_VALUE;
            var max=Integer.MIN_VALUE;
                        long result =0;

            Arrays.fill(diceLookup,0);
            
            for (int i1 = 0; i1 < numberOfDice; i1++) {
                int currentNumber = sc.nextInt();
                if(numberOfDice<=10) {
                    diceLookup[currentNumber]++;
                    min = Math.min(min, currentNumber);
                    max = Math.max(max, currentNumber);
                }
            }
            
            if(numberOfDice<=10) {
    
                for (int j = min; j <=max ; j++) {
                    result+=Math.min(diceLookup[j],j-result);
                }
            }
            System.out.println(""Case #""+(i+1)+"": ""+result);
        }
        sc.",DEB
8183,"public class Solution {
    public static void main(String[] args) {
        Scanner sc= new Scanner(System.in);
        var numberOfTestCases = sc.nextInt();
        int[] diceLookup = new int[1000000+2];
        for (int i = 0; i < numberOfTestCases; i++) {
            int numberOfDice = sc.nextInt();
            var min=Integer.MAX_VALUE;
            var max=Integer.MIN_VALUE;
                        long result =0;

            if(numberOfDice<=10) {
                Arrays.fill(diceLookup,0);
            }
            for (int i1 = 0; i1 < numberOfDice; i1++) {
                int currentNumber = sc.nextInt();
                if(numberOfDice<=10) {
                    diceLookup[currentNumber]++;
                    min = Math.min(min, currentNumber);
                    max = Math.max(max, currentNumber);
                }
            }
            
            if(numberOfDice<=10) {
    
                for (int j = min; j <=max ; j++) {
                    result+=Math.min(diceLookup[j],j-result);
                }
            }
            System.out.println(""Case #""+(i+1)+"": ""+result);
        }
        sc.",DEB
8184,"public class Solution {
    public static void main(String[] args) {
        Scanner sc= new Scanner(System.in);
        var numberOfTestCases = sc.nextInt();
        int[] diceLookup = new int[100000+2];
        for (int i = 0; i < numberOfTestCases; i++) {
            int numberOfDice = sc.nextInt();
            var min=Integer.MAX_VALUE;
            var max=Integer.MIN_VALUE;
                        long result =0;

            if(numberOfDice<=10) {
                Arrays.fill(diceLookup,0);
            }
            for (int i1 = 0; i1 < numberOfDice; i1++) {
                int currentNumber = sc.nextInt();
                if(numberOfDice<=10) {
                    diceLookup[currentNumber]++;
                    min = Math.min(min, currentNumber);
                    max = Math.max(max, currentNumber);
                }
            }
            
            if(numberOfDice<=10) {
    
                for (int j = min; j <=max ; j++) {
                    result+=Math.min(diceLookup[j],j-result);
                }
            }
            System.out.println(""Case #""+(i+1)+"": ""+result);
        }
        sc.",DEB
8185,"public class Solution {
    public static void main(String[] args) {
        Scanner sc= new Scanner(System.in);
        var numberOfTestCases = sc.nextInt();
        int[] diceLookup = new int[100000+2];
        for (int i = 0; i < numberOfTestCases; i++) {
            int numberOfDice = sc.nextInt();
            var min=Integer.MAX_VALUE;
            var max=Integer.MIN_VALUE;
                        int result =0;

            if(numberOfDice<=10) {
                Arrays.fill(diceLookup,0);
            }
            for (int i1 = 0; i1 < numberOfDice; i1++) {
                int currentNumber = sc.nextInt();
                if(numberOfDice<=10) {
                    diceLookup[currentNumber]++;
                    min = Math.min(min, currentNumber);
                    max = Math.max(max, currentNumber);
                }
            }
            
            if(numberOfDice<=10) {
    
                for (int j = min; j <=max ; j++) {
                    result+=Math.min(diceLookup[j],j-result);
                }
            }
            System.out.println(""Case #""+(i+1)+"": ""+result);
        }
        sc.",DEB
8186,"public class Solution {
    public static void main(String[] args) {
        Scanner sc= new Scanner(System.in);
        var numberOfTestCases = sc.nextInt();
        int[] diceLookup = new int[100000+2];
        for (int i = 0; i < numberOfTestCases; i++) {
            int numberOfDice = sc.nextInt();
            var min=Integer.MAX_VALUE;
            var max=Integer.MIN_VALUE;
                        int result =0;

            if(numberOfDice<=10) {
                Arrays.fill(diceLookup,0);
            }
            for (int i1 = 0; i1 < numberOfDice; i1++) {
                if(numberOfDice<=10) {
                    int currentNumber = sc.nextInt();
                    diceLookup[currentNumber]++;
                    min = Math.min(min, currentNumber);
                    max = Math.max(max, currentNumber);
                }else{
                    sc.nextLine();
                }
            }
            
            if(numberOfDice<=10) {
    
                for (int j = min; j <=max ; j++) {
                    result+=Math.min(diceLookup[j],j-result);
                }
            }
            System.out.println(""Case #""+(i+1)+"": ""+result);
        }
        sc.",DEB
8187,"public class Solution {
    public static void main(String[] args) {
        Scanner sc= new Scanner(System.in);
        var numberOfTestCases = sc.nextInt();
        int[] diceLookup = new int[100000+2];
        for (int i = 0; i < numberOfTestCases; i++) {
            int numberOfDice = sc.nextInt();
            var min=Integer.MAX_VALUE;
            var max=Integer.MIN_VALUE;
                        int result =0;

            if(numberOfDice<=10) {
                Arrays.fill(diceLookup,0);
            }
            for (int i1 = 0; i1 < numberOfDice; i1++) {
                if(numberOfDice<=10) {
                    int currentNumber = sc.nextInt();
                    diceLookup[currentNumber]++;
                    min = Math.min(min, currentNumber);
                    max = Math.max(max, currentNumber);
                }else{
                    sc.nextLong();
                }
            }
            
            if(numberOfDice<=10) {
    
                for (int j = min; j <=max ; j++) {
                    result+=Math.min(diceLookup[j],j-result);
                }
            }
            System.out.println(""Case #""+(i+1)+"": ""+result);
        }
        sc.",DEB
8188,"public class Solution {
    public static void main(String[] args) {
        Scanner sc= new Scanner(System.in);
        var numberOfTestCases = sc.nextInt();
        int[] diceLookup = new int[100000+2];
        for (int i = 0; i < numberOfTestCases; i++) {
            int numberOfDice = sc.nextInt();
            var min=Integer.MAX_VALUE;
            var max=Integer.MIN_VALUE;
                        int result =0;

            if(numberOfDice<=10) {
                Arrays.fill(diceLookup,0);
            }
            for (int i1 = 0; i1 < numberOfDice; i1++) {
                if(numberOfDice<=10) {
                    int currentNumber = sc.nextInt();
                    diceLookup[currentNumber]++;
                    min = Math.min(min, currentNumber);
                    max = Math.max(max, currentNumber);
                }
            }
            
            if(numberOfDice<=10) {
    
                for (int j = min; j <=max ; j++) {
                    result+=Math.min(diceLookup[j],j-result);
                }
            }
            System.out.println(""Case #""+(i+1)+"": ""+result);
        }
        sc.",DEB
8190,"public class Solution {
    public static void main(String[] args) {
        Scanner sc= new Scanner(System.in);
        var numberOfTestCases = sc.nextInt();
        int[] diceLookup = new int[100000+2];
        for (int i = 0; i < numberOfTestCases; i++) {
            int numberOfDice = sc.nextInt();
            var min=Integer.MAX_VALUE;
            var max=Integer.MIN_VALUE;
                        int result =0;

            if(numberOfDice<=10) {
                Arrays.fill(diceLookup,0);
            }
            for (int i1 = 0; i1 < numberOfDice; i1++) {
                int currentNumber = sc.nextInt();
                diceLookup[currentNumber]++;
                min = Math.min(min, currentNumber);
                max = Math.max(max, currentNumber);
            }
            
            if(numberOfDice<=10) {
    
                for (int j = min; j <=max ; j++) {
                    result+=Math.min(diceLookup[j],j-result);
                }
            }
            System.out.println(""Case #""+(i+1)+"": ""+result);
        }
        sc.",DEB
8191,"public class Solution {
    public static void main(String[] args) {
        Scanner sc= new Scanner(System.in);
        var numberOfTestCases = sc.nextInt();
        int[] diceLookup = new int[100000+2];
        for (int i = 0; i < numberOfTestCases; i++) {
            int numberOfDice = sc.nextInt();
            var min=Integer.MAX_VALUE;
            var max=Integer.MIN_VALUE;
                        int result =0;

            if(numberOfDice<=10) {
                Arrays.fill(diceLookup,0);
            
                for (int i1 = 0; i1 < numberOfDice; i1++) {
                    int currentNumber = sc.nextInt();
                    diceLookup[currentNumber]++;
                    min = Math.min(min, currentNumber);
                    max = Math.max(max, currentNumber);
                }
                for (int j = min; j <=max ; j++) {
                    result+=Math.min(diceLookup[j],j-result);
                }
            }
            System.out.println(""Case #""+(i+1)+"": ""+result);
        }
        sc.",DEB
8192,"public class Solution {
    public static void main(String[] args) {
        Scanner sc= new Scanner(System.in);
        var numberOfTestCases = sc.nextInt();
        int[] diceLookup = new int[100000+2];
        for (int i = 0; i < numberOfTestCases; i++) {
            int numberOfDice = sc.nextInt();
            var min=Integer.MAX_VALUE;
            var max=Integer.MIN_VALUE;
            if(numberOfDice<=10) {
                Arrays.fill(diceLookup,0);
            }
            for (int i1 = 0; i1 < numberOfDice; i1++) {
                int currentNumber = sc.nextInt();
                diceLookup[currentNumber]++;
                min = Math.min(min, currentNumber);
                max = Math.max(max, currentNumber);
            }
            int result =0;
            for (int j = min; j <=max ; j++) {
                result+=Math.min(diceLookup[j],j-result);
            }
            System.out.println(""Case #""+(i+1)+"": ""+result);
        }
        sc.",DEB
8193,"public class Solution {
    public static void main(String[] args) {
        Scanner sc= new Scanner(System.in);
        var numberOfTestCases = sc.nextInt();
        int[] diceLookup = new int[1];
        for (int i = 0; i < numberOfTestCases; i++) {
            int numberOfDice = sc.nextInt();
            var min=Integer.MAX_VALUE;
            var max=Integer.MIN_VALUE;
            if(numberOfDice<=10) {
                Arrays.fill(diceLookup,0);
            }
            for (int i1 = 0; i1 < numberOfDice; i1++) {
                int currentNumber = sc.nextInt();
                diceLookup[0]++;
                min = Math.min(min, currentNumber);
                max = Math.max(max, currentNumber);
            }
            int result =0;
            for (int j = min; j <=max ; j++) {
                result+=Math.min(diceLookup[0],j-result);
            }
            System.out.println(""Case #""+(i+1)+"": ""+result);
        }
        sc.",DEB
8194,"public class Solution {
    public static void main(String[] args) {
        Scanner sc= new Scanner(System.in);
        var numberOfTestCases = sc.nextInt();
        int[] diceLookup = new int[100000];
        for (int i = 0; i < numberOfTestCases; i++) {
            int numberOfDice = sc.nextInt();
            var min=Integer.MAX_VALUE;
            var max=Integer.MIN_VALUE;
            if(numberOfDice<=10) {
                Arrays.fill(diceLookup,0);
            }
            for (int i1 = 0; i1 < numberOfDice; i1++) {
                int currentNumber = sc.nextInt();
                diceLookup[currentNumber]++;
                min = Math.min(min, currentNumber);
                max = Math.max(max, currentNumber);
            }
            int result =0;
            for (int j = min; j <=max ; j++) {
                result+=Math.min(diceLookup[j],j-result);
            }
            System.out.println(""Case #""+(i+1)+"": ""+result);
        }
        sc.",DEB
8195,"public class Solution {
    public static void main(String[] args) {
        Scanner sc= new Scanner(System.in);
        var numberOfTestCases = sc.nextInt();
        int[] diceLookup = new int[100000];
        for (int i = 0; i < numberOfTestCases; i++) {
            int numberOfDice = sc.nextInt();
            var min=Integer.MAX_VALUE;
            var max=Integer.MIN_VALUE;
            Arrays.fill(diceLookup,0);
            for (int i1 = 0; i1 < numberOfDice; i1++) {
                int currentNumber = sc.nextInt();
                diceLookup[currentNumber]++;
                min = Math.min(min, currentNumber);
                max = Math.max(max, currentNumber);
            }
            int result =0;
            for (int j = min; j <=max ; j++) {
                result+=Math.min(diceLookup[j],j-result);
            }
            System.out.println(""Case #""+(i+1)+"": ""+result);
        }
        sc.",DEB
8196,"public class Solution {
    public static void main(String[] args) {
        Scanner sc= new Scanner(System.in);
        var numberOfTestCases = sc.nextInt();
        for (int i = 0; i < numberOfTestCases; i++) {
            int numberOfDice = sc.nextInt();
            int[] diceLookup = new int[100000];
            var min=Integer.MAX_VALUE;
            var max=Integer.MIN_VALUE;
            for (int i1 = 0; i1 < numberOfDice; i1++) {
                int currentNumber = sc.nextInt();
                diceLookup[currentNumber]++;
                min = Math.min(min, currentNumber);
                max = Math.max(max, currentNumber);
            }
            int result =0;
            for (int j = min; j <=max ; j++) {
                result+=Math.min(diceLookup[j],j-result);
            }
            System.out.println(""Case #""+(i+1)+"": ""+result);
        }
        sc.",DEB
8197,"public class Solution {

    public static void main(String[] args) {
//        System.out.println(""Enter"");
        Scanner sc = new Scanner(System.in);
        var numberOfTestCases = sc.nextInt();
        for (int i = 0; i < numberOfTestCases; i++) {
            var numberOfRooms = sc.nextInt();
            var numberOfChances = sc.nextInt();
            // var roomGraph = new boolean[numberOfRooms + 1][numberOfRooms + 1];
            var minNumberOfPassages = 0;
            Integer nextUnvisitedRoom = 1;
            var justWalk = false;
            var isLastOpWalking = false;
            for (int i1 = 0; i1 < numberOfChances; i1++) {
                var currentRoom = sc.nextInt();
                var currentRoomPassages = sc.nextInt();
             
            }
            System.out.println(""E "" + minNumberOfPassages);
        }
        sc.",DEB
8198,"public class Solution {

    public static void main(String[] args) {
//        System.out.println(""Enter"");
        Scanner sc = new Scanner(System.in);
        var numberOfTestCases = sc.nextInt();
        for (int i = 0; i < numberOfTestCases; i++) {
            var numberOfRooms = sc.nextInt();
            var numberOfChances = sc.nextInt();
            var roomGraph = new boolean[numberOfRooms + 1][numberOfRooms + 1];
            var minNumberOfPassages = 0;
            Integer nextUnvisitedRoom = 1;
            var justWalk = false;
            var isLastOpWalking = false;
            for (int i1 = 0; i1 < numberOfChances; i1++) {
                var currentRoom = sc.nextInt();
                var currentRoomPassages = sc.nextInt();
             
            }
            System.out.println(""E "" + minNumberOfPassages);
        }
        sc.",DEB
8199,"public class Solution {

    public static void main(String[] args) {
//        System.out.println(""Enter"");
        Scanner sc = new Scanner(System.in);
        var numberOfTestCases = sc.nextInt();
        for (int i = 0; i < numberOfTestCases; i++) {
            var numberOfRooms = sc.nextInt();
            var numberOfChances = sc.nextInt();
            var roomGraph = new boolean[numberOfRooms + 1][numberOfRooms + 1];
            var minNumberOfPassages = 0;
            Integer nextUnvisitedRoom = 1;
            var justWalk = false;
            var isLastOpWalking = false;
            for (int i1 = 0; i1 < numberOfChances; i1++) {
                var currentRoom = sc.nextInt();
                var currentRoomPassages = sc.nextInt();
                if (roomGraph[currentRoom][0]) {// visited, so
                    minNumberOfPassages -= 1;
                    if (justWalk) {
                        System.out.println(""W"");
                    }
                } else {
                    minNumberOfPassages += currentRoomPassages - (isLastOpWalking ? 1 : 0);
                    if (justWalk || currentRoomPassages == 1) {
                        System.out.println(""W"");
                        isLastOpWalking = true;
                        roomGraph[currentRoom][0] = true;
                        continue;
                    }
                }

                if (!justWalk) {
                    roomGraph[currentRoom][0] = true;
                    //             teleport to next unvisited
                    if (roomGraph[nextUnvisitedRoom][0]) { //find next
                        var previousRoom = nextUnvisitedRoom;
                        for (int i2 = nextUnvisitedRoom + 1; i2 < numberOfRooms; i2++) {
                            if (!roomGraph[i2][0]) {
                                nextUnvisitedRoom = i2;
                                break;
                            }
                        }
                        if (nextUnvisitedRoom.equals(previousRoom)) {
                            justWalk = true;
                        }
                    }
                    isLastOpWalking = false;
                    System.out.println(""T "" + nextUnvisitedRoom);
                }
            }
            System.out.println(""E "" + minNumberOfPassages);
        }
        sc.",DEB
8906,"class Solution {
    public static void main(String[] args) {

        try (Scanner reader = new Scanner(System.in)) {
            if (reader.hasNextLine() && reader.hasNextInt()) {
                long T = printAsErr(Integer.parseInt(reader.nextLine()));

//                LocalDateTime before = LocalDateTime.now();
                for (long i = 0; i < T; i++) {
                    double N = printAsErr(reader.nextLong()); // rooms
                    double K = printAsErr((reader.nextLong())); // attempts

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

//                    Map<Integer, Integer> roomsMap = new HashMap<>(); // room number , # passages
                    List<Long> passagesList = new ArrayList<>();
                    long passages = 0;

                    double jumpFactor = 1;
                    if (K < N) {
                        jumpFactor = N/K;
                    }

                    for (int j = 1; j <= K; j++) { // use all attempts

                        if (j > N) { // we checked all rooms
                            break;
                        }

                        long roomNumber = printAsErr((reader.nextLong()));
                        if (roomNumber == -1) { // I did something wrong
                            System.exit(0);
                        }
                        long amountOfPassages = printAsErr((reader.nextLong()));
                        passages += amountOfPassages;
                        passagesList.add(amountOfPassages);
//                        roomsMap.put(roomNumber, amountOfPassages);

                        if (reader.hasNextLine()) {
                            reader.nextLine();
                        }

                        System.out.println(printAsErr(""T "" + Math.round(j * jumpFactor)));
                    }

                    long roomNumber = printAsErr((reader.nextLong()));
                    if (roomNumber == -1) { // I did something wrong
                        System.exit(0);
                    }
                    long amountOfPassages = printAsErr((reader.nextLong()));
                    passages += amountOfPassages;
                    passagesList.add(amountOfPassages);
//                        roomsMap.put(roomNumber, amountOfPassages);

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

                    // make a guess
                    long guess0 = (long) passagesList.stream().mapToLong(val -> val).average().orElse(0);
                    guess0 = (long) (guess0 * N / 2);
                    int size = passagesList.size();
                    long guess1 = (long) passagesList.stream().mapToLong(val -> val).sorted().skip((size-1)/2).limit(2-size%2).average().orElse(0);
                    guess1 = (long) (guess1 * N / 2);
//
//                    System.out.println(printAsErr(""E "" + guess * N / 2));
                    passages /= 2;
//                    double desperateFactor = 0;
                    long guess2;
                    if (K < N) {
                        guess2= Math.round(passages * jumpFactor);
                    } else {
                        guess2 = passages;
                    }
                    Set<Long> guesses = new TreeSet<>();
//                    System.err.println(guess0);
//                    System.err.println(guess1);
//                    System.err.println(guess2);
                    guesses.add(guess0);
                    guesses.add(guess1);
                    guesses.add(guess2);

                    Iterator<Long> iterator = guesses.iterator();
                    iterator.next();
                    long guess = iterator.next(); // median

//                    long guess = (guess0 + guess1 + guess2) / 3;
                    System.out.println(printAsErr(""E "" + guess));
                }
//                LocalDateTime after = LocalDateTime.now();
//                System.err.println(SECONDS.between(before, after) + "" sec"");
            }
        }
    }

    private static long printAsErr(long info) {
//        System.err.println(info);
        return info;
    }

    private static String printAsErr(String info) ",JanDL
8907,"class Solution {
    public static void main(String[] args) {

        try (Scanner reader = new Scanner(System.in)) {
            if (reader.hasNextLine() && reader.hasNextInt()) {
                long T = printAsErr(Integer.parseInt(reader.nextLine()));

//                LocalDateTime before = LocalDateTime.now();
                for (long i = 0; i < T; i++) {
                    double N = printAsErr(reader.nextLong()); // rooms
                    double K = printAsErr((reader.nextLong())); // attempts

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

//                    Map<Integer, Integer> roomsMap = new HashMap<>(); // room number , # passages
                    List<Long> passagesList = new ArrayList<>();
                    long passages = 0;

                    double jumpFactor = 1;
                    if (K < N) {
                        jumpFactor = N/K;
                    }

                    for (int j = 1; j <= K; j++) { // use all attempts

                        if (j > N) { // we checked all rooms
                            break;
                        }

                        long roomNumber = printAsErr((reader.nextLong()));
                        if (roomNumber == -1) { // I did something wrong
                            System.exit(0);
                        }
                        long amountOfPassages = printAsErr((reader.nextLong()));
                        passages += amountOfPassages;
                        passagesList.add(amountOfPassages);
//                        roomsMap.put(roomNumber, amountOfPassages);

                        if (reader.hasNextLine()) {
                            reader.nextLine();
                        }

                        System.out.println(printAsErr(""T "" + Math.round(j * jumpFactor)));
                    }

                    long roomNumber = printAsErr((reader.nextLong()));
                    if (roomNumber == -1) { // I did something wrong
                        System.exit(0);
                    }
                    long amountOfPassages = printAsErr((reader.nextLong()));
                    passages += amountOfPassages;
                    passagesList.add(amountOfPassages);
//                        roomsMap.put(roomNumber, amountOfPassages);

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

                    // make a guess
                    long guess0 = (long) passagesList.stream().mapToLong(val -> val).average().orElse(0);
                    guess0 = (long) (guess0 * N / 2);
                    int size = passagesList.size();
                    long guess1 = (long) passagesList.stream().mapToLong(val -> val).sorted().skip((size-1)/2).limit(2-size%2).average().orElse(0);
                    guess1 = (long) (guess1 * N / 2);
//
//                    System.out.println(printAsErr(""E "" + guess * N / 2));
                    passages /= 2;
                    double desperateFactor = 0;
                    long guess2;
                    if (K < N) {
                        guess2= Math.round(passages * jumpFactor);
                    } else {
                        guess2 = passages;
                    }
                    Set<Long> guesses = new TreeSet<>();
//                    System.err.println(guess0);
//                    System.err.println(guess1);
//                    System.err.println(guess2);
                    guesses.add(guess0);
                    guesses.add(guess1);
                    guesses.add(guess2);

                    Iterator<Long> iterator = guesses.iterator();
                    iterator.next();
                    long guess = iterator.next(); // median

//                    long guess = (guess0 + guess1 + guess2) / 3;
                    System.out.println(printAsErr(""E "" + (long) (guess + guess * desperateFactor)));
                }
//                LocalDateTime after = LocalDateTime.now();
//                System.err.println(SECONDS.between(before, after) + "" sec"");
            }
        }
    }

    private static long printAsErr(long info) {
//        System.err.println(info);
        return info;
    }

    private static String printAsErr(String info) ",JanDL
8908,"class Solution {
    public static void main(String[] args) {

        try (Scanner reader = new Scanner(System.in)) {
            if (reader.hasNextLine() && reader.hasNextInt()) {
                long T = printAsErr(Integer.parseInt(reader.nextLine()));

//                LocalDateTime before = LocalDateTime.now();
                for (long i = 0; i < T; i++) {
                    double N = printAsErr(reader.nextLong()); // rooms
                    double K = printAsErr((reader.nextLong())); // attempts

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

//                    Map<Integer, Integer> roomsMap = new HashMap<>(); // room number , # passages
                    List<Long> passagesList = new ArrayList<>();
                    long passages = 0;

                    double jumpFactor = 1;
                    if (K < N) {
                        jumpFactor = N/K;
                    }

                    for (int j = 1; j <= K; j++) { // use all attempts

                        if (j > N) { // we checked all rooms
                            break;
                        }

                        long roomNumber = printAsErr((reader.nextLong()));
                        if (roomNumber == -1) { // I did something wrong
                            System.exit(0);
                        }
                        long amountOfPassages = printAsErr((reader.nextLong()));
                        passages += amountOfPassages;
                        passagesList.add(amountOfPassages);
//                        roomsMap.put(roomNumber, amountOfPassages);

                        if (reader.hasNextLine()) {
                            reader.nextLine();
                        }

                        System.out.println(printAsErr(""T "" + Math.round(j * jumpFactor)));
                    }

                    long roomNumber = printAsErr((reader.nextLong()));
                    if (roomNumber == -1) { // I did something wrong
                        System.exit(0);
                    }
                    long amountOfPassages = printAsErr((reader.nextLong()));
                    passages += amountOfPassages;
                    passagesList.add(amountOfPassages);
//                        roomsMap.put(roomNumber, amountOfPassages);

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

                    // make a guess
                    long guess0 = (long) passagesList.stream().mapToLong(val -> val).average().orElse(0);
                    guess0 = (long) (guess0 * N / 2);
                    int size = passagesList.size();
                    long guess1 = (long) passagesList.stream().mapToLong(val -> val).sorted().skip((size-1)/2).limit(2-size%2).average().orElse(0);
                    guess1 = (long) (guess1 * N / 2);
//
//                    System.out.println(printAsErr(""E "" + guess * N / 2));
                    passages /= 2;
                    double desperateFactor = -0.25;
                    long guess2;
                    if (K < N) {
                        guess2= Math.round(passages * jumpFactor);
                    } else {
                        guess2 = passages;
                    }
                    long guess = (guess0 + guess1 + guess2) / 3;
                    System.out.println(printAsErr(""E "" + (long) (guess + guess * desperateFactor)));
                }
//                LocalDateTime after = LocalDateTime.now();
//                System.err.println(SECONDS.between(before, after) + "" sec"");
            }
        }
    }

    private static long printAsErr(long info) {
//        System.err.println(info);
        return info;
    }

    private static String printAsErr(String info) ",JanDL
8909,"class Solution {
    public static void main(String[] args) {

        try (Scanner reader = new Scanner(System.in)) {
            if (reader.hasNextLine() && reader.hasNextInt()) {
                long T = printAsErr(Integer.parseInt(reader.nextLine()));

//                LocalDateTime before = LocalDateTime.now();
                for (long i = 0; i < T; i++) {
                    double N = printAsErr(reader.nextLong()); // rooms
                    double K = printAsErr((reader.nextLong())); // attempts

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

//                    Map<Integer, Integer> roomsMap = new HashMap<>(); // room number , # passages
                    List<Long> passagesList = new ArrayList<>();
                    long passages = 0;

                    double jumpFactor = 1;
                    if (K < N) {
                        jumpFactor = N/K;
                    }

                    for (int j = 1; j <= K; j++) { // use all attempts

                        if (j > N) { // we checked all rooms
                            break;
                        }

                        long roomNumber = printAsErr((reader.nextLong()));
                        if (roomNumber == -1) { // I did something wrong
                            System.exit(0);
                        }
                        long amountOfPassages = printAsErr((reader.nextLong()));
                        passages += amountOfPassages;
                        passagesList.add(amountOfPassages);
//                        roomsMap.put(roomNumber, amountOfPassages);

                        if (reader.hasNextLine()) {
                            reader.nextLine();
                        }

                        System.out.println(printAsErr(""T "" + Math.round(j * jumpFactor)));
                    }

                    long roomNumber = printAsErr((reader.nextLong()));
                    if (roomNumber == -1) { // I did something wrong
                        System.exit(0);
                    }
                    long amountOfPassages = printAsErr((reader.nextLong()));
                    passages += amountOfPassages;
                    passagesList.add(amountOfPassages);
//                        roomsMap.put(roomNumber, amountOfPassages);

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

                    // make a guess
                    long guess0 = (long) passagesList.stream().mapToLong(val -> val).average().orElse(0);
                    guess0 = (long) (guess0 * N / 2);
                    int size = passagesList.size();
                    long guess1 = (long) passagesList.stream().mapToLong(val -> val).sorted().skip((size-1)/2).limit(2-size%2).average().orElse(0);
                    guess1 = (long) (guess1 * N / 2);
//
//                    System.out.println(printAsErr(""E "" + guess * N / 2));
                    passages /= 2;
                    double desperateFactor = 0.25;
                    long guess2;
                    if (K < N) {
                        guess2= Math.round(passages * jumpFactor);
                    } else {
                        guess2 = passages;
                    }
                    long guess = (guess0 + guess1 + guess2) / 3;
                    System.out.println(printAsErr(""E "" + (long) (guess + guess * desperateFactor)));
                }
//                LocalDateTime after = LocalDateTime.now();
//                System.err.println(SECONDS.between(before, after) + "" sec"");
            }
        }
    }

    private static long printAsErr(long info) {
//        System.err.println(info);
        return info;
    }

    private static String printAsErr(String info) ",JanDL
8910,"class Solution {
    public static void main(String[] args) {

        try (Scanner reader = new Scanner(System.in)) {
            if (reader.hasNextLine() && reader.hasNextInt()) {
                long T = printAsErr(Integer.parseInt(reader.nextLine()));

//                LocalDateTime before = LocalDateTime.now();
                for (long i = 0; i < T; i++) {
                    double N = printAsErr(reader.nextLong()); // rooms
                    double K = printAsErr((reader.nextLong())); // attempts

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

//                    Map<Integer, Integer> roomsMap = new HashMap<>(); // room number , # passages
                    List<Long> passagesList = new ArrayList<>();
                    long passages = 0;

                    double jumpFactor = 1;
                    if (K < N) {
                        jumpFactor = N/K;
                    }

                    for (int j = 1; j <= K; j++) { // use all attempts

                        if (j > N) { // we checked all rooms
                            break;
                        }

                        long roomNumber = printAsErr((reader.nextLong()));
                        if (roomNumber == -1) { // I did something wrong
                            System.exit(0);
                        }
                        long amountOfPassages = printAsErr((reader.nextLong()));
                        passages += amountOfPassages;
                        passagesList.add(amountOfPassages);
//                        roomsMap.put(roomNumber, amountOfPassages);

                        if (reader.hasNextLine()) {
                            reader.nextLine();
                        }

                        System.out.println(printAsErr(""T "" + Math.round(j * jumpFactor)));
                    }

                    long roomNumber = printAsErr((reader.nextLong()));
                    if (roomNumber == -1) { // I did something wrong
                        System.exit(0);
                    }
                    long amountOfPassages = printAsErr((reader.nextLong()));
                    passages += amountOfPassages;
                    passagesList.add(amountOfPassages);
//                        roomsMap.put(roomNumber, amountOfPassages);

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

                    // make a guess
                    long guess0 = (long) passagesList.stream().mapToLong(val -> val).average().orElse(0);
                    guess0 = (long) (guess0 * N / 2);
                    int size = passagesList.size();
                    long guess1 = (long) passagesList.stream().mapToLong(val -> val).sorted().skip((size-1)/2).limit(2-size%2).average().orElse(0);
                    guess1 = (long) (guess1 * N / 2);
//
//                    System.out.println(printAsErr(""E "" + guess * N / 2));
                    passages /= 2;
                    double desperateFactor = 0.20;
                    long guess2;
                    if (K < N) {
                        guess2= Math.round(passages * jumpFactor);
                    } else {
                        guess2 = passages;
                    }
                    long guess = (guess0 + guess1 + guess2) / 3;
                    System.out.println(printAsErr(""E "" + (long) (guess + guess * desperateFactor)));
                }
//                LocalDateTime after = LocalDateTime.now();
//                System.err.println(SECONDS.between(before, after) + "" sec"");
            }
        }
    }

    private static long printAsErr(long info) {
//        System.err.println(info);
        return info;
    }

    private static String printAsErr(String info) ",JanDL
8911,"class Solution {
    public static void main(String[] args) {

        try (Scanner reader = new Scanner(System.in)) {
            if (reader.hasNextLine() && reader.hasNextInt()) {
                long T = printAsErr(Integer.parseInt(reader.nextLine()));

//                LocalDateTime before = LocalDateTime.now();
                for (long i = 0; i < T; i++) {
                    double N = printAsErr(reader.nextLong()); // rooms
                    double K = printAsErr((reader.nextLong())); // attempts

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

//                    Map<Integer, Integer> roomsMap = new HashMap<>(); // room number , # passages
                    List<Long> passagesList = new ArrayList<>();
                    long passages = 0;

                    double jumpFactor = 1;
                    if (K < N) {
                        jumpFactor = N/K;
                    }

                    for (int j = 1; j <= K; j++) { // use all attempts

                        if (j > N) { // we checked all rooms
                            break;
                        }

                        long roomNumber = printAsErr((reader.nextLong()));
                        if (roomNumber == -1) { // I did something wrong
                            System.exit(0);
                        }
                        long amountOfPassages = printAsErr((reader.nextLong()));
                        passages += amountOfPassages;
                        passagesList.add(amountOfPassages);
//                        roomsMap.put(roomNumber, amountOfPassages);

                        if (reader.hasNextLine()) {
                            reader.nextLine();
                        }

                        System.out.println(printAsErr(""T "" + Math.round(j * jumpFactor)));
                    }

                    long roomNumber = printAsErr((reader.nextLong()));
                    if (roomNumber == -1) { // I did something wrong
                        System.exit(0);
                    }
                    long amountOfPassages = printAsErr((reader.nextLong()));
                    passages += amountOfPassages;
                    passagesList.add(amountOfPassages);
//                        roomsMap.put(roomNumber, amountOfPassages);

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

                    // make a guess
                    long guess0 = (long) passagesList.stream().mapToLong(val -> val).average().orElse(0);
                    guess0 = (long) (guess0 * N / 2);
                    int size = passagesList.size();
                    long guess1 = (long) passagesList.stream().mapToLong(val -> val).sorted().skip((size-1)/2).limit(2-size%2).average().orElse(0);
                    guess1 = (long) (guess1 * N / 2);
//
//                    System.out.println(printAsErr(""E "" + guess * N / 2));
                    passages /= 2;
                    double desperateFactor = -0.20;
                    long guess2;
                    if (K < N) {
                        guess2= Math.round(passages * jumpFactor);
                    } else {
                        guess2 = passages;
                    }
                    long guess = (guess0 + guess1 + guess2) / 3;
                    System.out.println(printAsErr(""E "" + (long) (guess + guess * desperateFactor)));
                }
//                LocalDateTime after = LocalDateTime.now();
//                System.err.println(SECONDS.between(before, after) + "" sec"");
            }
        }
    }

    private static long printAsErr(long info) {
//        System.err.println(info);
        return info;
    }

    private static String printAsErr(String info) ",JanDL
8912,"class Solution {
    public static void main(String[] args) {

        try (Scanner reader = new Scanner(System.in)) {
            if (reader.hasNextLine() && reader.hasNextInt()) {
                long T = printAsErr(Integer.parseInt(reader.nextLine()));

//                LocalDateTime before = LocalDateTime.now();
                for (long i = 0; i < T; i++) {
                    double N = printAsErr(reader.nextLong()); // rooms
                    double K = printAsErr((reader.nextLong())); // attempts

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

//                    Map<Integer, Integer> roomsMap = new HashMap<>(); // room number , # passages
                    List<Long> passagesList = new ArrayList<>();
                    long passages = 0;

                    double jumpFactor = 1;
                    if (K < N) {
                        jumpFactor = N/K;
                    }

                    for (int j = 1; j <= K; j++) { // use all attempts

                        if (j > N) { // we checked all rooms
                            break;
                        }

                        long roomNumber = printAsErr((reader.nextLong()));
                        if (roomNumber == -1) { // I did something wrong
                            System.exit(0);
                        }
                        long amountOfPassages = printAsErr((reader.nextLong()));
                        passages += amountOfPassages;
                        passagesList.add(amountOfPassages);
//                        roomsMap.put(roomNumber, amountOfPassages);

                        if (reader.hasNextLine()) {
                            reader.nextLine();
                        }

                        System.out.println(printAsErr(""T "" + Math.round(j * jumpFactor)));
                    }

                    long roomNumber = printAsErr((reader.nextLong()));
                    if (roomNumber == -1) { // I did something wrong
                        System.exit(0);
                    }
                    long amountOfPassages = printAsErr((reader.nextLong()));
                    passages += amountOfPassages;
                    passagesList.add(amountOfPassages);
//                        roomsMap.put(roomNumber, amountOfPassages);

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

                    // make a guess
                    long guess0 = (long) passagesList.stream().mapToLong(val -> val).average().orElse(0);
                    guess0 = (long) (guess0 * N / 2);
                    int size = passagesList.size();
                    long guess1 = (long) passagesList.stream().mapToLong(val -> val).sorted().skip((size-1)/2).limit(2-size%2).average().orElse(0);
                    guess1 = (long) (guess1 * N / 2);
//
//                    System.out.println(printAsErr(""E "" + guess * N / 2));
                    passages /= 2;
                    double desperateFactor = -0.05;
                    long guess2;
                    if (K < N) {
                        guess2= Math.round(passages * jumpFactor);
                    } else {
                        guess2 = passages;
                    }
                    long guess = (guess0 + guess1 + guess2) / 3;
                    System.out.println(printAsErr(""E "" + (long) (guess + guess * desperateFactor)));
                }
//                LocalDateTime after = LocalDateTime.now();
//                System.err.println(SECONDS.between(before, after) + "" sec"");
            }
        }
    }

    private static long printAsErr(long info) {
//        System.err.println(info);
        return info;
    }

    private static String printAsErr(String info) ",JanDL
8913,"class Solution {
    public static void main(String[] args) {

        try (Scanner reader = new Scanner(System.in)) {
            if (reader.hasNextLine() && reader.hasNextInt()) {
                long T = printAsErr(Integer.parseInt(reader.nextLine()));

//                LocalDateTime before = LocalDateTime.now();
                for (long i = 0; i < T; i++) {
                    double N = printAsErr(reader.nextLong()); // rooms
                    double K = printAsErr((reader.nextLong())); // attempts

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

//                    Map<Integer, Integer> roomsMap = new HashMap<>(); // room number , # passages
                    List<Long> passagesList = new ArrayList<>();
                    long passages = 0;

                    double jumpFactor = 1;
                    if (K < N) {
                        jumpFactor = N/K;
                    }

                    for (int j = 1; j <= K; j++) { // use all attempts

                        if (j > N) { // we checked all rooms
                            break;
                        }

                        long roomNumber = printAsErr((reader.nextLong()));
                        if (roomNumber == -1) { // I did something wrong
                            System.exit(0);
                        }
                        long amountOfPassages = printAsErr((reader.nextLong()));
                        passages += amountOfPassages;
                        passagesList.add(amountOfPassages);
//                        roomsMap.put(roomNumber, amountOfPassages);

                        if (reader.hasNextLine()) {
                            reader.nextLine();
                        }

                        System.out.println(printAsErr(""T "" + Math.round(j * jumpFactor)));
                    }

                    long roomNumber = printAsErr((reader.nextLong()));
                    if (roomNumber == -1) { // I did something wrong
                        System.exit(0);
                    }
                    long amountOfPassages = printAsErr((reader.nextLong()));
                    passages += amountOfPassages;
                    passagesList.add(amountOfPassages);
//                        roomsMap.put(roomNumber, amountOfPassages);

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

                    // make a guess
                    long guess0 = (long) passagesList.stream().mapToLong(val -> val).average().orElse(0);
                    guess0 = (long) (guess0 * N / 2);
                    int size = passagesList.size();
                    long guess1 = (long) passagesList.stream().mapToLong(val -> val).sorted().skip((size-1)/2).limit(2-size%2).average().orElse(0);
                    guess1 = (long) (guess1 * N / 2);
//
//                    System.out.println(printAsErr(""E "" + guess * N / 2));
                    passages /= 2;
                    double desperateFactor = 0.05;
                    long guess2;
                    if (K < N) {
                        guess2= Math.round(passages * jumpFactor);
                    } else {
                        guess2 = passages;
                    }
                    long guess = (guess0 + guess1 + guess2) / 3;
                    System.out.println(printAsErr(""E "" + (long) (guess + guess * desperateFactor)));
                }
//                LocalDateTime after = LocalDateTime.now();
//                System.err.println(SECONDS.between(before, after) + "" sec"");
            }
        }
    }

    private static long printAsErr(long info) {
//        System.err.println(info);
        return info;
    }

    private static String printAsErr(String info) ",JanDL
8914,"class Solution {
    public static void main(String[] args) {

        try (Scanner reader = new Scanner(System.in)) {
            if (reader.hasNextLine() && reader.hasNextInt()) {
                long T = printAsErr(Integer.parseInt(reader.nextLine()));

//                LocalDateTime before = LocalDateTime.now();
                for (long i = 0; i < T; i++) {
                    double N = printAsErr(reader.nextLong()); // rooms
                    double K = printAsErr((reader.nextLong())); // attempts

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

//                    Map<Integer, Integer> roomsMap = new HashMap<>(); // room number , # passages
                    List<Long> passagesList = new ArrayList<>();
                    long passages = 0;

                    double jumpFactor = 1;
                    if (K < N) {
                        jumpFactor = N/K;
                    }

                    for (int j = 1; j <= K; j++) { // use all attempts

                        if (j > N) { // we checked all rooms
                            break;
                        }

                        long roomNumber = printAsErr((reader.nextLong()));
                        if (roomNumber == -1) { // I did something wrong
                            System.exit(0);
                        }
                        long amountOfPassages = printAsErr((reader.nextLong()));
                        passages += amountOfPassages;
                        passagesList.add(amountOfPassages);
//                        roomsMap.put(roomNumber, amountOfPassages);

                        if (reader.hasNextLine()) {
                            reader.nextLine();
                        }

                        System.out.println(printAsErr(""T "" + Math.round(j * jumpFactor)));
                    }

                    long roomNumber = printAsErr((reader.nextLong()));
                    if (roomNumber == -1) { // I did something wrong
                        System.exit(0);
                    }
                    long amountOfPassages = printAsErr((reader.nextLong()));
                    passages += amountOfPassages;
                    passagesList.add(amountOfPassages);
//                        roomsMap.put(roomNumber, amountOfPassages);

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

                    // make a guess
                    long guess0 = (long) passagesList.stream().mapToLong(val -> val).average().orElse(0);
                    guess0 = (long) (guess0 * N / 2);
                    int size = passagesList.size();
                    long guess1 = (long) passagesList.stream().mapToLong(val -> val).sorted().skip((size-1)/2).limit(2-size%2).average().orElse(0);
                    guess1 = (long) (guess1 * N / 2);
//
//                    System.out.println(printAsErr(""E "" + guess * N / 2));
                    passages /= 2;
                    double desperateFactor = 0.05;
                    long guess2;
                    if (K < N) {
                        guess2= Math.round(passages * jumpFactor);
                    } else {
                        guess2 = passages;
                    }
                    long guess = (guess0 + guess1 + guess2) / 3;
                    System.out.println(printAsErr(""E "" + (guess)));
                }
//                LocalDateTime after = LocalDateTime.now();
//                System.err.println(SECONDS.between(before, after) + "" sec"");
            }
        }
    }

    private static long printAsErr(long info) {
//        System.err.println(info);
        return info;
    }

    private static String printAsErr(String info) ",JanDL
8915,"class Solution {
    public static void main(String[] args) {

        try (Scanner reader = new Scanner(System.in)) {
            if (reader.hasNextLine() && reader.hasNextInt()) {
                long T = printAsErr(Integer.parseInt(reader.nextLine()));

//                LocalDateTime before = LocalDateTime.now();
                for (long i = 0; i < T; i++) {
                    double N = printAsErr(reader.nextLong()); // rooms
                    double K = printAsErr((reader.nextLong())); // attempts

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

//                    Map<Integer, Integer> roomsMap = new HashMap<>(); // room number , # passages
                    List<Long> passagesList = new ArrayList<>();
                    long passages = 0;

                    double jumpFactor = 1;
                    if (K < N) {
                        jumpFactor = N/K;
                    }

                    for (int j = 1; j <= K; j++) { // use all attempts

                        if (j > N) { // we checked all rooms
                            break;
                        }

                        long roomNumber = printAsErr((reader.nextLong()));
                        if (roomNumber == -1) { // I did something wrong
                            System.exit(0);
                        }
                        long amountOfPassages = printAsErr((reader.nextLong()));
                        passages += amountOfPassages;
                        passagesList.add(amountOfPassages);
//                        roomsMap.put(roomNumber, amountOfPassages);

                        if (reader.hasNextLine()) {
                            reader.nextLine();
                        }

                        System.out.println(printAsErr(""T "" + Math.round(j * jumpFactor)));
                    }

                    long roomNumber = printAsErr((reader.nextLong()));
                    if (roomNumber == -1) { // I did something wrong
                        System.exit(0);
                    }
                    long amountOfPassages = printAsErr((reader.nextLong()));
                    passages += amountOfPassages;
                    passagesList.add(amountOfPassages);
//                        roomsMap.put(roomNumber, amountOfPassages);

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

                    // make a guess
//                    long guess = (long) passagesList.stream().mapToLong(val -> val).average().orElse(0);
                    int size = passagesList.size();
                    long guess1 = (long) passagesList.stream().mapToLong(val -> val).sorted().skip((size-1)/2).limit(2-size%2).average().orElse(0);
                    guess1 = (long) (guess1 * N / 2);
//
//                    System.out.println(printAsErr(""E "" + guess * N / 2));
                    passages /= 2;
                    double desperateFactor = 0.05;
                    long guess2;
                    if (K < N) {
                        guess2= Math.round(passages * jumpFactor);
                    } else {
                        guess2 = passages;
                    }
                    long guess = (guess1 + guess2) / 2;
                    System.out.println(printAsErr(""E "" + (guess)));
                }
//                LocalDateTime after = LocalDateTime.now();
//                System.err.println(SECONDS.between(before, after) + "" sec"");
            }
        }
    }

    private static long printAsErr(long info) {
//        System.err.println(info);
        return info;
    }

    private static String printAsErr(String info) ",JanDL
8916,"class Solution {
    public static void main(String[] args) {

        try (Scanner reader = new Scanner(System.in)) {
            if (reader.hasNextLine() && reader.hasNextInt()) {
                long T = printAsErr(Integer.parseInt(reader.nextLine()));

                LocalDateTime before = LocalDateTime.now();
                for (long i = 0; i < T; i++) {
                    double N = printAsErr(reader.nextLong()); // rooms
                    double K = printAsErr((reader.nextLong())); // attempts

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

//                    Map<Integer, Integer> roomsMap = new HashMap<>(); // room number , # passages
                    List<Long> passagesList = new ArrayList<>();
                    long passages = 0;

                    double jumpFactor = 1;
                    if (K < N) {
                        jumpFactor = N/K;
                    }

                    for (int j = 1; j <= K; j++) { // use all attempts

                        if (j > N) { // we checked all rooms
                            break;
                        }

                        long roomNumber = printAsErr((reader.nextLong()));
                        if (roomNumber == -1) { // I did something wrong
                            System.exit(0);
                        }
                        long amountOfPassages = printAsErr((reader.nextLong()));
                        passages += amountOfPassages;
                        passagesList.add(amountOfPassages);
//                        roomsMap.put(roomNumber, amountOfPassages);

                        if (reader.hasNextLine()) {
                            reader.nextLine();
                        }

                        System.out.println(printAsErr(""T "" + Math.round(j * jumpFactor)));
                    }

                    long roomNumber = printAsErr((reader.nextLong()));
                    if (roomNumber == -1) { // I did something wrong
                        System.exit(0);
                    }
                    long amountOfPassages = printAsErr((reader.nextLong()));
                    passages += amountOfPassages;
                    passagesList.add(amountOfPassages);
//                        roomsMap.put(roomNumber, amountOfPassages);

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

                    // make a guess
//                    long guess = (long) passagesList.stream().mapToLong(val -> val).average().orElse(0);
                    int size = passagesList.size();
                    long guess1 = (long) passagesList.stream().mapToLong(val -> val).sorted().skip((size-1)/2).limit(2-size%2).average().orElse(0);
                    guess1 = (long) (guess1 * N / 2);
//
//                    System.out.println(printAsErr(""E "" + guess * N / 2));
                    passages /= 2;
                    double desperateFactor = 0.05;
                    long guess2;
                    if (K < N) {
                        guess2= Math.round(passages * jumpFactor);
                    } else {
                        guess2 = passages;
                    }
                    long guess = (guess1 + guess2) / 2;
                    System.out.println(printAsErr(""E "" + (guess)));
                }
                LocalDateTime after = LocalDateTime.now();
                System.err.println(SECONDS.between(before, after) + "" sec"");
            }
        }
    }

    private static long printAsErr(long info) {
//        System.err.println(info);
        return info;
    }

    private static String printAsErr(String info) ",JanDL
8917,"class Solution {
    public static void main(String[] args) {

        try (Scanner reader = new Scanner(System.in)) {
            if (reader.hasNextLine() && reader.hasNextInt()) {
                long T = printAsErr(Integer.parseInt(reader.nextLine()));

                LocalDateTime before = LocalDateTime.now();
                for (long i = 0; i < T; i++) {
                    double N = printAsErr(reader.nextLong()); // rooms
                    double K = printAsErr((reader.nextLong())); // attempts

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

//                    Map<Integer, Integer> roomsMap = new HashMap<>(); // room number , # passages
//                    List<Long> passagesList = new ArrayList<>();
                    long passages = 0;

                    double jumpFactor = 1;
                    if (K < N) {
                        jumpFactor = N/K;
                    }

                    for (int j = 1; j <= K; j++) { // use all attempts

                        if (j > N) { // we checked all rooms
                            break;
                        }

                        long roomNumber = printAsErr((reader.nextLong()));
                        if (roomNumber == -1) { // I did something wrong
                            System.exit(0);
                        }
                        long amountOfPassages = printAsErr((reader.nextLong()));
                        passages += amountOfPassages;
//                        passagesList.add(amountOfPassages);
//                        roomsMap.put(roomNumber, amountOfPassages);

                        if (reader.hasNextLine()) {
                            reader.nextLine();
                        }

                        System.out.println(printAsErr(""T "" + Math.round(j * jumpFactor)));
                    }

                    long roomNumber = printAsErr((reader.nextLong()));
                    if (roomNumber == -1) { // I did something wrong
                        System.exit(0);
                    }
                    long amountOfPassages = printAsErr((reader.nextLong()));
                    passages += amountOfPassages;
//                    passagesList.add(amountOfPassages);
//                        roomsMap.put(roomNumber, amountOfPassages);

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

                    // make a guess
//                    long guess = (long) passagesList.stream().mapToLong(val -> val).average().orElse(0);
//                    int size = passagesList.size();
//                    long guess = (long) passagesList.stream().mapToLong(val -> val).sorted().skip((size-1)/2).limit(2-size%2).average().orElse(0);

//
//                    System.out.println(printAsErr(""E "" + guess * N / 2));
                    passages /= 2;
                    double desperateFactor = 0.025;
                    long guess;
                    if (K < N) {
                        guess = Math.round(passages * jumpFactor);
                    } else {
                        guess = passages;
                    }
                    System.out.println(printAsErr(""E "" + (long)(guess + desperateFactor*guess)));
                }
                LocalDateTime after = LocalDateTime.now();
                System.err.println(SECONDS.between(before, after) + "" sec"");
            }
        }
    }

    private static long printAsErr(long info) {
//        System.err.println(info);
        return info;
    }

    private static String printAsErr(String info) ",JanDL
8918,"class Solution {
    public static void main(String[] args) {

        try (Scanner reader = new Scanner(System.in)) {
            if (reader.hasNextLine() && reader.hasNextInt()) {
                long T = printAsErr(Integer.parseInt(reader.nextLine()));

                LocalDateTime before = LocalDateTime.now();
                for (long i = 0; i < T; i++) {
                    double N = printAsErr(reader.nextLong()); // rooms
                    double K = printAsErr((reader.nextLong())); // attempts

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

//                    Map<Integer, Integer> roomsMap = new HashMap<>(); // room number , # passages
//                    List<Long> passagesList = new ArrayList<>();
                    long passages = 0;

                    double jumpFactor = 1;
                    if (K < N) {
                        jumpFactor = N/K;
                    }

                    for (int j = 1; j <= K; j++) { // use all attempts

                        if (j > N) { // we checked all rooms
                            break;
                        }

                        long roomNumber = printAsErr((reader.nextLong()));
                        if (roomNumber == -1) { // I did something wrong
                            System.exit(0);
                        }
                        long amountOfPassages = printAsErr((reader.nextLong()));
                        passages += amountOfPassages;
//                        passagesList.add(amountOfPassages);
//                        roomsMap.put(roomNumber, amountOfPassages);

                        if (reader.hasNextLine()) {
                            reader.nextLine();
                        }

                        System.out.println(printAsErr(""T "" + Math.round(j * jumpFactor)));
                    }

                    long roomNumber = printAsErr((reader.nextLong()));
                    if (roomNumber == -1) { // I did something wrong
                        System.exit(0);
                    }
                    long amountOfPassages = printAsErr((reader.nextLong()));
                    passages += amountOfPassages;
//                    passagesList.add(amountOfPassages);
//                        roomsMap.put(roomNumber, amountOfPassages);

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

                    // make a guess
//                    long guess = (long) passagesList.stream().mapToLong(val -> val).average().orElse(0);
//                    int size = passagesList.size();
//                    long guess = (long) passagesList.stream().mapToLong(val -> val).sorted().skip((size-1)/2).limit(2-size%2).average().orElse(0);

//
//                    System.out.println(printAsErr(""E "" + guess * N / 2));
                    passages /= 2;
                    double desperateFactor = -0.025;
                    long guess;
                    if (K < N) {
                        guess = Math.round(passages * jumpFactor);
                    } else {
                        guess = passages;
                    }
                    System.out.println(printAsErr(""E "" + (long)(guess + desperateFactor*guess)));
                }
                LocalDateTime after = LocalDateTime.now();
                System.err.println(SECONDS.between(before, after) + "" sec"");
            }
        }
    }

    private static long printAsErr(long info) {
//        System.err.println(info);
        return info;
    }

    private static String printAsErr(String info) ",JanDL
8919,"class Solution {
    public static void main(String[] args) {

        try (Scanner reader = new Scanner(System.in)) {
            if (reader.hasNextLine() && reader.hasNextInt()) {
                long T = printAsErr(Integer.parseInt(reader.nextLine()));

                LocalDateTime before = LocalDateTime.now();
                for (long i = 0; i < T; i++) {
                    double N = printAsErr(reader.nextLong()); // rooms
                    double K = printAsErr((reader.nextLong())); // attempts

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

//                    Map<Integer, Integer> roomsMap = new HashMap<>(); // room number , # passages
//                    List<Long> passagesList = new ArrayList<>();
                    long passages = 0;

                    double jumpFactor = 1;
                    if (K < N) {
                        jumpFactor = N/K;
                    }

                    for (int j = 1; j <= K; j++) { // use all attempts

                        if (j > N) { // we checked all rooms
                            break;
                        }

                        long roomNumber = printAsErr((reader.nextLong()));
                        if (roomNumber == -1) { // I did something wrong
                            System.exit(0);
                        }
                        long amountOfPassages = printAsErr((reader.nextLong()));
                        passages += amountOfPassages;
//                        passagesList.add(amountOfPassages);
//                        roomsMap.put(roomNumber, amountOfPassages);

                        if (reader.hasNextLine()) {
                            reader.nextLine();
                        }

                        System.out.println(printAsErr(""T "" + Math.round(j * jumpFactor)));
                    }

                    long roomNumber = printAsErr((reader.nextLong()));
                    if (roomNumber == -1) { // I did something wrong
                        System.exit(0);
                    }
                    long amountOfPassages = printAsErr((reader.nextLong()));
                    passages += amountOfPassages;
//                    passagesList.add(amountOfPassages);
//                        roomsMap.put(roomNumber, amountOfPassages);

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

                    // make a guess
//                    long guess = (long) passagesList.stream().mapToLong(val -> val).average().orElse(0);
//                    int size = passagesList.size();
//                    long guess = (long) passagesList.stream().mapToLong(val -> val).sorted().skip((size-1)/2).limit(2-size%2).average().orElse(0);

//
//                    System.out.println(printAsErr(""E "" + guess * N / 2));
                    passages /= 2;
                    double desperateFactor = -0.1;
                    long guess;
                    if (K < N) {
                        guess = Math.round(passages * jumpFactor);
                    } else {
                        guess = passages;
                    }
                    System.out.println(printAsErr(""E "" + (long)(guess + desperateFactor*guess)));
                }
                LocalDateTime after = LocalDateTime.now();
                System.err.println(SECONDS.between(before, after) + "" sec"");
            }
        }
    }

    private static long printAsErr(long info) {
//        System.err.println(info);
        return info;
    }

    private static String printAsErr(String info) ",JanDL
8920,"class Solution {
    public static void main(String[] args) {

        try (Scanner reader = new Scanner(System.in)) {
            if (reader.hasNextLine() && reader.hasNextInt()) {
                long T = printAsErr(Integer.parseInt(reader.nextLine()));

                LocalDateTime before = LocalDateTime.now();
                for (long i = 0; i < T; i++) {
                    double N = printAsErr(reader.nextLong()); // rooms
                    double K = printAsErr((reader.nextLong())); // attempts

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

//                    Map<Integer, Integer> roomsMap = new HashMap<>(); // room number , # passages
//                    List<Long> passagesList = new ArrayList<>();
                    long passages = 0;

                    double jumpFactor = 1;
                    if (K < N) {
                        jumpFactor = N/K;
                    }

                    for (int j = 1; j <= K; j++) { // use all attempts

                        if (j > N) { // we checked all rooms
                            break;
                        }

                        long roomNumber = printAsErr((reader.nextLong()));
                        if (roomNumber == -1) { // I did something wrong
                            System.exit(0);
                        }
                        long amountOfPassages = printAsErr((reader.nextLong()));
                        passages += amountOfPassages;
//                        passagesList.add(amountOfPassages);
//                        roomsMap.put(roomNumber, amountOfPassages);

                        if (reader.hasNextLine()) {
                            reader.nextLine();
                        }

                        System.out.println(printAsErr(""T "" + Math.round(j * jumpFactor)));
                    }

                    long roomNumber = printAsErr((reader.nextLong()));
                    if (roomNumber == -1) { // I did something wrong
                        System.exit(0);
                    }
                    long amountOfPassages = printAsErr((reader.nextLong()));
                    passages += amountOfPassages;
//                    passagesList.add(amountOfPassages);
//                        roomsMap.put(roomNumber, amountOfPassages);

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

                    // make a guess
//                    long guess = (long) passagesList.stream().mapToLong(val -> val).average().orElse(0);
//                    int size = passagesList.size();
//                    long guess = (long) passagesList.stream().mapToLong(val -> val).sorted().skip((size-1)/2).limit(2-size%2).average().orElse(0);

//
//                    System.out.println(printAsErr(""E "" + guess * N / 2));
                    passages /= 2;
                    double desperateFactor = -0.05;
                    long guess;
                    if (K < N) {
                        guess = Math.round(passages * jumpFactor);
                    } else {
                        guess = passages;
                    }
                    System.out.println(printAsErr(""E "" + (long)(guess + desperateFactor*guess)));
                }
                LocalDateTime after = LocalDateTime.now();
                System.err.println(SECONDS.between(before, after) + "" sec"");
            }
        }
    }

    private static long printAsErr(long info) {
//        System.err.println(info);
        return info;
    }

    private static String printAsErr(String info) ",JanDL
8921,"class Solution {
    public static void main(String[] args) {

        try (Scanner reader = new Scanner(System.in)) {
            if (reader.hasNextLine() && reader.hasNextInt()) {
                long T = printAsErr(Integer.parseInt(reader.nextLine()));

                LocalDateTime before = LocalDateTime.now();
                for (long i = 0; i < T; i++) {
                    double N = printAsErr(reader.nextLong()); // rooms
                    double K = printAsErr((reader.nextLong())); // attempts

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

//                    Map<Integer, Integer> roomsMap = new HashMap<>(); // room number , # passages
//                    List<Long> passagesList = new ArrayList<>();
                    long passages = 0;

                    double jumpFactor = 1;
                    if (K < N) {
                        jumpFactor = N/K;
                    }

                    for (int j = 1; j <= K; j++) { // use all attempts

                        if (j > N) { // we checked all rooms
                            break;
                        }

                        long roomNumber = printAsErr((reader.nextLong()));
                        if (roomNumber == -1) { // I did something wrong
                            System.exit(0);
                        }
                        long amountOfPassages = printAsErr((reader.nextLong()));
                        passages += amountOfPassages;
//                        passagesList.add(amountOfPassages);
//                        roomsMap.put(roomNumber, amountOfPassages);

                        if (reader.hasNextLine()) {
                            reader.nextLine();
                        }

                        System.out.println(printAsErr(""T "" + Math.round(j * jumpFactor)));
                    }

                    long roomNumber = printAsErr((reader.nextLong()));
                    if (roomNumber == -1) { // I did something wrong
                        System.exit(0);
                    }
                    long amountOfPassages = printAsErr((reader.nextLong()));
                    passages += amountOfPassages;
//                    passagesList.add(amountOfPassages);
//                        roomsMap.put(roomNumber, amountOfPassages);

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

                    // make a guess
//                    long guess = (long) passagesList.stream().mapToLong(val -> val).average().orElse(0);
//                    int size = passagesList.size();
//                    long guess = (long) passagesList.stream().mapToLong(val -> val).sorted().skip((size-1)/2).limit(2-size%2).average().orElse(0);

//
//                    System.out.println(printAsErr(""E "" + guess * N / 2));
                    passages /= 2;
                    double desperateFactor = 0.10;
                    long guess;
                    if (K < N) {
                        guess = Math.round(passages * jumpFactor);
                    } else {
                        guess = passages;
                    }
                    System.out.println(printAsErr(""E "" + (long)(guess + desperateFactor*guess)));
                }
                LocalDateTime after = LocalDateTime.now();
                System.err.println(SECONDS.between(before, after) + "" sec"");
            }
        }
    }

    private static long printAsErr(long info) {
//        System.err.println(info);
        return info;
    }

    private static String printAsErr(String info) ",JanDL
8922,"class Solution {
    public static void main(String[] args) {

        try (Scanner reader = new Scanner(System.in)) {
            if (reader.hasNextLine() && reader.hasNextInt()) {
                long T = printAsErr(Integer.parseInt(reader.nextLine()));

                LocalDateTime before = LocalDateTime.now();
                for (long i = 0; i < T; i++) {
                    double N = printAsErr(reader.nextLong()); // rooms
                    double K = printAsErr((reader.nextLong())); // attempts

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

//                    Map<Integer, Integer> roomsMap = new HashMap<>(); // room number , # passages
//                    List<Long> passagesList = new ArrayList<>();
                    long passages = 0;

                    double jumpFactor = 1;
                    if (K < N) {
                        jumpFactor = N/K;
                    }

                    for (int j = 1; j <= K; j++) { // use all attempts

                        if (j > N) { // we checked all rooms
                            break;
                        }

                        long roomNumber = printAsErr((reader.nextLong()));
                        if (roomNumber == -1) { // I did something wrong
                            System.exit(0);
                        }
                        long amountOfPassages = printAsErr((reader.nextLong()));
                        passages += amountOfPassages;
//                        passagesList.add(amountOfPassages);
//                        roomsMap.put(roomNumber, amountOfPassages);

                        if (reader.hasNextLine()) {
                            reader.nextLine();
                        }

                        System.out.println(printAsErr(""T "" + Math.round(j * jumpFactor)));
                    }

                    long roomNumber = printAsErr((reader.nextLong()));
                    if (roomNumber == -1) { // I did something wrong
                        System.exit(0);
                    }
                    long amountOfPassages = printAsErr((reader.nextLong()));
                    passages += amountOfPassages;
//                    passagesList.add(amountOfPassages);
//                        roomsMap.put(roomNumber, amountOfPassages);

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

                    // make a guess
//                    long guess = (long) passagesList.stream().mapToLong(val -> val).average().orElse(0);
//                    int size = passagesList.size();
//                    long guess = (long) passagesList.stream().mapToLong(val -> val).sorted().skip((size-1)/2).limit(2-size%2).average().orElse(0);

//
//                    System.out.println(printAsErr(""E "" + guess * N / 2));
                    passages /= 2;
                    double desperateFactor = 0.05;
                    long guess;
                    if (K < N) {
                        guess = Math.round(passages * jumpFactor);
                    } else {
                        guess = passages;
                    }
                    System.out.println(printAsErr(""E "" + (long)(guess + desperateFactor*guess)));
                }
                LocalDateTime after = LocalDateTime.now();
                System.err.println(SECONDS.between(before, after) + "" sec"");
            }
        }
    }

    private static long printAsErr(long info) {
//        System.err.println(info);
        return info;
    }

    private static String printAsErr(String info) ",JanDL
8923,"class Solution {
    public static void main(String[] args) {

        try (Scanner reader = new Scanner(System.in)) {
            if (reader.hasNextLine() && reader.hasNextInt()) {
                long T = printAsErr(Integer.parseInt(reader.nextLine()));

                LocalDateTime before = LocalDateTime.now();
                for (long i = 0; i < T; i++) {
                    double N = printAsErr(reader.nextLong()); // rooms
                    double K = printAsErr((reader.nextLong())); // attempts

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

//                    Map<Integer, Integer> roomsMap = new HashMap<>(); // room number , # passages
//                    List<Long> passagesList = new ArrayList<>();
                    long passages = 0;

                    double jumpFactor = 1;
                    if (K < N) {
                        jumpFactor = N/K;
                    }

                    for (int j = 1; j <= K; j++) { // use all attempts

                        if (j > N) { // we checked all rooms
                            break;
                        }

                        long roomNumber = printAsErr((reader.nextLong()));
                        if (roomNumber == -1) { // I did something wrong
                            System.exit(0);
                        }
                        long amountOfPassages = printAsErr((reader.nextLong()));
                        passages += amountOfPassages;
//                        passagesList.add(amountOfPassages);
//                        roomsMap.put(roomNumber, amountOfPassages);

                        if (reader.hasNextLine()) {
                            reader.nextLine();
                        }

                        System.out.println(printAsErr(""T "" + Math.round(j * jumpFactor)));
                    }

                    long roomNumber = printAsErr((reader.nextLong()));
                    if (roomNumber == -1) { // I did something wrong
                        System.exit(0);
                    }
                    long amountOfPassages = printAsErr((reader.nextLong()));
                    passages += amountOfPassages;
//                    passagesList.add(amountOfPassages);
//                        roomsMap.put(roomNumber, amountOfPassages);

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

                    // make a guess
//                    long guess = (long) passagesList.stream().mapToLong(val -> val).average().orElse(0);
//                    int size = passagesList.size();
//                    long guess = (long) passagesList.stream().mapToLong(val -> val).sorted().skip((size-1)/2).limit(2-size%2).average().orElse(0);

//
//                    System.out.println(printAsErr(""E "" + guess * N / 2));
                    passages /= 2;
                    double desperateFactor = 0.00;
                    long guess;
                    if (K < N) {
                        guess = Math.round(passages * jumpFactor);
                    } else {
                        guess = passages;
                    }
                    System.out.println(printAsErr(""E "" + (long)(guess + desperateFactor*guess)));
                }
                LocalDateTime after = LocalDateTime.now();
                System.err.println(SECONDS.between(before, after) + "" sec"");
            }
        }
    }

    private static long printAsErr(long info) {
//        System.err.println(info);
        return info;
    }

    private static String printAsErr(String info) ",JanDL
8924,"class Solution {
    public static void main(String[] args) {

        try (Scanner reader = new Scanner(System.in)) {
            if (reader.hasNextLine() && reader.hasNextInt()) {
                long T = printAsErr(Integer.parseInt(reader.nextLine()));

                LocalDateTime before = LocalDateTime.now();
                for (long i = 0; i < T; i++) {
                    double N = printAsErr(reader.nextLong()); // rooms
                    double K = printAsErr((reader.nextLong())); // attempts

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

//                    Map<Integer, Integer> roomsMap = new HashMap<>(); // room number , # passages
//                    List<Long> passagesList = new ArrayList<>();
                    long passages = 0;

                    double jumpFactor = 1;
                    if (K < N) {
                        jumpFactor = N/K;
                    }

                    for (int j = 1; j <= K; j++) { // use all attempts

                        if (j > N) { // we checked all rooms
                            break;
                        }

                        long roomNumber = printAsErr((reader.nextLong()));
                        if (roomNumber == -1) { // I did something wrong
                            System.exit(0);
                        }
                        long amountOfPassages = printAsErr((reader.nextLong()));
                        passages += amountOfPassages;
//                        passagesList.add(amountOfPassages);
//                        roomsMap.put(roomNumber, amountOfPassages);

                        if (reader.hasNextLine()) {
                            reader.nextLine();
                        }

                        System.out.println(printAsErr(""T "" + Math.round(j * jumpFactor)));
                    }

                    long roomNumber = printAsErr((reader.nextLong()));
                    if (roomNumber == -1) { // I did something wrong
                        System.exit(0);
                    }
                    long amountOfPassages = printAsErr((reader.nextLong()));
                    passages += amountOfPassages;
//                    passagesList.add(amountOfPassages);
//                        roomsMap.put(roomNumber, amountOfPassages);

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

                    // make a guess
//                    long guess = (long) passagesList.stream().mapToLong(val -> val).average().orElse(0);
//                    int size = passagesList.size();
//                    long guess = (long) passagesList.stream().mapToLong(val -> val).sorted().skip((size-1)/2).limit(2-size%2).average().orElse(0);

//
//                    System.out.println(printAsErr(""E "" + guess * N / 2));
                    passages /= 2;
                    if (K < N) {
                        System.out.println(printAsErr(""E "" + Math.round(passages* jumpFactor)));
                    } else {
                        System.out.println(printAsErr(""E "" + passages/2));
                    }
                }
                LocalDateTime after = LocalDateTime.now();
                System.err.println(SECONDS.between(before, after) + "" sec"");
            }
        }
    }

    private static long printAsErr(long info) {
//        System.err.println(info);
        return info;
    }

    private static String printAsErr(String info) ",JanDL
8925,"class Solution {
    public static void main(String[] args) {

        try (Scanner reader = new Scanner(System.in)) {
            if (reader.hasNextLine() && reader.hasNextInt()) {
                long T = printAsErr(Integer.parseInt(reader.nextLine()));

                for (long i = 0; i < T; i++) {
                    long N = printAsErr(reader.nextLong()); // rooms
                    long K = printAsErr((reader.nextLong())); // attempts

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

//                    Map<Integer, Integer> roomsMap = new HashMap<>(); // room number , # passages
                    List<Long> passagesList = new ArrayList<>();
                    long passages = 0;

                    long jumpFactor = 1;
                    if (K < N) {
                        jumpFactor = N/K;
                    }

                    for (int j = 1; j <= K; j++) { // use all attempts

                        if (j > N) { // we checked all rooms
                            break;
                        }

                        long roomNumber = printAsErr((reader.nextLong()));
                        if (roomNumber == -1) { // I did something wrong
                            System.exit(0);
                        }
                        long amountOfPassages = printAsErr((reader.nextLong()));
                        passages += amountOfPassages;
                        passagesList.add(amountOfPassages);
//                        roomsMap.put(roomNumber, amountOfPassages);

                        if (reader.hasNextLine()) {
                            reader.nextLine();
                        }

                        System.out.println(printAsErr(""T "" + (j * jumpFactor)));
                    }

                    long roomNumber = printAsErr((reader.nextLong()));
                    if (roomNumber == -1) { // I did something wrong
                        System.exit(0);
                    }
                    long amountOfPassages = printAsErr((reader.nextLong()));
                    passages += amountOfPassages;
                    passagesList.add(amountOfPassages);
//                        roomsMap.put(roomNumber, amountOfPassages);

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

                    // make a guess
//                    long guess = (long) passagesList.stream().mapToLong(val -> val).average().orElse(0);
//                    int size = passagesList.size();
//                    long guess = (long) passagesList.stream().mapToLong(val -> val).sorted().skip((size-1)/2).limit(2-size%2).average().orElse(0);

//
//                    System.out.println(printAsErr(""E "" + guess * N / 2));
                    if (K < N) {
                        System.out.println(printAsErr(""E "" + passages / 2 * jumpFactor));
                    } else {
                        System.out.println(printAsErr(""E "" + passages/2));
                    }
                }
            }
        }
    }

    private static long printAsErr(long info) {
//        System.err.println(info);
        return info;
    }

    private static String printAsErr(String info) ",JanDL
8926,"class Solution {
    public static void main(String[] args) {

        try (Scanner reader = new Scanner(System.in)) {
            if (reader.hasNextLine() && reader.hasNextInt()) {
                long T = printAsErr(Integer.parseInt(reader.nextLine()));

                for (long i = 0; i < T; i++) {
                    long N = printAsErr(reader.nextLong()); // rooms
                    long K = printAsErr((reader.nextLong())); // attempts

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

//                    Map<Integer, Integer> roomsMap = new HashMap<>(); // room number , # passages
                    List<Long> passagesList = new ArrayList<>();
                    long passages = 0;

//                    int jumpFactor = 1;
//                    if (K < N) {
//                        jumpFactor = N/K;
//                    }

                    for (int j = 1; j <= K; j++) { // use all attempts

                        if (j > N) { // we checked all rooms
                            break;
                        }

                        long roomNumber = printAsErr((reader.nextLong()));
                        if (roomNumber == -1) { // I did something wrong
                            System.exit(0);
                        }
                        long amountOfPassages = printAsErr((reader.nextLong()));
                        passages += amountOfPassages;
                        passagesList.add(amountOfPassages);
//                        roomsMap.put(roomNumber, amountOfPassages);

                        if (reader.hasNextLine()) {
                            reader.nextLine();
                        }

                        System.out.println(printAsErr(""T "" + j));
                    }

                    long roomNumber = printAsErr((reader.nextLong()));
                    if (roomNumber == -1) { // I did something wrong
                        System.exit(0);
                    }
                    long amountOfPassages = printAsErr((reader.nextLong()));
                    passages += amountOfPassages;
                    passagesList.add(amountOfPassages);
//                        roomsMap.put(roomNumber, amountOfPassages);

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

                    // make a guess
                    long average = (long) passagesList.stream().mapToLong(val -> val).average().orElse(0);
                    System.out.println(printAsErr(""E "" + average * N / 2));
//                    if (K < N) {
//                        System.out.println(""E"" + average/2 * jumpFactor);
//                    } else {
//                        System.out.println(""E "" + average/2);
//                    }
                }
            }
        }
    }

    private static long printAsErr(long info) {
//        System.err.println(info);
        return info;
    }

    private static String printAsErr(String info) ",JanDL
8927,"class Solution {
    public static void main(String[] args) {

        try (Scanner reader = new Scanner(System.in)) {
            if (reader.hasNextLine() && reader.hasNextInt()) {
                int T = Integer.parseInt(reader.nextLine());

                for (long i = 0; i < T; i++) {
                    int N = reader.nextInt(); // rooms
                    int K = reader.nextInt(); // attempts

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

//                    Map<Integer, Integer> roomsMap = new HashMap<>(); // room number , # passages
                    List<Integer> passagesList = new ArrayList<>();
                    int passages = 0;

                    int jumpFactor = 1;
                    if (K < N) {
                        jumpFactor = N/K;
                    }

                    for (int j = 1; j <= K; j++) { // use all attempts

                        if (j > N) { // we checked all rooms
                            break;
                        }

                        int roomNumber = reader.nextInt();
                        if (roomNumber == -1) { // I did something wrong
                            System.exit(0);
                        }
                        int amountOfPassages = reader.nextInt();
                        passages += amountOfPassages;
                        passagesList.add(amountOfPassages);
//                        roomsMap.put(roomNumber, amountOfPassages);

                        if (reader.hasNextLine()) {
                            reader.nextLine();
                        }

                        System.out.println(""T "" + (j * jumpFactor));
                    }

                    // make a guess
                    int average = (int) passagesList.stream().mapToInt(val -> val).average().orElse(0);
                    System.out.println(""E "" + average * N / 2);
//                    if (K < N) {
//                        System.out.println(""E"" + average/2 * jumpFactor);
//                    } else {
//                        System.out.println(""E "" + average/2);
//                    }
                }
            }
        }
    }
}",JanDL
8928,"class Solution {
    public static void main(String[] args) {

        try (Scanner reader = new Scanner(System.in)) {
            if (reader.hasNextLine() && reader.hasNextInt()) {
                int T = Integer.parseInt(reader.nextLine());

                for (long i = 0; i < T; i++) {
                    int N = reader.nextInt(); // rooms
                    int K = reader.nextInt(); // attempts

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

//                    Map<Integer, Integer> roomsMap = new HashMap<>(); // room number , # passages
                    int passages = 0;

                    int jumpFactor = 1;
                    if (K < N) {
                        jumpFactor = N/K;
                    }
                    
                    for (int j = 1; j <= K; j++) { // use all attempts

                        if (j > N) { // we checked all rooms
                            break;
                        }

                        int roomNumber = reader.nextInt();
                        if (roomNumber == -1) { // I did something wrong
                            System.exit(0);
                        }
                        int amountOfPassages = reader.nextInt();
                        passages += amountOfPassages;
//                        roomsMap.put(roomNumber, amountOfPassages);

                        if (reader.hasNextLine()) {
                            reader.nextLine();
                        }

                        System.out.println(""T "" + (j * jumpFactor));
                    }

                    // make a guess
                    if (K < N) {
                        System.out.println(""E"" + passages/2 * jumpFactor);
                    } else {
                        System.",JanDL
8929,"class Solution {
    public static void main(String[] args) {

        try (Scanner reader = new Scanner(System.in)) {
            if (reader.hasNextLine() && reader.hasNextInt()) {
                int T = Integer.parseInt(reader.nextLine());

                for (long i = 0; i < T; i++) {
                    int N = reader.nextInt(); // rooms
                    int K = reader.nextInt(); // attempts

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

//                    Map<Integer, Integer> roomsMap = new HashMap<>(); // room number , # passages
                    int passages = 0;

                    for (int j = 1; j <= K; j++) { // use all attempts
                        //todo try taking jumps which rooms to check depending on the amount of moves

                        if (j > N) { // we checked all rooms
                            break;
                        }

                        int roomNumber = reader.nextInt();
                        if (roomNumber == -1) { // I did something wrong
                            System.exit(0);
                        }
                        int amountOfPassages = reader.nextInt();
                        passages += amountOfPassages;
//                        roomsMap.put(roomNumber, amountOfPassages);

                        if (reader.hasNextLine()) {
                            reader.nextLine();
                        }

                        System.out.println(""T "" + j);
                    }

                    // make a guess
                    if (K >= N) {
                        System.out.println(""E "" + passages/2);
                    } else {
                        System.",JanDL
8930,"class Solution {
    public static void main(String[] args) {
//        provideInput(""1
"" +
//                ""11
"" +
//                ""1 3 1 2 1 1 1 1 3 2 2
"" +
//                ""0 0 0 2 2 2 4 4 5 6 6
""); // 13
//        provideInput(""1
"" +
//                ""12
"" +
//                ""1 3 1 2 1 1 1 1 2 2 2 1
"" +
//                ""0 0 0 2 2 2 4 4 5 6 6 5
""); // 14
//        provideInput(""1
"" +
//                ""13
"" +
//                ""1 3 1 2 1 1 1 1 1 2 2 1 2
"" +
//                ""0 0 0 2 2 2 4 4 5 6 6 9 12
""); // 12

//        provideInput(""3
"" +
//                ""4
"" +
//                ""60 20 40 50
"" +
//                ""0 1 1 2
"" +
//                ""5
"" +
//                ""3 2 1 4 5
"" +
//                ""0 1 1 1 0
"" +
//                ""8
"" +
//                ""100 100 100 90 80 100 90 100
"" +
//                ""0 1 2 1 2 3 1 3
"");

        try (Scanner reader = new Scanner(System.in)) {
            if (reader.hasNextLine() && reader.hasNextInt()) {
                int T = Integer.parseInt(reader.nextLine());

                for (long i = 0; i < T; i++) {
                    long N = Integer.parseInt(reader.nextLine());

                    Node abyss = new Node(0);
                    List<Node> modules = new ArrayList<>();
                    modules.add(abyss);

                    for (int j = 1; j <= N; j++) {
                        modules.add(j, new Node(reader.nextLong()));
                    }

                    for (int j = 1; j <= N; j++) {
                        Node child = modules.get(j);
                        Node parent = modules.get(reader.nextInt());
                        child.parent.add(parent);
                        parent.child.add(child);
                    }

                    updateFunFromUnusedInitiator(abyss);

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

                    System.out.printf(""Case #%s: %s%n"", i + 1, abyss.fun);
                }
            }
        }
    }

    public static void updateFunFromUnusedInitiator(Node node) {
        long sumFun = 0;
        long minFun = Long.MAX_VALUE;

        Set<Node> children = node.child;
        if (children.isEmpty()) {
            node.minFun = node.fun;
            return;
        }

        for (Node child : children) {
            updateFunFromUnusedInitiator(child);
            minFun = Math.min(minFun, child.minFun);
            sumFun += child.fun;
        }

        node.minFun = Math.max(minFun, node.fun);
        node.fun += sumFun - Math.min(minFun, node.fun);
    }

    private static void provideInput(String data) {
        ByteArrayInputStream testIn;
        testIn = new ByteArrayInputStream(data.getBytes(StandardCharsets.UTF_8));
        System.setIn(testIn);
    }
}

class Node {
    public long fun, minFun;
    public Set<Node> parent, child;

    public Node(long fun) {
        this.fun = fun;
        this.minFun = Long.MAX_VALUE;
        this.parent = new HashSet<>();
        this.child = new HashSet<>();
    }
}",JanDL
8931,"class Solution {
    public static void main(String[] args) {
//        provideInput(""1
"" +
//                ""11
"" +
//                ""1 3 1 2 1 1 1 1 3 2 2
"" +
//                ""0 0 0 2 2 2 4 4 5 6 6
""); // 13
//        provideInput(""1
"" +
//                ""12
"" +
//                ""1 3 1 2 1 1 1 1 2 2 2 1
"" +
//                ""0 0 0 2 2 2 4 4 5 6 6 5
""); // 14

//        provideInput(""3
"" +
//                ""4
"" +
//                ""60 20 40 50
"" +
//                ""0 1 1 2
"" +
//                ""5
"" +
//                ""3 2 1 4 5
"" +
//                ""0 1 1 1 0
"" +
//                ""8
"" +
//                ""100 100 100 90 80 100 90 100
"" +
//                ""0 1 2 1 2 3 1 3
"");

        try (Scanner reader = new Scanner(System.in)) {
            if (reader.hasNextLine() && reader.hasNextInt()) {
                int T = Integer.parseInt(reader.nextLine());

                for (long i = 0; i < T; i++) {
                    long N = Integer.parseInt(reader.nextLine());

                    Node abyss = new Node(0);
                    List<Node> modules = new ArrayList<>();
                    modules.add(abyss);

                    for (int j = 1; j <= N; j++) {
                        modules.add(j, new Node(reader.nextLong()));
                    }

                    for (int j = 1; j <= N; j++) {
                        Node child = modules.get(j);
                        Node parent = modules.get(reader.nextInt());
                        child.parent.add(parent);
                        parent.child.add(child);
                    }

                    updateFunFromUnusedInitiator(abyss);

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

                    System.out.printf(""Case #%s: %s%n"", i + 1, abyss.fun);
                }
            }
        }
    }

    public static void updateFunFromUnusedInitiator(Node node) {
        long sumFun = 0;
        long minFun = 0;

        Set<Node> children = node.child;
        if (children.isEmpty() || node.used) {
            node.minFun = node.fun;
            node.used = true;
            return;
        }
        node.used = true;

        for (Node child : children) {
            updateFunFromUnusedInitiator(child);
            node.minFun = Math.min(node.minFun, child.minFun);
            sumFun += child.fun;
        }

        minFun = Math.max(node.minFun, node.fun);
        if (children.size() == 1) {
            node.fun = Math.max(sumFun, node.fun);
        } else {
            node.fun += sumFun - Math.min(node.minFun, node.fun);
        }
        node.minFun = minFun;
    }

    private static void provideInput(String data) {
        ByteArrayInputStream testIn;
        testIn = new ByteArrayInputStream(data.getBytes(StandardCharsets.UTF_8));
        System.setIn(testIn);
    }
}

class Node {
    public long fun, minFun;
    public Set<Node> parent, child;
    public boolean used;

    public Node(long fun) {
        this.fun = fun;
        this.minFun = Long.MAX_VALUE;
        this.parent = new HashSet<>();
        this.child = new HashSet<>();
        this.used = false;
    }
}",JanDL
8932,"class Solution {
    public static void main(String[] args) {
        // provideInput(""1
"" +
        //         ""16
"" +
        //         ""3 2 1 4 5 3 5 1 2 6 5 3 1 2 10 2
"" +
        //         ""0 1 1 1 0 3 3 5 5 4 0 6 6 6 4 4
"");

//        provideInput(""3
"" +
//                ""4
"" +
//                ""60 20 40 50
"" +
//                ""0 1 1 2
"" +
//                ""5
"" +
//                ""3 2 1 4 5
"" +
//                ""0 1 1 1 0
"" +
//                ""8
"" +
//                ""100 100 100 90 80 100 90 100
"" +
//                ""0 1 2 1 2 3 1 3
"");

        try (Scanner reader = new Scanner(System.in)) {
            if (reader.hasNextLine() && reader.hasNextInt()) {
                int T = Integer.parseInt(reader.nextLine());

                for (long i = 0; i < T; i++) {
                    long N = Integer.parseInt(reader.nextLine());

                    Node abyss = new Node(0);
                    List<Node> modules = new ArrayList<>();
                    modules.add(abyss);

                    for (int j = 1; j <= N; j++) {
                        modules.add(j, new Node(reader.nextLong()));
                    }

                    for (int j = 1; j <= N; j++) {
                        Node child = modules.get(j);
                        Node parent = modules.get(reader.nextInt());
                        child.parent.add(parent);
                        parent.child.add(child);
                    }

                    updateFunFromUnusedInitiator(abyss);

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

                    System.out.printf(""Case #%s: %s%n"", i + 1, abyss.fun);
                }
            }
        }
    }

    private static void provideInput(String data) {
        ByteArrayInputStream testIn;
        testIn = new ByteArrayInputStream(data.getBytes(StandardCharsets.UTF_8));
        System.setIn(testIn);
    }

    public static void updateFunFromUnusedInitiator(Node node) {
        long sumFun = 0;
        long minFun = 1_000_000_000;

        Set<Node> children = node.child;
        if (children.isEmpty() || node.used) {
            node.used = true;
            return;
        }

        for (Node child : children) {
            updateFunFromUnusedInitiator(child);
            minFun = Math.min(minFun, child.fun);
            sumFun += child.fun;
        }

        if (children.size() == 1) {
            node.fun = sumFun;
        } else {
            node.fun = Math.max(minFun, node.fun);
            node.fun += sumFun - minFun;
        }
        node.used = true;
    }
}

class Node {
    public long fun;
    public Set<Node> parent, child;
    public boolean used;

    public Node(long fun) {
        this.fun = fun;
        this.parent = new HashSet<>();
        this.child = new HashSet<>();
        this.used = false;
    }
}",JanDL
8933,"class Solution {
    public static void main(String[] args) {
//        provideInput(""1
"" +
//                ""16
"" +
//                ""3 2 1 4 5 3 5 1 2 6 5 3 1 2 10 2
"" +
//                ""0 1 1 1 0 3 3 5 5 4 0 6 6 6 4 4
"");

//        provideInput(""3
"" +
//                ""4
"" +
//                ""60 20 40 50
"" +
//                ""0 1 1 2
"" +
//                ""5
"" +
//                ""3 2 1 4 5
"" +
//                ""0 1 1 1 0
"" +
//                ""8
"" +
//                ""100 100 100 90 80 100 90 100
"" +
//                ""0 1 2 1 2 3 1 3
"");

        try (Scanner reader = new Scanner(System.in)) {
            if (reader.hasNextLine() && reader.hasNextInt()) {
                int T = Integer.parseInt(reader.nextLine());

                for (long i = 0; i < T; i++) {
                    long N = Integer.parseInt(reader.nextLine());

                    Node abyss = new Node(0);
                    List<Node> modules = new ArrayList<>();
                    modules.add(abyss);

                    for (int j = 1; j <= N; j++) {
                        modules.add(j, new Node(reader.nextLong()));
                    }

                    for (int j = 1; j <= N; j++) {
                        Node child = modules.get(j);
                        Node parent = modules.get(reader.nextInt());
                        child.parent.add(parent);
                        parent.child.add(child);
                    }

                    updateFunFromUnusedInitiator(abyss);

//                    for (int j = 0; j <= N; j++) {
//                        Node node = modules.get(j);
//                        if(!node.used) {
//                            abyss.fun += node.fun;
//                        }
//                    }

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

                    System.out.printf(""Case #%s: %s%n"", i + 1, abyss.fun);
                }
            }
        }
    }

    private static void provideInput(String data) {
        ByteArrayInputStream testIn;
        testIn = new ByteArrayInputStream(data.getBytes(StandardCharsets.UTF_8));
        System.setIn(testIn);
    }

    public static void updateFunFromUnusedInitiator(Node node) {
        long sumFun = 0;
        long minFun = 1_000_000_000;

        Set<Node> children = node.child;
        if (children.isEmpty()) {
            node.used = true;
            return;
        }

        for (Node child : children) {
            updateFunFromUnusedInitiator(child);
            minFun = Math.min(minFun, child.fun);
            sumFun += child.fun;
        }

        if (children.size() == 1) {
            node.fun = sumFun;
        } else {
            node.fun = Math.max(minFun, node.fun);
            node.fun += sumFun - minFun;
        }
        node.used = true;
    }
}

class Node {
    public long fun;
    public Set<Node> parent, child;
    public boolean used;

    public Node(long fun) {
        this.fun = fun;
        this.parent = new HashSet<>();
        this.child = new HashSet<>();
        this.used = false;
    }
}",JanDL
8934,"class Solution {
    public static void main(String[] args) {
//        provideInput(""1
"" +
//                ""11
"" +
//                ""3 2 1 4 5 3 5 1 2 6 5
"" +
//                ""0 1 1 1 0 3 3 5 5 4 0
"");

//        provideInput(""3
"" +
//                ""4
"" +
//                ""60 20 40 50
"" +
//                ""0 1 1 2
"" +
//                ""5
"" +
//                ""3 2 1 4 5
"" +
//                ""0 1 1 1 0
"" +
//                ""8
"" +
//                ""100 100 100 90 80 100 90 100
"" +
//                ""0 1 2 1 2 3 1 3
"");

        try (Scanner reader = new Scanner(System.in)) {
            if (reader.hasNextLine() && reader.hasNextInt()) {
                int T = Integer.parseInt(reader.nextLine());

                for (long i = 0; i < T; i++) {
                    long N = Integer.parseInt(reader.nextLine());

                    Node abyss = new Node(0);
                    List<Node> modules = new ArrayList<>();
                    modules.add(abyss);

                    for (int j = 1; j <= N; j++) {
                        modules.add(j, new Node(reader.nextLong()));
                    }

                    for (int j = 1; j <= N; j++) {
                        Node child = modules.get(j);
                        Node parent = modules.get(reader.nextInt());
                        child.parent.add(parent);
                        parent.child.add(child);
                    }

                    updateFunFromUnusedInitiator(abyss);

                    for (int j = 0; j <= N; j++) {
                        Node node = modules.get(j);
                        if(!node.used) {
                            abyss.fun += node.fun;
                        }
                    }

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

                    System.out.printf(""Case #%s: %s%n"", i + 1, abyss.fun);
                }
            }
        }
    }

    private static void provideInput(String data) {
        ByteArrayInputStream testIn;
        testIn = new ByteArrayInputStream(data.getBytes(StandardCharsets.UTF_8));
        System.setIn(testIn);
    }

    public static void updateFunFromUnusedInitiator(Node node) {
        long sumFun = 0;
        long minFun = 1_000_000_000;

        Set<Node> children = node.child;
        if (children.isEmpty()) {
            node.used = true;
            return;
        }

        for (Node child : children) {
            updateFunFromUnusedInitiator(child);
            minFun = Math.min(minFun, child.fun);
            sumFun += child.fun;
        }

        if (children.size() == 1) {
            node.fun = sumFun;
        } else {
            node.fun = Math.max(minFun, node.fun);
            node.fun += sumFun - minFun;
        }
        node.used = true;
    }
}

class Node {
    public long fun;
    public Set<Node> parent, child;
    public boolean used;

    public Node(long fun) {
        this.fun = fun;
        this.parent = new HashSet<>();
        this.child = new HashSet<>();
        this.used = false;
    }
}",JanDL
8935,"class Solution {
    public static void main(String[] args) {
//        provideInput(""1
"" +
//                ""10
"" +
//                ""3 2 1 4 5 3 5 1 2 6
"" +
//                ""0 1 1 1 0 3 3 5 5 4
"");

//        provideInput(""3
"" +
//                ""4
"" +
//                ""60 20 40 50
"" +
//                ""0 1 1 2
"" +
//                ""5
"" +
//                ""3 2 1 4 5
"" +
//                ""0 1 1 1 0
"" +
//                ""8
"" +
//                ""100 100 100 90 80 100 90 100
"" +
//                ""0 1 2 1 2 3 1 3
"");

        try (Scanner reader = new Scanner(System.in)) {
            if (reader.hasNextLine() && reader.hasNextInt()) {
                int T = Integer.parseInt(reader.nextLine());

                for (int i = 0; i < T; i++) {
                    int N = Integer.parseInt(reader.nextLine());

                    Node abyss = new Node(0);
                    List<Node> modules = new ArrayList<>();
                    modules.add(abyss);

                    for (int j = 1; j <= N; j++) {
                        modules.add(j, new Node(reader.nextInt()));
                    }

                    for (int j = 1; j <= N; j++) {
                        Node child = modules.get(j);
                        Node parent = modules.get(reader.nextInt());
                        child.parent.add(parent);
                        parent.child.add(child);
                    }

                    updateFunFromUnusedInitiator(abyss);

                    for (int j = 0; j <= N; j++) {
                        Node node = modules.get(j);
                        if(!node.used) {
                            abyss.fun += node.fun;
                        }
                    }

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

                    System.out.printf(""Case #%s: %s%n"", i + 1, abyss.fun);
                }
            }
        }
    }

    private static void provideInput(String data) {
        ByteArrayInputStream testIn;
        testIn = new ByteArrayInputStream(data.getBytes(StandardCharsets.UTF_8));
        System.setIn(testIn);
    }

    public static void updateFunFromUnusedInitiator(Node node) {
        int sumFun = 0;
        int minFun = 1_000_000_000;

        Set<Node> children = node.child;
        if (children.isEmpty()) {
            node.used = true;
            return;
        }

        for (Node child : children) {
            updateFunFromUnusedInitiator(child);
            minFun = Math.min(minFun, child.fun);
            sumFun += child.fun;
        }

        if (children.size() == 1) {
            node.fun = sumFun;
        } else {
            node.fun = Math.max(minFun, node.fun);
            node.fun += sumFun - minFun;
        }
        node.used = true;
    }
}

class Node {
    public int fun;
    public Set<Node> parent, child;
    public boolean used;

    public Node(int fun) {
        this.fun = fun;
        this.parent = new HashSet<>();
        this.child = new HashSet<>();
        this.used = false;
    }
}",JanDL
8936,"class Solution {
    public static void main(String[] args) {
//        provideInput(""3
"" +
//                ""4
"" +
//                ""60 20 40 50
"" +
//                ""0 1 1 2
"" +
//                ""5
"" +
//                ""3 2 1 4 5
"" +
//                ""0 1 1 1 0
"" +
//                ""8
"" +
//                ""100 100 100 90 80 100 90 100
"" +
//                ""0 1 2 1 2 3 1 3
"");

        try (Scanner reader = new Scanner(System.in)) {
            if (reader.hasNextLine() && reader.hasNextInt()) {
                int T = Integer.parseInt(reader.nextLine());

                for (int i = 0; i < T; i++) {
                    int N = Integer.parseInt(reader.nextLine());

                    Node abyss = new Node(0);
                    List<Node> modules = new ArrayList<>();
                    modules.add(abyss);

                    for (int j = 1; j <= N; j++) {
                        modules.add(j, new Node(reader.nextInt()));
                    }

                    for (int j = 1; j <= N; j++) {
                        Node child = modules.get(j);
                        Node parent = modules.get(reader.nextInt());
                        child.parent.add(parent);
                        parent.child.add(child);
                    }

                    updateFunFromUnusedInitiator(abyss);

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

                    System.out.printf(""Case #%s: %s%n"", i + 1, abyss.fun);
                }
            }
        }
    }

    private static void provideInput(String data) {
        ByteArrayInputStream testIn;
        testIn = new ByteArrayInputStream(data.getBytes(StandardCharsets.UTF_8));
        System.setIn(testIn);
    }

    public static void updateFunFromUnusedInitiator(Node node) {
        int sumFun = 0;
        int minFun = 1_000_000_000;

        Set<Node> children = node.child;
        if (children.isEmpty()) {
            return;
        }

        for (Node child : children) {
            updateFunFromUnusedInitiator(child);
            minFun = Math.min(minFun, child.fun);
            sumFun += child.fun;
        }

        if (children.size() == 1) {
            node.fun = sumFun;
        } else {
            node.fun = Math.max(minFun, node.fun);
            node.fun += sumFun - minFun;
        }
    }
}

class Node {
    public int fun;
    public Set<Node> parent, child;
    public boolean used;

    public Node(int fun) {
        this.fun = fun;
        this.parent = new HashSet<>();
        this.child = new HashSet<>();
        this.used = false;
    }
}",JanDL
8937,"class Solution {
    public static void main(String[] args) {
//        provideInput(""4
"" +
//                ""4
"" +
//                ""6 10 12 8
"" +
//                ""6
"" +
//                ""5 4 5 4 4 4
"" +
//                ""10
"" +
//                ""10 10 7 6 7 4 4 5 7 4
"" +
//                ""1
"" +
//                ""10
"");

        try (Scanner reader = new Scanner(System.in)) {
            if (reader.hasNextLine() && reader.hasNextInt()) {
                int T = Integer.parseInt(reader.nextLine());

                for (int i = 0; i < T; i++) {
                    int N = Integer.parseInt(reader.nextLine());

                    List<Integer> dice = new ArrayList<>();

                    for (int j = 0; j < N; j++) {
                        dice.add(reader.nextInt());
                    }
                    dice.sort(Comparator.naturalOrder());

                    int length = 0;
                    for (int die : dice) {
                        if (die > length) {
                            length++;
                        }
                    }
                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }
                    System.out.printf(""Case #%s: %s%n"", i + 1, length);
                }
            }
        }
    }

    private static void provideInput(String data) {
        ByteArrayInputStream testIn;
        testIn = new ByteArrayInputStream(data.getBytes(StandardCharsets.UTF_8));
        System.setIn(testIn);
    }
}
",JanDL
8938,"class Solution {
    public static void main(String[] args) {
//        provideInput(""4
"" +
//                ""4
"" +
//                ""6 10 12 8
"" +
//                ""6
"" +
//                ""5 4 5 4 4 4
"" +
//                ""14
"" +
//                ""10 10 7 6 7 4 4 5 7 4 5 5 5 12
"" +
//                ""1
"" +
//                ""10
"");

        try (Scanner reader = new Scanner(System.in)) {
            if (reader.hasNextLine() && reader.hasNextInt()) {
                int T = Integer.parseInt(reader.nextLine());

                for (int i = 0; i < T; i++) {
                    int N = Integer.parseInt(reader.nextLine());

                    List<Integer> dice = new ArrayList<>();

                    for (int j = 0; j < N; j++) {
                        dice.add(reader.nextInt());
                    }
                    dice.sort(Comparator.naturalOrder());

                    Set<Integer> rolledDice = new HashSet<>();
                    for (int die : dice) {
                        for (int j = 1; j <= die; j++) {
                            if (!rolledDice.contains(j)) {
                                rolledDice.add(j);
                                break;
                            }
                        }
                    }
                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }
                    System.out.printf(""Case #%s: %s%n"", i + 1, rolledDice.size());
                }
            }
        }
    }

    private static void provideInput(String data) {
        ByteArrayInputStream testIn;
        testIn = new ByteArrayInputStream(data.getBytes(StandardCharsets.UTF_8));
        System.setIn(testIn);
    }
}
",JanDL
8939,"class Solution {
    public static void main(String[] args) {
//        provideInput(""3
"" +
//                ""300000 200000 300000 500000
"" +
//                ""300000 200000 500000 300000
"" +
//                ""300000 500000 300000 200000
"" +
//                ""1000000 1000000 0 0
"" +
//                ""0 1000000 1000000 1000000
"" +
//                ""999999 999999 999999 999999
"" +
//                ""768763 148041 178147 984173
"" +
//                ""699508 515362 534729 714381
"" +
//                ""949704 625054 946212 951187
"");

        int million = 1_000_000;

        try (Scanner reader = new Scanner(System.in)) {
            if (reader.hasNextLine() && reader.hasNextInt()) {
                int T = Integer.parseInt(reader.nextLine());

                for (int i = 0; i < T; i++) {
                    Map<Integer, List<Integer>> printers = new HashMap<>();
                    for (int j = 0; j < 3; j++) {
                        printers.put(j, new ArrayList<>());
                        for (int k = 0; k < 4; k++) {
                            printers.get(j).add(reader.nextInt());
                        }
                        if (reader.hasNextLine()) {
                            reader.nextLine();
                        }
                    }
                    int sumMin = 0;
                    List<Integer> min = new ArrayList<>();
                    for (int j = 0; j < 4; j++) {
                        min.add(0);
                    }

                    for (int j = 0; j < 4; j++) {
                        int min1 = Math.min(printers.get(0).get(j), printers.get(1).get(j));
                        int min2 = Math.min(min1, printers.get(2).get(j));
                        sumMin += min2;

                        if (sumMin >= million) {
                            min.set(j, min2 - (sumMin - million));
                            break;
                        }
                        min.set(j, min2);
                    }

                    if (sumMin < million) {
                        System.out.printf(""Case #%s: IMPOSSIBLE%n"", i+1);
                    } else {
                        System.out.printf(""Case #%s: %s %s %s %s%n"", i + 1, min.get(0), min.get(1), min.get(2), min.get(3));
                    }
                }
            }
        }
    }

    private static void provideInput(String data) {
        ByteArrayInputStream testIn;
        testIn = new ByteArrayInputStream(data.getBytes(StandardCharsets.UTF_8));
        System.setIn(testIn);
    }
}
",JanDL
8940,"class Solution {
    public static void main(String[] args) {
//        provideInput(""3
"" +
//                ""3 4
"" +
//                ""2 2
"" +
//                ""2 3
"");

        try (Scanner reader = new Scanner(System.in)) {
            if (reader.hasNextLine() && reader.hasNextInt()) {
                int T = Integer.parseInt(reader.nextLine());

                for (int i = 0; i < T; i++) {
                    int R = reader.nextInt();
                    int C = reader.nextInt();

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

                    StringBuilder matrix = new StringBuilder("""");
                    System.out.printf(""Case #%s:
"", i+1);

                    if (R > 0) {
                        createBorderRow(-1, matrix, C);
                    }

                    for (int a = 0; a < R; a++) {
                        createNormalRow(a, matrix, C);
                        createBorderRow(a, matrix, C);
                    }

                    if (i+1 == T) {
                        System.out.println(matrix.toString().trim());
                    } else {
                        System.out.print(matrix);
                    }
                }
            }
        }
    }

    private static void createBorderRow(int row, StringBuilder matrix, int amountCols) {
        if (row == -1) {
            matrix.append(""."");
        } else {
            matrix.append(""+"");
        }
        for (int b = 0; b < amountCols; b++) {
            if (row == -1 && b == 0) {
                matrix.append("".+"");
            } else {
                matrix.append(""-+"");
            }
        }
        matrix.append(""
"");
    }

    private static void createNormalRow(int row, StringBuilder matrix, int amountCols) {
        if (row == 0) {
            matrix.append(""."");
        } else {
            matrix.append(""|"");
        }
        for (int b = 0; b < amountCols; b++) {
            matrix.append("".|"");
        }
        matrix.append(""
"");
    }


    private static void provideInput(String data) {
        ByteArrayInputStream testIn;
        testIn = new ByteArrayInputStream(data.getBytes(StandardCharsets.UTF_8));
        System.setIn(testIn);
    }
}
",JanDL
8941,"class Solution {
    public static void main(String[] args) {
        provideInput(""3
"" +
                ""3 4
"" +
                ""2 2
"" +
                ""2 3
"");

        try (Scanner reader = new Scanner(System.in)) {
            if (reader.hasNextLine() && reader.hasNextInt()) {
                int T = Integer.parseInt(reader.nextLine());

                for (int i = 0; i < T; i++) {
                    int R = reader.nextInt();
                    int C = reader.nextInt();

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

                    StringBuilder matrix = new StringBuilder("""");
                    System.out.printf(""Case #%s:
"", i+1);

                    if (R > 0) {
                        createBorderRow(-1, matrix, C);
                    }

                    for (int a = 0; a < R; a++) {
                        createNormalRow(a, matrix, C);
                        createBorderRow(a, matrix, C);
                    }

                    if (i+1 == T) {
                        System.out.println(matrix.toString().trim());
                    } else {
                        System.out.print(matrix);
                    }
                }
            }
        }
    }

    private static void createBorderRow(int row, StringBuilder matrix, int amountCols) {
        if (row == -1) {
            matrix.append(""."");
        } else {
            matrix.append(""+"");
        }
        for (int b = 0; b < amountCols; b++) {
            if (row == -1 && b == 0) {
                matrix.append("".+"");
            } else {
                matrix.append(""-+"");
            }
        }
        matrix.append(""
"");
    }

    private static void createNormalRow(int row, StringBuilder matrix, int amountCols) {
        if (row == 0) {
            matrix.append(""."");
        } else {
            matrix.append(""|"");
        }
        for (int b = 0; b < amountCols; b++) {
            matrix.append("".|"");
        }
        matrix.append(""
"");
    }


    private static void provideInput(String data) {
        ByteArrayInputStream testIn;
        testIn = new ByteArrayInputStream(data.getBytes(StandardCharsets.UTF_8));
        System.setIn(testIn);
    }
}
",JanDL
8942,"class Solution {
    public static void main(String[] args) {

        try (Scanner reader = new Scanner(System.in)) {
            if (reader.hasNextLine() && reader.hasNextInt()) {
                long T = Integer.parseInt(reader.nextLine());

//                LocalDateTime before = LocalDateTime.now();
                for (long i = 0; i < T; i++) {
                    double N = reader.nextLong(); // rooms
                    double K = (reader.nextLong()); // attempts

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

//                    Map<Integer, Integer> roomsMap = new HashMap<>(); // room number , # passages
                    List<Long> passagesList = new ArrayList<>();
                    long passages = 0;

                    double jumpFactor = 1;
                    if (K < N) {
                        jumpFactor = N / K;
                    }

                    for (int j = 1; j <= K; j++) { // use all attempts

                        if (j > N) { // we checked all rooms
                            break;
                        }

                        long roomNumber = (reader.nextLong());
                        if (roomNumber == -1) { // I did something wrong
                            System.exit(0);
                        }
                        long amountOfPassages = (reader.nextLong());
                        passages += amountOfPassages;
                        passagesList.add(amountOfPassages);
//                        roomsMap.put(roomNumber, amountOfPassages);

                        if (reader.hasNextLine()) {
                            reader.nextLine();
                        }

//                        System.out.println(""T "" + Math.round(j * jumpFactor));
                        System.out.println(""T "" + j);
                    }

                    long roomNumber = (reader.nextLong());
                    if (roomNumber == -1) { // I did something wrong
                        System.exit(0);
                    }
                    long amountOfPassages = (reader.nextLong());
                    passages += amountOfPassages;
                    passagesList.add(amountOfPassages);
//                        roomsMap.put(roomNumber, amountOfPassages);

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

                    // make a guess
                    double guess0 = passagesList.stream().mapToDouble(val -> val).average().orElse(0);
                    guess0 = guess0 * (double) N / (double) 2;
                    int size = passagesList.size();
                    double guess1 = passagesList.stream().mapToDouble(val -> val).sorted().skip((size - 1) / 2).limit(2 - size % 2).average().orElse(0);
                    guess1 = guess1 * (double) N / (double) 2;
//
//                    System.out.println(""E "" + guess * N / 2));
                    passages /= 2;
//                    double desperateFactor = 0;
                    double guess2;
                    if (K < N) {
                        guess2 = passages * jumpFactor;
                    } else {
                        guess2 = passages;
                    }
                    List<Double> guesses = new ArrayList<>();
//                    System.err.println(guess0);
//                    System.err.println(guess1);
//                    System.err.println(guess2);
                    if (guess0 == 0) {
                        guess0 = guess1;
                        if (guess0 == 0) {
                            guess0 = guess2;
                            guess1 = guess2;
                        }
                    }
                    if (guess1 == 0) {
                        guess1 = guess0;
                        if (guess1 == 0) {
                            guess1 = guess2;
                            guess0 = guess2;
                        }
                    }

                    guesses.add(guess0);
                    guesses.add(guess1);
                    guesses.add(guess2);

//                                       System.err.println(guesses.get(0));
//                    System.err.println(guesses.get(1));
//                    System.err.println(guesses.get(2));
                    guesses.sort(Comparator.naturalOrder());
//
//
//
//                    System.err.println(guesses.size());
//                    System.err.println(guesses.get(0));
//                    System.err.println(guesses.get(1));
//                    System.err.println(guesses.get(2));

                    long guess = Math.round(guesses.get(1)); // median

//                    long guess = (guess0 + guess1 + guess2) / 3;
                    System.out.println(""E "" + guess);
                }
//                LocalDateTime after = LocalDateTime.now();
//                System.err.println(SECONDS.between(before, after) + "" sec"");
            }
        }
    }
}",JanDL
8943,"class Solution {
    public static void main(String[] args) {

        try (Scanner reader = new Scanner(System.in)) {
            if (reader.hasNextLine() && reader.hasNextInt()) {
                long T = Integer.parseInt(reader.nextLine());

//                LocalDateTime before = LocalDateTime.now();
                for (long i = 0; i < T; i++) {
                    double N = reader.nextLong(); // rooms
                    double K = (reader.nextLong()); // attempts

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

//                    Map<Integer, Integer> roomsMap = new HashMap<>(); // room number , # passages
                    List<Long> passagesList = new ArrayList<>();
                    long passages = 0;

                    double jumpFactor = 1;
                    if (K < N) {
                        jumpFactor = N / K;
                    }

                    for (int j = 1; j <= K; j++) { // use all attempts

                        if (j > N) { // we checked all rooms
                            break;
                        }

                        long roomNumber = (reader.nextLong());
                        if (roomNumber == -1) { // I did something wrong
                            System.exit(0);
                        }
                        long amountOfPassages = (reader.nextLong());
                        passages += amountOfPassages;
                        passagesList.add(amountOfPassages);
//                        roomsMap.put(roomNumber, amountOfPassages);

                        if (reader.hasNextLine()) {
                            reader.nextLine();
                        }

                        System.out.println(""T "" + Math.round(j * jumpFactor));
                    }

                    long roomNumber = (reader.nextLong());
                    if (roomNumber == -1) { // I did something wrong
                        System.exit(0);
                    }
                    long amountOfPassages = (reader.nextLong());
                    passages += amountOfPassages;
                    passagesList.add(amountOfPassages);
//                        roomsMap.put(roomNumber, amountOfPassages);

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

                    // make a guess
                    double guess0 = passagesList.stream().mapToDouble(val -> val).average().orElse(0);
                    guess0 = guess0 * (double) N / (double) 2;
                    int size = passagesList.size();
                    double guess1 = passagesList.stream().mapToDouble(val -> val).sorted().skip((size - 1) / 2).limit(2 - size % 2).average().orElse(0);
                    guess1 = guess1 * (double) N / (double) 2;
//
//                    System.out.println(""E "" + guess * N / 2));
                    passages /= 2;
//                    double desperateFactor = 0;
                    double guess2;
                    if (K < N) {
                        guess2 = passages * jumpFactor;
                    } else {
                        guess2 = passages;
                    }
                    List<Double> guesses = new ArrayList<>();
//                    System.err.println(guess0);
//                    System.err.println(guess1);
//                    System.err.println(guess2);
                    if (guess0 == 0) {
                        guess0 = guess1;
                        if (guess0 == 0) {
                            guess0 = guess2;
                            guess1 = guess2;
                        }
                    }
                    if (guess1 == 0) {
                        guess1 = guess0;
                        if (guess1 == 0) {
                            guess1 = guess2;
                            guess0 = guess2;
                        }
                    }

                    guesses.add(guess0);
                    guesses.add(guess1);
                    guesses.add(guess2);

//                                       System.err.println(guesses.get(0));
//                    System.err.println(guesses.get(1));
//                    System.err.println(guesses.get(2));
                    guesses.sort(Comparator.naturalOrder());
//
//
//
//                    System.err.println(guesses.size());
//                    System.err.println(guesses.get(0));
//                    System.err.println(guesses.get(1));
//                    System.err.println(guesses.get(2));

                    long guess = Math.round(guesses.get(1)); // median

//                    long guess = (guess0 + guess1 + guess2) / 3;
                    System.out.println(""E "" + guess);
                }
//                LocalDateTime after = LocalDateTime.now();
//                System.err.println(SECONDS.between(before, after) + "" sec"");
            }
        }
    }
}",JanDL
8944,"class Solution {
    public static void main(String[] args) {

        try (Scanner reader = new Scanner(System.in)) {
            if (reader.hasNextLine() && reader.hasNextInt()) {
                long T = Integer.parseInt(reader.nextLine());

//                LocalDateTime before = LocalDateTime.now();
                for (long i = 0; i < T; i++) {
                    double N = reader.nextLong(); // rooms
                    double K = (reader.nextLong()); // attempts

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

//                    Map<Integer, Integer> roomsMap = new HashMap<>(); // room number , # passages
                    List<Long> passagesList = new ArrayList<>();
                    long passages = 0;

                    double jumpFactor = 1;
                    if (K < N) {
                        jumpFactor = N / K;
                    }

                    for (int j = 1; j <= K; j++) { // use all attempts

                        if (j > N) { // we checked all rooms
                            break;
                        }

                        long roomNumber = (reader.nextLong());
                        if (roomNumber == -1) { // I did something wrong
                            System.exit(0);
                        }
                        long amountOfPassages = (reader.nextLong());
                        passages += amountOfPassages;
                        passagesList.add(amountOfPassages);
//                        roomsMap.put(roomNumber, amountOfPassages);

                        if (reader.hasNextLine()) {
                            reader.nextLine();
                        }

                        System.out.println(""T "" + Math.round(j * jumpFactor));
                    }

                    long roomNumber = (reader.nextLong());
                    if (roomNumber == -1) { // I did something wrong
                        System.exit(0);
                    }
                    long amountOfPassages = (reader.nextLong());
                    passages += amountOfPassages;
                    passagesList.add(amountOfPassages);
//                        roomsMap.put(roomNumber, amountOfPassages);

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

                    // make a guess
                    double guess0 = passagesList.stream().mapToDouble(val -> val).average().orElse(0);
                    guess0 = guess0 * (double) N / (double) 2;
                    int size = passagesList.size();
                    double guess1 = passagesList.stream().mapToDouble(val -> val).sorted().skip((size - 1) / 2).limit(2 - size % 2).average().orElse(0);
                    guess1 = guess1 * (double) N / (double) 2;
//
//                    System.out.println(""E "" + guess * N / 2));
                    passages /= 2;
//                    double desperateFactor = 0;
                    double guess2;
                    if (K < N) {
                        guess2 = passages * jumpFactor;
                    } else {
                        guess2 = passages;
                    }
                    Set<Double> guesses = new TreeSet<>();
//                    System.err.println(guess0);
//                    System.err.println(guess1);
//                    System.err.println(guess2);
                    if (guess0 == 0) {
                        guess0 = guess1;
                        if (guess0 == 0) {
                            guess0 = guess2;
                            guess1 = guess2;
                        }
                    }
                    if (guess1 == 0) {
                        guess1 = guess0;
                        if (guess1 == 0) {
                            guess1 = guess2;
                            guess0 = guess2;
                        }
                    }
                    guesses.add(guess0);
                    guesses.add(guess1);
                    guesses.add(guess2);

                    Iterator<Double> iterator = guesses.iterator();
                    iterator.next();
                    long guess = Math.round(iterator.next()); // median

//                    long guess = (guess0 + guess1 + guess2) / 3;
                    System.out.println(""E "" + guess);
                }
//                LocalDateTime after = LocalDateTime.now();
//                System.err.println(SECONDS.between(before, after) + "" sec"");
            }
        }
    }
}",JanDL
8945,"class Solution {
    public static void main(String[] args) {

        try (Scanner reader = new Scanner(System.in)) {
            if (reader.hasNextLine() && reader.hasNextInt()) {
                long T = printAsErr(Integer.parseInt(reader.nextLine()));

//                LocalDateTime before = LocalDateTime.now();
                for (long i = 0; i < T; i++) {
                    double N = printAsErr(reader.nextLong()); // rooms
                    double K = printAsErr((reader.nextLong())); // attempts

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

//                    Map<Integer, Integer> roomsMap = new HashMap<>(); // room number , # passages
                    List<Long> passagesList = new ArrayList<>();
                    long passages = 0;

                    double jumpFactor = 1;
                    if (K < N) {
                        jumpFactor = N/K;
                    }

                    for (int j = 1; j <= K; j++) { // use all attempts

                        if (j > N) { // we checked all rooms
                            break;
                        }

                        long roomNumber = printAsErr((reader.nextLong()));
                        if (roomNumber == -1) { // I did something wrong
                            System.exit(0);
                        }
                        long amountOfPassages = printAsErr((reader.nextLong()));
                        passages += amountOfPassages;
                        passagesList.add(amountOfPassages);
//                        roomsMap.put(roomNumber, amountOfPassages);

                        if (reader.hasNextLine()) {
                            reader.nextLine();
                        }

                        System.out.println(printAsErr(""T "" + Math.round(j * jumpFactor)));
                    }

                    long roomNumber = printAsErr((reader.nextLong()));
                    if (roomNumber == -1) { // I did something wrong
                        System.exit(0);
                    }
                    long amountOfPassages = printAsErr((reader.nextLong()));
                    passages += amountOfPassages;
                    passagesList.add(amountOfPassages);
//                        roomsMap.put(roomNumber, amountOfPassages);

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

                    // make a guess
                    double guess0 = passagesList.stream().mapToDouble(val -> val).average().orElse(0);
                    guess0 = guess0 * (double) N / (double) 2;
                    int size = passagesList.size();
                    double guess1 = passagesList.stream().mapToDouble(val -> val).sorted().skip((size-1)/2).limit(2-size%2).average().orElse(0);
                    guess1 = guess1 * (double) N / (double) 2;
//
//                    System.out.println(printAsErr(""E "" + guess * N / 2));
                    passages /= 2;
//                    double desperateFactor = 0;
                    double guess2;
                    if (K < N) {
                        guess2 = passages * jumpFactor;
                    } else {
                        guess2 = passages;
                    }
                    Set<Double> guesses = new TreeSet<>();
//                    System.err.println(guess0);
//                    System.err.println(guess1);
//                    System.err.println(guess2);
                    if (guess0 == 0) {
                        guess0 = guess1;
                        if (guess0 == 0) {
                            guess0 = guess2;
                            guess1 = guess2;
                        }
                    }
                    if (guess1 == 0) {
                        guess1 = guess0;
                        if (guess1 == 0) {
                            guess1 = guess2;
                            guess0 = guess2;
                        }
                    }
                    guesses.add(guess0);
                    guesses.add(guess1);
                    guesses.add(guess2);

                    Iterator<Double> iterator = guesses.iterator();
                    iterator.next();
                    long guess = Math.round(iterator.next()); // median

//                    long guess = (guess0 + guess1 + guess2) / 3;
                    System.out.println(printAsErr(""E "" + guess));
                }
//                LocalDateTime after = LocalDateTime.now();
//                System.err.println(SECONDS.between(before, after) + "" sec"");
            }
        }
    }

    private static double printAsErr(double info) {
//        System.err.println(info);
        return info;
    }

    private static String printAsErr(String info) ",JanDL
8946,"class Solution {
    public static void main(String[] args) {

        try (Scanner reader = new Scanner(System.in)) {
            if (reader.hasNextLine() && reader.hasNextInt()) {
                long T = printAsErr(Integer.parseInt(reader.nextLine()));

//                LocalDateTime before = LocalDateTime.now();
                for (long i = 0; i < T; i++) {
                    double N = printAsErr(reader.nextLong()); // rooms
                    double K = printAsErr((reader.nextLong())); // attempts

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

//                    Map<Integer, Integer> roomsMap = new HashMap<>(); // room number , # passages
                    List<Long> passagesList = new ArrayList<>();
                    long passages = 0;

                    double jumpFactor = 1;
                    if (K < N) {
                        jumpFactor = N/K;
                    }

                    for (int j = 1; j <= K; j++) { // use all attempts

                        if (j > N) { // we checked all rooms
                            break;
                        }

                        long roomNumber = printAsErr((reader.nextLong()));
                        if (roomNumber == -1) { // I did something wrong
                            System.exit(0);
                        }
                        long amountOfPassages = printAsErr((reader.nextLong()));
                        passages += amountOfPassages;
                        passagesList.add(amountOfPassages);
//                        roomsMap.put(roomNumber, amountOfPassages);

                        if (reader.hasNextLine()) {
                            reader.nextLine();
                        }

                        System.out.println(printAsErr(""T "" + Math.round(j * jumpFactor)));
                    }

                    long roomNumber = printAsErr((reader.nextLong()));
                    if (roomNumber == -1) { // I did something wrong
                        System.exit(0);
                    }
                    long amountOfPassages = printAsErr((reader.nextLong()));
                    passages += amountOfPassages;
                    passagesList.add(amountOfPassages);
//                        roomsMap.put(roomNumber, amountOfPassages);

                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }

                    // make a guess
                    double guess0 = passagesList.stream().mapToDouble(val -> val).average().orElse(0);
                    guess0 = guess0 * (double) N / (double) 2;
                    int size = passagesList.size();
                    double guess1 = passagesList.stream().mapToDouble(val -> val).sorted().skip((size-1)/2).limit(2-size%2).average().orElse(0);
                    guess1 = guess1 * (double) N / (double) 2;
//
//                    System.out.println(printAsErr(""E "" + guess * N / 2));
                    passages /= 2;
//                    double desperateFactor = 0;
                    double guess2;
                    if (K < N) {
                        guess2 = passages * jumpFactor;
                    } else {
                        guess2 = passages;
                    }
                    Set<Double> guesses = new TreeSet<>();
//                    System.err.println(guess0);
//                    System.err.println(guess1);
//                    System.err.println(guess2);
                    if (guess0 == 0) {
                        guess0 = guess1;
                        if (guess0 == 0) {
                            guess0 = guess2;
                            guess1 = guess2;
                        }
                    }
                    if (guess1 == 0) {
                        guess1 = guess0;
                        if (guess1 == 0) {
                            guess1 = guess2;
                            guess0 = guess2;
                        }
                    }
                    guesses.add(guess0);
                    guesses.add(guess1);
                    guesses.add(guess2);

                    Iterator<Double> iterator = guesses.iterator();
                    iterator.next();
                    long guess = Math.round(iterator.next()); // median

//                    long guess = (guess0 + guess1 + guess2) / 3;
                    System.out.println(printAsErr(""E "" + guess));
                }
//                LocalDateTime after = LocalDateTime.now();
//                System.err.println(SECONDS.between(before, after) + "" sec"");
            }
        }
    }

    private static long printAsErr(long info) {
//        System.err.println(info);
        return info;
    }

    private static String printAsErr(String info) ",JanDL
9591,"class Solution {

    public static void main(String[] args) {
        final Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        final int testQuantity = in.nextInt();

        for (int i = 1; i <= testQuantity; ++i) {
            final long numberOfRooms = in.nextLong();
            final long mxNumberOfOperations = in.nextLong();
            // Rooms are numbered between 1 and N

            Map<Long, Long> passages = new HashMap<>();

            long currentRoom = in.nextLong();
            long passageQuantity = in.nextLong();

            passages.put(currentRoom, passageQuantity);

            for (int j = 0; j < mxNumberOfOperations; j++) {

                long nextRoom = numberOfRooms;
                while (true) {

                    nextRoom = nextRoom > 1 ? nextRoom - 1 : numberOfRooms;

                    if (!passages.keySet().contains(nextRoom)) {
                        break;
                    }

                    if (passages.keySet().size() >= numberOfRooms) {
                        break;
                    }

                }

                if (j % 2 == 0) {
                    System.out.printf(""T %s%n"", nextRoom);
                } else {
                    System.out.printf(""W%n"");
                }

                currentRoom = in.nextLong();
                passageQuantity = in.nextLong();
                passages.put(currentRoom, passageQuantity);

            }

            long passagesAns;

            long discovered = passages.keySet().size();
            long discoveredResult = passages.values().stream().mapToLong(Long::longValue).sum();
            long toDiscovered = numberOfRooms;

            passagesAns = ",MikBac
9592,"class Solution {

    public static void main(String[] args) {
        final Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        final int testQuantity = in.nextInt();

        for (int i = 1; i <= testQuantity; ++i) {
            final long numberOfRooms = in.nextLong();
            final long mxNumberOfOperations = in.nextLong();
            // Rooms are numbered between 1 and N

            Map<Long, Long> passages = new HashMap<>();

            long currentRoom = in.nextLong();
            long passageQuantity = in.nextLong();

            passages.put(currentRoom, passageQuantity);

            for (int j = 0; j < mxNumberOfOperations; j++) {

                long nextRoom = numberOfRooms;
                while (true) {

                    nextRoom = nextRoom > 1 ? nextRoom - 1 : numberOfRooms;

                    if (!passages.keySet().contains(nextRoom)) {
                        break;
                    }

                    if (passages.keySet().size() >= numberOfRooms) {
                        break;
                    }

                }

                if (j % 2 == 0) {
                    System.out.println(""T "" + nextRoom);
                } else {
                    System.out.println(""W"");
                }

                currentRoom = in.nextLong();
                passageQuantity = in.nextLong();
                passages.put(currentRoom, passageQuantity);

            }

            long passagesAns;

            long discovered = passages.keySet().size();
            long discoveredResult = passages.values().stream().mapToLong(Long::longValue).sum();
            long toDiscovered = numberOfRooms;

            passagesAns = ",MikBac
9593,"public class Solution {

    public static void main(String[] args) {
        final Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        final int testQuantity = in.nextInt();

        for (int i = 1; i <= testQuantity; ++i) {
            final long numberOfRooms = in.nextLong();
            final long mxNumberOfOperations = in.nextLong();
            // Rooms are numbered between 1 and N

            Map<Long, Long> passages = new HashMap<>();

            long currentRoom = in.nextLong();
            long passageQuantity = in.nextLong();

            passages.put(currentRoom, passageQuantity);

            for (int j = 0; j < mxNumberOfOperations; j++) {

                long nextRoom = numberOfRooms;
                while (true) {

                    nextRoom = nextRoom > 1 ? nextRoom - 1 : numberOfRooms;

                    if (!passages.keySet().contains(nextRoom)) {
                        break;
                    }

                    if (passages.keySet().size() >= numberOfRooms) {
                        break;
                    }

                }

                if (j % 2 == 0) {
                    System.out.println(""T "" + nextRoom);
                } else {
                    System.out.println(""W"");
                }

                currentRoom = in.nextLong();
                passageQuantity = in.nextLong();
                passages.put(currentRoom, passageQuantity);

            }

            long passagesAns;

            long discovered = passages.keySet().size();
            long discoveredResult = passages.values().stream().mapToLong(Long::longValue).sum();
            long toDiscovered = numberOfRooms;

            passagesAns = ",MikBac
9594,"public class Solution {

    private static final DecimalFormat df = new DecimalFormat(""0.00"");

    public static void main(String[] args) {
        final Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        final int testQuantity = in.nextInt();

        for (int i = 1; i <= testQuantity; ++i) {
            final long numberOfRooms = in.nextLong();
            final long mxNumberOfOperations = in.nextLong();
            // Rooms are numbered between 1 and N

            Map<Long, Long> passages = new HashMap<>();

            long currentRoom = in.nextLong();
            long passageQuantity = in.nextLong();

            passages.put(currentRoom, passageQuantity);

            for (int j = 0; j < mxNumberOfOperations; j++) {

                long nextRoom = numberOfRooms;
                while (true) {

                    nextRoom = nextRoom > 1 ? nextRoom - 1 : numberOfRooms;

                    if (!passages.keySet().contains(nextRoom)) {
                        break;
                    }

                    if (passages.keySet().size() >= numberOfRooms) {
                        break;
                    }

                }

                if (j % 2 == 0) {
                    System.out.println(""T "" + nextRoom);
                } else {
                    System.out.println(""W"");
                }

                currentRoom = in.nextLong();
                passageQuantity = in.nextLong();
                passages.put(currentRoom, passageQuantity);

            }

            long passagesAns;

            long discovered = passages.keySet().size();
            long discoveredResult = passages.values().stream().mapToLong(Long::longValue).sum();
            long toDiscovered = numberOfRooms;

            passagesAns = ",MikBac
9595,"public class Solution {

    public static void main(String[] args) {
        final Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        final int testQuantity = in.nextInt();

        for (int i = 1; i <= testQuantity; ++i) {
            final long numberOfRooms = in.nextLong();
            final long mxNumberOfOperations = in.nextLong();
            // Rooms are numbered between 1 and N

            Map<Long, Long> passages = new HashMap<>();

            long currentRoom = in.nextLong();
            long passageQuantity = in.nextLong();

            passages.put(currentRoom, passageQuantity);

            for (int j = 0; j < mxNumberOfOperations; j++) {

                long nextRoom = numberOfRooms;
                while (true) {

                    nextRoom = nextRoom > 1 ? nextRoom - 1 : numberOfRooms;

                    if (!passages.keySet().contains(nextRoom)) {
                        break;
                    }

                    if (passages.keySet().size() >= numberOfRooms) {
                        break;
                    }

                }

                //

                System.out.println(""T "" + nextRoom);
//                System.out.println(""W"");

                currentRoom = in.nextLong();
                passageQuantity = in.nextLong();

                passages.put(currentRoom, passageQuantity);
            }

            long passagesAns = ",MikBac
9596,"public class Solution {

    public static void main(String[] args) {
        final Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        final int testQuantity = in.nextInt();

        for (int i = 1; i <= testQuantity; ++i) {
            final long numberOfRooms = in.nextLong();
            final long mxNumberOfOperations = in.nextLong();
            // Rooms are numbered between 1 and N

            Map<Long, Long> passages = new HashMap<>();

            long currentRoom = in.nextLong();
            long passageQuantity = in.nextLong();

            passages.put(currentRoom, passageQuantity);

            for (int j = 0; j < mxNumberOfOperations; j++) {

                long nextRoom = numberOfRooms;
                while (true) {
                    if (!passages.keySet().contains(nextRoom)) {
                        break;
                    }
                    nextRoom = currentRoom - 1;
                }

                //

                System.out.println(""T "" + nextRoom);
//                System.out.println(""W"");

                currentRoom = in.nextLong();
                passageQuantity = in.nextLong();

                passages.put(currentRoom, passageQuantity);
            }

            long passagesAns = ",MikBac
9597,"public class Solution {

    public static void main(String[] args) {
        final Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        final long testQuantity = in.nextLong();

        for (long i = 1; i <= testQuantity; ++i) {
            final long modulesQuantity = in.nextLong();
            List<Long> edgesValues = new ArrayList<>();
            Set<Long> initModules = new HashSet();
            // <moduleId, moduleValue>
            Map<Long, Long> modules = new HashMap();
            for (long j = 1; j <= modulesQuantity; j++) {
                long edge = in.nextLong();
                modules.put(j, edge);
                initModules.add(j);
                edgesValues.add(edge);
            }

            // <moduleId, nextModuleId>
            Map<Long, Long> modulesPath = new HashMap();
            for (long j = 1; j <= modulesQuantity; j++) {
                long nextModule = in.nextLong();
                modulesPath.put(j, nextModule);
                initModules.remove(nextModule);
            }

            List<Long> freeModules = new ArrayList<>(modules.keySet());
            freeModules.removeAll(initModules);

            Map<Long, Long> initModulesValues = new HashMap();
            for (long initModule : initModules) {
                initModulesValues.put(initModule, modules.get(initModule));
            }

            Map<Long, Long> finalValues = new HashMap<>();

            while (true) {
                var entity = initModulesValues
                        .entrySet()
                        .stream()
                        .min(Comparator.comparingLong(Map.Entry::getValue))
                        .orElse(null);

                if (entity == null) {
                    break;
                }

                long nextValueKey = modulesPath.get(entity.getKey());

                if (nextValueKey == 0 || !freeModules.contains(nextValueKey)) {
                    finalValues.put(entity.getKey(), entity.getValue());
                    initModulesValues.remove(entity.getKey());
                    continue;
                }

                long nextValueValue = modules.get(nextValueKey);

                if (nextValueValue > entity.getValue()) {
                    initModulesValues.put(entity.getKey(), nextValueValue);
                    modulesPath.put(entity.getKey(), modulesPath.get(nextValueKey));
                    freeModules.remove(nextValueKey);
                } else {
                    modulesPath.put(entity.getKey(), modulesPath.get(nextValueKey));
                    freeModules.remove(nextValueKey);
                }
            }

            System.",MikBac
9598,"public class Solution {

    public static void main(String[] args) {
        final Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        final long testQuantity = in.nextLong();

        for (long i = 1; i <= testQuantity; ++i) {
            final long modulesQuantity = in.nextLong();
            List<Long> edgesValues = new ArrayList<>();
            Set<Long> initModules = new HashSet();
            // <moduleId, moduleValue>
            Map<Long, Long> modules = new HashMap();
            for (long j = 1; j <= modulesQuantity; j++) {
                long edge = in.nextLong();
                modules.put(j, edge);
                initModules.add(j);
                edgesValues.add(edge);
            }

            // <moduleId, nextModuleId>
            Map<Long, Long> modulesPath = new HashMap();
            for (long j = 1; j <= modulesQuantity; j++) {
                long nextModule = in.nextLong();
                modulesPath.put(j, nextModule);
                initModules.remove(nextModule);
            }

            //

//            long potentialMaxValue = 0;
//
//            Collections.sort(edgesValues, Collections.reverseOrder());
//            potentialMaxValue = edgesValues.stream().limit(initModules.size()).mapToLong(Long::longValue).sum();

            //

            List<Long> freeModules = new ArrayList<>();
            freeModules.addAll(modules.keySet());
            freeModules.removeAll(initModules);

            Map<Long, Long> initModulesValues = new HashMap();
            for (long initModule : initModules) {
                initModulesValues.put(initModule, modules.get(initModule));
            }

            Map<Long, Long> finalValues = new HashMap<>();

            while (true) {
                var entity = initModulesValues
                        .entrySet()
                        .stream()
                        .min(Comparator.comparingLong(o -> o.getValue()))
                        .orElse(null);

                if (entity == null) {
                    break;
                }
                
                long nextValueKey = modulesPath.get(entity.getKey());

                if (nextValueKey == 0 || !freeModules.contains(nextValueKey)) {
                    finalValues.put(entity.getKey(), entity.getValue());
                    initModulesValues.remove(entity.getKey());
                    continue;
                }

                long nextValueValue = modules.get(nextValueKey);

                if (nextValueValue > entity.getValue()) {
                    initModulesValues.put(entity.getKey(), nextValueValue);
                    freeModules.remove(nextValueKey);
                } else {
                    modulesPath.put(entity.getKey(), modulesPath.get(nextValueKey));
                }

            }

            System.",MikBac
9599,"public class Solution {

    public static void main(String[] args) {
        final Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        final long testQuantity = in.nextLong();

        for (long i = 1; i <= testQuantity; ++i) {
            final long modulesQuantity = in.nextLong();
            List<Long> edgesValues = new ArrayList<>();
            Set<Long> initModules = new HashSet();
            // <moduleId, moduleValue>
            Map<Long, Long> modules = new HashMap();
            for (long j = 1; j <= modulesQuantity; j++) {
                long edge = in.nextLong();
                modules.put(j, edge);
                initModules.add(j);
                edgesValues.add(edge);
            }

            // <moduleId, nextModuleId>
            Map<Long, Long> modulesPath = new HashMap();
            for (long j = 1; j <= modulesQuantity; j++) {
                long nextModule = in.nextLong();
                modulesPath.put(j, nextModule);
                initModules.remove(nextModule);
            }

            //

//            long potentialMaxValue = 0;
//
//            Collections.sort(edgesValues, Collections.reverseOrder());
//            potentialMaxValue = edgesValues.stream().limit(initModules.size()).mapToLong(Long::longValue).sum();

            //

            List<Long> freeModules = new ArrayList<>();
            freeModules.addAll(modules.keySet());
            freeModules.removeAll(initModules);

            Map<Long, Long> initModulesValues = new HashMap();
            for (long initModule : initModules) {
                initModulesValues.put(initModule, modules.get(initModule));
            }

            Map<Long, Long> finalValues = new HashMap<>();

            while (true) {
                var entity = initModulesValues
                        .entrySet()
                        .stream()
                        .min(Comparator.comparingLong(o -> o.getValue()))
                        .orElse(null);

                if (entity == null) {
                    break;
                }

                long nextValueKey = modulesPath.get(entity.getKey());
                if (nextValueKey == 0 || !freeModules.contains(nextValueKey)) {
                    finalValues.put(entity.getKey(), entity.getValue());
                    initModulesValues.remove(entity.getKey());
                    continue;
                }

                long nextValueValue = modules.get(nextValueKey);

                if (nextValueValue > entity.getValue()) {
                    initModulesValues.put(entity.getKey(), nextValueValue);
                    freeModules.remove(nextValueKey);
                } else {
                    modulesPath.put(entity.getKey(), modulesPath.get(nextValueKey));
                }

                if (freeModules.isEmpty()) {
                    break;
                }
            }

            System.",MikBac
9600,"public class Solution {

    public static void main(String[] args) {
        final Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        final long testQuantity = in.nextLong();

        for (long i = 1; i <= testQuantity; ++i) {
            final long modulesQuantity = in.nextLong();
            List<Long> edgesValues = new ArrayList<>();
            Set<Long> initModules = new HashSet();
            // <moduleId, moduleValue>
            Map<Long, Long> modules = new HashMap();
            for (long j = 1; j <= modulesQuantity; j++) {
                long edge = in.nextLong();
                modules.put(j, edge);
                initModules.add(j);
                edgesValues.add(edge);
            }

            // <moduleId, nextModuleId>
            Map<Long, Long> modulesPath = new HashMap();
            for (long j = 1; j <= modulesQuantity; j++) {
                long nextModule = in.nextLong();
                modulesPath.put(j, nextModule);
                initModules.remove(nextModule);
            }

            //

//            long potentialMaxValue = 0;
//
//            Collections.sort(edgesValues, Collections.reverseOrder());
//            potentialMaxValue = edgesValues.stream().limit(initModules.size()).mapToLong(Long::longValue).sum();

            //

            List<Long> freeModules = new ArrayList<>();
            freeModules.addAll(modules.keySet());
            freeModules.removeAll(initModules);

            Map<Long, Long> initModulesValues = new HashMap();
            for (long initModule : initModules) {
                initModulesValues.put(initModule, modules.get(initModule));
            }

            while (true) {
                var entity = initModulesValues.entrySet()
                        .stream()
                        .min(Comparator.comparingLong(o -> o.getValue()))
                        .get();

                long nextValueKey = modulesPath.get(entity.getKey());
                if (nextValueKey == 0 || !freeModules.contains(nextValueKey)) {
                    break;
                }

                long nextValueValue = modules.get(nextValueKey);

                if (nextValueValue > entity.getValue()) {
                    initModulesValues.put(entity.getKey(), nextValueValue);
                    freeModules.remove(nextValueKey);
                } else {
                    modulesPath.put(entity.getKey(), modulesPath.get(nextValueKey));
                }

                if (freeModules.isEmpty()) {
                    break;
                }
            }

            System.",MikBac
9601,"public class Solution {

    public static void main(String[] args) {
        final Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        final long testQuantity = in.nextLong();

        for (long i = 1; i <= testQuantity; ++i) {
            final long modulesQuantity = in.nextLong();
            List<Long> edgesValues = new ArrayList<>();
            Set<Long> initModules = new HashSet();
            // <moduleId, moduleValue>
            Map<Long, Long> modules = new HashMap();
            for (long j = 1; j <= modulesQuantity; j++) {
                long edge = in.nextLong();
                modules.put(j, edge);
                initModules.add(j);
                edgesValues.add(edge);
            }

            // <moduleId, nextModuleId>
            Map<Long, Long> modulesPath = new HashMap();
            for (long j = 1; j <= modulesQuantity; j++) {
                long nextModule = in.nextLong();
                modulesPath.put(j, nextModule);
                initModules.remove(nextModule);
            }

            //

            long potentialMaxValue = 0;

            Collections.sort(edgesValues, Collections.reverseOrder());
            potentialMaxValue = edgesValues.stream().limit(initModules.size()).mapToLong(Long::longValue).sum();

            //
            List<SearchModel> visitedModulesList = new ArrayList<>();
            for (var initModule : initModules) {
                Map<Long, Long> visitedModules = new HashMap<>();
                long currentModule = initModule;
                visitedModules.put(currentModule, modules.get(currentModule));
                long pathValue = modules.get(currentModule);

                while (true) {
                    currentModule = modulesPath.get(currentModule);

                    if (currentModule == 0) {
                        break;
                    }

                    visitedModules.put(currentModule, modules.get(currentModule));

                    pathValue += modules.get(currentModule);

                }

                visitedModulesList.add(new SearchModel(pathValue, visitedModules));
            }

            Set<Long> visitedModules = new HashSet<>();
            long maxSum = 0;

            visitedModulesList.sort(Comparator.comparingLong(o -> o.sum));
            for (var pathElement : visitedModulesList) {
                var path = pathElement.map;
                path.keySet().removeAll(visitedModules);
                var entity = Collections.max(path.entrySet(), Comparator.comparingLong(Map.Entry::getValue));
                visitedModules.add(entity.getKey());
                maxSum += entity.getValue();
            }

            //
            System.out.printf(""Case #%s: %s%n"", i, maxSum);
        }
    }

    private static class SearchModel {
        public long sum;
        public Map<Long, Long> map;

        public SearchModel(final long sum, final Map<Long, Long> map) {
            this.sum = sum;
            this.map = map;
        }

        @Override
        public String toString() ",MikBac
9602,"public class Solution {

    public static void main(String[] args) {
        final Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        final long testQuantity = in.nextLong();

        for (long i = 1; i <= testQuantity; ++i) {
            final long modulesQuantity = in.nextLong();
            Set<Long> initModules = new HashSet();
            // <moduleId, moduleValue>
            Map<Long, Long> modules = new HashMap();
            for (long j = 1; j <= modulesQuantity; j++) {
                modules.put(j, in.nextLong());
                initModules.add(j);
            }

            // <moduleId, nextModuleId>
            Map<Long, Long> modulesPath = new HashMap();
            for (long j = 1; j <= modulesQuantity; j++) {
                long nextModule = in.nextLong();
                modulesPath.put(j, nextModule);
                initModules.remove(nextModule);
            }
            long maxRoundValueSum = 0;

            List<List<Long>> permutations = getPermutations(new ArrayList<>(initModules));

            for (var permutation : permutations) {

                long roundValueSum = 0;
                Set<Long> visitedModules = new HashSet();
                for (var initModule : permutation) {

                    visitedModules.add(initModule);
                    long currentModule = initModule;
                    long maxVisitedElement = modules.get(currentModule);

                    while (true) {
                        currentModule = modulesPath.get(currentModule);
                        if (currentModule == 0 || visitedModules.contains(currentModule)) {
                            break;
                        }
                        visitedModules.add(currentModule);

                        long newVisitedModuleValue = modules.get(currentModule);
                        if (newVisitedModuleValue > maxVisitedElement) {
                            maxVisitedElement = newVisitedModuleValue;
                        }
                    }
                    roundValueSum += maxVisitedElement;
                }

                if (roundValueSum > maxRoundValueSum) {
                    maxRoundValueSum = roundValueSum;
                }
            }

            System.out.printf(""Case #%s: %s%n"", i, maxRoundValueSum);
        }
    }

    public static List<List<Long>> getPermutations(List<Long> initModules) {
        if (initModules.isEmpty()) {
            List<List<Long>> result = new ArrayList<>();
            result.add(new ArrayList<>());
            return result;
        }

        Long firstElement = initModules.remove(0);
        List<List<Long>> ans = new ArrayList<>();
        List<List<Long>> permutations = getPermutations(initModules);

        for (List<Long> smallerPermutation : permutations) {
            for (long i = 0; i <= smallerPermutation.size(); i++) {
                List<Long> newSmallerPermutation = new ArrayList<>(smallerPermutation);
                newSmallerPermutation.add((int) i, firstElement);
                ans.",MikBac
9603,"public class Solution {

    public static void main(String[] args) {
        final Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        final int testQuantity = in.nextInt();

        for (int i = 1; i <= testQuantity; ++i) {
            final int modulesQuantity = in.nextInt();
            Set<Integer> initModules = new HashSet();
            // <moduleId, moduleValue>
            Map<Integer, Integer> modules = new HashMap();
            for (int j = 1; j <= modulesQuantity; j++) {
                modules.put(j, in.nextInt());
                initModules.add(j);
            }

            // <moduleId, nextModuleId>
            Map<Integer, Integer> modulesPath = new HashMap();
            for (int j = 1; j <= modulesQuantity; j++) {
                int nextModule = in.nextInt();
                modulesPath.put(j, nextModule);
                initModules.remove(nextModule);
            }

            int maxRoundValueSum = 0;

            List<List<Integer>> permutations = getPermutations(new ArrayList<>(initModules));

            for (var permutation : permutations) {

                int roundValueSum = 0;
                Set<Integer> visitedModules = new HashSet();
                for (var initModule : permutation) {

                    visitedModules.add(initModule);
                    int currentModule = initModule;
                    int maxVisitedElement = modules.get(currentModule);

                    while (true) {
                        currentModule = modulesPath.get(currentModule);
                        if (currentModule == 0 || visitedModules.contains(currentModule)) {
                            break;
                        }
                        visitedModules.add(currentModule);
                        int newVisitedModuleValue = modules.get(currentModule);
                        if (newVisitedModuleValue > maxVisitedElement) {
                            maxVisitedElement = newVisitedModuleValue;
                        }
                    }
                    roundValueSum += maxVisitedElement;
                }
                if (roundValueSum > maxRoundValueSum) {
                    maxRoundValueSum = roundValueSum;
                }
            }

            System.out.printf(""Case #%s: %s%n"", i, maxRoundValueSum);
        }
    }

    public static List<List<Integer>> getPermutations(List<Integer> initModules) {
        if (initModules.isEmpty()) {
            List<List<Integer>> result = new ArrayList<>();
            result.add(new ArrayList<>());
            return result;
        }

        Integer firstElement = initModules.remove(0);
        List<List<Integer>> ans = new ArrayList<>();
        List<List<Integer>> permutations = getPermutations(initModules);

        for (List<Integer> smallerPermutation : permutations) {
            for (int i = 0; i <= smallerPermutation.size(); i++) {
                List<Integer> newSmallerPermutation = new ArrayList<>(smallerPermutation);
                newSmallerPermutation.add(i, firstElement);
                ans.",MikBac
9604,"public class Solution {

    public static void main(String[] args) {
        final Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        final int testQuantity = in.nextInt();

        for (int i = 1; i <= testQuantity; ++i) {
            final int diceQuantity = in.nextInt();
            Map<Integer, Integer> dices = new TreeMap<>();
            for (int j = 0; j < diceQuantity; j++) {
                int nextValue = in.nextInt();
                dices.put(nextValue, dices.getOrDefault(nextValue, 0) + 1);
            }

            int counter = 0;

            for (var entry : dices.entrySet()) {
                counter += entry.getValue();
                if (counter > entry.getKey()) {
                    counter = entry.getKey();
                }
            }

            System.",MikBac
9605,"public class Solution {

    public static void main(String[] args) {
        final Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        final int testQuantity = in.nextInt();

        for (int i = 1; i <= testQuantity; ++i) {
            final int diceQuantity = in.nextInt();
            Map<Integer, Integer> dices = new HashMap<>();
            for (int j = 0; j < diceQuantity; j++) {
                int nextValue = in.nextInt();
                dices.put(nextValue, dices.getOrDefault(nextValue, 0) + 1);
            }

            int counter = 0;
            for (var entry : dices.entrySet()) {
                if (entry.getKey() > counter) {
                    counter += entry.getValue();
                }
                if (counter > entry.getKey()) {
                    counter = entry.getKey();
                }
            }

            System.",MikBac
9606,"public class Solution {

    public static void main(String[] args) {
        final Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        final int testQuantity = in.nextInt();

        for (int i = 1; i <= testQuantity; ++i) {
            final int diceQuantity = in.nextInt();
            Map<Integer, Integer> dices = new HashMap<>();
            for (int j = 0; j < diceQuantity; j++) {
                int nextValue = in.nextInt();
                dices.put(nextValue, dices.getOrDefault(nextValue, 0) + 1);
            }

            int counter = 0;
            for (var entry : dices.entrySet()) {
                int toAdd = entry.getValue() > entry.getKey() ? entry.getKey() : entry.getValue();
                counter += toAdd;
                if (counter > entry.getKey()) {
                    counter = entry.getKey();
                }
            }

            System.",MikBac
9607,"public class Solution {

    public static void main(String[] args) {
        final Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        final int testQuantity = in.nextInt();

        for (int i = 1; i <= testQuantity; ++i) {
            final int diceQuantity = in.nextInt();
            Map<Integer, Integer> dices = new HashMap<>();
            for (int j = 0; j < diceQuantity; j++) {
                int nextValue = in.nextInt();
                dices.put(nextValue, dices.getOrDefault(nextValue, 0) + 1);
            }

            int counter = 0;

            for (var entry : dices.entrySet()) {
                if (entry.getValue() > entry.getKey()) {
                    counter = entry.getKey();
                } else {
                    int newCounter = counter + entry.getValue();
                    counter = newCounter > entry.getKey() ? entry.getKey() : newCounter;
                }
            }

            System.",MikBac
9608,"public class Solution {

    public static void main(String[] args) {
        final Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        final int testQuantity = in.nextInt();

        for (int i = 1; i <= testQuantity; ++i) {
            final int diceQuantity = in.nextInt();
            Map<Integer, Integer> dices = new HashMap<>();
            for (int j = 0; j < diceQuantity; j++) {
                int nextValue = in.nextInt();
                dices.put(nextValue, dices.getOrDefault(nextValue, 0) + 1);
            }

            int counter = 0;

            for (var entry : dices.entrySet()) {
                counter += entry.getValue();
                if (counter > entry.getKey()) {
                    counter = entry.getKey();
                }
            }

            System.",MikBac
9609,"public class Solution {

    public static void main(String[] args) {
        final Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        final int testQuantity = in.nextInt();

        for (int i = 1; i <= testQuantity; ++i) {
            final int diceQuantity = in.nextInt();
            Map<Integer, Integer> dices = new HashMap<>();
            for (int j = 0; j < diceQuantity; j++) {
                int nextValue = in.nextInt();
                dices.put(nextValue, dices.getOrDefault(nextValue, 0) + 1);
            }

            int counter = 0;

            for (int j : dices.keySet()) {
                int minJQuantity = dices.get(j);

                counter = j < minJQuantity ? j : counter + minJQuantity;
                if (counter > j) {
                    counter = j;
                }
            }

            System.",MikBac
9610,"public class Solution {

    public static void main(String[] args) {
        final Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        final int testQuantity = in.nextInt();

        for (int i = 1; i <= testQuantity; ++i) {
            final int diceQuantity = in.nextInt();
            Map<Integer, Integer> dices = new HashMap<>();
            for (int j = 0; j < diceQuantity; j++) {
                int nextValue = in.nextInt();
                dices.put(nextValue, dices.getOrDefault(nextValue, 0) + 1);
            }

            int minKey = dices.keySet().stream().min(Integer::compare).get();
            int minKeyValuesQuantity = dices.get(minKey);

            int counter = Math.min(minKey, minKeyValuesQuantity);

            dices.remove(minKey);

            while (!dices.isEmpty()) {
                minKey = dices.keySet().stream().min(Integer::compare).get();
                minKeyValuesQuantity = dices.get(minKey);

                if (minKeyValuesQuantity > minKey) {
                    counter = minKey;
                } else {
                    if (counter + minKeyValuesQuantity > minKey) {
                        counter = minKey;
                    } else {
                        counter += minKeyValuesQuantity;
                    }

                }

                dices.remove(minKey);
            }

            System.",MikBac
9611,"public class Solution {

    public static void main(String[] args) {
        final Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        final int testQuantity = in.nextInt();

        for (int i = 1; i <= testQuantity; ++i) {
            final int diceQuantity = in.nextInt();
            List<Integer> dices = new ArrayList<>();
            for (int j = 0; j < diceQuantity; j++) {
                dices.add(in.nextInt());
            }

            int counter = 0;

            while (true) {
                int min = dices.stream().min(Integer::compare).orElse(0);
                dices.remove((Integer) min);
                if (min > counter) {
                    if (min - 1 == counter) {
                        dices.removeAll(Collections.singleton(min));
                    }
                    counter++;
                }
                if (min == 0) {
                    break;
                }
            }

            System.",MikBac
9612,"public class Solution {

    public static void main(String[] args) {
        final Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        final int testQuantity = in.nextInt();

        for (int i = 1; i <= testQuantity; ++i) {
            final int diceQuantity = in.nextInt();
            List<Integer> dices = new ArrayList<>();
            for (int j = 0; j < diceQuantity; j++) {
                dices.add(in.nextInt());
            }

            int counter = 0;

            while (true) {
                int min = dices.stream().min(Integer::compare).orElse(0);
                dices.remove((Integer) min);
                if (min > counter) {
                    counter++;
                }
                if (min == 0) {
                    break;
                }
            }

            System.",MikBac
9613,"public class Solution {

    public static void main(String[] args) {
        final Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        final int testQuantity = in.nextInt();

        for (int i = 1; i <= testQuantity; ++i) {
            final int p1C = in.nextInt();
            final int p1M = in.nextInt();
            final int p1Y = in.nextInt();
            final int p1K = in.nextInt();

            final int p2C = in.nextInt();
            final int p2M = in.nextInt();
            final int p2Y = in.nextInt();
            final int p2K = in.nextInt();

            final int p3C = in.nextInt();
            final int p3M = in.nextInt();
            final int p3Y = in.nextInt();
            final int p3K = in.nextInt();

            int minC = Arrays.asList(p1C, p2C, p3C).stream().min(Integer::compare).get();
            int minM = Arrays.asList(p1M, p2M, p3M).stream().min(Integer::compare).get();
            int minY = Arrays.asList(p1Y, p2Y, p3Y).stream().min(Integer::compare).get();
            int minK = Arrays.asList(p1K, p2K, p3K).stream().min(Integer::compare).get();

            int minSum = minC + minM + minY + minK;

            if (minSum < 1_000_000) {
                System.out.printf(""Case #%s: %s%n"", i, ""IMPOSSIBLE"");
                continue;
            }

            int basicSum = 1_000_000;

            int ansC = 0;
            int ansM = 0;
            int ansY = 0;
            int ansK = 0;

            if (minC >= basicSum) {
                ansC = basicSum;
                System.out.printf(""Case #%s: %s %s %s %s%n"", i, ansC, ansM, ansY, ansK);
                continue;
            } else {
                ansC = minC;
                basicSum -= minC;
            }

            if (minM >= basicSum) {
                ansM = basicSum;
                System.out.printf(""Case #%s: %s %s %s %s%n"", i, ansC, ansM, ansY, ansK);
                continue;
            } else {
                ansM = minM;
                basicSum -= minM;
            }

            if (minY >= basicSum) {
                ansY = basicSum;
                System.out.printf(""Case #%s: %s %s %s %s%n"", i, ansC, ansM, ansY, ansK);
                continue;
            } else {
                ansY = minY;
                basicSum -= minY;
            }

            if (minK >= basicSum) {
                ansK = basicSum;
                System.",MikBac
9614,"public class Solution {

    public static void main(String[] args) {
        final Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        final int testQuantity = in.nextInt();

        for (int i = 1; i <= testQuantity; ++i) {
            final int p1C = in.nextInt();
            final int p1M = in.nextInt();
            final int p1Y = in.nextInt();
            final int p1K = in.nextInt();

            final int p2C = in.nextInt();
            final int p2M = in.nextInt();
            final int p2Y = in.nextInt();
            final int p2K = in.nextInt();

            final int p3C = in.nextInt();
            final int p3M = in.nextInt();
            final int p3Y = in.nextInt();
            final int p3K = in.nextInt();

            int minC = Arrays.asList(p1C, p2C, p3C).stream().min(Integer::compare).get();
            int minM = Arrays.asList(p1M, p2M, p3M).stream().min(Integer::compare).get();
            int minY = Arrays.asList(p1Y, p2Y, p3Y).stream().min(Integer::compare).get();
            int minK = Arrays.asList(p1K, p2K, p3K).stream().min(Integer::compare).get();

            int minSum = minC + minM + minY + minK;

            if (minSum < 1_000_000) {
                System.out.printf(""Case #%s: %s%n"", i, ""IMPOSSIBLE"");
                continue;
            }

            final int basicSum = 1_000_000;

            int ansC = 0;
            int ansM = 0;
            int ansY = 0;
            int ansK = 0;

            if (minC >= basicSum) {
                ansC = basicSum;
                System.out.printf(""Case #%s: %s %s %s %s%n"", i, ansC, ansM, ansY, ansK);
                continue;
            } else {
                ansC = minC;
                basicSum -= minC;
            }

            if (minM >= basicSum) {
                ansM = basicSum;
                System.out.printf(""Case #%s: %s %s %s %s%n"", i, ansC, ansM, ansY, ansK);
                continue;
            } else {
                ansM = minM;
                basicSum -= minM;
            }

            if (minY >= basicSum) {
                ansY = basicSum;
                System.out.printf(""Case #%s: %s %s %s %s%n"", i, ansC, ansM, ansY, ansK);
                continue;
            } else {
                ansY = minY;
                basicSum -= minY;
            }

            if (minK >= basicSum) {
                ansK = basicSum;
                System.",MikBac
9615,"public class Solution {

    public static void main(String[] args) {
        final Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        final int testQuantity = in.nextInt();

        for (int i = 1; i <= testQuantity; ++i) {
            final int p1C = in.nextInt();
            final int p1M = in.nextInt();
            final int p1Y = in.nextInt();
            final int p1K = in.nextInt();

            final int p2C = in.nextInt();
            final int p2M = in.nextInt();
            final int p2Y = in.nextInt();
            final int p2K = in.nextInt();

            final int p3C = in.nextInt();
            final int p3M = in.nextInt();
            final int p3Y = in.nextInt();
            final int p3K = in.nextInt();

            int minC = Arrays.asList(p1C, p2C, p3C).stream().min(Integer::compare).get();
            int minM = Arrays.asList(p1M, p2M, p3M).stream().min(Integer::compare).get();
            int minY = Arrays.asList(p1Y, p2Y, p3Y).stream().min(Integer::compare).get();
            int minK = Arrays.asList(p1K, p2K, p3K).stream().min(Integer::compare).get();

            int minSum = minC + minM + minY + minK;

            if (minSum < 1_000_000) {
                System.out.printf(""Case #%s: %s%n"", i, ""IMPOSSIBLE"");
                continue;
            }

            int basicSum = minSum - (minSum % 1_000_000);

            int ansC = 0;
            int ansM = 0;
            int ansY = 0;
            int ansK = 0;

            if (minC >= basicSum) {
                ansC = basicSum;
                System.out.printf(""Case #%s: %s %s %s %s%n"", i, ansC, ansM, ansY, ansK);
                continue;
            } else {
                ansC = minC;
                basicSum -= minC;
            }

            if (minM >= basicSum) {
                ansM = basicSum;
                System.out.printf(""Case #%s: %s %s %s %s%n"", i, ansC, ansM, ansY, ansK);
                continue;
            } else {
                ansM = minM;
                basicSum -= minM;
            }

            if (minY >= basicSum) {
                ansY = basicSum;
                System.out.printf(""Case #%s: %s %s %s %s%n"", i, ansC, ansM, ansY, ansK);
                continue;
            } else {
                ansY = minY;
                basicSum -= minY;
            }

            if (minK >= basicSum) {
                ansK = basicSum;
                System.",MikBac
9616,"public class Solution {

    public static void main(String[] args) {
        final Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        final int testQuantity = in.nextInt();

        for (int i = 1; i <= testQuantity; ++i) {
            final int rows = in.nextInt();
            final int columns = in.nextInt();

            System.out.printf(""Case #%s:
"", i);

            // line 1
            System.out.print("".."");
            for (int j = 0; j < columns - 1; j++) {
                System.out.print(""+-"");
            }
            System.out.println(""+"");

            // line 2
            System.out.print("".."");
            for (int j = 0; j < columns - 1; j++) {
                System.out.print(""|."");
            }
            System.out.println(""|"");

            // line 3
            for (int j = 0; j < columns; j++) {
                System.out.print(""+-"");
            }
            System.out.println(""+"");

            for (int j = 0; j < rows - 1; j++) {
                for (int k = 0; k < columns; k++) {
                    System.out.print(""|."");
                }
                System.out.println(""|"");

                for (int k = 0; k < columns; k++) {
                    System.out.print(""+-"");
                }",MikBac
9617,"class Solution {

    public static void main(String[] args) {
        final Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        final int testQuantity = in.nextInt();

        for (int i = 1; i <= testQuantity; ++i) {
            final long numberOfRooms = in.nextLong();
            final long mxNumberOfOperations = in.nextLong();
            // Rooms are numbered between 1 and N

            Map<Long, Long> passages = new HashMap<>();

            long currentRoom = in.nextLong();
            long passageQuantity = in.nextLong();

            passages.put(currentRoom, passageQuantity);

            for (int j = 0; j < mxNumberOfOperations; j++) {

                long nextRoom = numberOfRooms;
                while (true) {

                    nextRoom = nextRoom > 1 ? nextRoom - 1 : numberOfRooms;

                    if (!passages.keySet().contains(nextRoom)) {
                        break;
                    }

                    if (passages.keySet().size() >= numberOfRooms) {
                        break;
                    }

                }

                if (j % 2 == 0) {
                    System.out.printf(""T %s%n"", nextRoom);
                } else {
                    System.out.printf(""W%n"");
                }
                System.out.flush();

                currentRoom = in.nextLong();
                passageQuantity = in.nextLong();
                passages.put(currentRoom, passageQuantity);

            }

            long passagesAns;

            long discovered = passages.keySet().size();
            long discoveredResult = passages.values().stream().mapToLong(Long::longValue).sum();
            long toDiscovered = numberOfRooms;

            passagesAns = ",MikBac
9619,"class solution {

    public static void main(String[] args) {
        final Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        final int testQuantity = in.nextInt();

        for (int i = 1; i <= testQuantity; ++i) {
            final long numberOfRooms = in.nextLong();
            final long mxNumberOfOperations = in.nextLong();
            // Rooms are numbered between 1 and N

            Map<Long, Long> passages = new HashMap<>();

            long currentRoom = in.nextLong();
            long passageQuantity = in.nextLong();

            passages.put(currentRoom, passageQuantity);

            for (int j = 0; j < mxNumberOfOperations; j++) {

                long nextRoom = numberOfRooms;
                while (true) {

                    nextRoom = nextRoom > 1 ? nextRoom - 1 : numberOfRooms;

                    if (!passages.keySet().contains(nextRoom)) {
                        break;
                    }

                    if (passages.keySet().size() >= numberOfRooms) {
                        break;
                    }

                }

                if (j % 2 == 0) {
                    System.out.printf(""T %s%n"", nextRoom);
                } else {
                    System.out.printf(""W%n"");
                }

                currentRoom = in.nextLong();
                passageQuantity = in.nextLong();
                passages.put(currentRoom, passageQuantity);

            }

            long passagesAns;

            long discovered = passages.keySet().size();
            long discoveredResult = passages.values().stream().mapToLong(Long::longValue).sum();
            long toDiscovered = numberOfRooms;

            passagesAns = ",MikBac
9790,"public class Solution {
	private static boolean extracted(Room currentRoom, long passageSizes, long checkedRoomsCount) {
		boolean check = currentRoom.maxPassages > 24 ||currentRoom.maxPassages > passageSizes*2/checkedRoomsCount;
		//to transport if in hub
		//currentRoom.maxPassages > 6 &&
		return check;
	}

	private static long extracted2(long countUnvisited, long passagesInVisited, double average) {
		long totalRooms = (long) Math.round(1.0*(passagesInVisited + countUnvisited*average)/2.);
		return totalRooms;
	}	
	
	public static void main(String[] args) {
		Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int problem = 5;
		switch (problem) {
		case 1:
			experiment1(in);
			break;
		case 2:
			experiment2(in);
			break;
		case 3:
			experiment3(in);
			break;
		case 4:
			experiment4(in);
			break;
		case 5:
			experiment5(in);
			break;
		default:
			break;
		}

	}

	private static class Room{
		
		public Room(int i,int mp) {
			
			id = i;
			maxPassages = mp;
		}
		
		final int id;
		int minPassages = 1;
		int maxPassages;
		public int visitedConnections = 0;
		public boolean hasBeenVisited = false;
		public int[] visit(int krp) {
			int delta1 = maxPassages-krp;
			int delta0 = krp-minPassages;
			maxPassages = krp;
			minPassages = krp;
			hasBeenVisited = true;
			return new int[] {delta0,delta1};
			
		}
	}
	private static class Request{

		public boolean isWalk;

		public void print() {
			// TODO Auto-generated method stub
			
		}
		
	}
	private static class BelieveState{

		private Room[] rooms;
		//private int[][] connections; //0 means unknown; -1 means not; 1 means excists;
		private boolean certain = false;
		//private int minConnectionsTimes2;
	//	private int maxConnectionsTimes2;
		//private int maxConnections;
		public BelieveState(int n) {
			rooms = new Room[n+1];
			//connections = new int[n][n];
		//	minConnectionsTimes2 = (int) n;
			//maxConnectionsTimes2 = (int)(n*(n-1)/2);
			//maxConnections = (int)(n*(n-1)/2);
			for (int i = 1; i <= n; i++) {
				rooms[i] = new Room(i,n-1);
			}
		}
		public void update(int kri, int krp) {
			Room r = rooms[kri];
			if (!r.hasBeenVisited) {
				int[] changedPassages = r.visit(krp);
				//maxConnectionsTimes2-=changedPassages[1];
				//minConnectionsTimes2-=changedPassages[0];
			}
			
		}
		public Request getBestRequest() {
			return null;
			// TODO Auto-generated method stub
			
		}
		public int guess() {
			// TODO Auto-generated method stub
			return 0;
		}
		/*public void addConnection(Room currentRoom, Room nextRoom) {
			if (connections[currentRoom.id][nextRoom.id]==0) {
				currentRoom.visitedConnections++;
				nextRoom.visitedConnections++;
			}
			connections[currentRoom.id][nextRoom.id] = 1;
			connections[nextRoom.id][currentRoom.id] = 1;
			
		}*/
		
		
	}
	private static int nextInt(boolean fj, Scanner in ,boolean[][] conn, int room, boolean b) {
		if (!fj)return in.nextInt();
		if (b) {
			System.out.print(room + "" "");
			return room;
		}
		else {
			int counter = 0;
			boolean[] list = conn[room-1];
			for (int i = 0; i < list.length; i++) {
				if (list[i])counter++;
			}
			System.out.println(counter);
			return counter;
		}
		
		
	}
	private static void experiment5(Scanner in) {
		long startTime = System.currentTimeMillis();
		boolean useFakeJudge = false;
		
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		boolean[][] connections = null;
		
		
		for (int i = 1; i <= t; ++i) {
		
			int n = in.nextInt();
			boolean[] checkedRooms = new boolean[n+1];
			int k = in.nextInt();
			//BelieveState bs2;
			if (useFakeJudge) {
				connections = new boolean[n][n];
				int max = n*(n-1)/2;
				double chance = (1/4.);
				for (int j = 0; j < connections.length; j++) {
					int rj = (int) (Math.random()*n);
					connections[j][rj] = true;
					connections[rj][j] = true;
					for (int j2 = j+1; j2 < connections.length; j2++) {
						if (Math.random()<chance) {
							connections[j][j2] = true;
							connections[j2][j] = true;
						}
					}
				}
			};
			BelieveState bs = new BelieveState(n);
			int kri = in.nextInt();
			checkedRooms[kri] = true;
			int krp = in.nextInt();
			bs.update(kri,krp);
			Room currentRoom = bs.rooms[kri];
			ArrayList<Integer> grabBag = new ArrayList<>();
			for (int j = 1; j <= n; j++) {
				if (j == kri)continue;
				grabBag.add(j);
			}
			Collections.shuffle(grabBag);
			int counter = 0;
			Room nextRoom = null;
			long passageSizes = krp;
			long checkedRoomsCount = 1;
			while(k>0&&counter<grabBag.size()&&bs.certain==false) {
				
				//Request r = bs.getBestRequest();
				//r.print();
				int room = 1;
				//if (k % 2 == 0) {
				boolean check = extracted(currentRoom, passageSizes, checkedRoomsCount);
				if (check) {
					grabBag.get((counter++)%grabBag.size());
					if (checkedRooms[room])continue;
					System.out.println(""T "" + room);}
				else {
					System.out.println(""W"");
				}
					
				int nextI = nextInt(useFakeJudge, in, connections,room,true);
				if (nextI==-1)break;
				
				
				int nextP = nextInt(useFakeJudge, in, connections,room, false);
				 nextRoom = bs.rooms[nextI];
				 if (!checkedRooms[nextI]) {
						checkedRoomsCount++;
						checkedRooms[nextI] = true;
						passageSizes+=nextP;
					}
				//if (r.isWalk) {
					//bs.addConnection(currentRoom,nextRoom);
				//}
				bs.update(nextI,nextP);
				currentRoom = nextRoom;
				k--;
			}
			long countUnvisited = 0;
			long countVisited = 0;
			long passagesInVisited = 0;
			Room[] roms = bs.rooms;
			for (int j = 1; j < roms.length; j++) {
				Room room = roms[j];
				if (room.hasBeenVisited) {
					passagesInVisited+=room.maxPassages;
					countVisited++;
				}
				else countUnvisited += 1;
			}
			double average = passagesInVisited/countVisited;
			long totalRooms = extracted2(countUnvisited, passagesInVisited, average);
			
			long g = totalRooms;
			System.out.println(""E "" + g);
		}
		
	}


	

	public static class Willies{

		public int fun;
		public Willies parent;
		public ArrayList<Willies> children = new ArrayList<Willies>();
		public ArrayList<Signal> signals = new ArrayList<Signal>();
		public int id;
		public Signal winningSignal; 
		public Willies(int i) {
			this.id = i;
		}
		public void addChild(Willies w) {
			children.add(w);
		}
		public boolean needsMoreSignals() {
			return (signals.size()<children.size());
			
		}
		public void addSignal(Signal signal) {
			this.signals.add(signal);
			if (winningSignal==null)winningSignal = signal;
			else winningSignal = winningSignal.maxFun<signal.maxFun?winningSignal:signal;//smaller max fun gets through
		}
		
		
	}

	public static class Signal{
		private Willies current;

		public Signal(Willies willies) {
			current=",Nibbla
9791,"public class Solution {
	private static boolean extracted(Room currentRoom, long passageSizes, long checkedRoomsCount) {
		boolean check = currentRoom.maxPassages > 24 &&currentRoom.maxPassages > passageSizes*2/checkedRoomsCount;
		//to transport if in hub
		//currentRoom.maxPassages > 6 &&
		return check;
	}

	private static long extracted2(long countUnvisited, long passagesInVisited, double average) {
		long totalRooms = (long) Math.round(1.0*(passagesInVisited + countUnvisited*average)/2.);
		return totalRooms;
	}	
	
	public static void main(String[] args) {
		Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int problem = 5;
		switch (problem) {
		case 1:
			experiment1(in);
			break;
		case 2:
			experiment2(in);
			break;
		case 3:
			experiment3(in);
			break;
		case 4:
			experiment4(in);
			break;
		case 5:
			experiment5(in);
			break;
		default:
			break;
		}

	}

	private static class Room{
		
		public Room(int i,int mp) {
			
			id = i;
			maxPassages = mp;
		}
		
		final int id;
		int minPassages = 1;
		int maxPassages;
		public int visitedConnections = 0;
		public boolean hasBeenVisited = false;
		public int[] visit(int krp) {
			int delta1 = maxPassages-krp;
			int delta0 = krp-minPassages;
			maxPassages = krp;
			minPassages = krp;
			hasBeenVisited = true;
			return new int[] {delta0,delta1};
			
		}
	}
	private static class Request{

		public boolean isWalk;

		public void print() {
			// TODO Auto-generated method stub
			
		}
		
	}
	private static class BelieveState{

		private Room[] rooms;
		//private int[][] connections; //0 means unknown; -1 means not; 1 means excists;
		private boolean certain = false;
		//private int minConnectionsTimes2;
	//	private int maxConnectionsTimes2;
		//private int maxConnections;
		public BelieveState(int n) {
			rooms = new Room[n+1];
			//connections = new int[n][n];
		//	minConnectionsTimes2 = (int) n;
			//maxConnectionsTimes2 = (int)(n*(n-1)/2);
			//maxConnections = (int)(n*(n-1)/2);
			for (int i = 1; i <= n; i++) {
				rooms[i] = new Room(i,n-1);
			}
		}
		public void update(int kri, int krp) {
			Room r = rooms[kri];
			if (!r.hasBeenVisited) {
				int[] changedPassages = r.visit(krp);
				//maxConnectionsTimes2-=changedPassages[1];
				//minConnectionsTimes2-=changedPassages[0];
			}
			
		}
		public Request getBestRequest() {
			return null;
			// TODO Auto-generated method stub
			
		}
		public int guess() {
			// TODO Auto-generated method stub
			return 0;
		}
		/*public void addConnection(Room currentRoom, Room nextRoom) {
			if (connections[currentRoom.id][nextRoom.id]==0) {
				currentRoom.visitedConnections++;
				nextRoom.visitedConnections++;
			}
			connections[currentRoom.id][nextRoom.id] = 1;
			connections[nextRoom.id][currentRoom.id] = 1;
			
		}*/
		
		
	}
	private static int nextInt(boolean fj, Scanner in ,boolean[][] conn, int room, boolean b) {
		if (!fj)return in.nextInt();
		if (b) {
			System.out.print(room + "" "");
			return room;
		}
		else {
			int counter = 0;
			boolean[] list = conn[room-1];
			for (int i = 0; i < list.length; i++) {
				if (list[i])counter++;
			}
			System.out.println(counter);
			return counter;
		}
		
		
	}
	private static void experiment5(Scanner in) {
		long startTime = System.currentTimeMillis();
		boolean useFakeJudge = false;
		
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		boolean[][] connections = null;
		
		
		for (int i = 1; i <= t; ++i) {
		
			int n = in.nextInt();
			boolean[] checkedRooms = new boolean[n+1];
			int k = in.nextInt();
			//BelieveState bs2;
			if (useFakeJudge) {
				connections = new boolean[n][n];
				int max = n*(n-1)/2;
				double chance = (1/4.);
				for (int j = 0; j < connections.length; j++) {
					int rj = (int) (Math.random()*n);
					connections[j][rj] = true;
					connections[rj][j] = true;
					for (int j2 = j+1; j2 < connections.length; j2++) {
						if (Math.random()<chance) {
							connections[j][j2] = true;
							connections[j2][j] = true;
						}
					}
				}
			};
			BelieveState bs = new BelieveState(n);
			int kri = in.nextInt();
			checkedRooms[kri] = true;
			int krp = in.nextInt();
			bs.update(kri,krp);
			Room currentRoom = bs.rooms[kri];
			ArrayList<Integer> grabBag = new ArrayList<>();
			for (int j = 1; j <= n; j++) {
				if (j == kri)continue;
				grabBag.add(j);
			}
			Collections.shuffle(grabBag);
			int counter = 0;
			Room nextRoom = null;
			long passageSizes = krp;
			long checkedRoomsCount = 1;
			while(k>0&&counter<grabBag.size()&&bs.certain==false) {
				
				//Request r = bs.getBestRequest();
				//r.print();
				int room = 1;
				//if (k % 2 == 0) {
				boolean check = extracted(currentRoom, passageSizes, checkedRoomsCount);
				if (check) {
					grabBag.get((counter++)%grabBag.size());
					if (checkedRooms[room])continue;
					System.out.println(""T "" + room);}
				else {
					System.out.println(""W"");
				}
					
				int nextI = nextInt(useFakeJudge, in, connections,room,true);
				if (nextI==-1)break;
				
				
				int nextP = nextInt(useFakeJudge, in, connections,room, false);
				 nextRoom = bs.rooms[nextI];
				 if (!checkedRooms[nextI]) {
						checkedRoomsCount++;
						checkedRooms[nextI] = true;
						passageSizes+=nextP;
					}
				//if (r.isWalk) {
					//bs.addConnection(currentRoom,nextRoom);
				//}
				bs.update(nextI,nextP);
				currentRoom = nextRoom;
				k--;
			}
			long countUnvisited = 0;
			long countVisited = 0;
			long passagesInVisited = 0;
			Room[] roms = bs.rooms;
			for (int j = 1; j < roms.length; j++) {
				Room room = roms[j];
				if (room.hasBeenVisited) {
					passagesInVisited+=room.maxPassages;
					countVisited++;
				}
				else countUnvisited += 1;
			}
			double average = passagesInVisited/countVisited;
			long totalRooms = extracted2(countUnvisited, passagesInVisited, average);
			
			long g = totalRooms;
			System.out.println(""E "" + g);
		}
		
	}


	

	public static class Willies{

		public int fun;
		public Willies parent;
		public ArrayList<Willies> children = new ArrayList<Willies>();
		public ArrayList<Signal> signals = new ArrayList<Signal>();
		public int id;
		public Signal winningSignal; 
		public Willies(int i) {
			this.id = i;
		}
		public void addChild(Willies w) {
			children.add(w);
		}
		public boolean needsMoreSignals() {
			return (signals.size()<children.size());
			
		}
		public void addSignal(Signal signal) {
			this.signals.add(signal);
			if (winningSignal==null)winningSignal = signal;
			else winningSignal = winningSignal.maxFun<signal.maxFun?winningSignal:signal;//smaller max fun gets through
		}
		
		
	}

	public static class Signal{
		private Willies current;

		public Signal(Willies willies) {
			current=",Nibbla
9792,"public class Solution {
	private static boolean extracted(Room currentRoom, long passageSizes, long checkedRoomsCount) {
		boolean check =  currentRoom.maxPassages > 6 &&currentRoom.maxPassages > passageSizes*1.2/checkedRoomsCount;
		//to transport if in hub
		//currentRoom.maxPassages > 6 &&
		return check;
	}

	private static long extracted2(long countUnvisited, long passagesInVisited, double average) {
		long totalRooms = (long) Math.round(1.0*(passagesInVisited + countUnvisited*average)/2.);
		return totalRooms;
	}	
	
	public static void main(String[] args) {
		Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int problem = 5;
		switch (problem) {
		case 1:
			experiment1(in);
			break;
		case 2:
			experiment2(in);
			break;
		case 3:
			experiment3(in);
			break;
		case 4:
			experiment4(in);
			break;
		case 5:
			experiment5(in);
			break;
		default:
			break;
		}

	}

	private static class Room{
		
		public Room(int i,int mp) {
			
			id = i;
			maxPassages = mp;
		}
		
		final int id;
		int minPassages = 1;
		int maxPassages;
		public int visitedConnections = 0;
		public boolean hasBeenVisited = false;
		public int[] visit(int krp) {
			int delta1 = maxPassages-krp;
			int delta0 = krp-minPassages;
			maxPassages = krp;
			minPassages = krp;
			hasBeenVisited = true;
			return new int[] {delta0,delta1};
			
		}
	}
	private static class Request{

		public boolean isWalk;

		public void print() {
			// TODO Auto-generated method stub
			
		}
		
	}
	private static class BelieveState{

		private Room[] rooms;
		//private int[][] connections; //0 means unknown; -1 means not; 1 means excists;
		private boolean certain = false;
		//private int minConnectionsTimes2;
	//	private int maxConnectionsTimes2;
		//private int maxConnections;
		public BelieveState(int n) {
			rooms = new Room[n+1];
			//connections = new int[n][n];
		//	minConnectionsTimes2 = (int) n;
			//maxConnectionsTimes2 = (int)(n*(n-1)/2);
			//maxConnections = (int)(n*(n-1)/2);
			for (int i = 1; i <= n; i++) {
				rooms[i] = new Room(i,n-1);
			}
		}
		public void update(int kri, int krp) {
			Room r = rooms[kri];
			if (!r.hasBeenVisited) {
				int[] changedPassages = r.visit(krp);
				//maxConnectionsTimes2-=changedPassages[1];
				//minConnectionsTimes2-=changedPassages[0];
			}
			
		}
		public Request getBestRequest() {
			return null;
			// TODO Auto-generated method stub
			
		}
		public int guess() {
			// TODO Auto-generated method stub
			return 0;
		}
		/*public void addConnection(Room currentRoom, Room nextRoom) {
			if (connections[currentRoom.id][nextRoom.id]==0) {
				currentRoom.visitedConnections++;
				nextRoom.visitedConnections++;
			}
			connections[currentRoom.id][nextRoom.id] = 1;
			connections[nextRoom.id][currentRoom.id] = 1;
			
		}*/
		
		
	}
	private static int nextInt(boolean fj, Scanner in ,boolean[][] conn, int room, boolean b) {
		if (!fj)return in.nextInt();
		if (b) {
			System.out.print(room + "" "");
			return room;
		}
		else {
			int counter = 0;
			boolean[] list = conn[room-1];
			for (int i = 0; i < list.length; i++) {
				if (list[i])counter++;
			}
			System.out.println(counter);
			return counter;
		}
		
		
	}
	private static void experiment5(Scanner in) {
		long startTime = System.currentTimeMillis();
		boolean useFakeJudge = false;
		
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		boolean[][] connections = null;
		
		
		for (int i = 1; i <= t; ++i) {
		
			int n = in.nextInt();
			boolean[] checkedRooms = new boolean[n+1];
			int k = in.nextInt();
			//BelieveState bs2;
			if (useFakeJudge) {
				connections = new boolean[n][n];
				int max = n*(n-1)/2;
				double chance = (1/4.);
				for (int j = 0; j < connections.length; j++) {
					int rj = (int) (Math.random()*n);
					connections[j][rj] = true;
					connections[rj][j] = true;
					for (int j2 = j+1; j2 < connections.length; j2++) {
						if (Math.random()<chance) {
							connections[j][j2] = true;
							connections[j2][j] = true;
						}
					}
				}
			};
			BelieveState bs = new BelieveState(n);
			int kri = in.nextInt();
			checkedRooms[kri] = true;
			int krp = in.nextInt();
			bs.update(kri,krp);
			Room currentRoom = bs.rooms[kri];
			ArrayList<Integer> grabBag = new ArrayList<>();
			for (int j = 1; j <= n; j++) {
				if (j == kri)continue;
				grabBag.add(j);
			}
			Collections.shuffle(grabBag);
			int counter = 0;
			Room nextRoom = null;
			long passageSizes = krp;
			long checkedRoomsCount = 1;
			while(k>0&&counter<grabBag.size()&&bs.certain==false) {
				
				//Request r = bs.getBestRequest();
				//r.print();
				int room = 1;
				//if (k % 2 == 0) {
				boolean check = extracted(currentRoom, passageSizes, checkedRoomsCount);
				if (check) {
					grabBag.get((counter++)%grabBag.size());
					if (checkedRooms[room])continue;
					System.out.println(""T "" + room);}
				else {
					System.out.println(""W"");
				}
					
				int nextI = nextInt(useFakeJudge, in, connections,room,true);
				if (nextI==-1)break;
				
				
				int nextP = nextInt(useFakeJudge, in, connections,room, false);
				 nextRoom = bs.rooms[nextI];
				 if (!checkedRooms[nextI]) {
						checkedRoomsCount++;
						checkedRooms[nextI] = true;
						passageSizes+=nextP;
					}
				//if (r.isWalk) {
					//bs.addConnection(currentRoom,nextRoom);
				//}
				bs.update(nextI,nextP);
				currentRoom = nextRoom;
				k--;
			}
			long countUnvisited = 0;
			long countVisited = 0;
			long passagesInVisited = 0;
			Room[] roms = bs.rooms;
			for (int j = 1; j < roms.length; j++) {
				Room room = roms[j];
				if (room.hasBeenVisited) {
					passagesInVisited+=room.maxPassages;
					countVisited++;
				}
				else countUnvisited += 1;
			}
			double average = passagesInVisited/countVisited;
			long totalRooms = extracted2(countUnvisited, passagesInVisited, average);
			
			long g = totalRooms;
			System.out.println(""E "" + g);
		}
		
	}


	

	public static class Willies{

		public int fun;
		public Willies parent;
		public ArrayList<Willies> children = new ArrayList<Willies>();
		public ArrayList<Signal> signals = new ArrayList<Signal>();
		public int id;
		public Signal winningSignal; 
		public Willies(int i) {
			this.id = i;
		}
		public void addChild(Willies w) {
			children.add(w);
		}
		public boolean needsMoreSignals() {
			return (signals.size()<children.size());
			
		}
		public void addSignal(Signal signal) {
			this.signals.add(signal);
			if (winningSignal==null)winningSignal = signal;
			else winningSignal = winningSignal.maxFun<signal.maxFun?winningSignal:signal;//smaller max fun gets through
		}
		
		
	}

	public static class Signal{
		private Willies current;

		public Signal(Willies willies) {
			current=",Nibbla
9793,"public class Solution {
	private static boolean extracted(Room currentRoom, long passageSizes, long checkedRoomsCount) {
		boolean check =  currentRoom.maxPassages > passageSizes*1.2/checkedRoomsCount;
		//to transport if in hub
		//currentRoom.maxPassages > 6 &&
		return check;
	}

	private static long extracted2(long countUnvisited, long passagesInVisited, double average) {
		long totalRooms = (long) Math.round(1.0*(passagesInVisited + countUnvisited*average)/2.);
		return totalRooms;
	}	
	
	public static void main(String[] args) {
		Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int problem = 5;
		switch (problem) {
		case 1:
			experiment1(in);
			break;
		case 2:
			experiment2(in);
			break;
		case 3:
			experiment3(in);
			break;
		case 4:
			experiment4(in);
			break;
		case 5:
			experiment5(in);
			break;
		default:
			break;
		}

	}

	private static class Room{
		
		public Room(int i,int mp) {
			
			id = i;
			maxPassages = mp;
		}
		
		final int id;
		int minPassages = 1;
		int maxPassages;
		public int visitedConnections = 0;
		public boolean hasBeenVisited = false;
		public int[] visit(int krp) {
			int delta1 = maxPassages-krp;
			int delta0 = krp-minPassages;
			maxPassages = krp;
			minPassages = krp;
			hasBeenVisited = true;
			return new int[] {delta0,delta1};
			
		}
	}
	private static class Request{

		public boolean isWalk;

		public void print() {
			// TODO Auto-generated method stub
			
		}
		
	}
	private static class BelieveState{

		private Room[] rooms;
		//private int[][] connections; //0 means unknown; -1 means not; 1 means excists;
		private boolean certain = false;
		//private int minConnectionsTimes2;
	//	private int maxConnectionsTimes2;
		//private int maxConnections;
		public BelieveState(int n) {
			rooms = new Room[n+1];
			//connections = new int[n][n];
		//	minConnectionsTimes2 = (int) n;
			//maxConnectionsTimes2 = (int)(n*(n-1)/2);
			//maxConnections = (int)(n*(n-1)/2);
			for (int i = 1; i <= n; i++) {
				rooms[i] = new Room(i,n-1);
			}
		}
		public void update(int kri, int krp) {
			Room r = rooms[kri];
			if (!r.hasBeenVisited) {
				int[] changedPassages = r.visit(krp);
				//maxConnectionsTimes2-=changedPassages[1];
				//minConnectionsTimes2-=changedPassages[0];
			}
			
		}
		public Request getBestRequest() {
			return null;
			// TODO Auto-generated method stub
			
		}
		public int guess() {
			// TODO Auto-generated method stub
			return 0;
		}
		/*public void addConnection(Room currentRoom, Room nextRoom) {
			if (connections[currentRoom.id][nextRoom.id]==0) {
				currentRoom.visitedConnections++;
				nextRoom.visitedConnections++;
			}
			connections[currentRoom.id][nextRoom.id] = 1;
			connections[nextRoom.id][currentRoom.id] = 1;
			
		}*/
		
		
	}
	private static int nextInt(boolean fj, Scanner in ,boolean[][] conn, int room, boolean b) {
		if (!fj)return in.nextInt();
		if (b) {
			System.out.print(room + "" "");
			return room;
		}
		else {
			int counter = 0;
			boolean[] list = conn[room-1];
			for (int i = 0; i < list.length; i++) {
				if (list[i])counter++;
			}
			System.out.println(counter);
			return counter;
		}
		
		
	}
	private static void experiment5(Scanner in) {
		long startTime = System.currentTimeMillis();
		boolean useFakeJudge = false;
		
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		boolean[][] connections = null;
		
		
		for (int i = 1; i <= t; ++i) {
		
			int n = in.nextInt();
			boolean[] checkedRooms = new boolean[n+1];
			int k = in.nextInt();
			//BelieveState bs2;
			if (useFakeJudge) {
				connections = new boolean[n][n];
				int max = n*(n-1)/2;
				double chance = (1/4.);
				for (int j = 0; j < connections.length; j++) {
					int rj = (int) (Math.random()*n);
					connections[j][rj] = true;
					connections[rj][j] = true;
					for (int j2 = j+1; j2 < connections.length; j2++) {
						if (Math.random()<chance) {
							connections[j][j2] = true;
							connections[j2][j] = true;
						}
					}
				}
			};
			BelieveState bs = new BelieveState(n);
			int kri = in.nextInt();
			checkedRooms[kri] = true;
			int krp = in.nextInt();
			bs.update(kri,krp);
			Room currentRoom = bs.rooms[kri];
			ArrayList<Integer> grabBag = new ArrayList<>();
			for (int j = 1; j <= n; j++) {
				if (j == kri)continue;
				grabBag.add(j);
			}
			Collections.shuffle(grabBag);
			int counter = 0;
			Room nextRoom = null;
			long passageSizes = krp;
			long checkedRoomsCount = 1;
			while(k>0&&counter<grabBag.size()&&bs.certain==false) {
				
				//Request r = bs.getBestRequest();
				//r.print();
				int room = 1;
				//if (k % 2 == 0) {
				boolean check = extracted(currentRoom, passageSizes, checkedRoomsCount);
				if (check) {
					grabBag.get((counter++)%grabBag.size());
					if (checkedRooms[room])continue;
					System.out.println(""T "" + room);}
				else {
					System.out.println(""W"");
				}
					
				int nextI = nextInt(useFakeJudge, in, connections,room,true);
				if (nextI==-1)break;
				
				
				int nextP = nextInt(useFakeJudge, in, connections,room, false);
				 nextRoom = bs.rooms[nextI];
				 if (!checkedRooms[nextI]) {
						checkedRoomsCount++;
						checkedRooms[nextI] = true;
						passageSizes+=nextP;
					}
				//if (r.isWalk) {
					//bs.addConnection(currentRoom,nextRoom);
				//}
				bs.update(nextI,nextP);
				currentRoom = nextRoom;
				k--;
			}
			long countUnvisited = 0;
			long countVisited = 0;
			long passagesInVisited = 0;
			Room[] roms = bs.rooms;
			for (int j = 1; j < roms.length; j++) {
				Room room = roms[j];
				if (room.hasBeenVisited) {
					passagesInVisited+=room.maxPassages;
					countVisited++;
				}
				else countUnvisited += 1;
			}
			double average = passagesInVisited/countVisited;
			long totalRooms = extracted2(countUnvisited, passagesInVisited, average);
			
			long g = totalRooms;
			System.out.println(""E "" + g);
		}
		
	}


	

	public static class Willies{

		public int fun;
		public Willies parent;
		public ArrayList<Willies> children = new ArrayList<Willies>();
		public ArrayList<Signal> signals = new ArrayList<Signal>();
		public int id;
		public Signal winningSignal; 
		public Willies(int i) {
			this.id = i;
		}
		public void addChild(Willies w) {
			children.add(w);
		}
		public boolean needsMoreSignals() {
			return (signals.size()<children.size());
			
		}
		public void addSignal(Signal signal) {
			this.signals.add(signal);
			if (winningSignal==null)winningSignal = signal;
			else winningSignal = winningSignal.maxFun<signal.maxFun?winningSignal:signal;//smaller max fun gets through
		}
		
		
	}

	public static class Signal{
		private Willies current;

		public Signal(Willies willies) {
			current=",Nibbla
9794,"public class Solution {
	public static void main(String[] args) {
		Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int problem = 5;
		switch (problem) {
		case 1:
			experiment1(in);
			break;
		case 2:
			experiment2(in);
			break;
		case 3:
			experiment3(in);
			break;
		case 4:
			experiment4(in);
			break;
		case 5:
			experiment5(in);
			break;
		default:
			break;
		}

	}

	private static class Room{
		
		public Room(int i,int mp) {
			
			id = i;
			maxPassages = mp;
		}
		
		final int id;
		int minPassages = 1;
		int maxPassages;
		public int visitedConnections = 0;
		public boolean hasBeenVisited = false;
		public int[] visit(int krp) {
			int delta1 = maxPassages-krp;
			int delta0 = krp-minPassages;
			maxPassages = krp;
			minPassages = krp;
			hasBeenVisited = true;
			return new int[] {delta0,delta1};
			
		}
	}
	private static class Request{

		public boolean isWalk;

		public void print() {
			// TODO Auto-generated method stub
			
		}
		
	}
	private static class BelieveState{

		private Room[] rooms;
		//private int[][] connections; //0 means unknown; -1 means not; 1 means excists;
		private boolean certain = false;
		//private int minConnectionsTimes2;
	//	private int maxConnectionsTimes2;
		//private int maxConnections;
		public BelieveState(int n) {
			rooms = new Room[n+1];
			//connections = new int[n][n];
		//	minConnectionsTimes2 = (int) n;
			//maxConnectionsTimes2 = (int)(n*(n-1)/2);
			//maxConnections = (int)(n*(n-1)/2);
			for (int i = 1; i <= n; i++) {
				rooms[i] = new Room(i,n-1);
			}
		}
		public void update(int kri, int krp) {
			Room r = rooms[kri];
			if (!r.hasBeenVisited) {
				int[] changedPassages = r.visit(krp);
				//maxConnectionsTimes2-=changedPassages[1];
				//minConnectionsTimes2-=changedPassages[0];
			}
			
		}
		public Request getBestRequest() {
			return null;
			// TODO Auto-generated method stub
			
		}
		public int guess() {
			// TODO Auto-generated method stub
			return 0;
		}
		/*public void addConnection(Room currentRoom, Room nextRoom) {
			if (connections[currentRoom.id][nextRoom.id]==0) {
				currentRoom.visitedConnections++;
				nextRoom.visitedConnections++;
			}
			connections[currentRoom.id][nextRoom.id] = 1;
			connections[nextRoom.id][currentRoom.id] = 1;
			
		}*/
		
		
	}
	private static int nextInt(boolean fj, Scanner in ,boolean[][] conn, int room, boolean b) {
		if (!fj)return in.nextInt();
		if (b) {
			System.out.print(room + "" "");
			return room;
		}
		else {
			int counter = 0;
			boolean[] list = conn[room-1];
			for (int i = 0; i < list.length; i++) {
				if (list[i])counter++;
			}
			System.out.println(counter);
			return counter;
		}
		
		
	}
	private static void experiment5(Scanner in) {
		long startTime = System.currentTimeMillis();
		boolean useFakeJudge = false;
		
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		boolean[][] connections = null;
		
		
		for (int i = 1; i <= t; ++i) {
		
			int n = in.nextInt();
			boolean[] checkedRooms = new boolean[n+1];
			int k = in.nextInt();
			//BelieveState bs2;
			if (useFakeJudge) {
				connections = new boolean[n][n];
				int max = n*(n-1)/2;
				double chance = (1/4.);
				for (int j = 0; j < connections.length; j++) {
					int rj = (int) (Math.random()*n);
					connections[j][rj] = true;
					connections[rj][j] = true;
					for (int j2 = j+1; j2 < connections.length; j2++) {
						if (Math.random()<chance) {
							connections[j][j2] = true;
							connections[j2][j] = true;
						}
					}
				}
			};
			BelieveState bs = new BelieveState(n);
			int kri = in.nextInt();
			checkedRooms[kri] = true;
			int krp = in.nextInt();
			bs.update(kri,krp);
			Room currentRoom = bs.rooms[kri];
			ArrayList<Integer> grabBag = new ArrayList<>();
			for (int j = 1; j <= n; j++) {
				if (j == kri)continue;
				grabBag.add(j);
			}
			Collections.shuffle(grabBag);
			int counter = 0;
			Room nextRoom = null;
			long passageSizes = krp;
			long checkedRoomsCount = 1;
			while(k>0&&counter<grabBag.size()&&bs.certain==false) {
				
				//Request r = bs.getBestRequest();
				//r.print();
				int room = 1;
				//if (k % 2 == 0) {
				if (currentRoom.maxPassages > 6 && currentRoom.maxPassages > passageSizes*0.5/checkedRoomsCount) {
					grabBag.get((counter++)%grabBag.size());
					if (checkedRooms[room])continue;
					System.out.println(""T "" + room);}
				else {
					System.out.println(""W"");
				}
					
				int nextI = nextInt(useFakeJudge, in, connections,room,true);
				if (nextI==-1)break;
				
				
				int nextP = nextInt(useFakeJudge, in, connections,room, false);
				 nextRoom = bs.rooms[nextI];
				 if (!checkedRooms[nextI]) {
						checkedRoomsCount++;
						checkedRooms[nextI] = true;
						passageSizes+=nextP;
					}
				//if (r.isWalk) {
					//bs.addConnection(currentRoom,nextRoom);
				//}
				bs.update(nextI,nextP);
				currentRoom = nextRoom;
				k--;
			}
			long countUnvisited = 0;
			long countVisited = 0;
			long passagesInVisited = 0;
			Room[] roms = bs.rooms;
			for (int j = 1; j < roms.length; j++) {
				Room room = roms[j];
				if (room.hasBeenVisited) {
					passagesInVisited+=room.maxPassages;
					countVisited++;
				}
				else countUnvisited += 1;
			}
			double average = passagesInVisited/countVisited;
			long totalRooms = (long) Math.round(0.9*(passagesInVisited + countUnvisited*average)/2.);
			
			long g = totalRooms;
			System.out.println(""E "" + g);
		}
		
	}

	public static class Willies{

		public int fun;
		public Willies parent;
		public ArrayList<Willies> children = new ArrayList<Willies>();
		public ArrayList<Signal> signals = new ArrayList<Signal>();
		public int id;
		public Signal winningSignal; 
		public Willies(int i) {
			this.id = i;
		}
		public void addChild(Willies w) {
			children.add(w);
		}
		public boolean needsMoreSignals() {
			return (signals.size()<children.size());
			
		}
		public void addSignal(Signal signal) {
			this.signals.add(signal);
			if (winningSignal==null)winningSignal = signal;
			else winningSignal = winningSignal.maxFun<signal.maxFun?winningSignal:signal;//smaller max fun gets through
		}
		
		
	}

	public static class Signal{
		private Willies current;

		public Signal(Willies willies) {
			current=willies;
			current.addSignal(this);
			this.maxFun = Math.max(current.fun, maxFun);
		}

		public long maxFun = 0;
		private boolean stopped= false;

		public void step() {
			if (current.needsMoreSignals())return;
			if (current.winningSignal==this) {
				this.maxFun = ",Nibbla
9795,"public class Solution {
	public static void main(String[] args) {
		Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int problem = 5;
		switch (problem) {
		case 1:
			experiment1(in);
			break;
		case 2:
			experiment2(in);
			break;
		case 3:
			experiment3(in);
			break;
		case 4:
			experiment4(in);
			break;
		case 5:
			experiment5(in);
			break;
		default:
			break;
		}

	}

	private static class Room{
		
		public Room(int i,int mp) {
			
			id = i;
			maxPassages = mp;
		}
		
		final int id;
		int minPassages = 1;
		int maxPassages;
		public int visitedConnections = 0;
		public boolean hasBeenVisited = false;
		public int[] visit(int krp) {
			int delta1 = maxPassages-krp;
			int delta0 = krp-minPassages;
			maxPassages = krp;
			minPassages = krp;
			hasBeenVisited = true;
			return new int[] {delta0,delta1};
			
		}
	}
	private static class Request{

		public boolean isWalk;

		public void print() {
			// TODO Auto-generated method stub
			
		}
		
	}
	private static class BelieveState{

		private Room[] rooms;
		//private int[][] connections; //0 means unknown; -1 means not; 1 means excists;
		private boolean certain = false;
		//private int minConnectionsTimes2;
	//	private int maxConnectionsTimes2;
		//private int maxConnections;
		public BelieveState(int n) {
			rooms = new Room[n+1];
			//connections = new int[n][n];
		//	minConnectionsTimes2 = (int) n;
			//maxConnectionsTimes2 = (int)(n*(n-1)/2);
			//maxConnections = (int)(n*(n-1)/2);
			for (int i = 1; i <= n; i++) {
				rooms[i] = new Room(i,n-1);
			}
		}
		public void update(int kri, int krp) {
			Room r = rooms[kri];
			if (!r.hasBeenVisited) {
				int[] changedPassages = r.visit(krp);
				//maxConnectionsTimes2-=changedPassages[1];
				//minConnectionsTimes2-=changedPassages[0];
			}
			
		}
		public Request getBestRequest() {
			return null;
			// TODO Auto-generated method stub
			
		}
		public int guess() {
			// TODO Auto-generated method stub
			return 0;
		}
		/*public void addConnection(Room currentRoom, Room nextRoom) {
			if (connections[currentRoom.id][nextRoom.id]==0) {
				currentRoom.visitedConnections++;
				nextRoom.visitedConnections++;
			}
			connections[currentRoom.id][nextRoom.id] = 1;
			connections[nextRoom.id][currentRoom.id] = 1;
			
		}*/
		
		
	}
	private static int nextInt(boolean fj, Scanner in ,boolean[][] conn, int room, boolean b) {
		if (!fj)return in.nextInt();
		if (b) {
			System.out.print(room + "" "");
			return room;
		}
		else {
			int counter = 0;
			boolean[] list = conn[room-1];
			for (int i = 0; i < list.length; i++) {
				if (list[i])counter++;
			}
			System.out.println(counter);
			return counter;
		}
		
		
	}
	private static void experiment5(Scanner in) {
		long startTime = System.currentTimeMillis();
		boolean useFakeJudge = false;
		
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		boolean[][] connections = null;
		
		
		for (int i = 1; i <= t; ++i) {
		
			int n = in.nextInt();
			boolean[] checkedRooms = new boolean[n+1];
			int k = in.nextInt();
			//BelieveState bs2;
			if (useFakeJudge) {
				connections = new boolean[n][n];
				int max = n*(n-1)/2;
				double chance = (1/4.);
				for (int j = 0; j < connections.length; j++) {
					int rj = (int) (Math.random()*n);
					connections[j][rj] = true;
					connections[rj][j] = true;
					for (int j2 = j+1; j2 < connections.length; j2++) {
						if (Math.random()<chance) {
							connections[j][j2] = true;
							connections[j2][j] = true;
						}
					}
				}
			};
			BelieveState bs = new BelieveState(n);
			int kri = in.nextInt();
			checkedRooms[kri] = true;
			int krp = in.nextInt();
			bs.update(kri,krp);
			Room currentRoom = bs.rooms[kri];
			ArrayList<Integer> grabBag = new ArrayList<>();
			for (int j = 1; j <= n; j++) {
				if (j == kri)continue;
				grabBag.add(j);
			}
			Collections.shuffle(grabBag);
			int counter = 0;
			Room nextRoom = null;
			long passageSizes = krp;
			long checkedRoomsCount = 1;
			while(k>0&&counter<grabBag.size()&&bs.certain==false) {
				
				//Request r = bs.getBestRequest();
				//r.print();
				int room = 1;
				//if (k % 2 == 0) {
				if (currentRoom.maxPassages > 6 && currentRoom.maxPassages > passageSizes*0.5/checkedRoomsCount) {
					grabBag.get((counter++)%grabBag.size());
					if (checkedRooms[room])continue;
					System.out.println(""T "" + room);}
				else {
					System.out.println(""W"");
				}
					
				int nextI = nextInt(useFakeJudge, in, connections,room,true);
				if (nextI==-1)break;
				
				
				int nextP = nextInt(useFakeJudge, in, connections,room, false);
				 nextRoom = bs.rooms[nextI];
				 if (!checkedRooms[nextI]) {
						checkedRoomsCount++;
						checkedRooms[nextI] = true;
						passageSizes+=nextP;
					}
				//if (r.isWalk) {
					//bs.addConnection(currentRoom,nextRoom);
				//}
				bs.update(nextI,nextP);
				currentRoom = nextRoom;
				k--;
			}
			long countUnvisited = 0;
			long countVisited = 0;
			long passagesInVisited = 0;
			Room[] roms = bs.rooms;
			for (int j = 1; j < roms.length; j++) {
				Room room = roms[j];
				if (room.hasBeenVisited) {
					passagesInVisited+=room.maxPassages;
					countVisited++;
				}
				else countUnvisited += 1;
			}
			double average = passagesInVisited/countVisited;
			long totalRooms = (long) Math.round((passagesInVisited + 1.3*countUnvisited*average)/2.);
			
			long g = totalRooms;
			System.out.println(""E "" + g);
		}
		
	}

	public static class Willies{

		public int fun;
		public Willies parent;
		public ArrayList<Willies> children = new ArrayList<Willies>();
		public ArrayList<Signal> signals = new ArrayList<Signal>();
		public int id;
		public Signal winningSignal; 
		public Willies(int i) {
			this.id = i;
		}
		public void addChild(Willies w) {
			children.add(w);
		}
		public boolean needsMoreSignals() {
			return (signals.size()<children.size());
			
		}
		public void addSignal(Signal signal) {
			this.signals.add(signal);
			if (winningSignal==null)winningSignal = signal;
			else winningSignal = winningSignal.maxFun<signal.maxFun?winningSignal:signal;//smaller max fun gets through
		}
		
		
	}

	public static class Signal{
		private Willies current;

		public Signal(Willies willies) {
			current=willies;
			current.addSignal(this);
			this.maxFun = Math.max(current.fun, maxFun);
		}

		public long maxFun = 0;
		private boolean stopped= false;

		public void step() {
			if (current.needsMoreSignals())return;
			if (current.winningSignal==this) {
				this.maxFun = ",Nibbla
9796,"public class Solution {
	public static void main(String[] args) {
		Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int problem = 5;
		switch (problem) {
		case 1:
			experiment1(in);
			break;
		case 2:
			experiment2(in);
			break;
		case 3:
			experiment3(in);
			break;
		case 4:
			experiment4(in);
			break;
		case 5:
			experiment5(in);
			break;
		default:
			break;
		}

	}

	private static class Room{
		
		public Room(int i,int mp) {
			
			id = i;
			maxPassages = mp;
		}
		
		final int id;
		int minPassages = 1;
		int maxPassages;
		public int visitedConnections = 0;
		public boolean hasBeenVisited = false;
		public int[] visit(int krp) {
			int delta1 = maxPassages-krp;
			int delta0 = krp-minPassages;
			maxPassages = krp;
			minPassages = krp;
			hasBeenVisited = true;
			return new int[] {delta0,delta1};
			
		}
	}
	private static class Request{

		public boolean isWalk;

		public void print() {
			// TODO Auto-generated method stub
			
		}
		
	}
	private static class BelieveState{

		private Room[] rooms;
		//private int[][] connections; //0 means unknown; -1 means not; 1 means excists;
		private boolean certain = false;
		//private int minConnectionsTimes2;
	//	private int maxConnectionsTimes2;
		//private int maxConnections;
		public BelieveState(int n) {
			rooms = new Room[n+1];
			//connections = new int[n][n];
		//	minConnectionsTimes2 = (int) n;
			//maxConnectionsTimes2 = (int)(n*(n-1)/2);
			//maxConnections = (int)(n*(n-1)/2);
			for (int i = 1; i <= n; i++) {
				rooms[i] = new Room(i,n-1);
			}
		}
		public void update(int kri, int krp) {
			Room r = rooms[kri];
			if (!r.hasBeenVisited) {
				int[] changedPassages = r.visit(krp);
				//maxConnectionsTimes2-=changedPassages[1];
				//minConnectionsTimes2-=changedPassages[0];
			}
			
		}
		public Request getBestRequest() {
			return null;
			// TODO Auto-generated method stub
			
		}
		public int guess() {
			// TODO Auto-generated method stub
			return 0;
		}
		/*public void addConnection(Room currentRoom, Room nextRoom) {
			if (connections[currentRoom.id][nextRoom.id]==0) {
				currentRoom.visitedConnections++;
				nextRoom.visitedConnections++;
			}
			connections[currentRoom.id][nextRoom.id] = 1;
			connections[nextRoom.id][currentRoom.id] = 1;
			
		}*/
		
		
	}
	private static int nextInt(boolean fj, Scanner in ,boolean[][] conn, int room, boolean b) {
		if (!fj)return in.nextInt();
		if (b) {
			System.out.print(room + "" "");
			return room;
		}
		else {
			int counter = 0;
			boolean[] list = conn[room-1];
			for (int i = 0; i < list.length; i++) {
				if (list[i])counter++;
			}
			System.out.println(counter);
			return counter;
		}
		
		
	}
	private static void experiment5(Scanner in) {
		long startTime = System.currentTimeMillis();
		boolean useFakeJudge = false;
		
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		boolean[][] connections = null;
		
		
		for (int i = 1; i <= t; ++i) {
		
			int n = in.nextInt();
			boolean[] checkedRooms = new boolean[n+1];
			int k = in.nextInt();
			//BelieveState bs2;
			if (useFakeJudge) {
				connections = new boolean[n][n];
				int max = n*(n-1)/2;
				double chance = (1/4.);
				for (int j = 0; j < connections.length; j++) {
					int rj = (int) (Math.random()*n);
					connections[j][rj] = true;
					connections[rj][j] = true;
					for (int j2 = j+1; j2 < connections.length; j2++) {
						if (Math.random()<chance) {
							connections[j][j2] = true;
							connections[j2][j] = true;
						}
					}
				}
			};
			BelieveState bs = new BelieveState(n);
			int kri = in.nextInt();
			checkedRooms[kri] = true;
			int krp = in.nextInt();
			bs.update(kri,krp);
			Room currentRoom = bs.rooms[kri];
			ArrayList<Integer> grabBag = new ArrayList<>();
			for (int j = 1; j <= n; j++) {
				if (j == kri)continue;
				grabBag.add(j);
			}
			Collections.shuffle(grabBag);
			int counter = 0;
			Room nextRoom = null;
			long passageSizes = krp;
			long checkedRoomsCount = 1;
			while(k>0&&counter<grabBag.size()&&bs.certain==false) {
				
				//Request r = bs.getBestRequest();
				//r.print();
				int room = 1;
				//if (k % 2 == 0) {
				if (currentRoom.maxPassages > 6 && currentRoom.maxPassages > passageSizes*0.5/checkedRoomsCount) {
					grabBag.get((counter++)%grabBag.size());
					if (checkedRooms[room])continue;
					System.out.println(""T "" + room);}
				else {
					System.out.println(""W"");
				}
					
				int nextI = nextInt(useFakeJudge, in, connections,room,true);
				if (nextI==-1)break;
				
				
				int nextP = nextInt(useFakeJudge, in, connections,room, false);
				 nextRoom = bs.rooms[nextI];
				 if (!checkedRooms[nextI]) {
						checkedRoomsCount++;
						checkedRooms[nextI] = true;
						passageSizes+=nextP;
					}
				//if (r.isWalk) {
					//bs.addConnection(currentRoom,nextRoom);
				//}
				bs.update(nextI,nextP);
				currentRoom = nextRoom;
				k--;
			}
			long countUnvisited = 0;
			long countVisited = 0;
			long passagesInVisited = 0;
			Room[] roms = bs.rooms;
			for (int j = 1; j < roms.length; j++) {
				Room room = roms[j];
				if (room.hasBeenVisited) {
					passagesInVisited+=room.maxPassages;
					countVisited++;
				}
				else countUnvisited += 1;
			}
			double average = passagesInVisited/countVisited;
			long totalRooms = (long) Math.round((passagesInVisited + 1.2*countUnvisited*average)/2.);
			
			long g = totalRooms;
			System.out.println(""E "" + g);
		}
		
	}

	public static class Willies{

		public int fun;
		public Willies parent;
		public ArrayList<Willies> children = new ArrayList<Willies>();
		public ArrayList<Signal> signals = new ArrayList<Signal>();
		public int id;
		public Signal winningSignal; 
		public Willies(int i) {
			this.id = i;
		}
		public void addChild(Willies w) {
			children.add(w);
		}
		public boolean needsMoreSignals() {
			return (signals.size()<children.size());
			
		}
		public void addSignal(Signal signal) {
			this.signals.add(signal);
			if (winningSignal==null)winningSignal = signal;
			else winningSignal = winningSignal.maxFun<signal.maxFun?winningSignal:signal;//smaller max fun gets through
		}
		
		
	}

	public static class Signal{
		private Willies current;

		public Signal(Willies willies) {
			current=willies;
			current.addSignal(this);
			this.maxFun = Math.max(current.fun, maxFun);
		}

		public long maxFun = 0;
		private boolean stopped= false;

		public void step() {
			if (current.needsMoreSignals())return;
			if (current.winningSignal==this) {
				this.maxFun = ",Nibbla
9797,"public class Solution {
	public static void main(String[] args) {
		Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int problem = 5;
		switch (problem) {
		case 1:
			experiment1(in);
			break;
		case 2:
			experiment2(in);
			break;
		case 3:
			experiment3(in);
			break;
		case 4:
			experiment4(in);
			break;
		case 5:
			experiment5(in);
			break;
		default:
			break;
		}

	}

	private static class Room{
		
		public Room(int i,int mp) {
			
			id = i;
			maxPassages = mp;
		}
		
		final int id;
		int minPassages = 1;
		int maxPassages;
		public int visitedConnections = 0;
		public boolean hasBeenVisited = false;
		public int[] visit(int krp) {
			int delta1 = maxPassages-krp;
			int delta0 = krp-minPassages;
			maxPassages = krp;
			minPassages = krp;
			hasBeenVisited = true;
			return new int[] {delta0,delta1};
			
		}
	}
	private static class Request{

		public boolean isWalk;

		public void print() {
			// TODO Auto-generated method stub
			
		}
		
	}
	private static class BelieveState{

		private Room[] rooms;
		//private int[][] connections; //0 means unknown; -1 means not; 1 means excists;
		private boolean certain = false;
		//private int minConnectionsTimes2;
	//	private int maxConnectionsTimes2;
		//private int maxConnections;
		public BelieveState(int n) {
			rooms = new Room[n+1];
			//connections = new int[n][n];
		//	minConnectionsTimes2 = (int) n;
			//maxConnectionsTimes2 = (int)(n*(n-1)/2);
			//maxConnections = (int)(n*(n-1)/2);
			for (int i = 1; i <= n; i++) {
				rooms[i] = new Room(i,n-1);
			}
		}
		public void update(int kri, int krp) {
			Room r = rooms[kri];
			if (!r.hasBeenVisited) {
				int[] changedPassages = r.visit(krp);
				//maxConnectionsTimes2-=changedPassages[1];
				//minConnectionsTimes2-=changedPassages[0];
			}
			
		}
		public Request getBestRequest() {
			return null;
			// TODO Auto-generated method stub
			
		}
		public int guess() {
			// TODO Auto-generated method stub
			return 0;
		}
		/*public void addConnection(Room currentRoom, Room nextRoom) {
			if (connections[currentRoom.id][nextRoom.id]==0) {
				currentRoom.visitedConnections++;
				nextRoom.visitedConnections++;
			}
			connections[currentRoom.id][nextRoom.id] = 1;
			connections[nextRoom.id][currentRoom.id] = 1;
			
		}*/
		
		
	}
	private static int nextInt(boolean fj, Scanner in ,boolean[][] conn, int room, boolean b) {
		if (!fj)return in.nextInt();
		if (b) {
			System.out.print(room + "" "");
			return room;
		}
		else {
			int counter = 0;
			boolean[] list = conn[room-1];
			for (int i = 0; i < list.length; i++) {
				if (list[i])counter++;
			}
			System.out.println(counter);
			return counter;
		}
		
		
	}
	private static void experiment5(Scanner in) {
		long startTime = System.currentTimeMillis();
		boolean useFakeJudge = false;
		
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		boolean[][] connections = null;
		
		
		for (int i = 1; i <= t; ++i) {
		
			int n = in.nextInt();
			boolean[] checkedRooms = new boolean[n+1];
			int k = in.nextInt();
			//BelieveState bs2;
			if (useFakeJudge) {
				connections = new boolean[n][n];
				int max = n*(n-1)/2;
				double chance = (1/4.);
				for (int j = 0; j < connections.length; j++) {
					int rj = (int) (Math.random()*n);
					connections[j][rj] = true;
					connections[rj][j] = true;
					for (int j2 = j+1; j2 < connections.length; j2++) {
						if (Math.random()<chance) {
							connections[j][j2] = true;
							connections[j2][j] = true;
						}
					}
				}
			};
			BelieveState bs = new BelieveState(n);
			int kri = in.nextInt();
			checkedRooms[kri] = true;
			int krp = in.nextInt();
			bs.update(kri,krp);
			Room currentRoom = bs.rooms[kri];
			ArrayList<Integer> grabBag = new ArrayList<>();
			for (int j = 1; j <= n; j++) {
				if (j == kri)continue;
				grabBag.add(j);
			}
			Collections.shuffle(grabBag);
			int counter = 0;
			Room nextRoom = null;
			long passageSizes = krp;
			long checkedRoomsCount = 1;
			while(k>0&&counter<grabBag.size()&&bs.certain==false) {
				
				//Request r = bs.getBestRequest();
				//r.print();
				int room = 1;
				//if (k % 2 == 0) {
				if (currentRoom.maxPassages > 6 && currentRoom.maxPassages > passageSizes*0.5/checkedRoomsCount) {
					grabBag.get((counter++)%grabBag.size());
					if (checkedRooms[room])continue;
					System.out.println(""T "" + room);}
				else {
					System.out.println(""W"");
				}
					
				int nextI = nextInt(useFakeJudge, in, connections,room,true);
				if (nextI==-1)break;
				
				
				int nextP = nextInt(useFakeJudge, in, connections,room, false);
				 nextRoom = bs.rooms[nextI];
				 if (!checkedRooms[nextI]) {
						checkedRoomsCount++;
						checkedRooms[nextI] = true;
						passageSizes+=nextP;
					}
				//if (r.isWalk) {
					//bs.addConnection(currentRoom,nextRoom);
				//}
				bs.update(nextI,nextP);
				currentRoom = nextRoom;
				k--;
			}
			long countUnvisited = 0;
			long countVisited = 0;
			long passagesInVisited = 0;
			Room[] roms = bs.rooms;
			for (int j = 1; j < roms.length; j++) {
				Room room = roms[j];
				if (room.hasBeenVisited) {
					passagesInVisited+=room.maxPassages;
					countVisited++;
				}
				else countUnvisited += 1;
			}
			double average = passagesInVisited/countVisited;
			long totalRooms = (long) Math.round((passagesInVisited + 1.1*countUnvisited*average)/2.);
			
			long g = totalRooms;
			System.out.println(""E "" + g);
		}
		
	}

	public static class Willies{

		public int fun;
		public Willies parent;
		public ArrayList<Willies> children = new ArrayList<Willies>();
		public ArrayList<Signal> signals = new ArrayList<Signal>();
		public int id;
		public Signal winningSignal; 
		public Willies(int i) {
			this.id = i;
		}
		public void addChild(Willies w) {
			children.add(w);
		}
		public boolean needsMoreSignals() {
			return (signals.size()<children.size());
			
		}
		public void addSignal(Signal signal) {
			this.signals.add(signal);
			if (winningSignal==null)winningSignal = signal;
			else winningSignal = winningSignal.maxFun<signal.maxFun?winningSignal:signal;//smaller max fun gets through
		}
		
		
	}

	public static class Signal{
		private Willies current;

		public Signal(Willies willies) {
			current=willies;
			current.addSignal(this);
			this.maxFun = Math.max(current.fun, maxFun);
		}

		public long maxFun = 0;
		private boolean stopped= false;

		public void step() {
			if (current.needsMoreSignals())return;
			if (current.winningSignal==this) {
				this.maxFun = ",Nibbla
9798,"public class Solution {
	public static void main(String[] args) {
		Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int problem = 5;
		switch (problem) {
		case 1:
			experiment1(in);
			break;
		case 2:
			experiment2(in);
			break;
		case 3:
			experiment3(in);
			break;
		case 4:
			experiment4(in);
			break;
		case 5:
			experiment5(in);
			break;
		default:
			break;
		}

	}

	private static class Room{
		
		public Room(int i,int mp) {
			
			id = i;
			maxPassages = mp;
		}
		
		final int id;
		int minPassages = 1;
		int maxPassages;
		public int visitedConnections = 0;
		public boolean hasBeenVisited = false;
		public int[] visit(int krp) {
			int delta1 = maxPassages-krp;
			int delta0 = krp-minPassages;
			maxPassages = krp;
			minPassages = krp;
			hasBeenVisited = true;
			return new int[] {delta0,delta1};
			
		}
	}
	private static class Request{

		public boolean isWalk;

		public void print() {
			// TODO Auto-generated method stub
			
		}
		
	}
	private static class BelieveState{

		private Room[] rooms;
		//private int[][] connections; //0 means unknown; -1 means not; 1 means excists;
		private boolean certain = false;
		//private int minConnectionsTimes2;
	//	private int maxConnectionsTimes2;
		//private int maxConnections;
		public BelieveState(int n) {
			rooms = new Room[n+1];
			//connections = new int[n][n];
		//	minConnectionsTimes2 = (int) n;
			//maxConnectionsTimes2 = (int)(n*(n-1)/2);
			//maxConnections = (int)(n*(n-1)/2);
			for (int i = 1; i <= n; i++) {
				rooms[i] = new Room(i,n-1);
			}
		}
		public void update(int kri, int krp) {
			Room r = rooms[kri];
			if (!r.hasBeenVisited) {
				int[] changedPassages = r.visit(krp);
				//maxConnectionsTimes2-=changedPassages[1];
				//minConnectionsTimes2-=changedPassages[0];
			}
			
		}
		public Request getBestRequest() {
			return null;
			// TODO Auto-generated method stub
			
		}
		public int guess() {
			// TODO Auto-generated method stub
			return 0;
		}
		/*public void addConnection(Room currentRoom, Room nextRoom) {
			if (connections[currentRoom.id][nextRoom.id]==0) {
				currentRoom.visitedConnections++;
				nextRoom.visitedConnections++;
			}
			connections[currentRoom.id][nextRoom.id] = 1;
			connections[nextRoom.id][currentRoom.id] = 1;
			
		}*/
		
		
	}
	private static int nextInt(boolean fj, Scanner in ,boolean[][] conn, int room, boolean b) {
		if (!fj)return in.nextInt();
		if (b) {
			System.out.print(room + "" "");
			return room;
		}
		else {
			int counter = 0;
			boolean[] list = conn[room-1];
			for (int i = 0; i < list.length; i++) {
				if (list[i])counter++;
			}
			System.out.println(counter);
			return counter;
		}
		
		
	}
	private static void experiment5(Scanner in) {
		long startTime = System.currentTimeMillis();
		boolean useFakeJudge = false;
		
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		boolean[][] connections = null;
		
		
		for (int i = 1; i <= t; ++i) {
		
			int n = in.nextInt();
			boolean[] checkedRooms = new boolean[n+1];
			int k = in.nextInt();
			//BelieveState bs2;
			if (useFakeJudge) {
				connections = new boolean[n][n];
				int max = n*(n-1)/2;
				double chance = (1/4.);
				for (int j = 0; j < connections.length; j++) {
					int rj = (int) (Math.random()*n);
					connections[j][rj] = true;
					connections[rj][j] = true;
					for (int j2 = j+1; j2 < connections.length; j2++) {
						if (Math.random()<chance) {
							connections[j][j2] = true;
							connections[j2][j] = true;
						}
					}
				}
			};
			BelieveState bs = new BelieveState(n);
			int kri = in.nextInt();
			checkedRooms[kri] = true;
			int krp = in.nextInt();
			bs.update(kri,krp);
			Room currentRoom = bs.rooms[kri];
			ArrayList<Integer> grabBag = new ArrayList<>();
			for (int j = 1; j <= n; j++) {
				if (j == kri)continue;
				grabBag.add(j);
			}
			Collections.shuffle(grabBag);
			int counter = 0;
			Room nextRoom = null;
			long passageSizes = krp;
			long checkedRoomsCount = 1;
			while(k>0&&counter<grabBag.size()&&bs.certain==false) {
				
				//Request r = bs.getBestRequest();
				//r.print();
				int room = 1;
				//if (k % 2 == 0) {
				if (currentRoom.maxPassages > 6 && currentRoom.maxPassages > passageSizes*0.5/checkedRoomsCount) {
					grabBag.get((counter++)%grabBag.size());
					if (checkedRooms[room])continue;
					System.out.println(""T "" + room);}
				else {
					System.out.println(""W"");
				}
					
				int nextI = nextInt(useFakeJudge, in, connections,room,true);
				if (nextI==-1)break;
				
				
				int nextP = nextInt(useFakeJudge, in, connections,room, false);
				 nextRoom = bs.rooms[nextI];
				 if (!checkedRooms[nextI]) {
						checkedRoomsCount++;
						checkedRooms[nextI] = true;
						passageSizes+=nextP;
					}
				//if (r.isWalk) {
					//bs.addConnection(currentRoom,nextRoom);
				//}
				bs.update(nextI,nextP);
				currentRoom = nextRoom;
				k--;
			}
			long countUnvisited = 0;
			long countVisited = 0;
			long passagesInVisited = 0;
			Room[] roms = bs.rooms;
			for (int j = 1; j < roms.length; j++) {
				Room room = roms[j];
				if (room.hasBeenVisited) {
					passagesInVisited+=room.maxPassages;
					countVisited++;
				}
				else countUnvisited += 1;
			}
			double average = passagesInVisited/countVisited;
			long totalRooms = (long) Math.round((passagesInVisited + 0.9*countUnvisited*average)/2.);
			
			long g = totalRooms;
			System.out.println(""E "" + g);
		}
		
	}

	public static class Willies{

		public int fun;
		public Willies parent;
		public ArrayList<Willies> children = new ArrayList<Willies>();
		public ArrayList<Signal> signals = new ArrayList<Signal>();
		public int id;
		public Signal winningSignal; 
		public Willies(int i) {
			this.id = i;
		}
		public void addChild(Willies w) {
			children.add(w);
		}
		public boolean needsMoreSignals() {
			return (signals.size()<children.size());
			
		}
		public void addSignal(Signal signal) {
			this.signals.add(signal);
			if (winningSignal==null)winningSignal = signal;
			else winningSignal = winningSignal.maxFun<signal.maxFun?winningSignal:signal;//smaller max fun gets through
		}
		
		
	}

	public static class Signal{
		private Willies current;

		public Signal(Willies willies) {
			current=willies;
			current.addSignal(this);
			this.maxFun = Math.max(current.fun, maxFun);
		}

		public long maxFun = 0;
		private boolean stopped= false;

		public void step() {
			if (current.needsMoreSignals())return;
			if (current.winningSignal==this) {
				this.maxFun = ",Nibbla
9799,"public class Solution {
	public static void main(String[] args) {
		Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int problem = 5;
		switch (problem) {
		case 1:
			experiment1(in);
			break;
		case 2:
			experiment2(in);
			break;
		case 3:
			experiment3(in);
			break;
		case 4:
			experiment4(in);
			break;
		case 5:
			experiment5(in);
			break;
		default:
			break;
		}

	}

	private static class Room{
		
		public Room(int i,int mp) {
			
			id = i;
			maxPassages = mp;
		}
		
		final int id;
		int minPassages = 1;
		int maxPassages;
		public int visitedConnections = 0;
		public boolean hasBeenVisited = false;
		public int[] visit(int krp) {
			int delta1 = maxPassages-krp;
			int delta0 = krp-minPassages;
			maxPassages = krp;
			minPassages = krp;
			hasBeenVisited = true;
			return new int[] {delta0,delta1};
			
		}
	}
	private static class Request{

		public boolean isWalk;

		public void print() {
			// TODO Auto-generated method stub
			
		}
		
	}
	private static class BelieveState{

		private Room[] rooms;
		//private int[][] connections; //0 means unknown; -1 means not; 1 means excists;
		private boolean certain = false;
		//private int minConnectionsTimes2;
	//	private int maxConnectionsTimes2;
		//private int maxConnections;
		public BelieveState(int n) {
			rooms = new Room[n+1];
			//connections = new int[n][n];
		//	minConnectionsTimes2 = (int) n;
			//maxConnectionsTimes2 = (int)(n*(n-1)/2);
			//maxConnections = (int)(n*(n-1)/2);
			for (int i = 1; i <= n; i++) {
				rooms[i] = new Room(i,n-1);
			}
		}
		public void update(int kri, int krp) {
			Room r = rooms[kri];
			if (!r.hasBeenVisited) {
				int[] changedPassages = r.visit(krp);
				//maxConnectionsTimes2-=changedPassages[1];
				//minConnectionsTimes2-=changedPassages[0];
			}
			
		}
		public Request getBestRequest() {
			return null;
			// TODO Auto-generated method stub
			
		}
		public int guess() {
			// TODO Auto-generated method stub
			return 0;
		}
		/*public void addConnection(Room currentRoom, Room nextRoom) {
			if (connections[currentRoom.id][nextRoom.id]==0) {
				currentRoom.visitedConnections++;
				nextRoom.visitedConnections++;
			}
			connections[currentRoom.id][nextRoom.id] = 1;
			connections[nextRoom.id][currentRoom.id] = 1;
			
		}*/
		
		
	}
	private static int nextInt(boolean fj, Scanner in ,boolean[][] conn, int room, boolean b) {
		if (!fj)return in.nextInt();
		if (b) {
			System.out.print(room + "" "");
			return room;
		}
		else {
			int counter = 0;
			boolean[] list = conn[room-1];
			for (int i = 0; i < list.length; i++) {
				if (list[i])counter++;
			}
			System.out.println(counter);
			return counter;
		}
		
		
	}
	private static void experiment5(Scanner in) {
		long startTime = System.currentTimeMillis();
		boolean useFakeJudge = false;
		
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		boolean[][] connections = null;
		
		
		for (int i = 1; i <= t; ++i) {
		
			int n = in.nextInt();
			boolean[] checkedRooms = new boolean[n+1];
			int k = in.nextInt();
			//BelieveState bs2;
			if (useFakeJudge) {
				connections = new boolean[n][n];
				int max = n*(n-1)/2;
				double chance = (1/4.);
				for (int j = 0; j < connections.length; j++) {
					int rj = (int) (Math.random()*n);
					connections[j][rj] = true;
					connections[rj][j] = true;
					for (int j2 = j+1; j2 < connections.length; j2++) {
						if (Math.random()<chance) {
							connections[j][j2] = true;
							connections[j2][j] = true;
						}
					}
				}
			};
			BelieveState bs = new BelieveState(n);
			int kri = in.nextInt();
			checkedRooms[kri] = true;
			int krp = in.nextInt();
			bs.update(kri,krp);
			Room currentRoom = bs.rooms[kri];
			ArrayList<Integer> grabBag = new ArrayList<>();
			for (int j = 1; j <= n; j++) {
				if (j == kri)continue;
				grabBag.add(j);
			}
			Collections.shuffle(grabBag);
			int counter = 0;
			Room nextRoom = null;
			long passageSizes = krp;
			long checkedRoomsCount = 1;
			while(k>0&&counter<grabBag.size()&&bs.certain==false) {
				
				//Request r = bs.getBestRequest();
				//r.print();
				int room = 1;
				//if (k % 2 == 0) {
				if (currentRoom.maxPassages > 6 && currentRoom.maxPassages > passageSizes*0.5/checkedRoomsCount) {
					grabBag.get((counter++)%grabBag.size());
					if (checkedRooms[room])continue;
					System.out.println(""T "" + room);}
				else {
					System.out.println(""W"");
				}
					
				int nextI = nextInt(useFakeJudge, in, connections,room,true);
				if (nextI==-1)break;
				
				
				int nextP = nextInt(useFakeJudge, in, connections,room, false);
				 nextRoom = bs.rooms[nextI];
				 if (!checkedRooms[nextI]) {
						checkedRoomsCount++;
						checkedRooms[nextI] = true;
						passageSizes+=nextP;
					}
				//if (r.isWalk) {
					//bs.addConnection(currentRoom,nextRoom);
				//}
				bs.update(nextI,nextP);
				currentRoom = nextRoom;
				k--;
			}
			long countUnvisited = 0;
			long countVisited = 0;
			long passagesInVisited = 0;
			Room[] roms = bs.rooms;
			for (int j = 1; j < roms.length; j++) {
				Room room = roms[j];
				if (room.hasBeenVisited) {
					passagesInVisited+=room.maxPassages;
					countVisited++;
				}
				else countUnvisited += 1;
			}
			double average = passagesInVisited/countVisited;
			long totalRooms = (long) Math.round(1.0*(passagesInVisited + countUnvisited*average)/2.);
			
			long g = totalRooms;
			System.out.println(""E "" + g);
		}
		
	}

	public static class Willies{

		public int fun;
		public Willies parent;
		public ArrayList<Willies> children = new ArrayList<Willies>();
		public ArrayList<Signal> signals = new ArrayList<Signal>();
		public int id;
		public Signal winningSignal; 
		public Willies(int i) {
			this.id = i;
		}
		public void addChild(Willies w) {
			children.add(w);
		}
		public boolean needsMoreSignals() {
			return (signals.size()<children.size());
			
		}
		public void addSignal(Signal signal) {
			this.signals.add(signal);
			if (winningSignal==null)winningSignal = signal;
			else winningSignal = winningSignal.maxFun<signal.maxFun?winningSignal:signal;//smaller max fun gets through
		}
		
		
	}

	public static class Signal{
		private Willies current;

		public Signal(Willies willies) {
			current=willies;
			current.addSignal(this);
			this.maxFun = Math.max(current.fun, maxFun);
		}

		public long maxFun = 0;
		private boolean stopped= false;

		public void step() {
			if (current.needsMoreSignals())return;
			if (current.winningSignal==this) {
				this.maxFun = ",Nibbla
9800,"public class Solution {
	public static void main(String[] args) {
		Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int problem = 5;
		switch (problem) {
		case 1:
			experiment1(in);
			break;
		case 2:
			experiment2(in);
			break;
		case 3:
			experiment3(in);
			break;
		case 4:
			experiment4(in);
			break;
		case 5:
			experiment5(in);
			break;
		default:
			break;
		}

	}

	private static class Room{
		
		public Room(int i,int mp) {
			
			id = i;
			maxPassages = mp;
		}
		
		final int id;
		int minPassages = 1;
		int maxPassages;
		public int visitedConnections = 0;
		public boolean hasBeenVisited = false;
		public int[] visit(int krp) {
			int delta1 = maxPassages-krp;
			int delta0 = krp-minPassages;
			maxPassages = krp;
			minPassages = krp;
			hasBeenVisited = true;
			return new int[] {delta0,delta1};
			
		}
	}
	private static class Request{

		public boolean isWalk;

		public void print() {
			// TODO Auto-generated method stub
			
		}
		
	}
	private static class BelieveState{

		private Room[] rooms;
		//private int[][] connections; //0 means unknown; -1 means not; 1 means excists;
		private boolean certain = false;
		//private int minConnectionsTimes2;
	//	private int maxConnectionsTimes2;
		//private int maxConnections;
		public BelieveState(int n) {
			rooms = new Room[n+1];
			//connections = new int[n][n];
		//	minConnectionsTimes2 = (int) n;
			//maxConnectionsTimes2 = (int)(n*(n-1)/2);
			//maxConnections = (int)(n*(n-1)/2);
			for (int i = 1; i <= n; i++) {
				rooms[i] = new Room(i,n-1);
			}
		}
		public void update(int kri, int krp) {
			Room r = rooms[kri];
			if (!r.hasBeenVisited) {
				int[] changedPassages = r.visit(krp);
				//maxConnectionsTimes2-=changedPassages[1];
				//minConnectionsTimes2-=changedPassages[0];
			}
			
		}
		public Request getBestRequest() {
			return null;
			// TODO Auto-generated method stub
			
		}
		public int guess() {
			// TODO Auto-generated method stub
			return 0;
		}
		/*public void addConnection(Room currentRoom, Room nextRoom) {
			if (connections[currentRoom.id][nextRoom.id]==0) {
				currentRoom.visitedConnections++;
				nextRoom.visitedConnections++;
			}
			connections[currentRoom.id][nextRoom.id] = 1;
			connections[nextRoom.id][currentRoom.id] = 1;
			
		}*/
		
		
	}
	private static int nextInt(boolean fj, Scanner in ,boolean[][] conn, int room, boolean b) {
		if (!fj)return in.nextInt();
		if (b) {
			System.out.print(room + "" "");
			return room;
		}
		else {
			int counter = 0;
			boolean[] list = conn[room-1];
			for (int i = 0; i < list.length; i++) {
				if (list[i])counter++;
			}
			System.out.println(counter);
			return counter;
		}
		
		
	}
	private static void experiment5(Scanner in) {
		long startTime = System.currentTimeMillis();
		boolean useFakeJudge = false;
		
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		boolean[][] connections = null;
		
		
		for (int i = 1; i <= t; ++i) {
		
			int n = in.nextInt();
			boolean[] checkedRooms = new boolean[n+1];
			int k = in.nextInt();
			//BelieveState bs2;
			if (useFakeJudge) {
				connections = new boolean[n][n];
				int max = n*(n-1)/2;
				double chance = (1/4.);
				for (int j = 0; j < connections.length; j++) {
					int rj = (int) (Math.random()*n);
					connections[j][rj] = true;
					connections[rj][j] = true;
					for (int j2 = j+1; j2 < connections.length; j2++) {
						if (Math.random()<chance) {
							connections[j][j2] = true;
							connections[j2][j] = true;
						}
					}
				}
			};
			BelieveState bs = new BelieveState(n);
			int kri = in.nextInt();
			checkedRooms[kri] = true;
			int krp = in.nextInt();
			bs.update(kri,krp);
			Room currentRoom = bs.rooms[kri];
			ArrayList<Integer> grabBag = new ArrayList<>();
			for (int j = 1; j <= n; j++) {
				if (j == kri)continue;
				grabBag.add(j);
			}
			Collections.shuffle(grabBag);
			int counter = 0;
			Room nextRoom = null;
			long passageSizes = krp;
			long checkedRoomsCount = 1;
			while(k>0&&counter<grabBag.size()&&bs.certain==false) {
				
				//Request r = bs.getBestRequest();
				//r.print();
				int room = 1;
				//if (k % 2 == 0) {
				if (currentRoom.maxPassages > 6 && currentRoom.maxPassages < passageSizes*0.5/checkedRoomsCount) {
					grabBag.get((counter++)%grabBag.size());
					if (checkedRooms[room])continue;
					System.out.println(""T "" + room);}
				else {
					System.out.println(""W"");
				}
					
				int nextI = nextInt(useFakeJudge, in, connections,room,true);
				if (nextI==-1)break;
				
				
				int nextP = nextInt(useFakeJudge, in, connections,room, false);
				 nextRoom = bs.rooms[nextI];
				 if (!checkedRooms[nextI]) {
						checkedRoomsCount++;
						checkedRooms[nextI] = true;
						passageSizes+=nextP;
					}
				//if (r.isWalk) {
					//bs.addConnection(currentRoom,nextRoom);
				//}
				bs.update(nextI,nextP);
				currentRoom = nextRoom;
				k--;
			}
			long countUnvisited = 0;
			long countVisited = 0;
			long passagesInVisited = 0;
			Room[] roms = bs.rooms;
			for (int j = 1; j < roms.length; j++) {
				Room room = roms[j];
				if (room.hasBeenVisited) {
					passagesInVisited+=room.maxPassages;
					countVisited++;
				}
				else countUnvisited += 1;
			}
			double average = passagesInVisited/countVisited;
			long totalRooms = (long) Math.round(1.0*(passagesInVisited + countUnvisited*average)/2.);
			
			long g = totalRooms;
			System.out.println(""E "" + g);
		}
		
	}

	public static class Willies{

		public int fun;
		public Willies parent;
		public ArrayList<Willies> children = new ArrayList<Willies>();
		public ArrayList<Signal> signals = new ArrayList<Signal>();
		public int id;
		public Signal winningSignal; 
		public Willies(int i) {
			this.id = i;
		}
		public void addChild(Willies w) {
			children.add(w);
		}
		public boolean needsMoreSignals() {
			return (signals.size()<children.size());
			
		}
		public void addSignal(Signal signal) {
			this.signals.add(signal);
			if (winningSignal==null)winningSignal = signal;
			else winningSignal = winningSignal.maxFun<signal.maxFun?winningSignal:signal;//smaller max fun gets through
		}
		
		
	}

	public static class Signal{
		private Willies current;

		public Signal(Willies willies) {
			current=willies;
			current.addSignal(this);
			this.maxFun = Math.max(current.fun, maxFun);
		}

		public long maxFun = 0;
		private boolean stopped= false;

		public void step() {
			if (current.needsMoreSignals())return;
			if (current.winningSignal==this) {
				this.maxFun = ",Nibbla
9801,"public class Solution {
	public static void main(String[] args) {
		Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int problem = 5;
		switch (problem) {
		case 1:
			experiment1(in);
			break;
		case 2:
			experiment2(in);
			break;
		case 3:
			experiment3(in);
			break;
		case 4:
			experiment4(in);
			break;
		case 5:
			experiment5(in);
			break;
		default:
			break;
		}

	}

	private static class Room{
		
		public Room(int i,int mp) {
			
			id = i;
			maxPassages = mp;
		}
		
		final int id;
		int minPassages = 1;
		int maxPassages;
		public int visitedConnections = 0;
		public boolean hasBeenVisited = false;
		public int[] visit(int krp) {
			int delta1 = maxPassages-krp;
			int delta0 = krp-minPassages;
			maxPassages = krp;
			minPassages = krp;
			hasBeenVisited = true;
			return new int[] {delta0,delta1};
			
		}
	}
	private static class Request{

		public boolean isWalk;

		public void print() {
			// TODO Auto-generated method stub
			
		}
		
	}
	private static class BelieveState{

		private Room[] rooms;
		//private int[][] connections; //0 means unknown; -1 means not; 1 means excists;
		private boolean certain = false;
		//private int minConnectionsTimes2;
	//	private int maxConnectionsTimes2;
		//private int maxConnections;
		public BelieveState(int n) {
			rooms = new Room[n+1];
			//connections = new int[n][n];
		//	minConnectionsTimes2 = (int) n;
			//maxConnectionsTimes2 = (int)(n*(n-1)/2);
			//maxConnections = (int)(n*(n-1)/2);
			for (int i = 1; i <= n; i++) {
				rooms[i] = new Room(i,n-1);
			}
		}
		public void update(int kri, int krp) {
			Room r = rooms[kri];
			if (!r.hasBeenVisited) {
				int[] changedPassages = r.visit(krp);
				//maxConnectionsTimes2-=changedPassages[1];
				//minConnectionsTimes2-=changedPassages[0];
			}
			
		}
		public Request getBestRequest() {
			return null;
			// TODO Auto-generated method stub
			
		}
		public int guess() {
			// TODO Auto-generated method stub
			return 0;
		}
		/*public void addConnection(Room currentRoom, Room nextRoom) {
			if (connections[currentRoom.id][nextRoom.id]==0) {
				currentRoom.visitedConnections++;
				nextRoom.visitedConnections++;
			}
			connections[currentRoom.id][nextRoom.id] = 1;
			connections[nextRoom.id][currentRoom.id] = 1;
			
		}*/
		
		
	}
	private static int nextInt(boolean fj, Scanner in ,boolean[][] conn, int room, boolean b) {
		if (!fj)return in.nextInt();
		if (b) {
			System.out.print(room + "" "");
			return room;
		}
		else {
			int counter = 0;
			boolean[] list = conn[room-1];
			for (int i = 0; i < list.length; i++) {
				if (list[i])counter++;
			}
			System.out.println(counter);
			return counter;
		}
		
		
	}
	private static void experiment5(Scanner in) {
		long startTime = System.currentTimeMillis();
		boolean useFakeJudge = false;
		
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		boolean[][] connections = null;
		
		
		for (int i = 1; i <= t; ++i) {
		
			int n = in.nextInt();
			boolean[] checkedRooms = new boolean[n+1];
			int k = in.nextInt();
			//BelieveState bs2;
			if (useFakeJudge) {
				connections = new boolean[n][n];
				int max = n*(n-1)/2;
				double chance = (1/4.);
				for (int j = 0; j < connections.length; j++) {
					int rj = (int) (Math.random()*n);
					connections[j][rj] = true;
					connections[rj][j] = true;
					for (int j2 = j+1; j2 < connections.length; j2++) {
						if (Math.random()<chance) {
							connections[j][j2] = true;
							connections[j2][j] = true;
						}
					}
				}
			};
			BelieveState bs = new BelieveState(n);
			int kri = in.nextInt();
			checkedRooms[kri] = true;
			int krp = in.nextInt();
			bs.update(kri,krp);
			Room currentRoom = bs.rooms[kri];
			ArrayList<Integer> grabBag = new ArrayList<>();
			for (int j = 1; j <= n; j++) {
				if (j == kri)continue;
				grabBag.add(j);
			}
			Collections.shuffle(grabBag);
			int counter = 0;
			Room nextRoom = null;
			long passageSizes = krp;
			long checkedRoomsCount = 1;
			while(k>0&&counter<grabBag.size()&&bs.certain==false) {
				
				//Request r = bs.getBestRequest();
				//r.print();
				int room = 1;
				//if (k % 2 == 0) {
				if (currentRoom.maxPassages > 6 && currentRoom.maxPassages < passageSizes*1.0/checkedRoomsCount) {
					grabBag.get((counter++)%grabBag.size());
					if (checkedRooms[room])continue;
					System.out.println(""T "" + room);}
				else {
					System.out.println(""W"");
				}
					
				int nextI = nextInt(useFakeJudge, in, connections,room,true);
				if (nextI==-1)break;
				
				
				int nextP = nextInt(useFakeJudge, in, connections,room, false);
				 nextRoom = bs.rooms[nextI];
				 if (!checkedRooms[nextI]) {
						checkedRoomsCount++;
						checkedRooms[nextI] = true;
						passageSizes+=nextP;
					}
				//if (r.isWalk) {
					//bs.addConnection(currentRoom,nextRoom);
				//}
				bs.update(nextI,nextP);
				currentRoom = nextRoom;
				k--;
			}
			long countUnvisited = 0;
			long countVisited = 0;
			long passagesInVisited = 0;
			Room[] roms = bs.rooms;
			for (int j = 1; j < roms.length; j++) {
				Room room = roms[j];
				if (room.hasBeenVisited) {
					passagesInVisited+=room.maxPassages;
					countVisited++;
				}
				else countUnvisited += 1;
			}
			double average = passagesInVisited/countVisited;
			long totalRooms = (long) Math.round(1.0*(passagesInVisited + countUnvisited*average)/2.);
			
			long g = totalRooms;
			System.out.println(""E "" + g);
		}
		
	}

	public static class Willies{

		public int fun;
		public Willies parent;
		public ArrayList<Willies> children = new ArrayList<Willies>();
		public ArrayList<Signal> signals = new ArrayList<Signal>();
		public int id;
		public Signal winningSignal; 
		public Willies(int i) {
			this.id = i;
		}
		public void addChild(Willies w) {
			children.add(w);
		}
		public boolean needsMoreSignals() {
			return (signals.size()<children.size());
			
		}
		public void addSignal(Signal signal) {
			this.signals.add(signal);
			if (winningSignal==null)winningSignal = signal;
			else winningSignal = winningSignal.maxFun<signal.maxFun?winningSignal:signal;//smaller max fun gets through
		}
		
		
	}

	public static class Signal{
		private Willies current;

		public Signal(Willies willies) {
			current=willies;
			current.addSignal(this);
			this.maxFun = Math.max(current.fun, maxFun);
		}

		public long maxFun = 0;
		private boolean stopped= false;

		public void step() {
			if (current.needsMoreSignals())return;
			if (current.winningSignal==this) {
				this.maxFun = ",Nibbla
9802,"public class Solution {
	public static void main(String[] args) {
		Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int problem = 5;
		switch (problem) {
		case 1:
			experiment1(in);
			break;
		case 2:
			experiment2(in);
			break;
		case 3:
			experiment3(in);
			break;
		case 4:
			experiment4(in);
			break;
		case 5:
			experiment5(in);
			break;
		default:
			break;
		}

	}

	private static class Room{
		
		public Room(int i,int mp) {
			
			id = i;
			maxPassages = mp;
		}
		
		final int id;
		int minPassages = 1;
		int maxPassages;
		public int visitedConnections = 0;
		public boolean hasBeenVisited = false;
		public int[] visit(int krp) {
			int delta1 = maxPassages-krp;
			int delta0 = krp-minPassages;
			maxPassages = krp;
			minPassages = krp;
			hasBeenVisited = true;
			return new int[] {delta0,delta1};
			
		}
	}
	private static class Request{

		public boolean isWalk;

		public void print() {
			// TODO Auto-generated method stub
			
		}
		
	}
	private static class BelieveState{

		private Room[] rooms;
		//private int[][] connections; //0 means unknown; -1 means not; 1 means excists;
		private boolean certain = false;
		//private int minConnectionsTimes2;
	//	private int maxConnectionsTimes2;
		//private int maxConnections;
		public BelieveState(int n) {
			rooms = new Room[n+1];
			//connections = new int[n][n];
		//	minConnectionsTimes2 = (int) n;
			//maxConnectionsTimes2 = (int)(n*(n-1)/2);
			//maxConnections = (int)(n*(n-1)/2);
			for (int i = 1; i <= n; i++) {
				rooms[i] = new Room(i,n-1);
			}
		}
		public void update(int kri, int krp) {
			Room r = rooms[kri];
			if (!r.hasBeenVisited) {
				int[] changedPassages = r.visit(krp);
				//maxConnectionsTimes2-=changedPassages[1];
				//minConnectionsTimes2-=changedPassages[0];
			}
			
		}
		public Request getBestRequest() {
			return null;
			// TODO Auto-generated method stub
			
		}
		public int guess() {
			// TODO Auto-generated method stub
			return 0;
		}
		/*public void addConnection(Room currentRoom, Room nextRoom) {
			if (connections[currentRoom.id][nextRoom.id]==0) {
				currentRoom.visitedConnections++;
				nextRoom.visitedConnections++;
			}
			connections[currentRoom.id][nextRoom.id] = 1;
			connections[nextRoom.id][currentRoom.id] = 1;
			
		}*/
		
		
	}
	private static int nextInt(boolean fj, Scanner in ,boolean[][] conn, int room, boolean b) {
		if (!fj)return in.nextInt();
		if (b) {
			System.out.print(room + "" "");
			return room;
		}
		else {
			int counter = 0;
			boolean[] list = conn[room-1];
			for (int i = 0; i < list.length; i++) {
				if (list[i])counter++;
			}
			System.out.println(counter);
			return counter;
		}
		
		
	}
	private static void experiment5(Scanner in) {
		long startTime = System.currentTimeMillis();
		boolean useFakeJudge = false;
		
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		boolean[][] connections = null;
		
		
		for (int i = 1; i <= t; ++i) {
		
			int n = in.nextInt();
			boolean[] checkedRooms = new boolean[n+1];
			int k = in.nextInt();
			//BelieveState bs2;
			if (useFakeJudge) {
				connections = new boolean[n][n];
				int max = n*(n-1)/2;
				double chance = (1/4.);
				for (int j = 0; j < connections.length; j++) {
					int rj = (int) (Math.random()*n);
					connections[j][rj] = true;
					connections[rj][j] = true;
					for (int j2 = j+1; j2 < connections.length; j2++) {
						if (Math.random()<chance) {
							connections[j][j2] = true;
							connections[j2][j] = true;
						}
					}
				}
			};
			BelieveState bs = new BelieveState(n);
			int kri = in.nextInt();
			checkedRooms[kri] = true;
			int krp = in.nextInt();
			bs.update(kri,krp);
			Room currentRoom = bs.rooms[kri];
			ArrayList<Integer> grabBag = new ArrayList<>();
			for (int j = 1; j <= n; j++) {
				if (j == kri)continue;
				grabBag.add(j);
			}
			Collections.shuffle(grabBag);
			int counter = 0;
			Room nextRoom = null;
			long passageSizes = krp;
			long checkedRoomsCount = 1;
			while(k>0&&counter<grabBag.size()&&bs.certain==false) {
				
				//Request r = bs.getBestRequest();
				//r.print();
				int room = 1;
				//if (k % 2 == 0) {
				if (currentRoom.maxPassages > 6 && currentRoom.maxPassages < passageSizes*0.7/checkedRoomsCount) {
					grabBag.get((counter++)%grabBag.size());
					if (checkedRooms[room])continue;
					System.out.println(""T "" + room);}
				else {
					System.out.println(""W"");
				}
					
				int nextI = nextInt(useFakeJudge, in, connections,room,true);
				if (nextI==-1)break;
				
				
				int nextP = nextInt(useFakeJudge, in, connections,room, false);
				 nextRoom = bs.rooms[nextI];
				 if (!checkedRooms[nextI]) {
						checkedRoomsCount++;
						checkedRooms[nextI] = true;
						passageSizes+=nextP;
					}
				//if (r.isWalk) {
					//bs.addConnection(currentRoom,nextRoom);
				//}
				bs.update(nextI,nextP);
				currentRoom = nextRoom;
				k--;
			}
			long countUnvisited = 0;
			long countVisited = 0;
			long passagesInVisited = 0;
			Room[] roms = bs.rooms;
			for (int j = 1; j < roms.length; j++) {
				Room room = roms[j];
				if (room.hasBeenVisited) {
					passagesInVisited+=room.maxPassages;
					countVisited++;
				}
				else countUnvisited += 1;
			}
			double average = passagesInVisited/countVisited;
			long totalRooms = (long) Math.round(1.0*(passagesInVisited + countUnvisited*average)/2.);
			
			long g = totalRooms;
			System.out.println(""E "" + g);
		}
		
	}

	public static class Willies{

		public int fun;
		public Willies parent;
		public ArrayList<Willies> children = new ArrayList<Willies>();
		public ArrayList<Signal> signals = new ArrayList<Signal>();
		public int id;
		public Signal winningSignal; 
		public Willies(int i) {
			this.id = i;
		}
		public void addChild(Willies w) {
			children.add(w);
		}
		public boolean needsMoreSignals() {
			return (signals.size()<children.size());
			
		}
		public void addSignal(Signal signal) {
			this.signals.add(signal);
			if (winningSignal==null)winningSignal = signal;
			else winningSignal = winningSignal.maxFun<signal.maxFun?winningSignal:signal;//smaller max fun gets through
		}
		
		
	}

	public static class Signal{
		private Willies current;

		public Signal(Willies willies) {
			current=willies;
			current.addSignal(this);
			this.maxFun = Math.max(current.fun, maxFun);
		}

		public long maxFun = 0;
		private boolean stopped= false;

		public void step() {
			if (current.needsMoreSignals())return;
			if (current.winningSignal==this) {
				this.maxFun = ",Nibbla
9803,"public class Solution {
	public static void main(String[] args) {
		Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int problem = 5;
		switch (problem) {
		case 1:
			experiment1(in);
			break;
		case 2:
			experiment2(in);
			break;
		case 3:
			experiment3(in);
			break;
		case 4:
			experiment4(in);
			break;
		case 5:
			experiment5(in);
			break;
		default:
			break;
		}

	}

	private static class Room{
		
		public Room(int i,int mp) {
			
			id = i;
			maxPassages = mp;
		}
		
		final int id;
		int minPassages = 1;
		int maxPassages;
		public int visitedConnections = 0;
		public boolean hasBeenVisited = false;
		public int[] visit(int krp) {
			int delta1 = maxPassages-krp;
			int delta0 = krp-minPassages;
			maxPassages = krp;
			minPassages = krp;
			hasBeenVisited = true;
			return new int[] {delta0,delta1};
			
		}
	}
	private static class Request{

		public boolean isWalk;

		public void print() {
			// TODO Auto-generated method stub
			
		}
		
	}
	private static class BelieveState{

		private Room[] rooms;
		//private int[][] connections; //0 means unknown; -1 means not; 1 means excists;
		private boolean certain = false;
		//private int minConnectionsTimes2;
	//	private int maxConnectionsTimes2;
		//private int maxConnections;
		public BelieveState(int n) {
			rooms = new Room[n+1];
			//connections = new int[n][n];
		//	minConnectionsTimes2 = (int) n;
			//maxConnectionsTimes2 = (int)(n*(n-1)/2);
			//maxConnections = (int)(n*(n-1)/2);
			for (int i = 1; i <= n; i++) {
				rooms[i] = new Room(i,n-1);
			}
		}
		public void update(int kri, int krp) {
			Room r = rooms[kri];
			if (!r.hasBeenVisited) {
				int[] changedPassages = r.visit(krp);
				//maxConnectionsTimes2-=changedPassages[1];
				//minConnectionsTimes2-=changedPassages[0];
			}
			
		}
		public Request getBestRequest() {
			return null;
			// TODO Auto-generated method stub
			
		}
		public int guess() {
			// TODO Auto-generated method stub
			return 0;
		}
		/*public void addConnection(Room currentRoom, Room nextRoom) {
			if (connections[currentRoom.id][nextRoom.id]==0) {
				currentRoom.visitedConnections++;
				nextRoom.visitedConnections++;
			}
			connections[currentRoom.id][nextRoom.id] = 1;
			connections[nextRoom.id][currentRoom.id] = 1;
			
		}*/
		
		
	}
	private static int nextInt(boolean fj, Scanner in ,boolean[][] conn, int room, boolean b) {
		if (!fj)return in.nextInt();
		if (b) {
			System.out.print(room + "" "");
			return room;
		}
		else {
			int counter = 0;
			boolean[] list = conn[room-1];
			for (int i = 0; i < list.length; i++) {
				if (list[i])counter++;
			}
			System.out.println(counter);
			return counter;
		}
		
		
	}
	private static void experiment5(Scanner in) {
		long startTime = System.currentTimeMillis();
		boolean useFakeJudge = false;
		
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		boolean[][] connections = null;
		
		
		for (int i = 1; i <= t; ++i) {
		
			int n = in.nextInt();
			boolean[] checkedRooms = new boolean[n+1];
			int k = in.nextInt();
			//BelieveState bs2;
			if (useFakeJudge) {
				connections = new boolean[n][n];
				int max = n*(n-1)/2;
				double chance = (1/4.);
				for (int j = 0; j < connections.length; j++) {
					int rj = (int) (Math.random()*n);
					connections[j][rj] = true;
					connections[rj][j] = true;
					for (int j2 = j+1; j2 < connections.length; j2++) {
						if (Math.random()<chance) {
							connections[j][j2] = true;
							connections[j2][j] = true;
						}
					}
				}
			};
			BelieveState bs = new BelieveState(n);
			int kri = in.nextInt();
			checkedRooms[kri] = true;
			int krp = in.nextInt();
			bs.update(kri,krp);
			Room currentRoom = bs.rooms[kri];
			ArrayList<Integer> grabBag = new ArrayList<>();
			for (int j = 1; j <= n; j++) {
				if (j == kri)continue;
				grabBag.add(j);
			}
			Collections.shuffle(grabBag);
			int counter = 0;
			Room nextRoom = null;
			long passageSizes = krp;
			long checkedRoomsCount = 1;
			while(k>0&&counter<grabBag.size()&&bs.certain==false) {
				
				//Request r = bs.getBestRequest();
				//r.print();
				int room = 1;
				//if (k % 2 == 0) {
				if (currentRoom.maxPassages > 5
				&& currentRoom.maxPassages < passageSizes*0.7/checkedRoomsCount) {
					grabBag.get((counter++)%grabBag.size());
					if (checkedRooms[room])continue;
					System.out.println(""T "" + room);}
				else {
					System.out.println(""W"");
				}
					
				int nextI = nextInt(useFakeJudge, in, connections,room,true);
				if (nextI==-1)break;
				
				
				int nextP = nextInt(useFakeJudge, in, connections,room, false);
				 nextRoom = bs.rooms[nextI];
				 if (!checkedRooms[nextI]) {
						checkedRoomsCount++;
						checkedRooms[nextI] = true;
						passageSizes+=nextP;
					}
				//if (r.isWalk) {
					//bs.addConnection(currentRoom,nextRoom);
				//}
				bs.update(nextI,nextP);
				currentRoom = nextRoom;
				k--;
			}
			long countUnvisited = 0;
			long countVisited = 0;
			long passagesInVisited = 0;
			Room[] roms = bs.rooms;
			for (int j = 1; j < roms.length; j++) {
				Room room = roms[j];
				if (room.hasBeenVisited) {
					passagesInVisited+=room.maxPassages;
					countVisited++;
				}
				else countUnvisited += 1;
			}
			double average = passagesInVisited/countVisited;
			long totalRooms = (long) Math.round(1.0*(passagesInVisited + countUnvisited*average)/2.);
			
			long g = totalRooms;
			System.out.println(""E "" + g);
		}
		
	}

	public static class Willies{

		public int fun;
		public Willies parent;
		public ArrayList<Willies> children = new ArrayList<Willies>();
		public ArrayList<Signal> signals = new ArrayList<Signal>();
		public int id;
		public Signal winningSignal; 
		public Willies(int i) {
			this.id = i;
		}
		public void addChild(Willies w) {
			children.add(w);
		}
		public boolean needsMoreSignals() {
			return (signals.size()<children.size());
			
		}
		public void addSignal(Signal signal) {
			this.signals.add(signal);
			if (winningSignal==null)winningSignal = signal;
			else winningSignal = winningSignal.maxFun<signal.maxFun?winningSignal:signal;//smaller max fun gets through
		}
		
		
	}

	public static class Signal{
		private Willies current;

		public Signal(Willies willies) {
			current=willies;
			current.addSignal(this);
			this.maxFun = Math.max(current.fun, maxFun);
		}

		public long maxFun = 0;
		private boolean stopped= ",Nibbla
9804,"public class Solution {
	public static void main(String[] args) {
		Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int problem = 5;
		switch (problem) {
		case 1:
			experiment1(in);
			break;
		case 2:
			experiment2(in);
			break;
		case 3:
			experiment3(in);
			break;
		case 4:
			experiment4(in);
			break;
		case 5:
			experiment5(in);
			break;
		default:
			break;
		}

	}

	private static class Room{
		
		public Room(int i,int mp) {
			
			id = i;
			maxPassages = mp;
		}
		
		final int id;
		int minPassages = 1;
		int maxPassages;
		public int visitedConnections = 0;
		public boolean hasBeenVisited = false;
		public int[] visit(int krp) {
			int delta1 = maxPassages-krp;
			int delta0 = krp-minPassages;
			maxPassages = krp;
			minPassages = krp;
			hasBeenVisited = true;
			return new int[] {delta0,delta1};
			
		}
	}
	private static class Request{

		public boolean isWalk;

		public void print() {
			// TODO Auto-generated method stub
			
		}
		
	}
	private static class BelieveState{

		private Room[] rooms;
		//private int[][] connections; //0 means unknown; -1 means not; 1 means excists;
		private boolean certain = false;
		//private int minConnectionsTimes2;
	//	private int maxConnectionsTimes2;
		//private int maxConnections;
		public BelieveState(int n) {
			rooms = new Room[n+1];
			//connections = new int[n][n];
		//	minConnectionsTimes2 = (int) n;
			//maxConnectionsTimes2 = (int)(n*(n-1)/2);
			//maxConnections = (int)(n*(n-1)/2);
			for (int i = 1; i <= n; i++) {
				rooms[i] = new Room(i,n-1);
			}
		}
		public void update(int kri, int krp) {
			Room r = rooms[kri];
			if (!r.hasBeenVisited) {
				int[] changedPassages = r.visit(krp);
				//maxConnectionsTimes2-=changedPassages[1];
				//minConnectionsTimes2-=changedPassages[0];
			}
			
		}
		public Request getBestRequest() {
			return null;
			// TODO Auto-generated method stub
			
		}
		public int guess() {
			// TODO Auto-generated method stub
			return 0;
		}
		/*public void addConnection(Room currentRoom, Room nextRoom) {
			if (connections[currentRoom.id][nextRoom.id]==0) {
				currentRoom.visitedConnections++;
				nextRoom.visitedConnections++;
			}
			connections[currentRoom.id][nextRoom.id] = 1;
			connections[nextRoom.id][currentRoom.id] = 1;
			
		}*/
		
		
	}
	private static int nextInt(boolean fj, Scanner in ,boolean[][] conn, int room, boolean b) {
		if (!fj)return in.nextInt();
		if (b) {
			System.out.print(room + "" "");
			return room;
		}
		else {
			int counter = 0;
			boolean[] list = conn[room-1];
			for (int i = 0; i < list.length; i++) {
				if (list[i])counter++;
			}
			System.out.println(counter);
			return counter;
		}
		
		
	}
	private static void experiment5(Scanner in) {
		long startTime = System.currentTimeMillis();
		boolean useFakeJudge = false;
		
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		boolean[][] connections = null;
		
		
		for (int i = 1; i <= t; ++i) {
		
			int n = in.nextInt();
			boolean[] checkedRooms = new boolean[n+1];
			int k = in.nextInt();
			//BelieveState bs2;
			if (useFakeJudge) {
				connections = new boolean[n][n];
				int max = n*(n-1)/2;
				double chance = (1/4.);
				for (int j = 0; j < connections.length; j++) {
					int rj = (int) (Math.random()*n);
					connections[j][rj] = true;
					connections[rj][j] = true;
					for (int j2 = j+1; j2 < connections.length; j2++) {
						if (Math.random()<chance) {
							connections[j][j2] = true;
							connections[j2][j] = true;
						}
					}
				}
			};
			BelieveState bs = new BelieveState(n);
			int kri = in.nextInt();
			checkedRooms[kri] = true;
			int krp = in.nextInt();
			bs.update(kri,krp);
			Room currentRoom = bs.rooms[kri];
			ArrayList<Integer> grabBag = new ArrayList<>();
			for (int j = 1; j <= n; j++) {
				if (j == kri)continue;
				grabBag.add(j);
			}
			Collections.shuffle(grabBag);
			int counter = 0;
			Room nextRoom = null;
			long passageSizes = krp;
			long checkedRoomsCount = 1;
			while(k>0&&counter<grabBag.size()&&bs.certain==false) {
				
				//Request r = bs.getBestRequest();
				//r.print();
				int room = 1;
				//if (k % 2 == 0) {
				if (currentRoom.maxPassages > 4 && currentRoom.maxPassages < passageSizes*0.7/checkedRoomsCount) {
					grabBag.get((counter++)%grabBag.size());
					if (checkedRooms[room])continue;
					System.out.println(""T "" + room);}
				else {
					System.out.println(""W"");
				}
					
				int nextI = nextInt(useFakeJudge, in, connections,room,true);
				if (nextI==-1)break;
				
				
				int nextP = nextInt(useFakeJudge, in, connections,room, false);
				 nextRoom = bs.rooms[nextI];
				 if (!checkedRooms[nextI]) {
						checkedRoomsCount++;
						checkedRooms[nextI] = true;
						passageSizes+=nextP;
					}
				//if (r.isWalk) {
					//bs.addConnection(currentRoom,nextRoom);
				//}
				bs.update(nextI,nextP);
				currentRoom = nextRoom;
				k--;
			}
			long countUnvisited = 0;
			long countVisited = 0;
			long passagesInVisited = 0;
			Room[] roms = bs.rooms;
			for (int j = 1; j < roms.length; j++) {
				Room room = roms[j];
				if (room.hasBeenVisited) {
					passagesInVisited+=room.maxPassages;
					countVisited++;
				}
				else countUnvisited += 1;
			}
			double average = passagesInVisited/countVisited;
			long totalRooms = (long) Math.round(1.0*(passagesInVisited + countUnvisited*average)/2.);
			
			long g = totalRooms;
			System.out.println(""E "" + g);
		}
		
	}

	public static class Willies{

		public int fun;
		public Willies parent;
		public ArrayList<Willies> children = new ArrayList<Willies>();
		public ArrayList<Signal> signals = new ArrayList<Signal>();
		public int id;
		public Signal winningSignal; 
		public Willies(int i) {
			this.id = i;
		}
		public void addChild(Willies w) {
			children.add(w);
		}
		public boolean needsMoreSignals() {
			return (signals.size()<children.size());
			
		}
		public void addSignal(Signal signal) {
			this.signals.add(signal);
			if (winningSignal==null)winningSignal = signal;
			else winningSignal = winningSignal.maxFun<signal.maxFun?winningSignal:signal;//smaller max fun gets through
		}
		
		
	}

	public static class Signal{
		private Willies current;

		public Signal(Willies willies) {
			current=willies;
			current.addSignal(this);
			this.maxFun = Math.max(current.fun, maxFun);
		}

		public long maxFun = 0;
		private boolean stopped= false;

		public void step() {
			if (current.needsMoreSignals())return;
			if (current.winningSignal==this) {
				this.maxFun = ",Nibbla
9805,"public class Solution {
	public static void main(String[] args) {
		Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int problem = 5;
		switch (problem) {
		case 1:
			experiment1(in);
			break;
		case 2:
			experiment2(in);
			break;
		case 3:
			experiment3(in);
			break;
		case 4:
			experiment4(in);
			break;
		case 5:
			experiment5(in);
			break;
		default:
			break;
		}

	}

	private static class Room{
		
		public Room(int i,int mp) {
			
			id = i;
			maxPassages = mp;
		}
		
		final int id;
		int minPassages = 1;
		int maxPassages;
		public int visitedConnections = 0;
		public boolean hasBeenVisited = false;
		public int[] visit(int krp) {
			int delta1 = maxPassages-krp;
			int delta0 = krp-minPassages;
			maxPassages = krp;
			minPassages = krp;
			hasBeenVisited = true;
			return new int[] {delta0,delta1};
			
		}
	}
	private static class Request{

		public boolean isWalk;

		public void print() {
			// TODO Auto-generated method stub
			
		}
		
	}
	private static class BelieveState{

		private Room[] rooms;
		//private int[][] connections; //0 means unknown; -1 means not; 1 means excists;
		private boolean certain = false;
		//private int minConnectionsTimes2;
	//	private int maxConnectionsTimes2;
		//private int maxConnections;
		public BelieveState(int n) {
			rooms = new Room[n+1];
			//connections = new int[n][n];
		//	minConnectionsTimes2 = (int) n;
			//maxConnectionsTimes2 = (int)(n*(n-1)/2);
			//maxConnections = (int)(n*(n-1)/2);
			for (int i = 1; i <= n; i++) {
				rooms[i] = new Room(i,n-1);
			}
		}
		public void update(int kri, int krp) {
			Room r = rooms[kri];
			if (!r.hasBeenVisited) {
				int[] changedPassages = r.visit(krp);
				//maxConnectionsTimes2-=changedPassages[1];
				//minConnectionsTimes2-=changedPassages[0];
			}
			
		}
		public Request getBestRequest() {
			return null;
			// TODO Auto-generated method stub
			
		}
		public int guess() {
			// TODO Auto-generated method stub
			return 0;
		}
		/*public void addConnection(Room currentRoom, Room nextRoom) {
			if (connections[currentRoom.id][nextRoom.id]==0) {
				currentRoom.visitedConnections++;
				nextRoom.visitedConnections++;
			}
			connections[currentRoom.id][nextRoom.id] = 1;
			connections[nextRoom.id][currentRoom.id] = 1;
			
		}*/
		
		
	}
	private static int nextInt(boolean fj, Scanner in ,boolean[][] conn, int room, boolean b) {
		if (!fj)return in.nextInt();
		if (b) {
			System.out.print(room + "" "");
			return room;
		}
		else {
			int counter = 0;
			boolean[] list = conn[room-1];
			for (int i = 0; i < list.length; i++) {
				if (list[i])counter++;
			}
			System.out.println(counter);
			return counter;
		}
		
		
	}
	private static void experiment5(Scanner in) {
		long startTime = System.currentTimeMillis();
		boolean useFakeJudge = false;
		
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		boolean[][] connections = null;
		
		
		for (int i = 1; i <= t; ++i) {
		
			int n = in.nextInt();
			boolean[] checkedRooms = new boolean[n+1];
			int k = in.nextInt();
			//BelieveState bs2;
			if (useFakeJudge) {
				connections = new boolean[n][n];
				int max = n*(n-1)/2;
				double chance = (1/4.);
				for (int j = 0; j < connections.length; j++) {
					int rj = (int) (Math.random()*n);
					connections[j][rj] = true;
					connections[rj][j] = true;
					for (int j2 = j+1; j2 < connections.length; j2++) {
						if (Math.random()<chance) {
							connections[j][j2] = true;
							connections[j2][j] = true;
						}
					}
				}
			};
			BelieveState bs = new BelieveState(n);
			int kri = in.nextInt();
			checkedRooms[kri] = true;
			int krp = in.nextInt();
			bs.update(kri,krp);
			Room currentRoom = bs.rooms[kri];
			ArrayList<Integer> grabBag = new ArrayList<>();
			for (int j = 1; j <= n; j++) {
				if (j == kri)continue;
				grabBag.add(j);
			}
			Collections.shuffle(grabBag);
			int counter = 0;
			Room nextRoom = null;
			long passageSizes = krp;
			long checkedRoomsCount = 1;
			while(k>0&&counter<grabBag.size()&&bs.certain==false) {
				
				//Request r = bs.getBestRequest();
				//r.print();
				int room = 1;
				//if (k % 2 == 0) {
				if (currentRoom.maxPassages > 2 && currentRoom.maxPassages < passageSizes*0.7/checkedRoomsCount) {
					grabBag.get((counter++)%grabBag.size());
					if (checkedRooms[room])continue;
					System.out.println(""T "" + room);}
				else {
					System.out.println(""W"");
				}
					
				int nextI = nextInt(useFakeJudge, in, connections,room,true);
				if (nextI==-1)break;
				
				
				int nextP = nextInt(useFakeJudge, in, connections,room, false);
				 nextRoom = bs.rooms[nextI];
				 if (!checkedRooms[nextI]) {
						checkedRoomsCount++;
						checkedRooms[nextI] = true;
						passageSizes+=nextP;
					}
				//if (r.isWalk) {
					//bs.addConnection(currentRoom,nextRoom);
				//}
				bs.update(nextI,nextP);
				currentRoom = nextRoom;
				k--;
			}
			long countUnvisited = 0;
			long countVisited = 0;
			long passagesInVisited = 0;
			Room[] roms = bs.rooms;
			for (int j = 1; j < roms.length; j++) {
				Room room = roms[j];
				if (room.hasBeenVisited) {
					passagesInVisited+=room.maxPassages;
					countVisited++;
				}
				else countUnvisited += 1;
			}
			double average = passagesInVisited/countVisited;
			long totalRooms = (long) Math.round(1.0*(passagesInVisited + countUnvisited*average)/2.);
			
			long g = totalRooms;
			System.out.println(""E "" + g);
		}
		
	}

	public static class Willies{

		public int fun;
		public Willies parent;
		public ArrayList<Willies> children = new ArrayList<Willies>();
		public ArrayList<Signal> signals = new ArrayList<Signal>();
		public int id;
		public Signal winningSignal; 
		public Willies(int i) {
			this.id = i;
		}
		public void addChild(Willies w) {
			children.add(w);
		}
		public boolean needsMoreSignals() {
			return (signals.size()<children.size());
			
		}
		public void addSignal(Signal signal) {
			this.signals.add(signal);
			if (winningSignal==null)winningSignal = signal;
			else winningSignal = winningSignal.maxFun<signal.maxFun?winningSignal:signal;//smaller max fun gets through
		}
		
		
	}

	public static class Signal{
		private Willies current;

		public Signal(Willies willies) {
			current=willies;
			current.addSignal(this);
			this.maxFun = Math.max(current.fun, maxFun);
		}

		public long maxFun = 0;
		private boolean stopped= false;

		public void step() {
			if (current.needsMoreSignals())return;
			if (current.winningSignal==this) {
				this.maxFun = ",Nibbla
9806,"public class Solution {
	public static void main(String[] args) {
		Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int problem = 5;
		switch (problem) {
		case 1:
			experiment1(in);
			break;
		case 2:
			experiment2(in);
			break;
		case 3:
			experiment3(in);
			break;
		case 4:
			experiment4(in);
			break;
		case 5:
			experiment5(in);
			break;
		default:
			break;
		}

	}

	private static class Room{
		
		public Room(int i,int mp) {
			
			id = i;
			maxPassages = mp;
		}
		
		final int id;
		int minPassages = 1;
		int maxPassages;
		public int visitedConnections = 0;
		public boolean hasBeenVisited = false;
		public int[] visit(int krp) {
			int delta1 = maxPassages-krp;
			int delta0 = krp-minPassages;
			maxPassages = krp;
			minPassages = krp;
			hasBeenVisited = true;
			return new int[] {delta0,delta1};
			
		}
	}
	private static class Request{

		public boolean isWalk;

		public void print() {
			// TODO Auto-generated method stub
			
		}
		
	}
	private static class BelieveState{

		private Room[] rooms;
		//private int[][] connections; //0 means unknown; -1 means not; 1 means excists;
		private boolean certain = false;
		//private int minConnectionsTimes2;
	//	private int maxConnectionsTimes2;
		//private int maxConnections;
		public BelieveState(int n) {
			rooms = new Room[n+1];
			//connections = new int[n][n];
		//	minConnectionsTimes2 = (int) n;
			//maxConnectionsTimes2 = (int)(n*(n-1)/2);
			//maxConnections = (int)(n*(n-1)/2);
			for (int i = 1; i <= n; i++) {
				rooms[i] = new Room(i,n-1);
			}
		}
		public void update(int kri, int krp) {
			Room r = rooms[kri];
			if (!r.hasBeenVisited) {
				int[] changedPassages = r.visit(krp);
				//maxConnectionsTimes2-=changedPassages[1];
				//minConnectionsTimes2-=changedPassages[0];
			}
			
		}
		public Request getBestRequest() {
			return null;
			// TODO Auto-generated method stub
			
		}
		public int guess() {
			// TODO Auto-generated method stub
			return 0;
		}
		/*public void addConnection(Room currentRoom, Room nextRoom) {
			if (connections[currentRoom.id][nextRoom.id]==0) {
				currentRoom.visitedConnections++;
				nextRoom.visitedConnections++;
			}
			connections[currentRoom.id][nextRoom.id] = 1;
			connections[nextRoom.id][currentRoom.id] = 1;
			
		}*/
		
		
	}
	private static int nextInt(boolean fj, Scanner in ,boolean[][] conn, int room, boolean b) {
		if (!fj)return in.nextInt();
		if (b) {
			System.out.print(room + "" "");
			return room;
		}
		else {
			int counter = 0;
			boolean[] list = conn[room-1];
			for (int i = 0; i < list.length; i++) {
				if (list[i])counter++;
			}
			System.out.println(counter);
			return counter;
		}
		
		
	}
	private static void experiment5(Scanner in) {
		long startTime = System.currentTimeMillis();
		boolean useFakeJudge = false;
		
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		boolean[][] connections = null;
		
		
		for (int i = 1; i <= t; ++i) {
		
			int n = in.nextInt();
			boolean[] checkedRooms = new boolean[n+1];
			int k = in.nextInt();
			//BelieveState bs2;
			if (useFakeJudge) {
				connections = new boolean[n][n];
				int max = n*(n-1)/2;
				double chance = (1/4.);
				for (int j = 0; j < connections.length; j++) {
					int rj = (int) (Math.random()*n);
					connections[j][rj] = true;
					connections[rj][j] = true;
					for (int j2 = j+1; j2 < connections.length; j2++) {
						if (Math.random()<chance) {
							connections[j][j2] = true;
							connections[j2][j] = true;
						}
					}
				}
			};
			BelieveState bs = new BelieveState(n);
			int kri = in.nextInt();
			checkedRooms[kri] = true;
			int krp = in.nextInt();
			bs.update(kri,krp);
			Room currentRoom = bs.rooms[kri];
			ArrayList<Integer> grabBag = new ArrayList<>();
			for (int j = 1; j <= n; j++) {
				if (j == kri)continue;
				grabBag.add(j);
			}
			Collections.shuffle(grabBag);
			int counter = 0;
			Room nextRoom = null;
			long passageSizes = krp;
			long checkedRoomsCount = 1;
			while(k>0&&counter<grabBag.size()&&bs.certain==false) {
				
				//Request r = bs.getBestRequest();
				//r.print();
				int room = 1;
				//if (k % 2 == 0) {
				if (currentRoom.maxPassages > 2 && currentRoom.maxPassages < passageSizes*0.7/checkedRoomsCount) {
					grabBag.get((counter++)%grabBag.size());
					if (checkedRooms[room])continue;
					System.out.println(""T "" + room);}
				else {
					System.out.println(""W"");
				}
					
				int nextI = nextInt(useFakeJudge, in, connections,room,true);
				if (nextI==-1)break;
				
				
				int nextP = nextInt(useFakeJudge, in, connections,room, false);
				 nextRoom = bs.rooms[nextI];
				 if (!checkedRooms[nextI]) {
						checkedRoomsCount++;
						checkedRooms[nextI] = true;
						passageSizes+=nextP;
					}
				//if (r.isWalk) {
					//bs.addConnection(currentRoom,nextRoom);
				//}
				bs.update(nextI,nextP);
				currentRoom = nextRoom;
				k--;
			}
			long countUnvisited = 0;
			long countVisited = 0;
			long passagesInVisited = 0;
			Room[] roms = bs.rooms;
			for (int j = 1; j < roms.length; j++) {
				Room room = roms[j];
				if (room.hasBeenVisited) {
					passagesInVisited+=room.maxPassages;
					countVisited++;
				}
				else countUnvisited += 1;
			}
			double average = passagesInVisited/countVisited;
			long totalRooms = (long) Math.round(1.1*(passagesInVisited + countUnvisited*average)/2.);
			
			long g = totalRooms;
			System.out.println(""E "" + g);
		}
		
	}

	public static class Willies{

		public int fun;
		public Willies parent;
		public ArrayList<Willies> children = new ArrayList<Willies>();
		public ArrayList<Signal> signals = new ArrayList<Signal>();
		public int id;
		public Signal winningSignal; 
		public Willies(int i) {
			this.id = i;
		}
		public void addChild(Willies w) {
			children.add(w);
		}
		public boolean needsMoreSignals() {
			return (signals.size()<children.size());
			
		}
		public void addSignal(Signal signal) {
			this.signals.add(signal);
			if (winningSignal==null)winningSignal = signal;
			else winningSignal = winningSignal.maxFun<signal.maxFun?winningSignal:signal;//smaller max fun gets through
		}
		
		
	}

	public static class Signal{
		private Willies current;

		public Signal(Willies willies) {
			current=willies;
			current.addSignal(this);
			this.maxFun = Math.max(current.fun, maxFun);
		}

		public long maxFun = 0;
		private boolean stopped= false;

		public void step() {
			if (current.needsMoreSignals())return;
			if (current.winningSignal==this) {
				this.maxFun = ",Nibbla
9807,"public class Solution {
	public static void main(String[] args) {
		Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int problem = 5;
		switch (problem) {
		case 1:
			experiment1(in);
			break;
		case 2:
			experiment2(in);
			break;
		case 3:
			experiment3(in);
			break;
		case 4:
			experiment4(in);
			break;
		case 5:
			experiment5(in);
			break;
		default:
			break;
		}

	}

	private static class Room{
		
		public Room(int i,int mp) {
			
			id = i;
			maxPassages = mp;
		}
		
		final int id;
		int minPassages = 1;
		int maxPassages;
		public int visitedConnections = 0;
		public boolean hasBeenVisited = false;
		public int[] visit(int krp) {
			int delta1 = maxPassages-krp;
			int delta0 = krp-minPassages;
			maxPassages = krp;
			minPassages = krp;
			hasBeenVisited = true;
			return new int[] {delta0,delta1};
			
		}
	}
	private static class Request{

		public boolean isWalk;

		public void print() {
			// TODO Auto-generated method stub
			
		}
		
	}
	private static class BelieveState{

		private Room[] rooms;
		//private int[][] connections; //0 means unknown; -1 means not; 1 means excists;
		private boolean certain = false;
		private int minConnectionsTimes2;
		private int maxConnectionsTimes2;
		private int maxConnections;
		public BelieveState(int n) {
			rooms = new Room[n+1];
			//connections = new int[n][n];
			minConnectionsTimes2 = (int) n;
			maxConnectionsTimes2 = (int)(n*(n-1)/2);
			maxConnections = (int)(n*(n-1)/2);
			for (int i = 1; i <= n; i++) {
				rooms[i] = new Room(i,n-1);
			}
		}
		public void update(int kri, int krp) {
			Room r = rooms[kri];
			if (!r.hasBeenVisited) {
				int[] changedPassages = r.visit(krp);
				maxConnectionsTimes2-=changedPassages[1];
				minConnectionsTimes2-=changedPassages[0];
			}
			
		}
		public Request getBestRequest() {
			return null;
			// TODO Auto-generated method stub
			
		}
		public int guess() {
			// TODO Auto-generated method stub
			return 0;
		}
		/*public void addConnection(Room currentRoom, Room nextRoom) {
			if (connections[currentRoom.id][nextRoom.id]==0) {
				currentRoom.visitedConnections++;
				nextRoom.visitedConnections++;
			}
			connections[currentRoom.id][nextRoom.id] = 1;
			connections[nextRoom.id][currentRoom.id] = 1;
			
		}*/
		
		
	}
	private static int nextInt(boolean fj, Scanner in ,boolean[][] conn, int room, boolean b) {
		if (!fj)return in.nextInt();
		if (b) {
			System.out.print(room + "" "");
			return room;
		}
		else {
			int counter = 0;
			boolean[] list = conn[room-1];
			for (int i = 0; i < list.length; i++) {
				if (list[i])counter++;
			}
			System.out.println(counter);
			return counter;
		}
		
		
	}
	private static void experiment5(Scanner in) {
		long startTime = System.currentTimeMillis();
		boolean useFakeJudge = false;
		
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		boolean[][] connections = null;
		
		
		for (int i = 1; i <= t; ++i) {
		
			int n = in.nextInt();
			boolean[] checkedRooms = new boolean[n];
			int k = in.nextInt();
			BelieveState bs2;
			if (useFakeJudge) {
				connections = new boolean[n][n];
				int max = n*(n-1)/2;
				double chance = (1/4.);
				for (int j = 0; j < connections.length; j++) {
					int rj = (int) (Math.random()*n);
					connections[j][rj] = true;
					connections[rj][j] = true;
					for (int j2 = j+1; j2 < connections.length; j2++) {
						if (Math.random()<chance) {
							connections[j][j2] = true;
							connections[j2][j] = true;
						}
					}
				}
			};
			BelieveState bs = new BelieveState(n);
			int kri = in.nextInt();
			checkedRooms[kri] = true;
			int krp = in.nextInt();
			bs.update(kri,krp);
			Room currentRoom = bs.rooms[kri];
			ArrayList<Integer> grabBag = new ArrayList<>();
			for (int j = 1; j <= n; j++) {
				if (j == kri)continue;
				grabBag.add(j);
			}
			Collections.shuffle(grabBag);
			int counter = 0;
			Room nextRoom = null;
			long passageSizes = krp;
			long checkedRoomsCount = 1;
			while(k>0&&counter<grabBag.size()&&bs.certain==false) {
				
				//Request r = bs.getBestRequest();
				//r.print();
				int room = 1;
				//if (k % 2 == 0) {
				if (currentRoom.maxPassages < passageSizes*0.7/checkedRoomsCount) {
					grabBag.get((counter++)%grabBag.size());
					if (checkedRooms[room])continue;
					System.out.println(""T "" + room);}
				else {
					System.out.println(""W"");
				}
					
				int nextI = nextInt(useFakeJudge, in, connections,room,true);
				if (nextI==-1)break;
				
				
				int nextP = nextInt(useFakeJudge, in, connections,room, false);
				 nextRoom = bs.rooms[nextI];
				 if (!checkedRooms[nextI]) {
						checkedRoomsCount++;
						checkedRooms[nextI] = true;
						passageSizes+=nextP;
					}
				//if (r.isWalk) {
					//bs.addConnection(currentRoom,nextRoom);
				//}
				bs.update(nextI,nextP);
				currentRoom = nextRoom;
				k--;
			}
			long countUnvisited = 0;
			long countVisited = 0;
			long passagesInVisited = 0;
			Room[] roms = bs.rooms;
			for (int j = 1; j < roms.length; j++) {
				Room room = roms[j];
				if (room.hasBeenVisited) {
					passagesInVisited+=room.maxPassages;
					countVisited++;
				}
				else countUnvisited += 1;
			}
			double average = passagesInVisited/countVisited;
			long totalRooms = (long) Math.round(1.1*(passagesInVisited + countUnvisited*average)/2.);
			
			long g = totalRooms;
			System.out.println(""E "" + g);
		}
		
	}

	public static class Willies{

		public int fun;
		public Willies parent;
		public ArrayList<Willies> children = new ArrayList<Willies>();
		public ArrayList<Signal> signals = new ArrayList<Signal>();
		public int id;
		public Signal winningSignal; 
		public Willies(int i) {
			this.id = i;
		}
		public void addChild(Willies w) {
			children.add(w);
		}
		public boolean needsMoreSignals() {
			return (signals.size()<children.size());
			
		}
		public void addSignal(Signal signal) {
			this.signals.add(signal);
			if (winningSignal==null)winningSignal = signal;
			else winningSignal = winningSignal.maxFun<signal.maxFun?winningSignal:signal;//smaller max fun gets through
		}
		
		
	}

	public static class Signal{
		private Willies current;

		public Signal(Willies willies) {
			current=",Nibbla
9808,"public class Solution {
	public static void main(String[] args) {
		Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int problem = 5;
		switch (problem) {
		case 1:
			experiment1(in);
			break;
		case 2:
			experiment2(in);
			break;
		case 3:
			experiment3(in);
			break;
		case 4:
			experiment4(in);
			break;
		case 5:
			experiment5(in);
			break;
		default:
			break;
		}

	}

	private static class Room{
		
		public Room(int i,int mp) {
			
			id = i;
			maxPassages = mp;
		}
		
		final int id;
		int minPassages = 1;
		int maxPassages;
		public int visitedConnections = 0;
		public boolean hasBeenVisited = false;
		public int[] visit(int krp) {
			int delta1 = maxPassages-krp;
			int delta0 = krp-minPassages;
			maxPassages = krp;
			minPassages = krp;
			hasBeenVisited = true;
			return new int[] {delta0,delta1};
			
		}
	}
	private static class Request{

		public boolean isWalk;

		public void print() {
			// TODO Auto-generated method stub
			
		}
		
	}
	private static class BelieveState{

		private Room[] rooms;
		//private int[][] connections; //0 means unknown; -1 means not; 1 means excists;
		private boolean certain = false;
		private int minConnectionsTimes2;
		private int maxConnectionsTimes2;
		private int maxConnections;
		public BelieveState(int n) {
			rooms = new Room[n+1];
			//connections = new int[n][n];
			minConnectionsTimes2 = (int) n;
			maxConnectionsTimes2 = (int)(n*(n-1)/2);
			maxConnections = (int)(n*(n-1)/2);
			for (int i = 1; i <= n; i++) {
				rooms[i] = new Room(i,n-1);
			}
		}
		public void update(int kri, int krp) {
			Room r = rooms[kri];
			if (!r.hasBeenVisited) {
				int[] changedPassages = r.visit(krp);
				maxConnectionsTimes2-=changedPassages[1];
				minConnectionsTimes2-=changedPassages[0];
			}
			
		}
		public Request getBestRequest() {
			return null;
			// TODO Auto-generated method stub
			
		}
		public int guess() {
			// TODO Auto-generated method stub
			return 0;
		}
		/*public void addConnection(Room currentRoom, Room nextRoom) {
			if (connections[currentRoom.id][nextRoom.id]==0) {
				currentRoom.visitedConnections++;
				nextRoom.visitedConnections++;
			}
			connections[currentRoom.id][nextRoom.id] = 1;
			connections[nextRoom.id][currentRoom.id] = 1;
			
		}*/
		
		
	}
	private static int nextInt(boolean fj, Scanner in ,boolean[][] conn, int room, boolean b) {
		if (!fj)return in.nextInt();
		if (b) {
			System.out.print(room + "" "");
			return room;
		}
		else {
			int counter = 0;
			boolean[] list = conn[room-1];
			for (int i = 0; i < list.length; i++) {
				if (list[i])counter++;
			}
			System.out.println(counter);
			return counter;
		}
		
		
	}
	private static void experiment5(Scanner in) {
		long startTime = System.currentTimeMillis();
		boolean useFakeJudge = false;
		
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		boolean[][] connections = null;
		
		
		for (int i = 1; i <= t; ++i) {
		
			int n = in.nextInt();
			boolean[] checkedRooms = new boolean[n];
			int k = in.nextInt();
			BelieveState bs2;
			if (useFakeJudge) {
				connections = new boolean[n][n];
				int max = n*(n-1)/2;
				double chance = (1/4.);
				for (int j = 0; j < connections.length; j++) {
					int rj = (int) (Math.random()*n);
					connections[j][rj] = true;
					connections[rj][j] = true;
					for (int j2 = j+1; j2 < connections.length; j2++) {
						if (Math.random()<chance) {
							connections[j][j2] = true;
							connections[j2][j] = true;
						}
					}
				}
			};
			BelieveState bs = new BelieveState(n);
			int kri = in.nextInt();
			checkedRooms[kri] = true;
			int krp = in.nextInt();
			bs.update(kri,krp);
			Room currentRoom = bs.rooms[kri];
			ArrayList<Integer> grabBag = new ArrayList<>();
			for (int j = 1; j <= n; j++) {
				if (j == kri)continue;
				grabBag.add(j);
			}
			Collections.shuffle(grabBag);
			int counter = 0;
			Room nextRoom = null;
			long passageSizes = krp;
			long checkedRoomsCount = 1;
			while(k>0&&counter<grabBag.size()&&bs.certain==false) {
				
				//Request r = bs.getBestRequest();
				//r.print();
				int room = 1;
				//if (k % 2 == 0) {
				if (currentRoom.maxPassages < passageSizes*0.75/checkedRoomsCount) {
					grabBag.get(counter++);
					if (checkedRooms[room])continue;
					System.out.println(""T "" + room);}
				else {
					System.out.println(""W"");
				}
					
				int nextI = nextInt(useFakeJudge, in, connections,room,true);
				if (nextI==-1)break;
				
				
				int nextP = nextInt(useFakeJudge, in, connections,room, false);
				 nextRoom = bs.rooms[nextI];
				 if (!checkedRooms[nextI]) {
						checkedRoomsCount++;
						checkedRooms[nextI] = true;
						passageSizes+=nextP;
					}
				//if (r.isWalk) {
					//bs.addConnection(currentRoom,nextRoom);
				//}
				bs.update(nextI,nextP);
				currentRoom = nextRoom;
				k--;
			}
			long countUnvisited = 0;
			long countVisited = 0;
			long passagesInVisited = 0;
			Room[] roms = bs.rooms;
			for (int j = 1; j < roms.length; j++) {
				Room room = roms[j];
				if (room.hasBeenVisited) {
					passagesInVisited+=room.maxPassages;
					countVisited++;
				}
				else countUnvisited += 1;
			}
			double average = passagesInVisited/countVisited;
			long totalRooms = (long) Math.round((passagesInVisited + countUnvisited*average)/2.);
			
			long g = totalRooms;
			System.out.println(""E "" + g);
		}
		
	}

	public static class Willies{

		public int fun;
		public Willies parent;
		public ArrayList<Willies> children = new ArrayList<Willies>();
		public ArrayList<Signal> signals = new ArrayList<Signal>();
		public int id;
		public Signal winningSignal; 
		public Willies(int i) {
			this.id = i;
		}
		public void addChild(Willies w) {
			children.add(w);
		}
		public boolean needsMoreSignals() {
			return (signals.size()<children.size());
			
		}
		public void addSignal(Signal signal) {
			this.signals.add(signal);
			if (winningSignal==null)winningSignal = signal;
			else winningSignal = winningSignal.maxFun<signal.maxFun?winningSignal:signal;//smaller max fun gets through
		}
		
		
	}

	public static class Signal{
		private Willies current;

		public Signal(Willies willies) {
			current=",Nibbla
9809,"public class Solution {
	public static void main(String[] args) {
		Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int problem = 5;
		switch (problem) {
		case 1:
			experiment1(in);
			break;
		case 2:
			experiment2(in);
			break;
		case 3:
			experiment3(in);
			break;
		case 4:
			experiment4(in);
			break;
		case 5:
			experiment5(in);
			break;
		default:
			break;
		}

	}

	private static class Room{
		
		public Room(int i,int mp) {
			
			id = i;
			maxPassages = mp;
		}
		
		final int id;
		int minPassages = 1;
		int maxPassages;
		public int visitedConnections = 0;
		public boolean hasBeenVisited = false;
		public int[] visit(int krp) {
			int delta1 = maxPassages-krp;
			int delta0 = krp-minPassages;
			maxPassages = krp;
			minPassages = krp;
			hasBeenVisited = true;
			return new int[] {delta0,delta1};
			
		}
	}
	private static class Request{

		public boolean isWalk;

		public void print() {
			// TODO Auto-generated method stub
			
		}
		
	}
	private static class BelieveState{

		private Room[] rooms;
		//private int[][] connections; //0 means unknown; -1 means not; 1 means excists;
		private boolean certain = false;
		private int minConnectionsTimes2;
		private int maxConnectionsTimes2;
		private int maxConnections;
		public BelieveState(int n) {
			rooms = new Room[n+1];
			//connections = new int[n][n];
			minConnectionsTimes2 = (int) n;
			maxConnectionsTimes2 = (int)(n*(n-1)/2);
			maxConnections = (int)(n*(n-1)/2);
			for (int i = 1; i <= n; i++) {
				rooms[i] = new Room(i,n-1);
			}
		}
		public void update(int kri, int krp) {
			Room r = rooms[kri];
			if (!r.hasBeenVisited) {
				int[] changedPassages = r.visit(krp);
				maxConnectionsTimes2-=changedPassages[1];
				minConnectionsTimes2-=changedPassages[0];
			}
			
		}
		public Request getBestRequest() {
			return null;
			// TODO Auto-generated method stub
			
		}
		public int guess() {
			// TODO Auto-generated method stub
			return 0;
		}
		/*public void addConnection(Room currentRoom, Room nextRoom) {
			if (connections[currentRoom.id][nextRoom.id]==0) {
				currentRoom.visitedConnections++;
				nextRoom.visitedConnections++;
			}
			connections[currentRoom.id][nextRoom.id] = 1;
			connections[nextRoom.id][currentRoom.id] = 1;
			
		}*/
		
		
	}
	private static int nextInt(boolean fj, Scanner in ,boolean[][] conn, int room, boolean b) {
		if (!fj)return in.nextInt();
		if (b) {
			System.out.print(room + "" "");
			return room;
		}
		else {
			int counter = 0;
			boolean[] list = conn[room-1];
			for (int i = 0; i < list.length; i++) {
				if (list[i])counter++;
			}
			System.out.println(counter);
			return counter;
		}
		
		
	}
	private static void experiment5(Scanner in) {
		long startTime = System.currentTimeMillis();
		boolean useFakeJudge = false;
		
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		boolean[][] connections = null;
		
		
		for (int i = 1; i <= t; ++i) {
		
			int n = in.nextInt();
			boolean[] checkedRooms = new boolean[n];
			int k = in.nextInt();
			BelieveState bs2;
			if (useFakeJudge) {
				connections = new boolean[n][n];
				int max = n*(n-1)/2;
				double chance = (1/4.);
				for (int j = 0; j < connections.length; j++) {
					int rj = (int) (Math.random()*n);
					connections[j][rj] = true;
					connections[rj][j] = true;
					for (int j2 = j+1; j2 < connections.length; j2++) {
						if (Math.random()<chance) {
							connections[j][j2] = true;
							connections[j2][j] = true;
						}
					}
				}
			};
			BelieveState bs = new BelieveState(n);
			int kri = in.nextInt();
			checkedRooms[kri] = true;
			int krp = in.nextInt();
			bs.update(kri,krp);
			Room currentRoom = bs.rooms[kri];
			ArrayList<Integer> grabBag = new ArrayList<>();
			for (int j = 1; j <= n; j++) {
				if (j == kri)continue;
				grabBag.add(j);
			}
			Collections.shuffle(grabBag);
			int counter = 0;
			Room nextRoom = null;
			long passageSizes = krp;
			long checkedRoomsCount = 1;
			while(k>0&&counter<grabBag.size()&&bs.certain==false) {
				
				//Request r = bs.getBestRequest();
				//r.print();
				int room = 1;
				//if (k % 2 == 0) {
				if (currentRoom.maxPassages < passageSizes*0.8/checkedRoomsCount) {
					grabBag.get(counter++);
					if (checkedRooms[room])continue;
					System.out.println(""T "" + room);}
				else {
					System.out.println(""W"");
				}
					
				int nextI = nextInt(useFakeJudge, in, connections,room,true);
				if (nextI==-1)break;
				
				
				int nextP = nextInt(useFakeJudge, in, connections,room, false);
				 nextRoom = bs.rooms[nextI];
				 if (!checkedRooms[nextI]) {
						checkedRoomsCount++;
						checkedRooms[nextI] = true;
						passageSizes+=nextP;
					}
				//if (r.isWalk) {
					//bs.addConnection(currentRoom,nextRoom);
				//}
				bs.update(nextI,nextP);
				currentRoom = nextRoom;
				k--;
			}
			long countUnvisited = 0;
			long countVisited = 0;
			long passagesInVisited = 0;
			Room[] roms = bs.rooms;
			for (int j = 1; j < roms.length; j++) {
				Room room = roms[j];
				if (room.hasBeenVisited) {
					passagesInVisited+=room.maxPassages;
					countVisited++;
				}
				else countUnvisited += 1;
			}
			double average = passagesInVisited/countVisited;
			long totalRooms = (long) Math.round((passagesInVisited + countUnvisited*average)/2.);
			
			long g = totalRooms;
			System.out.println(""E "" + g);
		}
		
	}

	public static class Willies{

		public int fun;
		public Willies parent;
		public ArrayList<Willies> children = new ArrayList<Willies>();
		public ArrayList<Signal> signals = new ArrayList<Signal>();
		public int id;
		public Signal winningSignal; 
		public Willies(int i) {
			this.id = i;
		}
		public void addChild(Willies w) {
			children.add(w);
		}
		public boolean needsMoreSignals() {
			return (signals.size()<children.size());
			
		}
		public void addSignal(Signal signal) {
			this.signals.add(signal);
			if (winningSignal==null)winningSignal = signal;
			else winningSignal = winningSignal.maxFun<signal.maxFun?winningSignal:signal;//smaller max fun gets through
		}
		
		
	}

	public static class Signal{
		private Willies current;

		public Signal(Willies willies) {
			current=",Nibbla
9810,"public class Solution {
	public static void main(String[] args) {
		Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int problem = 5;
		switch (problem) {
		case 1:
			experiment1(in);
			break;
		case 2:
			experiment2(in);
			break;
		case 3:
			experiment3(in);
			break;
		case 4:
			experiment4(in);
			break;
		case 5:
			experiment5(in);
			break;
		default:
			break;
		}

	}

	private static class Room{
		
		public Room(int i,int mp) {
			
			id = i;
			maxPassages = mp;
		}
		
		final int id;
		int minPassages = 1;
		int maxPassages;
		public int visitedConnections = 0;
		public boolean hasBeenVisited = false;
		public int[] visit(int krp) {
			int delta1 = maxPassages-krp;
			int delta0 = krp-minPassages;
			maxPassages = krp;
			minPassages = krp;
			hasBeenVisited = true;
			return new int[] {delta0,delta1};
			
		}
	}
	private static class Request{

		public boolean isWalk;

		public void print() {
			// TODO Auto-generated method stub
			
		}
		
	}
	private static class BelieveState{

		private Room[] rooms;
		//private int[][] connections; //0 means unknown; -1 means not; 1 means excists;
		private boolean certain = false;
		private int minConnectionsTimes2;
		private int maxConnectionsTimes2;
		private int maxConnections;
		public BelieveState(int n) {
			rooms = new Room[n+1];
			//connections = new int[n][n];
			minConnectionsTimes2 = (int) n;
			maxConnectionsTimes2 = (int)(n*(n-1)/2);
			maxConnections = (int)(n*(n-1)/2);
			for (int i = 1; i <= n; i++) {
				rooms[i] = new Room(i,n-1);
			}
		}
		public void update(int kri, int krp) {
			Room r = rooms[kri];
			if (!r.hasBeenVisited) {
				int[] changedPassages = r.visit(krp);
				maxConnectionsTimes2-=changedPassages[1];
				minConnectionsTimes2-=changedPassages[0];
			}
			
		}
		public Request getBestRequest() {
			return null;
			// TODO Auto-generated method stub
			
		}
		public int guess() {
			// TODO Auto-generated method stub
			return 0;
		}
		/*public void addConnection(Room currentRoom, Room nextRoom) {
			if (connections[currentRoom.id][nextRoom.id]==0) {
				currentRoom.visitedConnections++;
				nextRoom.visitedConnections++;
			}
			connections[currentRoom.id][nextRoom.id] = 1;
			connections[nextRoom.id][currentRoom.id] = 1;
			
		}*/
		
		
	}
	private static int nextInt(boolean fj, Scanner in ,boolean[][] conn, int room, boolean b) {
		if (!fj)return in.nextInt();
		if (b) {
			System.out.print(room + "" "");
			return room;
		}
		else {
			int counter = 0;
			boolean[] list = conn[room-1];
			for (int i = 0; i < list.length; i++) {
				if (list[i])counter++;
			}
			System.out.println(counter);
			return counter;
		}
		
		
	}
	private static void experiment5(Scanner in) {
		long startTime = System.currentTimeMillis();
		boolean useFakeJudge = false;
		
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		boolean[][] connections = null;
		
		
		for (int i = 1; i <= t; ++i) {
		
			int n = in.nextInt();
			boolean[] checkedRooms = new boolean[n];
			int k = in.nextInt();
			BelieveState bs2;
			if (useFakeJudge) {
				connections = new boolean[n][n];
				int max = n*(n-1)/2;
				double chance = (1/4.);
				for (int j = 0; j < connections.length; j++) {
					int rj = (int) (Math.random()*n);
					connections[j][rj] = true;
					connections[rj][j] = true;
					for (int j2 = j+1; j2 < connections.length; j2++) {
						if (Math.random()<chance) {
							connections[j][j2] = true;
							connections[j2][j] = true;
						}
					}
				}
			};
			BelieveState bs = new BelieveState(n);
			int kri = in.nextInt();
			checkedRooms[kri] = true;
			int krp = in.nextInt();
			bs.update(kri,krp);
			Room currentRoom = bs.rooms[kri];
			ArrayList<Integer> grabBag = new ArrayList<>();
			for (int j = 1; j <= n; j++) {
				if (j == kri)continue;
				grabBag.add(j);
			}
			Collections.shuffle(grabBag);
			int counter = 0;
			Room nextRoom = null;
			long passageSizes = krp;
			long checkedRoomsCount = 1;
			while(k>0&&counter<grabBag.size()&&bs.certain==false) {
				
				//Request r = bs.getBestRequest();
				//r.print();
				int room = 1;
				//if (k % 2 == 0) {
				if (currentRoom.maxPassages < passageSizes*0.7/checkedRoomsCount) {
					grabBag.get(counter++);
					if (checkedRooms[room])continue;
					System.out.println(""T "" + room);}
				else {
					System.out.println(""W"");
				}
					
				int nextI = nextInt(useFakeJudge, in, connections,room,true);
				if (nextI==-1)break;
				
				
				int nextP = nextInt(useFakeJudge, in, connections,room, false);
				 nextRoom = bs.rooms[nextI];
				 if (!checkedRooms[nextI]) {
						checkedRoomsCount++;
						checkedRooms[nextI] = true;
						passageSizes+=nextP;
					}
				//if (r.isWalk) {
					//bs.addConnection(currentRoom,nextRoom);
				//}
				bs.update(nextI,nextP);
				currentRoom = nextRoom;
				k--;
			}
			long countUnvisited = 0;
			long countVisited = 0;
			long passagesInVisited = 0;
			Room[] roms = bs.rooms;
			for (int j = 1; j < roms.length; j++) {
				Room room = roms[j];
				if (room.hasBeenVisited) {
					passagesInVisited+=room.maxPassages;
					countVisited++;
				}
				else countUnvisited += 1;
			}
			double average = passagesInVisited/countVisited;
			long totalRooms = (long) Math.round((passagesInVisited + countUnvisited*average)/2.);
			
			long g = totalRooms;
			System.out.println(""E "" + g);
		}
		
	}

	public static class Willies{

		public int fun;
		public Willies parent;
		public ArrayList<Willies> children = new ArrayList<Willies>();
		public ArrayList<Signal> signals = new ArrayList<Signal>();
		public int id;
		public Signal winningSignal; 
		public Willies(int i) {
			this.id = i;
		}
		public void addChild(Willies w) {
			children.add(w);
		}
		public boolean needsMoreSignals() {
			return (signals.size()<children.size());
			
		}
		public void addSignal(Signal signal) {
			this.signals.add(signal);
			if (winningSignal==null)winningSignal = signal;
			else winningSignal = winningSignal.maxFun<signal.maxFun?winningSignal:signal;//smaller max fun gets through
		}
		
		
	}

	public static class Signal{
		private Willies current;

		public Signal(Willies willies) {
			current=",Nibbla
9811,"public class Solution {
	public static void main(String[] args) {
		Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int problem = 5;
		switch (problem) {
		case 1:
			experiment1(in);
			break;
		case 2:
			experiment2(in);
			break;
		case 3:
			experiment3(in);
			break;
		case 4:
			experiment4(in);
			break;
		case 5:
			experiment5(in);
			break;
		default:
			break;
		}

	}

	private static class Room{
		
		public Room(int i,int mp) {
			
			id = i;
			maxPassages = mp;
		}
		
		final int id;
		int minPassages = 1;
		int maxPassages;
		public int visitedConnections = 0;
		public boolean hasBeenVisited = false;
		public int[] visit(int krp) {
			int delta1 = maxPassages-krp;
			int delta0 = krp-minPassages;
			maxPassages = krp;
			minPassages = krp;
			hasBeenVisited = true;
			return new int[] {delta0,delta1};
			
		}
	}
	private static class Request{

		public boolean isWalk;

		public void print() {
			// TODO Auto-generated method stub
			
		}
		
	}
	private static class BelieveState{

		private Room[] rooms;
		//private int[][] connections; //0 means unknown; -1 means not; 1 means excists;
		private boolean certain = false;
		private int minConnectionsTimes2;
		private int maxConnectionsTimes2;
		private int maxConnections;
		public BelieveState(int n) {
			rooms = new Room[n+1];
			//connections = new int[n][n];
			minConnectionsTimes2 = (int) n;
			maxConnectionsTimes2 = (int)(n*(n-1)/2);
			maxConnections = (int)(n*(n-1)/2);
			for (int i = 1; i <= n; i++) {
				rooms[i] = new Room(i,n-1);
			}
		}
		public void update(int kri, int krp) {
			Room r = rooms[kri];
			if (!r.hasBeenVisited) {
				int[] changedPassages = r.visit(krp);
				maxConnectionsTimes2-=changedPassages[1];
				minConnectionsTimes2-=changedPassages[0];
			}
			
		}
		public Request getBestRequest() {
			return null;
			// TODO Auto-generated method stub
			
		}
		public int guess() {
			// TODO Auto-generated method stub
			return 0;
		}
		/*public void addConnection(Room currentRoom, Room nextRoom) {
			if (connections[currentRoom.id][nextRoom.id]==0) {
				currentRoom.visitedConnections++;
				nextRoom.visitedConnections++;
			}
			connections[currentRoom.id][nextRoom.id] = 1;
			connections[nextRoom.id][currentRoom.id] = 1;
			
		}*/
		
		
	}
	private static int nextInt(boolean fj, Scanner in ,boolean[][] conn, int room, boolean b) {
		if (!fj)return in.nextInt();
		if (b) {
			System.out.print(room + "" "");
			return room;
		}
		else {
			int counter = 0;
			boolean[] list = conn[room-1];
			for (int i = 0; i < list.length; i++) {
				if (list[i])counter++;
			}
			System.out.println(counter);
			return counter;
		}
		
		
	}
	private static void experiment5(Scanner in) {
		long startTime = System.currentTimeMillis();
		boolean useFakeJudge = false;
		
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		boolean[][] connections = null;
		
		
		for (int i = 1; i <= t; ++i) {
		
			int n = in.nextInt();
			boolean[] checkedRooms = new boolean[n];
			int k = in.nextInt();
			BelieveState bs2;
			if (useFakeJudge) {
				connections = new boolean[n][n];
				int max = n*(n-1)/2;
				double chance = (1/4.);
				for (int j = 0; j < connections.length; j++) {
					int rj = (int) (Math.random()*n);
					connections[j][rj] = true;
					connections[rj][j] = true;
					for (int j2 = j+1; j2 < connections.length; j2++) {
						if (Math.random()<chance) {
							connections[j][j2] = true;
							connections[j2][j] = true;
						}
					}
				}
			};
			BelieveState bs = new BelieveState(n);
			int kri = in.nextInt();
			checkedRooms[kri] = true;
			int krp = in.nextInt();
			bs.update(kri,krp);
			Room currentRoom = bs.rooms[kri];
			ArrayList<Integer> grabBag = new ArrayList<>();
			for (int j = 1; j <= n; j++) {
				if (j == kri)continue;
				grabBag.add(j);
			}
			Collections.shuffle(grabBag);
			int counter = 0;
			while(k>0&&counter<grabBag.size()&&bs.certain==false) {
				
				//Request r = bs.getBestRequest();
				//r.print();
				int room = 1;
				if (k % 2 == 0) {
					grabBag.get(counter++);
					if (checkedRooms[room])continue;
					System.out.println(""T "" + room);}
				else
					System.out.println(""W"");
				int nextI = nextInt(useFakeJudge, in, connections,room,true);
				if (nextI==-1)break;
				checkedRooms[nextI] = true;
				int nextP = nextInt(useFakeJudge, in, connections,room, false);
				Room nextRoom = bs.rooms[nextI];
				//if (r.isWalk) {
					//bs.addConnection(currentRoom,nextRoom);
				//}
				bs.update(nextI,nextP);
				currentRoom = nextRoom;
				k--;
			}
			long countUnvisited = 0;
			long countVisited = 0;
			long passagesInVisited = 0;
			Room[] roms = bs.rooms;
			for (int j = 1; j < roms.length; j++) {
				Room room = roms[j];
				if (room.hasBeenVisited) {
					passagesInVisited+=room.maxPassages;
					countVisited++;
				}
				else countUnvisited += 1;
			}
			double average = passagesInVisited/countVisited;
			long totalRooms = (long) Math.round(1.10*(passagesInVisited + countUnvisited*average)/2.);
			
			long g = totalRooms;
			System.out.println(""E "" + g);
		}
		
	}

	public static class Willies{

		public int fun;
		public Willies parent;
		public ArrayList<Willies> children = new ArrayList<Willies>();
		public ArrayList<Signal> signals = new ArrayList<Signal>();
		public int id;
		public Signal winningSignal; 
		public Willies(int i) {
			this.id = i;
		}
		public void addChild(Willies w) {
			children.add(w);
		}
		public boolean needsMoreSignals() {
			return (signals.size()<children.size());
			
		}
		public void addSignal(Signal signal) {
			this.signals.add(signal);
			if (winningSignal==null)winningSignal = signal;
			else winningSignal = winningSignal.maxFun<signal.maxFun?winningSignal:signal;//smaller max fun gets through
		}
		
		
	}

	public static class Signal{
		private Willies current;

		public Signal(Willies willies) {
			current=willies;
			current.addSignal(this);
			this.maxFun = Math.max(current.fun, maxFun);
		}

		public long maxFun = 0;
		private boolean stopped= ",Nibbla
9812,"public class Solution {
	public static void main(String[] args) {
		Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int problem = 5;
		switch (problem) {
		case 1:
			experiment1(in);
			break;
		case 2:
			experiment2(in);
			break;
		case 3:
			experiment3(in);
			break;
		case 4:
			experiment4(in);
			break;
		case 5:
			experiment5(in);
			break;
		default:
			break;
		}

	}

	private static class Room{
		
		public Room(int i,int mp) {
			
			id = i;
			maxPassages = mp;
		}
		
		final int id;
		int minPassages = 1;
		int maxPassages;
		public int visitedConnections = 0;
		public boolean hasBeenVisited = false;
		public int[] visit(int krp) {
			int delta1 = maxPassages-krp;
			int delta0 = krp-minPassages;
			maxPassages = krp;
			minPassages = krp;
			hasBeenVisited = true;
			return new int[] {delta0,delta1};
			
		}
	}
	private static class Request{

		public boolean isWalk;

		public void print() {
			// TODO Auto-generated method stub
			
		}
		
	}
	private static class BelieveState{

		private Room[] rooms;
		//private int[][] connections; //0 means unknown; -1 means not; 1 means excists;
		private boolean certain = false;
		private int minConnectionsTimes2;
		private int maxConnectionsTimes2;
		private int maxConnections;
		public BelieveState(int n) {
			rooms = new Room[n+1];
			//connections = new int[n][n];
			minConnectionsTimes2 = (int) n;
			maxConnectionsTimes2 = (int)(n*(n-1)/2);
			maxConnections = (int)(n*(n-1)/2);
			for (int i = 1; i <= n; i++) {
				rooms[i] = new Room(i,n-1);
			}
		}
		public void update(int kri, int krp) {
			Room r = rooms[kri];
			if (!r.hasBeenVisited) {
				int[] changedPassages = r.visit(krp);
				maxConnectionsTimes2-=changedPassages[1];
				minConnectionsTimes2-=changedPassages[0];
			}
			
		}
		public Request getBestRequest() {
			return null;
			// TODO Auto-generated method stub
			
		}
		public int guess() {
			// TODO Auto-generated method stub
			return 0;
		}
		/*public void addConnection(Room currentRoom, Room nextRoom) {
			if (connections[currentRoom.id][nextRoom.id]==0) {
				currentRoom.visitedConnections++;
				nextRoom.visitedConnections++;
			}
			connections[currentRoom.id][nextRoom.id] = 1;
			connections[nextRoom.id][currentRoom.id] = 1;
			
		}*/
		
		
	}
	private static int nextInt(boolean fj, Scanner in ,boolean[][] conn, int room, boolean b) {
		if (!fj)return in.nextInt();
		if (b) {
			System.out.print(room + "" "");
			return room;
		}
		else {
			int counter = 0;
			boolean[] list = conn[room-1];
			for (int i = 0; i < list.length; i++) {
				if (list[i])counter++;
			}
			System.out.println(counter);
			return counter;
		}
		
		
	}
	private static void experiment5(Scanner in) {
		long startTime = System.currentTimeMillis();
		boolean useFakeJudge = false;
		
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		boolean[][] connections = null;
		
		
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
		
			int k = in.nextInt();
			BelieveState bs2;
			if (useFakeJudge) {
				connections = new boolean[n][n];
				int max = n*(n-1)/2;
				double chance = (1/4.);
				for (int j = 0; j < connections.length; j++) {
					int rj = (int) (Math.random()*n);
					connections[j][rj] = true;
					connections[rj][j] = true;
					for (int j2 = j+1; j2 < connections.length; j2++) {
						if (Math.random()<chance) {
							connections[j][j2] = true;
							connections[j2][j] = true;
						}
					}
				}
			};
			BelieveState bs = new BelieveState(n);
			int kri = in.nextInt();
			int krp = in.nextInt();
			bs.update(kri,krp);
			Room currentRoom = bs.rooms[kri];
			ArrayList<Integer> grabBag = new ArrayList<>();
			for (int j = 1; j <= n; j++) {
				if (j == kri)continue;
				grabBag.add(j);
			}
			Collections.shuffle(grabBag);
			int counter = 0;
			while(k>0&&counter<grabBag.size()&&bs.certain==false) {
				
				//Request r = bs.getBestRequest();
				//r.print();
				int room = grabBag.get(counter++);
				System.out.println(""T "" + room);
				int nextI = nextInt(useFakeJudge, in, connections,room,true);
				if (nextI==-1)break;
				int nextP = nextInt(useFakeJudge, in, connections,room, false);
				Room nextRoom = bs.rooms[nextI];
				//if (r.isWalk) {
					//bs.addConnection(currentRoom,nextRoom);
				//}
				bs.update(nextI,nextP);
				currentRoom = nextRoom;
				k--;
			}
			int countUnvisited = 0;
			int countVisited = 0;
			int passagesInVisited = 0;
			Room[] roms = bs.rooms;
			for (int j = 1; j < roms.length; j++) {
				Room room = roms[j];
				if (room.hasBeenVisited) {
					passagesInVisited+=room.maxPassages;
					countVisited++;
				}
				else countUnvisited += 1;
			}
			double average = passagesInVisited/countVisited;
			int totalRooms = (int) Math.round((passagesInVisited + countUnvisited*average)/2.);
			
			int g = totalRooms;
			System.out.println(""E "" + g);
		}
		
	}

	public static class Willies{

		public int fun;
		public Willies parent;
		public ArrayList<Willies> children = new ArrayList<Willies>();
		public ArrayList<Signal> signals = new ArrayList<Signal>();
		public int id;
		public Signal winningSignal; 
		public Willies(int i) {
			this.id = i;
		}
		public void addChild(Willies w) {
			children.add(w);
		}
		public boolean needsMoreSignals() {
			return (signals.size()<children.size());
			
		}
		public void addSignal(Signal signal) {
			this.signals.add(signal);
			if (winningSignal==null)winningSignal = signal;
			else winningSignal = winningSignal.maxFun<signal.maxFun?winningSignal:signal;//smaller max fun gets through
		}
		
		
	}

	public static class Signal{
		private Willies current;

		public Signal(Willies willies) {
			current=willies;
			current.addSignal(this);
			this.maxFun = Math.max(current.fun, maxFun);
		}

		public long maxFun = 0;
		private boolean stopped= false;

		public void step() {
			if (current.needsMoreSignals())return;
			if (current.winningSignal==this) {
				this.maxFun = Math.max(current.fun, maxFun);
				current = current.parent;
				if (current!=null) {
					current.addSignal(this);
					
				}else stopped = true;
				
			}else {
				stopped = ",Nibbla
9813,"public class Solution {
	public static void main(String[] args) {
		Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		//System.out.println(""test"");
		//if (true) return;
		int problem = 5;
		switch (problem) {
		case 1:
			experiment1(in);
			break;
		case 2:
			experiment2(in);
			break;
		case 3:
			experiment3(in);
			break;
		case 4:
			experiment4(in);
			break;
		case 5:
			experiment5(in);
			break;
		default:
			break;
		}

	}

	private static class Room{
		
		public Room(int i,int mp) {
			
			id = i;
			maxPassages = mp;
		}
		
		final int id;
		int minPassages = 1;
		int maxPassages;
		public int visitedConnections = 0;
		public boolean hasBeenVisited = false;
		public int[] visit(int krp) {
			int delta1 = maxPassages-krp;
			int delta0 = krp-minPassages;
			maxPassages = krp;
			minPassages = krp;
			hasBeenVisited = true;
			return new int[] {delta0,delta1};
			
		}
	}
	private static class Request{

		public boolean isWalk;

		public void print() {
			// TODO Auto-generated method stub
			
		}
		
	}
	private static class BelieveState{

		private Room[] rooms;
		private int[][] connections; //0 means unknown; -1 means not; 1 means excists;
		private boolean certain = false;
		private int minConnectionsTimes2;
		private int maxConnectionsTimes2;
		private int maxConnections;
		public BelieveState(int n) {
			rooms = new Room[n+1];
			connections = new int[n][n];
			minConnectionsTimes2 = (int) n;
			maxConnectionsTimes2 = (int)(n*(n-1)/2);
			maxConnections = (int)(n*(n-1)/2);
			for (int i = 1; i <= n; i++) {
				rooms[i] = new Room(i,n-1);
			}
		}
		public void update(int kri, int krp) {
			Room r = rooms[kri];
			if (!r.hasBeenVisited) {
				int[] changedPassages = r.visit(krp);
				maxConnectionsTimes2-=changedPassages[1];
				minConnectionsTimes2-=changedPassages[0];
			}
			
		}
		public Request getBestRequest() {
			return null;
			// TODO Auto-generated method stub
			
		}
		public int guess() {
			// TODO Auto-generated method stub
			return 0;
		}
		public void addConnection(Room currentRoom, Room nextRoom) {
			if (connections[currentRoom.id][nextRoom.id]==0) {
				currentRoom.visitedConnections++;
				nextRoom.visitedConnections++;
			}
			connections[currentRoom.id][nextRoom.id] = 1;
			connections[nextRoom.id][currentRoom.id] = 1;
			
		}
		
		
	}
	private static int nextInt(boolean fj, Scanner in ,boolean[][] conn, int room, boolean b) {
		if (!fj)return in.nextInt();
		if (b) {
			System.out.print(room + "" "");
			return room;
		}
		else {
			int counter = 0;
			boolean[] list = conn[room-1];
			for (int i = 0; i < list.length; i++) {
				if (list[i])counter++;
			}
			System.out.println(counter);
			return counter;
		}
		
		
	}
	private static void experiment5(Scanner in) {
		long startTime = System.currentTimeMillis();
		boolean useFakeJudge = false;
	
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		boolean[][] connections = null;
		
		
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();
			BelieveState bs2;
			if (useFakeJudge) {
				connections = new boolean[n][n];
				int max = n*(n-1)/2;
				double chance = (max/n)/3.;
				for (int j = 0; j < connections.length; j++) {
					int rj = (int) (Math.random()*n);
					connections[j][rj] = true;
					connections[rj][j] = true;
					for (int j2 = j+1; j2 < connections.length; j2++) {
						if (Math.random()<chance) {
							connections[j][j2] = true;
							connections[j2][j] = true;
						}
					}
				}
			};
			BelieveState bs = new BelieveState(n);
			int kri = in.nextInt();
			int krp = in.nextInt();
			bs.update(kri,krp);
			Room currentRoom = bs.rooms[kri];
			ArrayList<Integer> grabBag = new ArrayList<>();
			for (int j = 1; j <= n; j++) {
				if (j == kri)continue;
				grabBag.add(j);
			}
			Collections.shuffle(grabBag);
			int counter = 0;
			while(k>0&&counter<grabBag.size()&&bs.certain==false) {
				
				//Request r = bs.getBestRequest();
				//r.print();
				int room = grabBag.get(counter++);
				System.out.println(""T "" + room);
				int nextI = nextInt(useFakeJudge, in, connections,room,true);
				if (nextI==-1)break;
				int nextP = nextInt(useFakeJudge, in, connections,room, false);
				Room nextRoom = bs.rooms[nextI];
				//if (r.isWalk) {
					//bs.addConnection(currentRoom,nextRoom);
				//}
				bs.update(nextI,nextP);
				currentRoom = nextRoom;
				k--;
			}
			int countUnvisited = 0;
			int countVisited = 0;
			int passagesInVisited = 0;
			Room[] roms = bs.rooms;
			for (int j = 1; j < roms.length; j++) {
				Room room = roms[j];
				if (room.hasBeenVisited) {
					passagesInVisited+=room.maxPassages;
					countVisited++;
				}
				else countUnvisited += 1;
			}
			double average = passagesInVisited/countVisited;
			int totalRooms = (int) Math.round((passagesInVisited + countUnvisited*average)/2.);
			
			int g = totalRooms;
			System.out.println(""E "" + g);
		}
		
	}

	public static class Willies{

		public int fun;
		public Willies parent;
		public ArrayList<Willies> children = new ArrayList<Willies>();
		public ArrayList<Signal> signals = new ArrayList<Signal>();
		public int id;
		public Signal winningSignal; 
		public Willies(int i) {
			this.id = i;
		}
		public void addChild(Willies w) {
			children.add(w);
		}
		public boolean needsMoreSignals() {
			return (signals.size()<children.size());
			
		}
		public void addSignal(Signal signal) {
			this.signals.add(signal);
			if (winningSignal==null)winningSignal = signal;
			else winningSignal = winningSignal.maxFun<signal.maxFun?winningSignal:signal;//smaller max fun gets through
		}
		
		
	}

	public static class Signal{
		private Willies current;

		public Signal(Willies willies) {
			current=willies;
			current.addSignal(this);
			this.maxFun = Math.max(current.fun, maxFun);
		}

		public long maxFun = 0;
		private boolean stopped= ",Nibbla
9814,"public class Solution {
	public static void main(String[] args) {
		Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int problem = 5;
		switch (problem) {
		case 1:
			experiment1(in);
			break;
		case 2:
			experiment2(in);
			break;
		case 3:
			experiment3(in);
			break;
		case 4:
			experiment4(in);
			break;
		case 5:
			experiment5(in);
			break;
		default:
			break;
		}

	}

	private static class Room{
		
		public Room(int i,int mp) {
			
			id = i;
			maxPassages = mp;
		}
		
		final int id;
		int minPassages = 1;
		int maxPassages;
		public int visitedConnections = 0;
		public boolean hasBeenVisited = false;
		public int[] visit(int krp) {
			int delta1 = maxPassages-krp;
			int delta0 = krp-minPassages;
			maxPassages = krp;
			minPassages = krp;
			hasBeenVisited = true;
			return new int[] {delta0,delta1};
			
		}
	}
	private static class Request{

		public boolean isWalk;

		public void print() {
			// TODO Auto-generated method stub
			
		}
		
	}
	private static class BelieveState{

		private Room[] rooms;
		private int[][] connections; //0 means unknown; -1 means not; 1 means excists;
		private boolean certain = false;
		private int minConnectionsTimes2;
		private int maxConnectionsTimes2;
		private int maxConnections;
		public BelieveState(int n) {
			rooms = new Room[n+1];
			connections = new int[n][n];
			minConnectionsTimes2 = (int) n;
			maxConnectionsTimes2 = (int)(n*(n-1)/2);
			maxConnections = (int)(n*(n-1)/2);
			for (int i = 1; i <= n; i++) {
				rooms[i] = new Room(i,n-1);
			}
		}
		public void update(int kri, int krp) {
			Room r = rooms[kri];
			if (!r.hasBeenVisited) {
				int[] changedPassages = r.visit(krp);
				maxConnectionsTimes2-=changedPassages[1];
				minConnectionsTimes2-=changedPassages[0];
			}
			
		}
		public Request getBestRequest() {
			return null;
			// TODO Auto-generated method stub
			
		}
		public int guess() {
			// TODO Auto-generated method stub
			return 0;
		}
		public void addConnection(Room currentRoom, Room nextRoom) {
			if (connections[currentRoom.id][nextRoom.id]==0) {
				currentRoom.visitedConnections++;
				nextRoom.visitedConnections++;
			}
			connections[currentRoom.id][nextRoom.id] = 1;
			connections[nextRoom.id][currentRoom.id] = 1;
			
		}
		
		
	}
	private static int nextInt(boolean fj, Scanner in ,boolean[][] conn, int room, boolean b) {
		if (!fj)return in.nextInt();
		if (b) {
			System.out.print(room + "" "");
			return room;
		}
		else {
			int counter = 0;
			boolean[] list = conn[room-1];
			for (int i = 0; i < list.length; i++) {
				if (list[i])counter++;
			}
			System.out.println(counter);
			return counter;
		}
		
		
	}
	private static void experiment5(Scanner in) {
		long startTime = System.currentTimeMillis();
		boolean useFakeJudge = false;
		
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		boolean[][] connections = null;
		
		
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();
			BelieveState bs2;
			if (useFakeJudge) {
				connections = new boolean[n][n];
				int max = n*(n-1)/2;
				double chance = (max/n)/3.;
				for (int j = 0; j < connections.length; j++) {
					int rj = (int) (Math.random()*n);
					connections[j][rj] = true;
					connections[rj][j] = true;
					for (int j2 = j+1; j2 < connections.length; j2++) {
						if (Math.random()<chance) {
							connections[j][j2] = true;
							connections[j2][j] = true;
						}
					}
				}
			};
			BelieveState bs = new BelieveState(n);
			int kri = in.nextInt();
			int krp = in.nextInt();
			bs.update(kri,krp);
			Room currentRoom = bs.rooms[kri];
			ArrayList<Integer> grabBag = new ArrayList<>();
			for (int j = 1; j <= n; j++) {
				if (j == kri)continue;
				grabBag.add(j);
			}
			Collections.shuffle(grabBag);
			int counter = 0;
			while(k>0&&counter<grabBag.size()&&bs.certain==false) {
				
				//Request r = bs.getBestRequest();
				//r.print();
				int room = grabBag.get(counter++);
				System.out.println(""T "" + room);
				int nextI = nextInt(useFakeJudge, in, connections,room,true);
				if (nextI==-1)break;
				int nextP = nextInt(useFakeJudge, in, connections,room, false);
				Room nextRoom = bs.rooms[nextI];
				//if (r.isWalk) {
					//bs.addConnection(currentRoom,nextRoom);
				//}
				bs.update(nextI,nextP);
				currentRoom = nextRoom;
				k--;
			}
			int countUnvisited = 0;
			int countVisited = 0;
			int passagesInVisited = 0;
			Room[] roms = bs.rooms;
			for (int j = 1; j < roms.length; j++) {
				Room room = roms[j];
				if (room.hasBeenVisited) {
					passagesInVisited+=room.maxPassages;
					countVisited++;
				}
				else countUnvisited += 1;
			}
			double average = passagesInVisited/countVisited;
			int totalRooms = (int) Math.round((passagesInVisited + countUnvisited*average)/2.);
			
			int g = totalRooms;
			System.out.println(""E "" + g);
		}
		
	}

	public static class Willies{

		public int fun;
		public Willies parent;
		public ArrayList<Willies> children = new ArrayList<Willies>();
		public ArrayList<Signal> signals = new ArrayList<Signal>();
		public int id;
		public Signal winningSignal; 
		public Willies(int i) {
			this.id = i;
		}
		public void addChild(Willies w) {
			children.add(w);
		}
		public boolean needsMoreSignals() {
			return (signals.size()<children.size());
			
		}
		public void addSignal(Signal signal) {
			this.signals.add(signal);
			if (winningSignal==null)winningSignal = signal;
			else winningSignal = winningSignal.maxFun<signal.maxFun?winningSignal:signal;//smaller max fun gets through
		}
		
		
	}

	public static class Signal{
		private Willies current;

		public Signal(Willies willies) {
			current=willies;
			current.addSignal(this);
			this.maxFun = Math.max(current.fun, maxFun);
		}

		public long maxFun = 0;
		private boolean stopped= ",Nibbla
9815,"public class Solution {
	public static void main(String[] args) {
		Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int problem = 5;
		switch (problem) {
		case 1:
			experiment1(in);
			break;
		case 2:
			experiment2(in);
			break;
		case 3:
			experiment3(in);
			break;
		case 4:
			experiment4(in);
			break;
		case 5:
			experiment5(in);
			break;
		default:
			break;
		}

	}

	private static class Room{
		
		public Room(int i,int mp) {
			
			id = i;
			maxPassages = mp;
		}
		
		final int id;
		int minPassages = 1;
		int maxPassages;
		public int visitedConnections = 0;
		public boolean hasBeenVisited = false;
		public int[] visit(int krp) {
			int delta1 = maxPassages-krp;
			int delta0 = krp-minPassages;
			maxPassages = krp;
			minPassages = krp;
			hasBeenVisited = true;
			return new int[] {delta0,delta1};
			
		}
	}
	private static class Request{

		public boolean isWalk;

		public void print() {
			// TODO Auto-generated method stub
			
		}
		
	}
	private static class BelieveState{

		private Room[] rooms;
		private int[][] connections; //0 means unknown; -1 means not; 1 means excists;
		private boolean certain = false;
		private int minConnectionsTimes2;
		private int maxConnectionsTimes2;
		private int maxConnections;
		public BelieveState(int n) {
			rooms = new Room[n+1];
			connections = new int[n][n];
			minConnectionsTimes2 = (int) n;
			maxConnectionsTimes2 = (int)(n*(n-1)/2);
			maxConnections = (int)(n*(n-1)/2);
			for (int i = 1; i <= rooms.length; i++) {
				rooms[i] = new Room(i,n-1);
			}
		}
		public void update(int kri, int krp) {
			Room r = rooms[kri];
			if (!r.hasBeenVisited) {
				int[] changedPassages = r.visit(krp);
				maxConnectionsTimes2-=changedPassages[1];
				minConnectionsTimes2-=changedPassages[0];
			}
			
		}
		public Request getBestRequest() {
			return null;
			// TODO Auto-generated method stub
			
		}
		public int guess() {
			// TODO Auto-generated method stub
			return 0;
		}
		public void addConnection(Room currentRoom, Room nextRoom) {
			if (connections[currentRoom.id][nextRoom.id]==0) {
				currentRoom.visitedConnections++;
				nextRoom.visitedConnections++;
			}
			connections[currentRoom.id][nextRoom.id] = 1;
			connections[nextRoom.id][currentRoom.id] = 1;
			
		}
		
		
	}
	
	private static void experiment5(Scanner in) {
		long startTime = System.currentTimeMillis();
		boolean useFakeJudge = true;
		if (useFakeJudge) ;
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.

		
		
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();
			BelieveState bs = new BelieveState(n);
			int kri = in.nextInt();
			int krp = in.nextInt();
			bs.update(kri,krp);
			Room currentRoom = bs.rooms[kri];
			ArrayList<Integer> grabBag = new ArrayList<>();
			for (int j = 1; j <= n; j++) {
				if (j == kri)continue;
				grabBag.add(j);
			}
			Collections.shuffle(grabBag);
			int counter = 0;
			while(k>0&&bs.certain==false) {
				
				//Request r = bs.getBestRequest();
				//r.print();
				System.out.println(""T "" + grabBag.get(counter++));
				int nextI = in.nextInt();
				if (nextI==-1)break;
				int nextP = in.nextInt();
				Room nextRoom = bs.rooms[nextI];
				//if (r.isWalk) {
					//bs.addConnection(currentRoom,nextRoom);
				//}
				bs.update(nextI,nextP);
				currentRoom = nextRoom;
				k--;
			}
			int countUnvisited = 0;
			int countVisited = 0;
			int passagesInVisited = 0;
			for (Room room : bs.rooms) {
				if (room.hasBeenVisited) {
					passagesInVisited+=room.maxPassages;
					countVisited++;
				}
				else countUnvisited += 1;
			}
			double average = passagesInVisited/countVisited;
			int totalRooms = (int) Math.round((passagesInVisited + countUnvisited*average)/2.);
			
			int g = totalRooms;
			System.out.println(""E "" + g);
		}
		
	}

	public static class Willies{

		public int fun;
		public Willies parent;
		public ArrayList<Willies> children = new ArrayList<Willies>();
		public ArrayList<Signal> signals = new ArrayList<Signal>();
		public int id;
		public Signal winningSignal; 
		public Willies(int i) {
			this.id = i;
		}
		public void addChild(Willies w) {
			children.add(w);
		}
		public boolean needsMoreSignals() {
			return (signals.size()<children.size());
			
		}
		public void addSignal(Signal signal) {
			this.signals.add(signal);
			if (winningSignal==null)winningSignal = signal;
			else winningSignal = winningSignal.maxFun<signal.maxFun?winningSignal:signal;//smaller max fun gets through
		}
		
		
	}

	public static class Signal{
		private Willies current;

		public Signal(Willies willies) {
			current=willies;
			current.addSignal(this);
			this.maxFun = Math.max(current.fun, maxFun);
		}

		public long maxFun = 0;
		private boolean stopped= false;

		public void step() {
			if (current.needsMoreSignals())return;
			if (current.winningSignal==this) {
				this.maxFun = Math.max(current.fun, maxFun);
				current = current.parent;
				if (current!=null) {
					current.addSignal(this);
					
				}else stopped = true;
				
			}else {
				stopped = true;
			}
			
		}

		public boolean hasStopped() {
			
			return stopped;
		}
		
	}
	
	private static void experiment4(Scanner in) {
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
        
        for (int i = 1; i <= t; ++i) {
        	int confirmed = 0;
        	int w = in.nextInt();
        	Willies[] wills = new Willies[w+1];
        	wills[0] = new Willies(0);
        	wills[0].fun = 0;
        	wills[0].parent = null;
        	for (int j = 1; j < wills.length; j++) {
				wills[j] = new Willies(j);
				wills[j].fun = in.nextInt();
				
			}
        	for (int j = 1; j < wills.length; j++) {
        		wills[j].parent = wills[in.nextInt()];
        	}
        	for (int j = 0; j < wills.length; j++) {
        		if (wills[j].parent!=null)wills[wills[j].parent.id].addChild(wills[j]);
        	}
        	ArrayList<Willies> activators = new ArrayList<>();
        	for (int j = ",Nibbla
9816,"public class Solution {
	public static void main(String[] args) {
		Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int problem = 5;
		switch (problem) {
		case 1:
			experiment1(in);
			break;
		case 2:
			experiment2(in);
			break;
		case 3:
			experiment3(in);
			break;
		case 4:
			experiment4(in);
			break;
		case 5:
			experiment5(in);
			break;
		default:
			break;
		}

	}

	private static class Room{
		
		public Room(int i,int mp) {
			
			id = i;
			maxPassages = mp;
		}
		
		final int id;
		int minPassages = 1;
		int maxPassages;
		public int visitedConnections = 0;
		public boolean hasBeenVisited = false;
		public int[] visit(int krp) {
			int delta1 = maxPassages-krp;
			int delta0 = krp-minPassages;
			maxPassages = krp;
			minPassages = krp;
			hasBeenVisited = true;
			return new int[] {delta0,delta1};
			
		}
	}
	private static class Request{

		public boolean isWalk;

		public void print() {
			// TODO Auto-generated method stub
			
		}
		
	}
	private static class BelieveState{

		private Room[] rooms;
		private int[][] connections; //0 means unknown; -1 means not; 1 means excists;
		private boolean certain = false;
		private int minConnectionsTimes2;
		private int maxConnectionsTimes2;
		private int maxConnections;
		public BelieveState(int n) {
			rooms = new Room[n];
			connections = new int[n][n];
			minConnectionsTimes2 = (int) n;
			maxConnectionsTimes2 = (int)(n*(n-1)/2);
			maxConnections = (int)(n*(n-1)/2);
			for (int i = 0; i < rooms.length; i++) {
				rooms[i] = new Room(i,n-1);
			}
		}
		public void update(int kri, int krp) {
			Room r = rooms[kri];
			if (!r.hasBeenVisited) {
				int[] changedPassages = r.visit(krp);
				maxConnectionsTimes2-=changedPassages[1];
				minConnectionsTimes2-=changedPassages[0];
			}
			
		}
		public Request getBestRequest() {
			return null;
			// TODO Auto-generated method stub
			
		}
		public int guess() {
			// TODO Auto-generated method stub
			return 0;
		}
		public void addConnection(Room currentRoom, Room nextRoom) {
			if (connections[currentRoom.id][nextRoom.id]==0) {
				currentRoom.visitedConnections++;
				nextRoom.visitedConnections++;
			}
			connections[currentRoom.id][nextRoom.id] = 1;
			connections[nextRoom.id][currentRoom.id] = 1;
			
		}
		
		
	}
	
	private static void experiment5(Scanner in) {
		long startTime = System.currentTimeMillis();
		boolean useFakeJudge = true;
		if (useFakeJudge) ;
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.

		
		
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();
			BelieveState bs = new BelieveState(n);
			int kri = in.nextInt();
			int krp = in.nextInt();
			bs.update(kri,krp);
			Room currentRoom = bs.rooms[kri];
			ArrayList<Integer> grabBag = new ArrayList<>();
			for (int j = 1; j < n; j++) {
				if (j == kri)continue;
				grabBag.add(j);
			}
			Collections.shuffle(grabBag);
			int counter = 0;
			while(k>0&&bs.certain==false) {
				
				//Request r = bs.getBestRequest();
				//r.print();
				System.out.println(""T "" + grabBag.get(counter++));
				int nextI = in.nextInt();
				if (nextI==-1)break;
				int nextP = in.nextInt();
				Room nextRoom = bs.rooms[nextI];
				//if (r.isWalk) {
					//bs.addConnection(currentRoom,nextRoom);
				//}
				bs.update(nextI,nextP);
				currentRoom = nextRoom;
				k--;
			}
			int countUnvisited = 0;
			int countVisited = 0;
			int passagesInVisited = 0;
			for (Room room : bs.rooms) {
				if (room.hasBeenVisited) {
					passagesInVisited+=room.maxPassages;
					countVisited++;
				}
				else countUnvisited += 1;
			}
			double average = passagesInVisited/countVisited;
			int totalRooms = (int) Math.round((passagesInVisited + countUnvisited*average)/2.);
			
			int g = totalRooms;
			System.out.println(""E "" + g);
		}
		
	}

	public static class Willies{

		public int fun;
		public Willies parent;
		public ArrayList<Willies> children = new ArrayList<Willies>();
		public ArrayList<Signal> signals = new ArrayList<Signal>();
		public int id;
		public Signal winningSignal; 
		public Willies(int i) {
			this.id = i;
		}
		public void addChild(Willies w) {
			children.add(w);
		}
		public boolean needsMoreSignals() {
			return (signals.size()<children.size());
			
		}
		public void addSignal(Signal signal) {
			this.signals.add(signal);
			if (winningSignal==null)winningSignal = signal;
			else winningSignal = winningSignal.maxFun<signal.maxFun?winningSignal:signal;//smaller max fun gets through
		}
		
		
	}

	public static class Signal{
		private Willies current;

		public Signal(Willies willies) {
			current=willies;
			current.addSignal(this);
			this.maxFun = Math.max(current.fun, maxFun);
		}

		public long maxFun = 0;
		private boolean stopped= false;

		public void step() {
			if (current.needsMoreSignals())return;
			if (current.winningSignal==this) {
				this.maxFun = Math.max(current.fun, maxFun);
				current = current.parent;
				if (current!=null) {
					current.addSignal(this);
					
				}else stopped = true;
				
			}else {
				stopped = true;
			}
			
		}

		public boolean hasStopped() {
			
			return stopped;
		}
		
	}
	
	private static void experiment4(Scanner in) {
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
        
        for (int i = 1; i <= t; ++i) {
        	int confirmed = 0;
        	int w = in.nextInt();
        	Willies[] wills = new Willies[w+1];
        	wills[0] = new Willies(0);
        	wills[0].fun = 0;
        	wills[0].parent = null;
        	for (int j = 1; j < wills.length; j++) {
				wills[j] = new Willies(j);
				wills[j].fun = in.nextInt();
				
			}
        	for (int j = 1; j < wills.length; j++) {
        		wills[j].parent = wills[in.nextInt()];
        	}
        	for (int j = 0; j < wills.length; j++) {
        		if (wills[j].parent!=null)wills[wills[j].parent.id].addChild(wills[j]);
        	}
        	ArrayList<Willies> activators = new ArrayList<>();
        	for (int j = ",Nibbla
9817,"public class Solution {
	public static void main(String[] args) {
		Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int problem = 4;
		switch (problem) {
		case 1:
			experiment1(in);
			break;
		case 2:
			experiment2(in);
			break;
		case 3:
			experiment3(in);
			break;
		case 4:
			experiment4(in);
			break;
		default:
			break;
		}

	}

	public static class Willies{

		public int fun;
		public Willies parent;
		public ArrayList<Willies> children = new ArrayList<Willies>();
		public ArrayList<Signal> signals = new ArrayList<Signal>();
		public int id;
		public Signal winningSignal; 
		public Willies(int i) {
			this.id = i;
		}
		public void addChild(Willies w) {
			children.add(w);
		}
		public boolean needsMoreSignals() {
			return (signals.size()<children.size());
			
		}
		public void addSignal(Signal signal) {
			this.signals.add(signal);
			if (winningSignal==null)winningSignal = signal;
			else winningSignal = winningSignal.maxFun<signal.maxFun?winningSignal:signal;//smaller max fun gets through
		}
		
		
	}

	public static class Signal{
		private Willies current;

		public Signal(Willies willies) {
			current=willies;
			current.addSignal(this);
			this.maxFun = Math.max(current.fun, maxFun);
		}

		public long maxFun = 0;
		private boolean stopped= false;

		public void step() {
			if (current.needsMoreSignals())return;
			if (current.winningSignal==this) {
				this.maxFun = Math.max(current.fun, maxFun);
				current = current.parent;
				if (current!=null) {
					current.addSignal(this);
					
				}else stopped = true;
				
			}else {
				stopped = true;
			}
			
		}

		public boolean hasStopped() {
			
			return stopped;
		}
		
	}
	
	private static void experiment4(Scanner in) {
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
        
        for (int i = 1; i <= t; ++i) {
        	int confirmed = 0;
        	int w = in.nextInt();
        	Willies[] wills = new Willies[w+1];
        	wills[0] = new Willies(0);
        	wills[0].fun = 0;
        	wills[0].parent = null;
        	for (int j = 1; j < wills.length; j++) {
				wills[j] = new Willies(j);
				wills[j].fun = in.nextInt();
				
			}
        	for (int j = 1; j < wills.length; j++) {
        		wills[j].parent = wills[in.nextInt()];
        	}
        	for (int j = 0; j < wills.length; j++) {
        		if (wills[j].parent!=null)wills[wills[j].parent.id].addChild(wills[j]);
        	}
        	ArrayList<Willies> activators = new ArrayList<>();
        	for (int j = 0; j < wills.length; j++) {
				if (wills[j].children.size()==0)activators.add(wills[j]);
			}
        	ArrayList<Signal> runningSignals = new ArrayList<>();
        	LinkedList<Signal> stoppedSignals = new LinkedList<>();
        	for (Willies willies : activators) {
				Signal s = new Signal(willies);
				runningSignals.add(s);
			}
        	while(runningSignals.size()>0) {
        		
        		for (Signal signal : runningSignals) {
					signal.step();
				}
        		
        		for (int j = runningSignals.size()-1; j >= 0; j--) {
					Signal s = runningSignals.get(j);
					if (s.hasStopped()) {
						stoppedSignals.add(s);
						runningSignals.set(j, runningSignals.get(runningSignals.size()-1));
						runningSignals.remove(runningSignals.size()-1);
					}
				}
        	}
        	
        	
        	 System.out.print(""Case #"" + i + "": "" );
             long sum = 0;
             for (Signal signal : stoppedSignals) {
				sum+=signal.maxFun;
			}
			System.out.println(sum );
        }
		
	}

	private static void experiment2(Scanner in) {
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
        
        for (int i = 1; i <= t; ++i) {
        	int[][]print = new int[3][4];
        	int[] mins = new int[4];
        	for (int j = 0; j < 3; j++) {
        		
				for (int j2 = 0; j2 < 4; j2++) {
					print[j][j2] =in.nextInt(); 
				}
			}
        	for (int j2 = 0; j2 < 4; j2++) {
        		mins[j2] = Integer.MAX_VALUE;
        		for (int j = 0; j < 3; j++) {
        			mins[j2] = Math.min(mins[j2], print[j][j2]);
				}
        	}
        	int sum = 0;
        	int last = 1000000;
        	for (int j = 0; j < mins.length; j++) {
				int k = mins[j];
				sum += k;
				if (j!=mins.length-1) {
					if (k>=last) {
						mins[j] = last;
						last = 0;
						
					}else
						last-=k;
				}
			}
        	
        	
        	
        	
        	System.out.print(""Case #"" + i + "": "" );
    		
            if (sum < 1000000) System.out.println(""IMPOSSIBLE"");
            else{
         	   for (int j = 0; j < mins.length-1; j++) {
         		   System.out.print(mins[j] + "" "");
                }
         	  System.out.print(last);
                System.out.println();
         	   }
        }
		
	}

	private static void experiment3(Scanner in) {
	int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
        
        for (int i = 1; i <= t; ++i) {
           
          int n = in.nextInt();
          int[] dices = new int[n];
          for (int j = 0; j < dices.length; j++) {
			dices[j] = in.nextInt();
		}
          Arrays.sort(dices);
          int target = 1;
          int confirmed = 0;
          for (int j = 0; j < dices.length; j++) {
			int j2 = dices[j];
			if (target>j2) {
				continue;
			}else{
				confirmed++;
				target++;
			}
		}
         
          
          
           System.out.print(""Case #"" + i + "": "" );
           System.out.println(confirmed);
        	
           
			
        }
	}

	private static void experiment1(Scanner in) {
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.

		for (int i = 1; i <= t; ++i) {
			StringBuilder text = new StringBuilder();
			int rows = in.nextInt();
			int columns = in.nextInt();
			for (int r = 0; r < rows*2+1; r++) {
				for (int c = 0; c < columns; c++) {
					if (r%2==1) {	
						if (r==1&&c==0)text.append("".."");
						else text.append(""|."");
					}
					else {
						if (r==0&&c==0)text.append("".."");
						else text.append(""+-"");
					}
				}
				if (r%2==1) {	
					text.append(""|"");
				}else {
					text.",Nibbla
9819,"public class Solution {
	public static void main(String[] args) {
		Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int problem = 4;
		switch (problem) {
		case 1:
			experiment1(in);
			break;
		case 2:
			experiment2(in);
			break;
		case 3:
			experiment3(in);
			break;
		case 4:
			experiment4(in);
			break;
		default:
			break;
		}

	}

	public static class Willies{

		public int fun;
		public Willies parent;
		public ArrayList<Willies> children = new ArrayList<Willies>();
		public ArrayList<Signal> signals = new ArrayList<Signal>();
		public int id;
		public Signal winningSignal; 
		public Willies(int i) {
			this.id = i;
		}
		public void addChild(Willies w) {
			children.add(w);
		}
		public boolean needsMoreSignals() {
			return (signals.size()<children.size());
			
		}
		public void addSignal(Signal signal) {
			this.signals.add(signal);
			if (winningSignal==null)winningSignal = signal;
			else winningSignal = winningSignal.maxFun<signal.maxFun?winningSignal:signal;//smaller max fun gets through
		}
		
		
	}

	public static class Signal{
		private Willies current;

		public Signal(Willies willies) {
			current=willies;
			current.addSignal(this);
			this.maxFun = Math.max(current.fun, maxFun);
		}

		public int maxFun = 0;
		private boolean stopped= false;

		public void step() {
			if (current.needsMoreSignals())return;
			if (current.winningSignal==this) {
				this.maxFun = Math.max(current.fun, maxFun);
				current = current.parent;
				if (current!=null) {
					current.addSignal(this);
					
				}else stopped = true;
				
			}else {
				stopped = true;
			}
			
		}

		public boolean hasStopped() {
			
			return stopped;
		}
		
	}
	
	private static void experiment4(Scanner in) {
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
        
        for (int i = 1; i <= t; ++i) {
        	int confirmed = 0;
        	int w = in.nextInt();
        	Willies[] wills = new Willies[w+1];
        	wills[0] = new Willies(0);
        	wills[0].fun = 0;
        	wills[0].parent = null;
        	for (int j = 1; j < wills.length; j++) {
				wills[j] = new Willies(j);
				wills[j].fun = in.nextInt();
				
			}
        	for (int j = 1; j < wills.length; j++) {
        		wills[j].parent = wills[in.nextInt()];
        	}
        	for (int j = 0; j < wills.length; j++) {
        		if (wills[j].parent!=null)wills[wills[j].parent.id].addChild(wills[j]);
        	}
        	ArrayList<Willies> activators = new ArrayList<>();
        	for (int j = 0; j < wills.length; j++) {
				if (wills[j].children.size()==0)activators.add(wills[j]);
			}
        	ArrayList<Signal> runningSignals = new ArrayList<>();
        	LinkedList<Signal> stoppedSignals = new LinkedList<>();
        	for (Willies willies : activators) {
				Signal s = new Signal(willies);
				runningSignals.add(s);
			}
        	while(runningSignals.size()>0) {
        		
        		for (Signal signal : runningSignals) {
					signal.step();
				}
        		
        		for (int j = runningSignals.size()-1; j >= 0; j--) {
					Signal s = runningSignals.get(j);
					if (s.hasStopped()) {
						stoppedSignals.add(s);
						runningSignals.set(j, runningSignals.get(runningSignals.size()-1));
						runningSignals.remove(runningSignals.size()-1);
					}
				}
        	}
        	
        	
        	 System.out.print(""Case #"" + i + "": "" );
             int sum = 0;
             for (Signal signal : stoppedSignals) {
				sum+=signal.maxFun;
			}
			System.out.println(sum );
        }
		
	}

	private static void experiment2(Scanner in) {
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
        
        for (int i = 1; i <= t; ++i) {
        	int[][]print = new int[3][4];
        	int[] mins = new int[4];
        	for (int j = 0; j < 3; j++) {
        		
				for (int j2 = 0; j2 < 4; j2++) {
					print[j][j2] =in.nextInt(); 
				}
			}
        	for (int j2 = 0; j2 < 4; j2++) {
        		mins[j2] = Integer.MAX_VALUE;
        		for (int j = 0; j < 3; j++) {
        			mins[j2] = Math.min(mins[j2], print[j][j2]);
				}
        	}
        	int sum = 0;
        	int last = 1000000;
        	for (int j = 0; j < mins.length; j++) {
				int k = mins[j];
				sum += k;
				if (j!=mins.length-1) {
					if (k>=last) {
						mins[j] = last;
						last = 0;
						
					}else
						last-=k;
				}
			}
        	
        	
        	
        	
        	System.out.print(""Case #"" + i + "": "" );
    		
            if (sum < 1000000) System.out.println(""IMPOSSIBLE"");
            else{
         	   for (int j = 0; j < mins.length-1; j++) {
         		   System.out.print(mins[j] + "" "");
                }
         	  System.out.print(last);
                System.out.println();
         	   }
        }
		
	}

	private static void experiment3(Scanner in) {
	int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
        
        for (int i = 1; i <= t; ++i) {
           
          int n = in.nextInt();
          int[] dices = new int[n];
          for (int j = 0; j < dices.length; j++) {
			dices[j] = in.nextInt();
		}
          Arrays.sort(dices);
          int target = 1;
          int confirmed = 0;
          for (int j = 0; j < dices.length; j++) {
			int j2 = dices[j];
			if (target>j2) {
				continue;
			}else{
				confirmed++;
				target++;
			}
		}
         
          
          
           System.out.print(""Case #"" + i + "": "" );
           System.out.println(confirmed);
        	
           
			
        }
	}

	private static void experiment1(Scanner in) {
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.

		for (int i = 1; i <= t; ++i) {
			StringBuilder text = new StringBuilder();
			int rows = in.nextInt();
			int columns = in.nextInt();
			for (int r = 0; r < rows*2+1; r++) {
				for (int c = 0; c < columns; c++) {
					if (r%2==1) {	
						if (r==1&&c==0)text.append("".."");
						else text.append(""|."");
					}
					else {
						if (r==0&&c==0)text.append("".."");
						else text.append(""+-"");
					}
				}
				if (r%2==1) {	
					text.append(""|"");
				}else {
					text.",Nibbla
9820,"public class Solution {
	private static boolean extracted(Room currentRoom, long passageSizes, long checkedRoomsCount) {
		boolean check =(currentRoom.maxPassages > 48 &&currentRoom.maxPassages > passageSizes*1.5/checkedRoomsCount);
		//to transport if in hub
		//currentRoom.maxPassages > 6 &&
		return check;
	}

	private static long extracted2(long countUnvisited, long passagesInVisited, double average) {
		long totalRooms = (long) Math.round(1.0*(passagesInVisited + countUnvisited*average)/2.);
		return totalRooms;
	}	
	
	public static void main(String[] args) {
		Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int problem = 5;
		switch (problem) {
		case 1:
			experiment1(in);
			break;
		case 2:
			experiment2(in);
			break;
		case 3:
			experiment3(in);
			break;
		case 4:
			experiment4(in);
			break;
		case 5:
			experiment5(in);
			break;
		default:
			break;
		}

	}

	private static class Room{
		
		public Room(int i,int mp) {
			
			id = i;
			maxPassages = mp;
		}
		
		final int id;
		int minPassages = 1;
		int maxPassages;
		public int visitedConnections = 0;
		public boolean hasBeenVisited = false;
		public int[] visit(int krp) {
			int delta1 = maxPassages-krp;
			int delta0 = krp-minPassages;
			maxPassages = krp;
			minPassages = krp;
			hasBeenVisited = true;
			return new int[] {delta0,delta1};
			
		}
	}
	private static class Request{

		public boolean isWalk;

		public void print() {
			// TODO Auto-generated method stub
			
		}
		
	}
	private static class BelieveState{

		private Room[] rooms;
		//private int[][] connections; //0 means unknown; -1 means not; 1 means excists;
		private boolean certain = false;
		//private int minConnectionsTimes2;
	//	private int maxConnectionsTimes2;
		//private int maxConnections;
		public BelieveState(int n) {
			rooms = new Room[n+1];
			//connections = new int[n][n];
		//	minConnectionsTimes2 = (int) n;
			//maxConnectionsTimes2 = (int)(n*(n-1)/2);
			//maxConnections = (int)(n*(n-1)/2);
			for (int i = 1; i <= n; i++) {
				rooms[i] = new Room(i,n-1);
			}
		}
		public void update(int kri, int krp) {
			Room r = rooms[kri];
			if (!r.hasBeenVisited) {
				int[] changedPassages = r.visit(krp);
				//maxConnectionsTimes2-=changedPassages[1];
				//minConnectionsTimes2-=changedPassages[0];
			}
			
		}
		public Request getBestRequest() {
			return null;
			// TODO Auto-generated method stub
			
		}
		public int guess() {
			// TODO Auto-generated method stub
			return 0;
		}
		/*public void addConnection(Room currentRoom, Room nextRoom) {
			if (connections[currentRoom.id][nextRoom.id]==0) {
				currentRoom.visitedConnections++;
				nextRoom.visitedConnections++;
			}
			connections[currentRoom.id][nextRoom.id] = 1;
			connections[nextRoom.id][currentRoom.id] = 1;
			
		}*/
		
		
	}
	private static int nextInt(boolean fj, Scanner in ,boolean[][] conn, int room, boolean b) {
		if (!fj)return in.nextInt();
		if (b) {
			System.out.print(room + "" "");
			return room;
		}
		else {
			int counter = 0;
			boolean[] list = conn[room-1];
			for (int i = 0; i < list.length; i++) {
				if (list[i])counter++;
			}
			System.out.println(counter);
			return counter;
		}
		
		
	}
	private static void experiment5(Scanner in) {
		long startTime = System.currentTimeMillis();
		boolean useFakeJudge = false;
		
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		boolean[][] connections = null;
		
		
		for (int i = 1; i <= t; ++i) {
		
			int n = in.nextInt();
			boolean[] checkedRooms = new boolean[n+1];
			int k = in.nextInt();
			//BelieveState bs2;
			if (useFakeJudge) {
				connections = new boolean[n][n];
				int max = n*(n-1)/2;
				double chance = (1/4.);
				for (int j = 0; j < connections.length; j++) {
					int rj = (int) (Math.random()*n);
					connections[j][rj] = true;
					connections[rj][j] = true;
					for (int j2 = j+1; j2 < connections.length; j2++) {
						if (Math.random()<chance) {
							connections[j][j2] = true;
							connections[j2][j] = true;
						}
					}
				}
			};
			BelieveState bs = new BelieveState(n);
			int kri = in.nextInt();
			checkedRooms[kri] = true;
			int krp = in.nextInt();
			bs.update(kri,krp);
			Room currentRoom = bs.rooms[kri];
			ArrayList<Integer> grabBag = new ArrayList<>();
			for (int j = 1; j <= n; j++) {
				if (j == kri)continue;
				grabBag.add(j);
			}
			Collections.shuffle(grabBag);
			int counter = 0;
			Room nextRoom = null;
			long passageSizes = krp;
			long checkedRoomsCount = 1;
			while(k>0&&counter<grabBag.size()&&bs.certain==false) {
				
				//Request r = bs.getBestRequest();
				//r.print();
				int room = 1;
				//if (k % 2 == 0) {
				boolean check = extracted(currentRoom, passageSizes, checkedRoomsCount);
				if (check) {
					grabBag.get((counter++)%grabBag.size());
					if (checkedRooms[room])continue;
					System.out.println(""T "" + room);}
				else {
					System.out.println(""W"");
				}
					
				int nextI = nextInt(useFakeJudge, in, connections,room,true);
				if (nextI==-1)break;
				
				
				int nextP = nextInt(useFakeJudge, in, connections,room, false);
				 nextRoom = bs.rooms[nextI];
				 if (!checkedRooms[nextI]) {
						checkedRoomsCount++;
						checkedRooms[nextI] = true;
						passageSizes+=nextP;
					}
				//if (r.isWalk) {
					//bs.addConnection(currentRoom,nextRoom);
				//}
				bs.update(nextI,nextP);
				currentRoom = nextRoom;
				k--;
			}
			long countUnvisited = 0;
			long countVisited = 0;
			long passagesInVisited = 0;
			Room[] roms = bs.rooms;
			for (int j = 1; j < roms.length; j++) {
				Room room = roms[j];
				if (room.hasBeenVisited) {
					passagesInVisited+=room.maxPassages;
					countVisited++;
				}
				else countUnvisited += 1;
			}
			double average = passagesInVisited/countVisited;
			long totalRooms = extracted2(countUnvisited, passagesInVisited, average);
			
			long g = totalRooms;
			System.out.println(""E "" + g);
		}
		
	}


	

	public static class Willies{

		public int fun;
		public Willies parent;
		public ArrayList<Willies> children = new ArrayList<Willies>();
		public ArrayList<Signal> signals = new ArrayList<Signal>();
		public int id;
		public Signal winningSignal; 
		public Willies(int i) {
			this.id = i;
		}
		public void addChild(Willies w) {
			children.add(w);
		}
		public boolean needsMoreSignals() {
			return (signals.size()<children.size());
			
		}
		public void addSignal(Signal signal) {
			this.signals.add(signal);
			if (winningSignal==null)winningSignal = signal;
			else winningSignal = winningSignal.maxFun<signal.maxFun?winningSignal:signal;//smaller max fun gets through
		}
		
		
	}

	public static class Signal{
		private Willies current;

		public Signal(Willies willies) {
			current=",Nibbla
9821,"public class Solution {
	public static void main(String[] args) {
		Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int problem = 2;
		switch (problem) {
		case 1:
			experiment1(in);
			break;
		case 2:
			experiment2(in);
			break;
		case 3:
			experiment3(in);
			break;
		case 4:
			experiment4(in);
			break;
		default:
			break;
		}

	}

	private static void experiment2(Scanner in) {
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
        
        for (int i = 1; i <= t; ++i) {
        	int[][]print = new int[3][4];
        	int[] mins = new int[4];
        	for (int j = 0; j < 3; j++) {
        		
				for (int j2 = 0; j2 < 4; j2++) {
					print[j][j2] =in.nextInt(); 
				}
			}
        	for (int j2 = 0; j2 < 4; j2++) {
        		mins[j2] = Integer.MAX_VALUE;
        		for (int j = 0; j < 3; j++) {
        			mins[j2] = Math.min(mins[j2], print[j][j2]);
				}
        	}
        	int sum = 0;
        	int last = 1000000;
        	for (int j = 0; j < mins.length; j++) {
				int k = mins[j];
				sum += k;
				if (j!=mins.length-1) {
					if (k>=last) {
						mins[j] = last;
						last = 0;
						
					}else
						last-=k;
				}
			}
        	
        	
        	
        	
        	System.out.print(""Case #"" + i + "": "" );
    		
            if (sum < 1000000) System.out.println(""IMPOSSIBLE"");
            else{
         	   for (int j = 0; j < mins.length-1; j++) {
         		   System.out.print(mins[j] + "" "");
                }
         	  System.out.print(last);
                System.out.println();
         	   }
        }
		
	}

	private static void experiment3(Scanner in) {
	int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
        
        for (int i = 1; i <= t; ++i) {
           
          int n = in.nextInt();
          int[] dices = new int[n];
          for (int j = 0; j < dices.length; j++) {
			dices[j] = in.nextInt();
		}
          Arrays.sort(dices);
          int target = 1;
          int confirmed = 0;
          for (int j = 0; j < dices.length; j++) {
			int j2 = dices[j];
			if (target>j2) {
				continue;
			}else{
				confirmed++;
				target++;
			}
		}
         
          
          
           System.out.print(""Case #"" + i + "": "" );
           System.out.println(confirmed);
        	
           
			
        }
	}

	private static void experiment1(Scanner in) {
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.

		for (int i = 1; i <= t; ++i) {
			StringBuilder text = new StringBuilder();
			int rows = in.nextInt();
			int columns = in.nextInt();
			for (int r = 0; r < rows*2+1; r++) {
				for (int c = 0; c < columns; c++) {
					if (r%2==1) {	
						if (r==1&&c==0)text.append("".."");
						else text.append(""|."");
					}
					else {
						if (r==0&&c==0)text.append("".."");
						else text.append(""+-"");
					}
				}
				if (r%2==1) {	
					text.append(""|"");
				}else {
					text.append(""+"");
				}
				text.append(""
"");
			}
			

			System.out.println(""Case #"" + i + "": "");
			
			System.out.println(text.toString());
		}
	}
	
	private static void experiment1_old(Scanner in) {
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.

		for (int i = 1; i <= t; ++i) {

			int n = in.nextInt();
			int[] vals = new int[n];
			for (int j = 0; j < n; ++j) {
				int m = in.nextInt();
				vals[j] = m;
			}
			int sum = reverseCount(vals);

			System.out.println(""Case #"" + i + "": "" + sum);
		}
	}

	private static int reverseCount(int[] vals) {
		int sum = 0;
		int n = vals.length;
		outer: for (int left = 0; left < n - 1; ++left) {
			int targetVal = left + 1;
			for (int right = left; right < n; ++right) {
				if (targetVal == vals[right]) {

					sum += reverse(vals, left, right);
					continue outer;
				}

			}

		}
		return sum;
	}

	private static class Value {
		public Value(int i) {
			val = i;
		}

		public String toString() {
			return val+"""";
		}
		final int val;
	}

	private static class Judge {

		private LinkedList<Value> solution;
		private int remainingQuerries;
		private boolean simulatedJudge;
		private Scanner scanner;

		public Judge(int n, int remainingQuerries, boolean simulatedJudge, Scanner in) {
			if (!simulatedJudge)
				return;
			solution = new LinkedList<>();
			for (int j = 0; j < n; j++) {
				solution.add(new Value(j + 1));
			}
			Collections.shuffle(solution);
			this.remainingQuerries = remainingQuerries;
			this.simulatedJudge = simulatedJudge;
			this.scanner = in;
		}

		public Querry querry(Querry q) {
			remainingQuerries--;
			if (!simulatedJudge) {
				System.out.println(q.i1 + "" "" + q.i2 + "" "" + q.i3);
				q.m = scanner.nextInt();
				return q;
			}

			boolean firstFound = false;
			for (Value val : solution) {
				if (val.val == q.i1 || val.val == q.i2 || val.val == q.i3) {
					if (!firstFound)
						firstFound = true;
					else {
						q.m = val.val;
						return q;
					}
				}
			}
			q.m = -1;
			return q;
		}

		public boolean checkSolution(LinkedList<Value> candit) {
			if (!simulatedJudge) {

				StringBuilder sb = new StringBuilder();
				for (Value value : candit) {
					sb.append(value.val + "" "");
				}
				sb.replace(sb.length() - 1, sb.length(), """");
				System.out.println(sb.toString());

				return scanner.nextInt() == 1;
			}
			outer:for (int i = 0; i <= 1; i++) {
				Iterator<Value> it1 = solution.iterator();
				Iterator<Value> it2;
				if (i==1) i",Nibbla
9822,"public class Solution {
	public static void main(String[] args) {
		Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int problem = 1;
		switch (problem) {
		case 1:
			experiment1(in);
			break;
		case 3:
			experiment3(in);
			break;
		case 4:
			experiment4(in);
			break;
		default:
			break;
		}

	}

	private static void experiment3(Scanner in) {
	int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
        
        for (int i = 1; i <= t; ++i) {
           
          int n = in.nextInt();
          int[] dices = new int[n];
          for (int j = 0; j < dices.length; j++) {
			dices[j] = in.nextInt();
		}
          Arrays.sort(dices);
          int target = 1;
          int confirmed = 0;
          for (int j = 0; j < dices.length; j++) {
			int j2 = dices[j];
			if (target>j2) {
				continue;
			}else{
				confirmed++;
				target++;
			}
		}
         
          
          
           System.out.print(""Case #"" + i + "": "" );
           System.out.println(confirmed);
        	
           
			
        }
	}

	private static void experiment1(Scanner in) {
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.

		for (int i = 1; i <= t; ++i) {
			StringBuilder text = new StringBuilder();
			int rows = in.nextInt();
			int columns = in.nextInt();
			for (int r = 0; r < rows*2+1; r++) {
				for (int c = 0; c < columns; c++) {
					if (r%2==1) {	
						if (r==1&&c==0)text.append("".."");
						else text.append(""|."");
					}
					else {
						if (r==0&&c==0)text.append("".."");
						else text.append(""+-"");
					}
				}
				if (r%2==1) {	
					text.append(""|"");
				}else {
					text.append(""+"");
				}
				text.append(""
"");
			}
			

			System.out.println(""Case #"" + i + "": "");
			
			System.out.println(text.toString());
		}
	}
	
	private static void experiment1_old(Scanner in) {
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.

		for (int i = 1; i <= t; ++i) {

			int n = in.nextInt();
			int[] vals = new int[n];
			for (int j = 0; j < n; ++j) {
				int m = in.nextInt();
				vals[j] = m;
			}
			int sum = reverseCount(vals);

			System.out.println(""Case #"" + i + "": "" + sum);
		}
	}

	private static int reverseCount(int[] vals) {
		int sum = 0;
		int n = vals.length;
		outer: for (int left = 0; left < n - 1; ++left) {
			int targetVal = left + 1;
			for (int right = left; right < n; ++right) {
				if (targetVal == vals[right]) {

					sum += reverse(vals, left, right);
					continue outer;
				}

			}

		}
		return sum;
	}

	private static class Value {
		public Value(int i) {
			val = i;
		}

		public String toString() {
			return val+"""";
		}
		final int val;
	}

	private static class Judge {

		private LinkedList<Value> solution;
		private int remainingQuerries;
		private boolean simulatedJudge;
		private Scanner scanner;

		public Judge(int n, int remainingQuerries, boolean simulatedJudge, Scanner in) {
			if (!simulatedJudge)
				return;
			solution = new LinkedList<>();
			for (int j = 0; j < n; j++) {
				solution.add(new Value(j + 1));
			}
			Collections.shuffle(solution);
			this.remainingQuerries = remainingQuerries;
			this.simulatedJudge = simulatedJudge;
			this.scanner = in;
		}

		public Querry querry(Querry q) {
			remainingQuerries--;
			if (!simulatedJudge) {
				System.out.println(q.i1 + "" "" + q.i2 + "" "" + q.i3);
				q.m = scanner.nextInt();
				return q;
			}

			boolean firstFound = false;
			for (Value val : solution) {
				if (val.val == q.i1 || val.val == q.i2 || val.val == q.i3) {
					if (!firstFound)
						firstFound = true;
					else {
						q.m = val.val;
						return q;
					}
				}
			}
			q.m = -1;
			return q;
		}

		public boolean checkSolution(LinkedList<Value> candit) {
			if (!simulatedJudge) {

				StringBuilder sb = new StringBuilder();
				for (Value value : candit) {
					sb.append(value.val + "" "");
				}
				sb.replace(sb.length() - 1, sb.length(), """");
				System.out.println(sb.toString());

				return scanner.nextInt() == 1;
			}
			outer:for (int i = 0; i <= 1; i++) {
				Iterator<Value> it1 = solution.iterator();
				Iterator<Value> it2;
				if (i==1) it2 =  candit.iterator();
				else it2 = candit.descendingIterator();
				while (it1.hasNext()) {
					if (it1.next().val!=it2.next().val)continue outer;
					
				}
				return true;
			}
			return false;
						
			
		}
	}
	private static class Querry{

		public int m = -1;
		private int i1;
		private int i2;
		private int i3;

		public Querry(int i, int j, int k) {
			i1 = i;
			i2 = j;
			i3 = k;
		}
		
		public String toString() {
			return ""qu: "" + i1 + "",""+ i2 + "",""+ i3 + ""-->"" + m;
		}

		public boolean isBorder(Value value) {
			// TODO Auto-generated method stub
			return false;
		}
		
	}

	private static void experiment4(Scanner in) {
		int t = 1; 
		int n = 6; 
		int qn = 300;
		if (false) {
			t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
			n = in.nextInt(); 
			qn = in.nextInt(); 
		}
		int remainingQuerries = qn;
		//insert and compliance is not working
		for (int i = 1; i <= t; ++i) {
			ArrayList<Querry> pastQuerries = new ArrayList<>();
			Judge judge = new Judge(n, remainingQuerries, true, in);
			LinkedList<Value> solution = createEmptySolution(n);

			Querry q = judge.querry(new Querry(1, 2, 3));
			pastQuerries.add(q);
			insert(solution,pastQuerries);
			System.out.println(compliance(pastQuerries,solution));
			",Nibbla
9823,"public class Solution {
	public static void main(String[] args) {
		Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int problem = 3;
		switch (problem) {
		case 1:
			experiment1(in);
			break;
		case 3:
			experiment3(in);
			break;
		case 4:
			experiment4(in);
			break;
		default:
			break;
		}

	}

	private static void experiment3(Scanner in) {
	int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
        
        for (int i = 1; i <= t; ++i) {
           
          int n = in.nextInt();
          int[] dices = new int[n];
          for (int j = 0; j < dices.length; j++) {
			dices[j] = in.nextInt();
		}
          Arrays.sort(dices);
          int target = 1;
          int confirmed = 0;
          for (int j = 0; j < dices.length; j++) {
			int j2 = dices[j];
			if (target>j2) {
				continue;
			}else{
				confirmed++;
				target++;
			}
		}
         
          
          
           System.out.print(""Case #"" + i + "": "" );
           System.out.println(confirmed);
        	
           
			
        }
	}

	private static void experiment1(Scanner in) {
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.

		for (int i = 1; i <= t; ++i) {

			int n = in.nextInt();
			int[] vals = new int[n];
			for (int j = 0; j < n; ++j) {
				int m = in.nextInt();
				vals[j] = m;
			}
			int sum = reverseCount(vals);

			System.out.println(""Case #"" + i + "": "" + sum);
		}
	}

	private static int reverseCount(int[] vals) {
		int sum = 0;
		int n = vals.length;
		outer: for (int left = 0; left < n - 1; ++left) {
			int targetVal = left + 1;
			for (int right = left; right < n; ++right) {
				if (targetVal == vals[right]) {

					sum += reverse(vals, left, right);
					continue outer;
				}

			}

		}
		return sum;
	}

	private static class Value {
		public Value(int i) {
			val = i;
		}

		public String toString() {
			return val+"""";
		}
		final int val;
	}

	private static class Judge {

		private LinkedList<Value> solution;
		private int remainingQuerries;
		private boolean simulatedJudge;
		private Scanner scanner;

		public Judge(int n, int remainingQuerries, boolean simulatedJudge, Scanner in) {
			if (!simulatedJudge)
				return;
			solution = new LinkedList<>();
			for (int j = 0; j < n; j++) {
				solution.add(new Value(j + 1));
			}
			Collections.shuffle(solution);
			this.remainingQuerries = remainingQuerries;
			this.simulatedJudge = simulatedJudge;
			this.scanner = in;
		}

		public Querry querry(Querry q) {
			remainingQuerries--;
			if (!simulatedJudge) {
				System.out.println(q.i1 + "" "" + q.i2 + "" "" + q.i3);
				q.m = scanner.nextInt();
				return q;
			}

			boolean firstFound = false;
			for (Value val : solution) {
				if (val.val == q.i1 || val.val == q.i2 || val.val == q.i3) {
					if (!firstFound)
						firstFound = true;
					else {
						q.m = val.val;
						return q;
					}
				}
			}
			q.m = -1;
			return q;
		}

		public boolean checkSolution(LinkedList<Value> candit) {
			if (!simulatedJudge) {

				StringBuilder sb = new StringBuilder();
				for (Value value : candit) {
					sb.append(value.val + "" "");
				}
				sb.replace(sb.length() - 1, sb.length(), """");
				System.out.println(sb.toString());

				return scanner.nextInt() == 1;
			}
			outer:for (int i = 0; i <= 1; i++) {
				Iterator<Value> it1 = solution.iterator();
				Iterator<Value> it2;
				if (i==1) it2 =  candit.iterator();
				else it2 = candit.descendingIterator();
				while (it1.hasNext()) {
					if (it1.next().val!=it2.next().val)continue outer;
					
				}
				return true;
			}
			return false;
						
			
		}
	}
	private static class Querry{

		public int m = -1;
		private int i1;
		private int i2;
		private int i3;

		public Querry(int i, int j, int k) {
			i1 = i;
			i2 = j;
			i3 = k;
		}
		
		public String toString() {
			return ""qu: "" + i1 + "",""+ i2 + "",""+ i3 + ""-->"" + m;
		}

		public boolean isBorder(Value value) {
			// TODO Auto-generated method stub
			return false;
		}
		
	}

	private static void experiment4(Scanner in) {
		int t = 1; 
		int n = 6; 
		int qn = 300;
		if (false) {
			t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
			n = in.nextInt(); 
			qn = in.nextInt(); 
		}
		int remainingQuerries = qn;
		//insert and compliance is not working
		for (int i = 1; i <= t; ++i) {
			ArrayList<Querry> pastQuerries = new ArrayList<>();
			Judge judge = new Judge(n, remainingQuerries, true, in);
			LinkedList<Value> solution = createEmptySolution(n);

			Querry q = judge.querry(new Querry(1, 2, 3));
			pastQuerries.add(q);
			insert(solution,pastQuerries);
			System.out.println(compliance(pastQuerries,solution));
			
			boolean isCorrect = judge.checkSolution(solution);

			System.out.print(""correct: "" + isCorrect);
			

			
		}
	}

	private static void insert(LinkedList<Value> solution, ArrayList<Querry> pastQuerries) {
		for (Querry querry : pastQuerries) {
			insert(solution,querry);
		}
		
	}

	private static void insert(LinkedList<Value> solution, Querry querry) {
		int firstIndex = -1;
		int thirdIndex = -2;
		int middleIndex = -3;
		
		boolean firstfound = false;
		
		
		
		for (int i = 0; i < solution.size(); i++) {
			Value value = solution.get(i);
			if (querry.i1 == value.val||querry.i3== value.val) {
				if (firstfound) thirdIndex = i;
				else {
					firstIndex = i;
					firstfound = true;
				}
			}else
			if (querry.i2 == value.val) {
				middleIndex = ",Nibbla
9824,"public class Solution {
	private static boolean extracted(Room currentRoom, long passageSizes, long checkedRoomsCount) {
		boolean check = Math.random() > 0.05 || (currentRoom.maxPassages > 24 &&currentRoom.maxPassages > passageSizes*1.5/checkedRoomsCount);
		//to transport if in hub
		//currentRoom.maxPassages > 6 &&
		return check;
	}

	private static long extracted2(long countUnvisited, long passagesInVisited, double average) {
		long totalRooms = (long) Math.round(1.0*(passagesInVisited + countUnvisited*average)/2.);
		return totalRooms;
	}	
	
	public static void main(String[] args) {
		Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int problem = 5;
		switch (problem) {
		case 1:
			experiment1(in);
			break;
		case 2:
			experiment2(in);
			break;
		case 3:
			experiment3(in);
			break;
		case 4:
			experiment4(in);
			break;
		case 5:
			experiment5(in);
			break;
		default:
			break;
		}

	}

	private static class Room{
		
		public Room(int i,int mp) {
			
			id = i;
			maxPassages = mp;
		}
		
		final int id;
		int minPassages = 1;
		int maxPassages;
		public int visitedConnections = 0;
		public boolean hasBeenVisited = false;
		public int[] visit(int krp) {
			int delta1 = maxPassages-krp;
			int delta0 = krp-minPassages;
			maxPassages = krp;
			minPassages = krp;
			hasBeenVisited = true;
			return new int[] {delta0,delta1};
			
		}
	}
	private static class Request{

		public boolean isWalk;

		public void print() {
			// TODO Auto-generated method stub
			
		}
		
	}
	private static class BelieveState{

		private Room[] rooms;
		//private int[][] connections; //0 means unknown; -1 means not; 1 means excists;
		private boolean certain = false;
		//private int minConnectionsTimes2;
	//	private int maxConnectionsTimes2;
		//private int maxConnections;
		public BelieveState(int n) {
			rooms = new Room[n+1];
			//connections = new int[n][n];
		//	minConnectionsTimes2 = (int) n;
			//maxConnectionsTimes2 = (int)(n*(n-1)/2);
			//maxConnections = (int)(n*(n-1)/2);
			for (int i = 1; i <= n; i++) {
				rooms[i] = new Room(i,n-1);
			}
		}
		public void update(int kri, int krp) {
			Room r = rooms[kri];
			if (!r.hasBeenVisited) {
				int[] changedPassages = r.visit(krp);
				//maxConnectionsTimes2-=changedPassages[1];
				//minConnectionsTimes2-=changedPassages[0];
			}
			
		}
		public Request getBestRequest() {
			return null;
			// TODO Auto-generated method stub
			
		}
		public int guess() {
			// TODO Auto-generated method stub
			return 0;
		}
		/*public void addConnection(Room currentRoom, Room nextRoom) {
			if (connections[currentRoom.id][nextRoom.id]==0) {
				currentRoom.visitedConnections++;
				nextRoom.visitedConnections++;
			}
			connections[currentRoom.id][nextRoom.id] = 1;
			connections[nextRoom.id][currentRoom.id] = 1;
			
		}*/
		
		
	}
	private static int nextInt(boolean fj, Scanner in ,boolean[][] conn, int room, boolean b) {
		if (!fj)return in.nextInt();
		if (b) {
			System.out.print(room + "" "");
			return room;
		}
		else {
			int counter = 0;
			boolean[] list = conn[room-1];
			for (int i = 0; i < list.length; i++) {
				if (list[i])counter++;
			}
			System.out.println(counter);
			return counter;
		}
		
		
	}
	private static void experiment5(Scanner in) {
		long startTime = System.currentTimeMillis();
		boolean useFakeJudge = false;
		
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		boolean[][] connections = null;
		
		
		for (int i = 1; i <= t; ++i) {
		
			int n = in.nextInt();
			boolean[] checkedRooms = new boolean[n+1];
			int k = in.nextInt();
			//BelieveState bs2;
			if (useFakeJudge) {
				connections = new boolean[n][n];
				int max = n*(n-1)/2;
				double chance = (1/4.);
				for (int j = 0; j < connections.length; j++) {
					int rj = (int) (Math.random()*n);
					connections[j][rj] = true;
					connections[rj][j] = true;
					for (int j2 = j+1; j2 < connections.length; j2++) {
						if (Math.random()<chance) {
							connections[j][j2] = true;
							connections[j2][j] = true;
						}
					}
				}
			};
			BelieveState bs = new BelieveState(n);
			int kri = in.nextInt();
			checkedRooms[kri] = true;
			int krp = in.nextInt();
			bs.update(kri,krp);
			Room currentRoom = bs.rooms[kri];
			ArrayList<Integer> grabBag = new ArrayList<>();
			for (int j = 1; j <= n; j++) {
				if (j == kri)continue;
				grabBag.add(j);
			}
			Collections.shuffle(grabBag);
			int counter = 0;
			Room nextRoom = null;
			long passageSizes = krp;
			long checkedRoomsCount = 1;
			while(k>0&&counter<grabBag.size()&&bs.certain==false) {
				
				//Request r = bs.getBestRequest();
				//r.print();
				int room = 1;
				//if (k % 2 == 0) {
				boolean check = extracted(currentRoom, passageSizes, checkedRoomsCount);
				if (check) {
					grabBag.get((counter++)%grabBag.size());
					if (checkedRooms[room])continue;
					System.out.println(""T "" + room);}
				else {
					System.out.println(""W"");
				}
					
				int nextI = nextInt(useFakeJudge, in, connections,room,true);
				if (nextI==-1)break;
				
				
				int nextP = nextInt(useFakeJudge, in, connections,room, false);
				 nextRoom = bs.rooms[nextI];
				 if (!checkedRooms[nextI]) {
						checkedRoomsCount++;
						checkedRooms[nextI] = true;
						passageSizes+=nextP;
					}
				//if (r.isWalk) {
					//bs.addConnection(currentRoom,nextRoom);
				//}
				bs.update(nextI,nextP);
				currentRoom = nextRoom;
				k--;
			}
			long countUnvisited = 0;
			long countVisited = 0;
			long passagesInVisited = 0;
			Room[] roms = bs.rooms;
			for (int j = 1; j < roms.length; j++) {
				Room room = roms[j];
				if (room.hasBeenVisited) {
					passagesInVisited+=room.maxPassages;
					countVisited++;
				}
				else countUnvisited += 1;
			}
			double average = passagesInVisited/countVisited;
			long totalRooms = extracted2(countUnvisited, passagesInVisited, average);
			
			long g = totalRooms;
			System.out.println(""E "" + g);
		}
		
	}


	

	public static class Willies{

		public int fun;
		public Willies parent;
		public ArrayList<Willies> children = new ArrayList<Willies>();
		public ArrayList<Signal> signals = new ArrayList<Signal>();
		public int id;
		public Signal winningSignal; 
		public Willies(int i) {
			this.id = i;
		}
		public void addChild(Willies w) {
			children.add(w);
		}
		public boolean needsMoreSignals() {
			return (signals.size()<children.size());
			
		}
		public void addSignal(Signal signal) {
			this.signals.add(signal);
			if (winningSignal==null)winningSignal = signal;
			else winningSignal = winningSignal.maxFun<signal.maxFun?winningSignal:signal;//smaller max fun gets through
		}
		
		
	}

	public static class Signal{
		private Willies current;

		public Signal(Willies willies) {
			current=",Nibbla
9825,"public class Solution {
	private static boolean extracted(Room currentRoom, long passageSizes, long checkedRoomsCount) {
		boolean check = Math.random() > 0.05 && currentRoom.maxPassages > 24 &&currentRoom.maxPassages > passageSizes*1.5/checkedRoomsCount;
		//to transport if in hub
		//currentRoom.maxPassages > 6 &&
		return check;
	}

	private static long extracted2(long countUnvisited, long passagesInVisited, double average) {
		long totalRooms = (long) Math.round(1.0*(passagesInVisited + countUnvisited*average)/2.);
		return totalRooms;
	}	
	
	public static void main(String[] args) {
		Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int problem = 5;
		switch (problem) {
		case 1:
			experiment1(in);
			break;
		case 2:
			experiment2(in);
			break;
		case 3:
			experiment3(in);
			break;
		case 4:
			experiment4(in);
			break;
		case 5:
			experiment5(in);
			break;
		default:
			break;
		}

	}

	private static class Room{
		
		public Room(int i,int mp) {
			
			id = i;
			maxPassages = mp;
		}
		
		final int id;
		int minPassages = 1;
		int maxPassages;
		public int visitedConnections = 0;
		public boolean hasBeenVisited = false;
		public int[] visit(int krp) {
			int delta1 = maxPassages-krp;
			int delta0 = krp-minPassages;
			maxPassages = krp;
			minPassages = krp;
			hasBeenVisited = true;
			return new int[] {delta0,delta1};
			
		}
	}
	private static class Request{

		public boolean isWalk;

		public void print() {
			// TODO Auto-generated method stub
			
		}
		
	}
	private static class BelieveState{

		private Room[] rooms;
		//private int[][] connections; //0 means unknown; -1 means not; 1 means excists;
		private boolean certain = false;
		//private int minConnectionsTimes2;
	//	private int maxConnectionsTimes2;
		//private int maxConnections;
		public BelieveState(int n) {
			rooms = new Room[n+1];
			//connections = new int[n][n];
		//	minConnectionsTimes2 = (int) n;
			//maxConnectionsTimes2 = (int)(n*(n-1)/2);
			//maxConnections = (int)(n*(n-1)/2);
			for (int i = 1; i <= n; i++) {
				rooms[i] = new Room(i,n-1);
			}
		}
		public void update(int kri, int krp) {
			Room r = rooms[kri];
			if (!r.hasBeenVisited) {
				int[] changedPassages = r.visit(krp);
				//maxConnectionsTimes2-=changedPassages[1];
				//minConnectionsTimes2-=changedPassages[0];
			}
			
		}
		public Request getBestRequest() {
			return null;
			// TODO Auto-generated method stub
			
		}
		public int guess() {
			// TODO Auto-generated method stub
			return 0;
		}
		/*public void addConnection(Room currentRoom, Room nextRoom) {
			if (connections[currentRoom.id][nextRoom.id]==0) {
				currentRoom.visitedConnections++;
				nextRoom.visitedConnections++;
			}
			connections[currentRoom.id][nextRoom.id] = 1;
			connections[nextRoom.id][currentRoom.id] = 1;
			
		}*/
		
		
	}
	private static int nextInt(boolean fj, Scanner in ,boolean[][] conn, int room, boolean b) {
		if (!fj)return in.nextInt();
		if (b) {
			System.out.print(room + "" "");
			return room;
		}
		else {
			int counter = 0;
			boolean[] list = conn[room-1];
			for (int i = 0; i < list.length; i++) {
				if (list[i])counter++;
			}
			System.out.println(counter);
			return counter;
		}
		
		
	}
	private static void experiment5(Scanner in) {
		long startTime = System.currentTimeMillis();
		boolean useFakeJudge = false;
		
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		boolean[][] connections = null;
		
		
		for (int i = 1; i <= t; ++i) {
		
			int n = in.nextInt();
			boolean[] checkedRooms = new boolean[n+1];
			int k = in.nextInt();
			//BelieveState bs2;
			if (useFakeJudge) {
				connections = new boolean[n][n];
				int max = n*(n-1)/2;
				double chance = (1/4.);
				for (int j = 0; j < connections.length; j++) {
					int rj = (int) (Math.random()*n);
					connections[j][rj] = true;
					connections[rj][j] = true;
					for (int j2 = j+1; j2 < connections.length; j2++) {
						if (Math.random()<chance) {
							connections[j][j2] = true;
							connections[j2][j] = true;
						}
					}
				}
			};
			BelieveState bs = new BelieveState(n);
			int kri = in.nextInt();
			checkedRooms[kri] = true;
			int krp = in.nextInt();
			bs.update(kri,krp);
			Room currentRoom = bs.rooms[kri];
			ArrayList<Integer> grabBag = new ArrayList<>();
			for (int j = 1; j <= n; j++) {
				if (j == kri)continue;
				grabBag.add(j);
			}
			Collections.shuffle(grabBag);
			int counter = 0;
			Room nextRoom = null;
			long passageSizes = krp;
			long checkedRoomsCount = 1;
			while(k>0&&counter<grabBag.size()&&bs.certain==false) {
				
				//Request r = bs.getBestRequest();
				//r.print();
				int room = 1;
				//if (k % 2 == 0) {
				boolean check = extracted(currentRoom, passageSizes, checkedRoomsCount);
				if (check) {
					grabBag.get((counter++)%grabBag.size());
					if (checkedRooms[room])continue;
					System.out.println(""T "" + room);}
				else {
					System.out.println(""W"");
				}
					
				int nextI = nextInt(useFakeJudge, in, connections,room,true);
				if (nextI==-1)break;
				
				
				int nextP = nextInt(useFakeJudge, in, connections,room, false);
				 nextRoom = bs.rooms[nextI];
				 if (!checkedRooms[nextI]) {
						checkedRoomsCount++;
						checkedRooms[nextI] = true;
						passageSizes+=nextP;
					}
				//if (r.isWalk) {
					//bs.addConnection(currentRoom,nextRoom);
				//}
				bs.update(nextI,nextP);
				currentRoom = nextRoom;
				k--;
			}
			long countUnvisited = 0;
			long countVisited = 0;
			long passagesInVisited = 0;
			Room[] roms = bs.rooms;
			for (int j = 1; j < roms.length; j++) {
				Room room = roms[j];
				if (room.hasBeenVisited) {
					passagesInVisited+=room.maxPassages;
					countVisited++;
				}
				else countUnvisited += 1;
			}
			double average = passagesInVisited/countVisited;
			long totalRooms = extracted2(countUnvisited, passagesInVisited, average);
			
			long g = totalRooms;
			System.out.println(""E "" + g);
		}
		
	}


	

	public static class Willies{

		public int fun;
		public Willies parent;
		public ArrayList<Willies> children = new ArrayList<Willies>();
		public ArrayList<Signal> signals = new ArrayList<Signal>();
		public int id;
		public Signal winningSignal; 
		public Willies(int i) {
			this.id = i;
		}
		public void addChild(Willies w) {
			children.add(w);
		}
		public boolean needsMoreSignals() {
			return (signals.size()<children.size());
			
		}
		public void addSignal(Signal signal) {
			this.signals.add(signal);
			if (winningSignal==null)winningSignal = signal;
			else winningSignal = winningSignal.maxFun<signal.maxFun?winningSignal:signal;//smaller max fun gets through
		}
		
		
	}

	public static class Signal{
		private Willies current;

		public Signal(Willies willies) {
			current=",Nibbla
9826,"public class Solution {
	private static boolean extracted(Room currentRoom, long passageSizes, long checkedRoomsCount) {
		boolean check = Math.random > 0.05 && currentRoom.maxPassages > 24 &&currentRoom.maxPassages > passageSizes*1.5/checkedRoomsCount;
		//to transport if in hub
		//currentRoom.maxPassages > 6 &&
		return check;
	}

	private static long extracted2(long countUnvisited, long passagesInVisited, double average) {
		long totalRooms = (long) Math.round(1.0*(passagesInVisited + countUnvisited*average)/2.);
		return totalRooms;
	}	
	
	public static void main(String[] args) {
		Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int problem = 5;
		switch (problem) {
		case 1:
			experiment1(in);
			break;
		case 2:
			experiment2(in);
			break;
		case 3:
			experiment3(in);
			break;
		case 4:
			experiment4(in);
			break;
		case 5:
			experiment5(in);
			break;
		default:
			break;
		}

	}

	private static class Room{
		
		public Room(int i,int mp) {
			
			id = i;
			maxPassages = mp;
		}
		
		final int id;
		int minPassages = 1;
		int maxPassages;
		public int visitedConnections = 0;
		public boolean hasBeenVisited = false;
		public int[] visit(int krp) {
			int delta1 = maxPassages-krp;
			int delta0 = krp-minPassages;
			maxPassages = krp;
			minPassages = krp;
			hasBeenVisited = true;
			return new int[] {delta0,delta1};
			
		}
	}
	private static class Request{

		public boolean isWalk;

		public void print() {
			// TODO Auto-generated method stub
			
		}
		
	}
	private static class BelieveState{

		private Room[] rooms;
		//private int[][] connections; //0 means unknown; -1 means not; 1 means excists;
		private boolean certain = false;
		//private int minConnectionsTimes2;
	//	private int maxConnectionsTimes2;
		//private int maxConnections;
		public BelieveState(int n) {
			rooms = new Room[n+1];
			//connections = new int[n][n];
		//	minConnectionsTimes2 = (int) n;
			//maxConnectionsTimes2 = (int)(n*(n-1)/2);
			//maxConnections = (int)(n*(n-1)/2);
			for (int i = 1; i <= n; i++) {
				rooms[i] = new Room(i,n-1);
			}
		}
		public void update(int kri, int krp) {
			Room r = rooms[kri];
			if (!r.hasBeenVisited) {
				int[] changedPassages = r.visit(krp);
				//maxConnectionsTimes2-=changedPassages[1];
				//minConnectionsTimes2-=changedPassages[0];
			}
			
		}
		public Request getBestRequest() {
			return null;
			// TODO Auto-generated method stub
			
		}
		public int guess() {
			// TODO Auto-generated method stub
			return 0;
		}
		/*public void addConnection(Room currentRoom, Room nextRoom) {
			if (connections[currentRoom.id][nextRoom.id]==0) {
				currentRoom.visitedConnections++;
				nextRoom.visitedConnections++;
			}
			connections[currentRoom.id][nextRoom.id] = 1;
			connections[nextRoom.id][currentRoom.id] = 1;
			
		}*/
		
		
	}
	private static int nextInt(boolean fj, Scanner in ,boolean[][] conn, int room, boolean b) {
		if (!fj)return in.nextInt();
		if (b) {
			System.out.print(room + "" "");
			return room;
		}
		else {
			int counter = 0;
			boolean[] list = conn[room-1];
			for (int i = 0; i < list.length; i++) {
				if (list[i])counter++;
			}
			System.out.println(counter);
			return counter;
		}
		
		
	}
	private static void experiment5(Scanner in) {
		long startTime = System.currentTimeMillis();
		boolean useFakeJudge = false;
		
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		boolean[][] connections = null;
		
		
		for (int i = 1; i <= t; ++i) {
		
			int n = in.nextInt();
			boolean[] checkedRooms = new boolean[n+1];
			int k = in.nextInt();
			//BelieveState bs2;
			if (useFakeJudge) {
				connections = new boolean[n][n];
				int max = n*(n-1)/2;
				double chance = (1/4.);
				for (int j = 0; j < connections.length; j++) {
					int rj = (int) (Math.random()*n);
					connections[j][rj] = true;
					connections[rj][j] = true;
					for (int j2 = j+1; j2 < connections.length; j2++) {
						if (Math.random()<chance) {
							connections[j][j2] = true;
							connections[j2][j] = true;
						}
					}
				}
			};
			BelieveState bs = new BelieveState(n);
			int kri = in.nextInt();
			checkedRooms[kri] = true;
			int krp = in.nextInt();
			bs.update(kri,krp);
			Room currentRoom = bs.rooms[kri];
			ArrayList<Integer> grabBag = new ArrayList<>();
			for (int j = 1; j <= n; j++) {
				if (j == kri)continue;
				grabBag.add(j);
			}
			Collections.shuffle(grabBag);
			int counter = 0;
			Room nextRoom = null;
			long passageSizes = krp;
			long checkedRoomsCount = 1;
			while(k>0&&counter<grabBag.size()&&bs.certain==false) {
				
				//Request r = bs.getBestRequest();
				//r.print();
				int room = 1;
				//if (k % 2 == 0) {
				boolean check = extracted(currentRoom, passageSizes, checkedRoomsCount);
				if (check) {
					grabBag.get((counter++)%grabBag.size());
					if (checkedRooms[room])continue;
					System.out.println(""T "" + room);}
				else {
					System.out.println(""W"");
				}
					
				int nextI = nextInt(useFakeJudge, in, connections,room,true);
				if (nextI==-1)break;
				
				
				int nextP = nextInt(useFakeJudge, in, connections,room, false);
				 nextRoom = bs.rooms[nextI];
				 if (!checkedRooms[nextI]) {
						checkedRoomsCount++;
						checkedRooms[nextI] = true;
						passageSizes+=nextP;
					}
				//if (r.isWalk) {
					//bs.addConnection(currentRoom,nextRoom);
				//}
				bs.update(nextI,nextP);
				currentRoom = nextRoom;
				k--;
			}
			long countUnvisited = 0;
			long countVisited = 0;
			long passagesInVisited = 0;
			Room[] roms = bs.rooms;
			for (int j = 1; j < roms.length; j++) {
				Room room = roms[j];
				if (room.hasBeenVisited) {
					passagesInVisited+=room.maxPassages;
					countVisited++;
				}
				else countUnvisited += 1;
			}
			double average = passagesInVisited/countVisited;
			long totalRooms = extracted2(countUnvisited, passagesInVisited, average);
			
			long g = totalRooms;
			System.out.println(""E "" + g);
		}
		
	}


	

	public static class Willies{

		public int fun;
		public Willies parent;
		public ArrayList<Willies> children = new ArrayList<Willies>();
		public ArrayList<Signal> signals = new ArrayList<Signal>();
		public int id;
		public Signal winningSignal; 
		public Willies(int i) {
			this.id = i;
		}
		public void addChild(Willies w) {
			children.add(w);
		}
		public boolean needsMoreSignals() {
			return (signals.size()<children.size());
			
		}
		public void addSignal(Signal signal) {
			this.signals.add(signal);
			if (winningSignal==null)winningSignal = signal;
			else winningSignal = winningSignal.maxFun<signal.maxFun?winningSignal:signal;//smaller max fun gets through
		}
		
		
	}

	public static class Signal{
		private Willies current;

		public Signal(Willies willies) {
			current=",Nibbla
9827,"public class Solution {
	private static boolean extracted(Room currentRoom, long passageSizes, long checkedRoomsCount) {
		boolean check = currentRoom.maxPassages > 24 &&currentRoom.maxPassages > passageSizes*3/checkedRoomsCount;
		//to transport if in hub
		//currentRoom.maxPassages > 6 &&
		return check;
	}

	private static long extracted2(long countUnvisited, long passagesInVisited, double average) {
		long totalRooms = (long) Math.round(1.0*(passagesInVisited + countUnvisited*average)/2.);
		return totalRooms;
	}	
	
	public static void main(String[] args) {
		Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int problem = 5;
		switch (problem) {
		case 1:
			experiment1(in);
			break;
		case 2:
			experiment2(in);
			break;
		case 3:
			experiment3(in);
			break;
		case 4:
			experiment4(in);
			break;
		case 5:
			experiment5(in);
			break;
		default:
			break;
		}

	}

	private static class Room{
		
		public Room(int i,int mp) {
			
			id = i;
			maxPassages = mp;
		}
		
		final int id;
		int minPassages = 1;
		int maxPassages;
		public int visitedConnections = 0;
		public boolean hasBeenVisited = false;
		public int[] visit(int krp) {
			int delta1 = maxPassages-krp;
			int delta0 = krp-minPassages;
			maxPassages = krp;
			minPassages = krp;
			hasBeenVisited = true;
			return new int[] {delta0,delta1};
			
		}
	}
	private static class Request{

		public boolean isWalk;

		public void print() {
			// TODO Auto-generated method stub
			
		}
		
	}
	private static class BelieveState{

		private Room[] rooms;
		//private int[][] connections; //0 means unknown; -1 means not; 1 means excists;
		private boolean certain = false;
		//private int minConnectionsTimes2;
	//	private int maxConnectionsTimes2;
		//private int maxConnections;
		public BelieveState(int n) {
			rooms = new Room[n+1];
			//connections = new int[n][n];
		//	minConnectionsTimes2 = (int) n;
			//maxConnectionsTimes2 = (int)(n*(n-1)/2);
			//maxConnections = (int)(n*(n-1)/2);
			for (int i = 1; i <= n; i++) {
				rooms[i] = new Room(i,n-1);
			}
		}
		public void update(int kri, int krp) {
			Room r = rooms[kri];
			if (!r.hasBeenVisited) {
				int[] changedPassages = r.visit(krp);
				//maxConnectionsTimes2-=changedPassages[1];
				//minConnectionsTimes2-=changedPassages[0];
			}
			
		}
		public Request getBestRequest() {
			return null;
			// TODO Auto-generated method stub
			
		}
		public int guess() {
			// TODO Auto-generated method stub
			return 0;
		}
		/*public void addConnection(Room currentRoom, Room nextRoom) {
			if (connections[currentRoom.id][nextRoom.id]==0) {
				currentRoom.visitedConnections++;
				nextRoom.visitedConnections++;
			}
			connections[currentRoom.id][nextRoom.id] = 1;
			connections[nextRoom.id][currentRoom.id] = 1;
			
		}*/
		
		
	}
	private static int nextInt(boolean fj, Scanner in ,boolean[][] conn, int room, boolean b) {
		if (!fj)return in.nextInt();
		if (b) {
			System.out.print(room + "" "");
			return room;
		}
		else {
			int counter = 0;
			boolean[] list = conn[room-1];
			for (int i = 0; i < list.length; i++) {
				if (list[i])counter++;
			}
			System.out.println(counter);
			return counter;
		}
		
		
	}
	private static void experiment5(Scanner in) {
		long startTime = System.currentTimeMillis();
		boolean useFakeJudge = false;
		
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		boolean[][] connections = null;
		
		
		for (int i = 1; i <= t; ++i) {
		
			int n = in.nextInt();
			boolean[] checkedRooms = new boolean[n+1];
			int k = in.nextInt();
			//BelieveState bs2;
			if (useFakeJudge) {
				connections = new boolean[n][n];
				int max = n*(n-1)/2;
				double chance = (1/4.);
				for (int j = 0; j < connections.length; j++) {
					int rj = (int) (Math.random()*n);
					connections[j][rj] = true;
					connections[rj][j] = true;
					for (int j2 = j+1; j2 < connections.length; j2++) {
						if (Math.random()<chance) {
							connections[j][j2] = true;
							connections[j2][j] = true;
						}
					}
				}
			};
			BelieveState bs = new BelieveState(n);
			int kri = in.nextInt();
			checkedRooms[kri] = true;
			int krp = in.nextInt();
			bs.update(kri,krp);
			Room currentRoom = bs.rooms[kri];
			ArrayList<Integer> grabBag = new ArrayList<>();
			for (int j = 1; j <= n; j++) {
				if (j == kri)continue;
				grabBag.add(j);
			}
			Collections.shuffle(grabBag);
			int counter = 0;
			Room nextRoom = null;
			long passageSizes = krp;
			long checkedRoomsCount = 1;
			while(k>0&&counter<grabBag.size()&&bs.certain==false) {
				
				//Request r = bs.getBestRequest();
				//r.print();
				int room = 1;
				//if (k % 2 == 0) {
				boolean check = extracted(currentRoom, passageSizes, checkedRoomsCount);
				if (check) {
					grabBag.get((counter++)%grabBag.size());
					if (checkedRooms[room])continue;
					System.out.println(""T "" + room);}
				else {
					System.out.println(""W"");
				}
					
				int nextI = nextInt(useFakeJudge, in, connections,room,true);
				if (nextI==-1)break;
				
				
				int nextP = nextInt(useFakeJudge, in, connections,room, false);
				 nextRoom = bs.rooms[nextI];
				 if (!checkedRooms[nextI]) {
						checkedRoomsCount++;
						checkedRooms[nextI] = true;
						passageSizes+=nextP;
					}
				//if (r.isWalk) {
					//bs.addConnection(currentRoom,nextRoom);
				//}
				bs.update(nextI,nextP);
				currentRoom = nextRoom;
				k--;
			}
			long countUnvisited = 0;
			long countVisited = 0;
			long passagesInVisited = 0;
			Room[] roms = bs.rooms;
			for (int j = 1; j < roms.length; j++) {
				Room room = roms[j];
				if (room.hasBeenVisited) {
					passagesInVisited+=room.maxPassages;
					countVisited++;
				}
				else countUnvisited += 1;
			}
			double average = passagesInVisited/countVisited;
			long totalRooms = extracted2(countUnvisited, passagesInVisited, average);
			
			long g = totalRooms;
			System.out.println(""E "" + g);
		}
		
	}


	

	public static class Willies{

		public int fun;
		public Willies parent;
		public ArrayList<Willies> children = new ArrayList<Willies>();
		public ArrayList<Signal> signals = new ArrayList<Signal>();
		public int id;
		public Signal winningSignal; 
		public Willies(int i) {
			this.id = i;
		}
		public void addChild(Willies w) {
			children.add(w);
		}
		public boolean needsMoreSignals() {
			return (signals.size()<children.size());
			
		}
		public void addSignal(Signal signal) {
			this.signals.add(signal);
			if (winningSignal==null)winningSignal = signal;
			else winningSignal = winningSignal.maxFun<signal.maxFun?winningSignal:signal;//smaller max fun gets through
		}
		
		
	}

	public static class Signal{
		private Willies current;

		public Signal(Willies willies) {
			current=",Nibbla
9828,"public class Solution {
	private static boolean extracted(Room currentRoom, long passageSizes, long checkedRoomsCount) {
		boolean check = currentRoom.maxPassages > 24 &&currentRoom.maxPassages > passageSizes*1.5/checkedRoomsCount;
		//to transport if in hub
		//currentRoom.maxPassages > 6 &&
		return check;
	}

	private static long extracted2(long countUnvisited, long passagesInVisited, double average) {
		long totalRooms = (long) Math.round(1.0*(passagesInVisited + countUnvisited*average)/2.);
		return totalRooms;
	}	
	
	public static void main(String[] args) {
		Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int problem = 5;
		switch (problem) {
		case 1:
			experiment1(in);
			break;
		case 2:
			experiment2(in);
			break;
		case 3:
			experiment3(in);
			break;
		case 4:
			experiment4(in);
			break;
		case 5:
			experiment5(in);
			break;
		default:
			break;
		}

	}

	private static class Room{
		
		public Room(int i,int mp) {
			
			id = i;
			maxPassages = mp;
		}
		
		final int id;
		int minPassages = 1;
		int maxPassages;
		public int visitedConnections = 0;
		public boolean hasBeenVisited = false;
		public int[] visit(int krp) {
			int delta1 = maxPassages-krp;
			int delta0 = krp-minPassages;
			maxPassages = krp;
			minPassages = krp;
			hasBeenVisited = true;
			return new int[] {delta0,delta1};
			
		}
	}
	private static class Request{

		public boolean isWalk;

		public void print() {
			// TODO Auto-generated method stub
			
		}
		
	}
	private static class BelieveState{

		private Room[] rooms;
		//private int[][] connections; //0 means unknown; -1 means not; 1 means excists;
		private boolean certain = false;
		//private int minConnectionsTimes2;
	//	private int maxConnectionsTimes2;
		//private int maxConnections;
		public BelieveState(int n) {
			rooms = new Room[n+1];
			//connections = new int[n][n];
		//	minConnectionsTimes2 = (int) n;
			//maxConnectionsTimes2 = (int)(n*(n-1)/2);
			//maxConnections = (int)(n*(n-1)/2);
			for (int i = 1; i <= n; i++) {
				rooms[i] = new Room(i,n-1);
			}
		}
		public void update(int kri, int krp) {
			Room r = rooms[kri];
			if (!r.hasBeenVisited) {
				int[] changedPassages = r.visit(krp);
				//maxConnectionsTimes2-=changedPassages[1];
				//minConnectionsTimes2-=changedPassages[0];
			}
			
		}
		public Request getBestRequest() {
			return null;
			// TODO Auto-generated method stub
			
		}
		public int guess() {
			// TODO Auto-generated method stub
			return 0;
		}
		/*public void addConnection(Room currentRoom, Room nextRoom) {
			if (connections[currentRoom.id][nextRoom.id]==0) {
				currentRoom.visitedConnections++;
				nextRoom.visitedConnections++;
			}
			connections[currentRoom.id][nextRoom.id] = 1;
			connections[nextRoom.id][currentRoom.id] = 1;
			
		}*/
		
		
	}
	private static int nextInt(boolean fj, Scanner in ,boolean[][] conn, int room, boolean b) {
		if (!fj)return in.nextInt();
		if (b) {
			System.out.print(room + "" "");
			return room;
		}
		else {
			int counter = 0;
			boolean[] list = conn[room-1];
			for (int i = 0; i < list.length; i++) {
				if (list[i])counter++;
			}
			System.out.println(counter);
			return counter;
		}
		
		
	}
	private static void experiment5(Scanner in) {
		long startTime = System.currentTimeMillis();
		boolean useFakeJudge = false;
		
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		boolean[][] connections = null;
		
		
		for (int i = 1; i <= t; ++i) {
		
			int n = in.nextInt();
			boolean[] checkedRooms = new boolean[n+1];
			int k = in.nextInt();
			//BelieveState bs2;
			if (useFakeJudge) {
				connections = new boolean[n][n];
				int max = n*(n-1)/2;
				double chance = (1/4.);
				for (int j = 0; j < connections.length; j++) {
					int rj = (int) (Math.random()*n);
					connections[j][rj] = true;
					connections[rj][j] = true;
					for (int j2 = j+1; j2 < connections.length; j2++) {
						if (Math.random()<chance) {
							connections[j][j2] = true;
							connections[j2][j] = true;
						}
					}
				}
			};
			BelieveState bs = new BelieveState(n);
			int kri = in.nextInt();
			checkedRooms[kri] = true;
			int krp = in.nextInt();
			bs.update(kri,krp);
			Room currentRoom = bs.rooms[kri];
			ArrayList<Integer> grabBag = new ArrayList<>();
			for (int j = 1; j <= n; j++) {
				if (j == kri)continue;
				grabBag.add(j);
			}
			Collections.shuffle(grabBag);
			int counter = 0;
			Room nextRoom = null;
			long passageSizes = krp;
			long checkedRoomsCount = 1;
			while(k>0&&counter<grabBag.size()&&bs.certain==false) {
				
				//Request r = bs.getBestRequest();
				//r.print();
				int room = 1;
				//if (k % 2 == 0) {
				boolean check = extracted(currentRoom, passageSizes, checkedRoomsCount);
				if (check) {
					grabBag.get((counter++)%grabBag.size());
					if (checkedRooms[room])continue;
					System.out.println(""T "" + room);}
				else {
					System.out.println(""W"");
				}
					
				int nextI = nextInt(useFakeJudge, in, connections,room,true);
				if (nextI==-1)break;
				
				
				int nextP = nextInt(useFakeJudge, in, connections,room, false);
				 nextRoom = bs.rooms[nextI];
				 if (!checkedRooms[nextI]) {
						checkedRoomsCount++;
						checkedRooms[nextI] = true;
						passageSizes+=nextP;
					}
				//if (r.isWalk) {
					//bs.addConnection(currentRoom,nextRoom);
				//}
				bs.update(nextI,nextP);
				currentRoom = nextRoom;
				k--;
			}
			long countUnvisited = 0;
			long countVisited = 0;
			long passagesInVisited = 0;
			Room[] roms = bs.rooms;
			for (int j = 1; j < roms.length; j++) {
				Room room = roms[j];
				if (room.hasBeenVisited) {
					passagesInVisited+=room.maxPassages;
					countVisited++;
				}
				else countUnvisited += 1;
			}
			double average = passagesInVisited/countVisited;
			long totalRooms = extracted2(countUnvisited, passagesInVisited, average);
			
			long g = totalRooms;
			System.out.println(""E "" + g);
		}
		
	}


	

	public static class Willies{

		public int fun;
		public Willies parent;
		public ArrayList<Willies> children = new ArrayList<Willies>();
		public ArrayList<Signal> signals = new ArrayList<Signal>();
		public int id;
		public Signal winningSignal; 
		public Willies(int i) {
			this.id = i;
		}
		public void addChild(Willies w) {
			children.add(w);
		}
		public boolean needsMoreSignals() {
			return (signals.size()<children.size());
			
		}
		public void addSignal(Signal signal) {
			this.signals.add(signal);
			if (winningSignal==null)winningSignal = signal;
			else winningSignal = winningSignal.maxFun<signal.maxFun?winningSignal:signal;//smaller max fun gets through
		}
		
		
	}

	public static class Signal{
		private Willies current;

		public Signal(Willies willies) {
			current=",Nibbla
10385,"public class Solution {


    private static boolean err = false;
    private final Scanner sc;
    private final int N;
    private final int K;
    private Random rand = new Random();

    public static void main(String[] args) {

        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        String s = read(in);
        int T = lineToInt(s, "" "")[0];

        for (int i = 1; i <= T; ++i) {
            int[] line = lineToInt(read(in), "" "");
            int N = line[0];
            int K = line[1];
            new Solution(in, N, K).solve();
        }

    }


    private void solve() {

        int[] line = lineToInt(read(sc), "" "");
        if(N <= K*1.2){
            double estimate = getEstimate();
            print(""E "" + Math.round(estimate*N/2));
            return;
        }

        int tries = 5;
        double[] averages = new double[tries];
        for (int i = 0; i < tries; i++) {
            averages[i] = getEstimate(K/(2*tries));
        }
        Arrays.sort(averages);



//        System.err.println(countCases);
            double estimate = averages[tries/2];
            print(""E "" + Math.round(estimate*N/2));
    }

    private double getEstimate(int k) {
        int[] line;
        long total = 0;
        for (int i = 1; i <= k; i++) {
            print(""T "" + (rand.nextInt(N) + 1));
            line = lineToInt(read(sc), "" "");
            int idv = line[0];
            int dv = line[1];
            print(""W"");
            line = lineToInt(read(sc), "" "");
            int idu = line[0];
            int du = line[1];


            if(du < dv || (du == dv && idu < idv)){
                total += dv*2;
            }

        }
        return ((double)total)/k;
    }

    private double getEstimate(){
        int[] degrees = new int[N+1];
        for (int i = 1; i <= K; i++) {
            print(""T ""+ i);
            int[] line = lineToInt(read(sc), "" "");
            degrees[line[0]] = line[1];
        }
        int computed = 0;
        long total = 0;
        for (int i = 1; i <= N; i++) {
            if(degrees[i] != 0) computed ++;
            total += degrees[i];
        }
        double averageDegree = ((double) total) / computed;
        return averageDegree;
    }


    public Solution(Scanner sc, int n, int k) {
        this.sc = sc;
        N = n;
        K = k;
    }

    private void print(String s) {
        System.out.println(s);
        if (err) {
            System.err.println(""out: "" + s);
        }
        System.out.flush();
    }

    private static String read(Scanner sc) {
        String s = sc.nextLine();
        if (err) {
            System.err.println(""in: "" + s);
        }
        return s;
    }

    public static int[] lineToInt(String line, String regex) {
        return Stream.",RicolaNouland
10386,"public class Solution {


    private static boolean err = false;
    private final Scanner sc;
    private final int N;
    private final int K;
    private Random rand = new Random();

    public static void main(String[] args) {

        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        String s = read(in);
        int T = lineToInt(s, "" "")[0];

        for (int i = 1; i <= T; ++i) {
            int[] line = lineToInt(read(in), "" "");
            int N = line[0];
            int K = line[1];
            new Solution(in, N, K).solve();
        }

    }


    private void solve() {

        int[] line = lineToInt(read(sc), "" "");
        if(N <= K*1.2){
            double estimate = getEstimate();
            print(""E "" + Math.round(estimate*N/2));
            return;
        }

        int tries = 10;
        double[] averages = new double[tries];
        for (int i = 0; i < tries; i++) {
            averages[i] = getEstimate(K/(2*tries));
        }
        Arrays.sort(averages);



//        System.err.println(countCases);
            double estimate = averages[tries/2];
            print(""E "" + Math.round(estimate*N/2));
    }

    private double getEstimate(int k) {
        int[] line;
        long total = 0;
        for (int i = 1; i <= k; i++) {
            print(""T "" + (rand.nextInt(N) + 1));
            line = lineToInt(read(sc), "" "");
            int idv = line[0];
            int dv = line[1];
            print(""W"");
            line = lineToInt(read(sc), "" "");
            int idu = line[0];
            int du = line[1];


            if(du < dv || (du == dv && idu < idv)){
                total += dv*2;
            }

        }
        return ((double)total)/k;
    }

    private double getEstimate(){
        int[] degrees = new int[N+1];
        for (int i = 1; i <= K; i++) {
            print(""T ""+ i);
            int[] line = lineToInt(read(sc), "" "");
            degrees[line[0]] = line[1];
        }
        int computed = 0;
        long total = 0;
        for (int i = 1; i <= N; i++) {
            if(degrees[i] != 0) computed ++;
            total += degrees[i];
        }
        double averageDegree = ((double) total) / computed;
        return averageDegree;
    }


    public Solution(Scanner sc, int n, int k) {
        this.sc = sc;
        N = n;
        K = k;
    }

    private void print(String s) {
        System.out.println(s);
        if (err) {
            System.err.println(""out: "" + s);
        }
        System.out.flush();
    }

    private static String read(Scanner sc) {
        String s = sc.nextLine();
        if (err) {
            System.err.println(""in: "" + s);
        }
        return s;
    }

    public static int[] lineToInt(String line, String regex) {
        return Stream.",RicolaNouland
10387,"public class Solution {


    private static boolean err = false;
    private final Scanner sc;
    private final int N;
    private final int K;
    private Random rand = new Random();

    public static void main(String[] args) {

        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        String s = read(in);
        int T = lineToInt(s, "" "")[0];

        for (int i = 1; i <= T; ++i) {
            int[] line = lineToInt(read(in), "" "");
            int N = line[0];
            int K = line[1];
            new Solution(in, N, K).solve();
        }

    }


    private void solve() {

        int[] line = lineToInt(read(sc), "" "");
        if(N <= K*3){
            double estimate = getEstimate();
            print(""E "" + Math.round(estimate*N/2));
            return;
        }

        int k = K / 2;
        long total = 0;
        for (int i = 1; i <= k; i++) {
            print(""T "" + (rand.nextInt(N) + 1));
            line = lineToInt(read(sc), "" "");
            int idv = line[0];
            int dv = line[1];
            print(""W"");
            line = lineToInt(read(sc), "" "");
            int idu = line[0];
            int du = line[1];


            if(du < dv || (du == dv && idu < idv)){
                total += 2*dv;
            }

        }
//        System.err.println(countCases);
            double estimate = ((double)total)/k;
            print(""E "" + Math.round(estimate*N/2));
    }

    private double getEstimate(){
        int[] degrees = new int[N+1];
        for (int i = 1; i <= K; i++) {
            print(""T ""+ i);
            int[] line = lineToInt(read(sc), "" "");
            degrees[line[0]] = line[1];
        }
        int computed = 0;
        long total = 0;
        for (int i = 1; i <= N; i++) {
            if(degrees[i] != 0) computed ++;
            total += degrees[i];
        }
        double averageDegree = ((double) total) / computed;
        return averageDegree;
    }


    public Solution(Scanner sc, int n, int k) {
        this.sc = sc;
        N = n;
        K = k;
    }

    private void print(String s) {
        System.out.println(s);
        if (err) {
            System.err.println(""out: "" + s);
        }
        System.out.flush();
    }

    private static String read(Scanner sc) {
        String s = sc.nextLine();
        if (err) {
            System.err.println(""in: "" + s);
        }
        return s;
    }

    public static int[] lineToInt(String line, String regex) {
        return Stream.",RicolaNouland
10388,"public class Solution {


    private static boolean err = false;
    private final Scanner sc;
    private final int N;
    private final int K;
    private Random rand = new Random();

    public static void main(String[] args) {

        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        String s = read(in);
        int T = lineToInt(s, "" "")[0];

        for (int i = 1; i <= T; ++i) {
            int[] line = lineToInt(read(in), "" "");
            int N = line[0];
            int K = line[1];
            new Solution(in, N, K).solve();
        }

    }


    private void solve() {

        int[] line = lineToInt(read(sc), "" "");
        if(N <= K*2.5){
            double estimate = getEstimate();
            print(""E "" + Math.round(estimate*N/2));
            return;
        }

        int k = K / 2;
        long total = 0;
        for (int i = 1; i <= k; i++) {
            print(""T "" + (rand.nextInt(N) + 1));
            line = lineToInt(read(sc), "" "");
            int idv = line[0];
            int dv = line[1];
            print(""W"");
            line = lineToInt(read(sc), "" "");
            int idu = line[0];
            int du = line[1];


            if(du < dv || (du == dv && idu < idv)){
                total += 2*dv;
            }

        }
//        System.err.println(countCases);
            double estimate = ((double)total)/k;
            print(""E "" + Math.round(estimate*N/2));
    }

    private double getEstimate(){
        int[] degrees = new int[N+1];
        for (int i = 1; i <= K; i++) {
            print(""T ""+ i);
            int[] line = lineToInt(read(sc), "" "");
            degrees[line[0]] = line[1];
        }
        int computed = 0;
        long total = 0;
        for (int i = 1; i <= N; i++) {
            if(degrees[i] != 0) computed ++;
            total += degrees[i];
        }
        double averageDegree = ((double) total) / computed;
        return averageDegree;
    }


    public Solution(Scanner sc, int n, int k) {
        this.sc = sc;
        N = n;
        K = k;
    }

    private void print(String s) {
        System.out.println(s);
        if (err) {
            System.err.println(""out: "" + s);
        }
        System.out.flush();
    }

    private static String read(Scanner sc) {
        String s = sc.nextLine();
        if (err) {
            System.err.println(""in: "" + s);
        }
        return s;
    }

    public static int[] lineToInt(String line, String regex) {
        return Stream.",RicolaNouland
10389,"public class Solution {


    private static boolean err = false;
    private final Scanner sc;
    private final int N;
    private final int K;
    private Random rand = new Random();

    public static void main(String[] args) {

        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        String s = read(in);
        int T = lineToInt(s, "" "")[0];

        for (int i = 1; i <= T; ++i) {
            int[] line = lineToInt(read(in), "" "");
            int N = line[0];
            int K = line[1];
            new Solution(in, N, K).solve();
        }

    }


    private void solve() {

        int[] line = lineToInt(read(sc), "" "");
        if(N <= K*2){
            double estimate = getEstimate();
            print(""E "" + Math.round(estimate*N/2));
            return;
        }

        int k = K / 2;
        long total = 0;
        for (int i = 1; i <= k; i++) {
            print(""T "" + (rand.nextInt(N) + 1));
            line = lineToInt(read(sc), "" "");
            int idv = line[0];
            int dv = line[1];
            print(""W"");
            line = lineToInt(read(sc), "" "");
            int idu = line[0];
            int du = line[1];


            if(du < dv || (du == dv && idu < idv)){
                total += 2*dv;
            }

        }
//        System.err.println(countCases);
            double estimate = ((double)total)/k;
            print(""E "" + Math.round(estimate*N/2));
    }

    private double getEstimate(){
        int[] degrees = new int[N+1];
        for (int i = 1; i <= K; i++) {
            print(""T ""+ i);
            int[] line = lineToInt(read(sc), "" "");
            degrees[line[0]] = line[1];
        }
        int computed = 0;
        long total = 0;
        for (int i = 1; i <= N; i++) {
            if(degrees[i] != 0) computed ++;
            total += degrees[i];
        }
        double averageDegree = ((double) total) / computed;
        return averageDegree;
    }


    public Solution(Scanner sc, int n, int k) {
        this.sc = sc;
        N = n;
        K = k;
    }

    private void print(String s) {
        System.out.println(s);
        if (err) {
            System.err.println(""out: "" + s);
        }
        System.out.flush();
    }

    private static String read(Scanner sc) {
        String s = sc.nextLine();
        if (err) {
            System.err.println(""in: "" + s);
        }
        return s;
    }

    public static int[] lineToInt(String line, String regex) {
        return Stream.",RicolaNouland
10390,"public class Solution {


    private static boolean err = false;
    private final Scanner sc;
    private final int N;
    private final int K;
    private Random rand = new Random();

    public static void main(String[] args) {

        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        String s = read(in);
        int T = lineToInt(s, "" "")[0];

        for (int i = 1; i <= T; ++i) {
            int[] line = lineToInt(read(in), "" "");
            int N = line[0];
            int K = line[1];
            new Solution(in, N, K).solve();
        }

    }


    private void solve() {

        int[] line = lineToInt(read(sc), "" "");
        if(N <= K*1.5){
            double estimate = getEstimate();
            print(""E "" + Math.round(estimate*N/2));
            return;
        }

        int k = K / 2;
        long total = 0;
        for (int i = 1; i <= k; i++) {
            print(""T "" + (rand.nextInt(N) + 1));
            line = lineToInt(read(sc), "" "");
            int idv = line[0];
            int dv = line[1];
            print(""W"");
            line = lineToInt(read(sc), "" "");
            int idu = line[0];
            int du = line[1];


            if(du < dv || (du == dv && idu < idv)){
                total += 2*dv;
            }

        }
//        System.err.println(countCases);
            double estimate = ((double)total)/k;
            print(""E "" + Math.round(estimate*N/2));
    }

    private double getEstimate(){
        int[] degrees = new int[N+1];
        for (int i = 1; i <= K; i++) {
            print(""T ""+ i);
            int[] line = lineToInt(read(sc), "" "");
            degrees[line[0]] = line[1];
        }
        int computed = 0;
        long total = 0;
        for (int i = 1; i <= N; i++) {
            if(degrees[i] != 0) computed ++;
            total += degrees[i];
        }
        double averageDegree = ((double) total) / computed;
        return averageDegree;
    }


    public Solution(Scanner sc, int n, int k) {
        this.sc = sc;
        N = n;
        K = k;
    }

    private void print(String s) {
        System.out.println(s);
        if (err) {
            System.err.println(""out: "" + s);
        }
        System.out.flush();
    }

    private static String read(Scanner sc) {
        String s = sc.nextLine();
        if (err) {
            System.err.println(""in: "" + s);
        }
        return s;
    }

    public static int[] lineToInt(String line, String regex) {
        return Stream.",RicolaNouland
10391,"public class Solution {


    private static boolean err = false;
    private final Scanner sc;
    private final int N;
    private final int K;
    private Random rand = new Random();

    public static void main(String[] args) {

        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        String s = read(in);
        int T = lineToInt(s, "" "")[0];

        for (int i = 1; i <= T; ++i) {
            int[] line = lineToInt(read(in), "" "");
            int N = line[0];
            int K = line[1];
            new Solution(in, N, K).solve();
        }

    }


    private void solve() {

        int[] line = lineToInt(read(sc), "" "");
        if(N <= K*1.1){
            double estimate = getEstimate();
            print(""E "" + Math.round(estimate*N/2));
            return;
        }

        int k = K / 2;
        long total = 0;
        for (int i = 1; i <= k; i++) {
            print(""T "" + (rand.nextInt(N) + 1));
            line = lineToInt(read(sc), "" "");
            int idv = line[0];
            int dv = line[1];
            print(""W"");
            line = lineToInt(read(sc), "" "");
            int idu = line[0];
            int du = line[1];


            if(du < dv || (du == dv && idu < idv)){
                total += 2*dv;
            }

        }
//        System.err.println(countCases);
            double estimate = ((double)total)/k;
            print(""E "" + Math.round(estimate*N/2));
    }

    private double getEstimate(){
        int[] degrees = new int[N+1];
        for (int i = 1; i <= K; i++) {
            print(""T ""+ i);
            int[] line = lineToInt(read(sc), "" "");
            degrees[line[0]] = line[1];
        }
        int computed = 0;
        long total = 0;
        for (int i = 1; i <= N; i++) {
            if(degrees[i] != 0) computed ++;
            total += degrees[i];
        }
        double averageDegree = ((double) total) / computed;
        return averageDegree;
    }


    public Solution(Scanner sc, int n, int k) {
        this.sc = sc;
        N = n;
        K = k;
    }

    private void print(String s) {
        System.out.println(s);
        if (err) {
            System.err.println(""out: "" + s);
        }
        System.out.flush();
    }

    private static String read(Scanner sc) {
        String s = sc.nextLine();
        if (err) {
            System.err.println(""in: "" + s);
        }
        return s;
    }

    public static int[] lineToInt(String line, String regex) {
        return Stream.",RicolaNouland
10392,"public class Solution {


    private static boolean err = false;
    private final Scanner sc;
    private final int N;
    private final int K;
    private Random rand = new Random();

    public static void main(String[] args) {

        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        String s = read(in);
        int T = lineToInt(s, "" "")[0];

        for (int i = 1; i <= T; ++i) {
            int[] line = lineToInt(read(in), "" "");
            int N = line[0];
            int K = line[1];
            new Solution(in, N, K).solve();
        }

    }


    private void solve() {

        int[] line = lineToInt(read(sc), "" "");
        if(N <= K){
            double estimate = getEstimate();
            print(""E "" + Math.round(estimate*N/2));
            return;
        }

        int k = K / 2;
        long total = 0;
        for (int i = 1; i <= k; i++) {
            print(""T "" + (rand.nextInt(N) + 1));
            line = lineToInt(read(sc), "" "");
            int idv = line[0];
            int dv = line[1];
            print(""W"");
            line = lineToInt(read(sc), "" "");
            int idu = line[0];
            int du = line[1];


            if(du < dv || (du == dv && idu < idv)){
                total += 2*dv;
            }

        }
//        System.err.println(countCases);
            double estimate = ((double)total)/k;
            print(""E "" + Math.round(estimate*N/2));
    }

    private double getEstimate(){
        int[] degrees = new int[N+1];
        for (int i = 1; i <= K; i++) {
            print(""T ""+ i);
            int[] line = lineToInt(read(sc), "" "");
            degrees[line[0]] = line[1];
        }
        int computed = 0;
        long total = 0;
        for (int i = 1; i <= N; i++) {
            if(degrees[i] != 0) computed ++;
            total += degrees[i];
        }
        double averageDegree = ((double) total) / computed;
        return averageDegree;
    }


    public Solution(Scanner sc, int n, int k) {
        this.sc = sc;
        N = n;
        K = k;
    }

    private void print(String s) {
        System.out.println(s);
        if (err) {
            System.err.println(""out: "" + s);
        }
        System.out.flush();
    }

    private static String read(Scanner sc) {
        String s = sc.nextLine();
        if (err) {
            System.err.println(""in: "" + s);
        }
        return s;
    }

    public static int[] lineToInt(String line, String regex) {
        return Stream.",RicolaNouland
10393,"public class Solution {


    private static boolean err = false;
    private final Scanner sc;
    private final int N;
    private final int K;
    private Random rand = new Random();

    public static void main(String[] args) {

        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        String s = read(in);
        int T = lineToInt(s, "" "")[0];

        for (int i = 1; i <= T; ++i) {
            int[] line = lineToInt(read(in), "" "");
            int N = line[0];
            int K = line[1];
            new Solution(in, N, K).solve();
        }

    }


    private void solve() {

        int[] line = lineToInt(read(sc), "" "");
        if(N <= K*1.2){
            double estimate = getEstimate();
            print(""E "" + Math.round(estimate*N/2));
            return;
        }

        int k = K / 2;
        long total = 0;
        for (int i = 1; i <= k; i++) {
            print(""T "" + (rand.nextInt(N) + 1));
            line = lineToInt(read(sc), "" "");
            int idv = line[0];
            int dv = line[1];
            print(""W"");
            line = lineToInt(read(sc), "" "");
            int idu = line[0];
            int du = line[1];


            if(du < dv || (du == dv && idu < idv)){
                total += 2*dv;
            }

        }
//        System.err.println(countCases);
            double estimate = ((double)total)/k;
            print(""E "" + Math.round(estimate*N/2));
    }

    private double getEstimate(){
        int[] degrees = new int[N+1];
        for (int i = 1; i <= K; i++) {
            print(""T ""+ i);
            int[] line = lineToInt(read(sc), "" "");
            degrees[line[0]] = line[1];
        }
        int computed = 0;
        long total = 0;
        for (int i = 1; i <= N; i++) {
            if(degrees[i] != 0) computed ++;
            total += degrees[i];
        }
        double averageDegree = ((double) total) / computed;
        return averageDegree;
    }


    public Solution(Scanner sc, int n, int k) {
        this.sc = sc;
        N = n;
        K = k;
    }

    private void print(String s) {
        System.out.println(s);
        if (err) {
            System.err.println(""out: "" + s);
        }
        System.out.flush();
    }

    private static String read(Scanner sc) {
        String s = sc.nextLine();
        if (err) {
            System.err.println(""in: "" + s);
        }
        return s;
    }

    public static int[] lineToInt(String line, String regex) {
        return Stream.",RicolaNouland
10394,"public class Solution {


    private static boolean err = false;
    private final Scanner sc;
    private final int N;
    private final int K;
    private Random rand = new Random();

    public static void main(String[] args) {

        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        String s = read(in);
        int T = lineToInt(s, "" "")[0];

        for (int i = 1; i <= T; ++i) {
            int[] line = lineToInt(read(in), "" "");
            int N = line[0];
            int K = line[1];
            new Solution(in, N, K).solve();
        }

    }


    private void solve() {

        int[] line = lineToInt(read(sc), "" "");

        int k = K / 2;
        long total = 0;
        int countCases = 0;
        for (int i = 1; i <= k; i++) {
            print(""T "" + (rand.nextInt(N) + 1));
            line = lineToInt(read(sc), "" "");
            int idv = line[0];
            int dv = line[1];
            print(""W"");
            line = lineToInt(read(sc), "" "");
            int idu = line[0];
            int du = line[1];


            if(du < dv || (du == dv && idu < idv)){
                total += 2*dv;
            }

        }
//        System.err.println(countCases);
            double estimate = ((double)total)/k;
            print(""E "" + Math.round(estimate*N/2));
    }

    private double getEstimate(int tries, int start, int[] degrees){
        for (int i = start; i < start + tries; i++) {
            print(""T ""+ (degrees[i] == 0 ? i : Math.min(K+1, N)));
            int[] line = lineToInt(read(sc), "" "");
            degrees[line[0]] = line[1];
        }
        int computed = 0;
        long total = 0;
        for (int i = 1; i <= N; i++) {
            if(degrees[i] != 0) computed ++;
            total += degrees[i];
        }
        double averageDegree = ((double) total) / computed;
        return averageDegree;
    }


    public Solution(Scanner sc, int n, int k) {
        this.sc = sc;
        N = n;
        K = k;
    }

    private void print(String s) {
        System.out.println(s);
        if (err) {
            System.err.println(""out: "" + s);
        }
        System.out.flush();
    }

    private static String read(Scanner sc) {
        String s = sc.nextLine();
        if (err) {
            System.err.println(""in: "" + s);
        }
        return s;
    }

    public static int[] lineToInt(String line, String regex) {
        return Stream.",RicolaNouland
10395,"public class Solution {


    private static boolean err = false;
    private final Scanner sc;
    private final int N;
    private final int K;

    public static void main(String[] args) {

        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        String s = read(in);
        int T = lineToInt(s, "" "")[0];

        for (int i = 1; i <= T; ++i) {
            int[] line = lineToInt(read(in), "" "");
            int N = line[0];
            int K = line[1];
            new Solution(in, N, K).solve();
        }

    }


    private void solve() {

        int[] line = lineToInt(read(sc), "" "");

        int k = K / 2;
        long total = 0;
        int countCases = 0;
        for (int i = 1; i <= k; i++) {
            print(""T "" + i);
            line = lineToInt(read(sc), "" "");
            int idv = line[0];
            int dv = line[1];
            print(""W"");
            line = lineToInt(read(sc), "" "");
            int idu = line[0];
            int du = line[1];


            if(du < dv || (du == dv && idu < idv)){
                total += 2*dv;
            }

        }
//        System.err.println(countCases);
            double estimate = ((double)total)/k;
            print(""E "" + Math.round(estimate*N/2));
    }

    private double getEstimate(int tries, int start, int[] degrees){
        for (int i = start; i < start + tries; i++) {
            print(""T ""+ (degrees[i] == 0 ? i : Math.min(K+1, N)));
            int[] line = lineToInt(read(sc), "" "");
            degrees[line[0]] = line[1];
        }
        int computed = 0;
        long total = 0;
        for (int i = 1; i <= N; i++) {
            if(degrees[i] != 0) computed ++;
            total += degrees[i];
        }
        double averageDegree = ((double) total) / computed;
        return averageDegree;
    }


    public Solution(Scanner sc, int n, int k) {
        this.sc = sc;
        N = n;
        K = k;
    }

    private void print(String s) {
        System.out.println(s);
        if (err) {
            System.err.println(""out: "" + s);
        }
        System.out.flush();
    }

    private static String read(Scanner sc) {
        String s = sc.nextLine();
        if (err) {
            System.err.println(""in: "" + s);
        }
        return s;
    }

    public static int[] lineToInt(String line, String regex) {
        return Stream.",RicolaNouland
10396,"public class Solution {


    private static boolean err = false;
    private final Scanner sc;
    private final int N;
    private final int K;

    public static void main(String[] args) {

        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        String s = read(in);
        int T = lineToInt(s, "" "")[0];

        for (int i = 1; i <= T; ++i) {
            int[] line = lineToInt(read(in), "" "");
            int N = line[0];
            int K = line[1];
            new Solution(in, N, K).solve();
        }

    }


    private void solve() {
        int[] degrees = new int[N+1];
        int[] line = lineToInt(read(sc), "" "");
        degrees[line[0]] = line[1];

        if(N <= K){
            double estimate = getEstimate(K, 0, degrees);
            print(""E "" + Math.round(estimate*N/2));
        } else {
            int tries = (int) Math.round(Math.sqrt(N));
            int factor = K/tries;

            double min = Double.MAX_VALUE;
            for (int i = 0; i < factor; i++) {
                min = Math.min(getEstimate(tries, tries *i+1, degrees), min);
            }
            print(""E "" + Math.round(min*N/2));
        }
    }

    private double getEstimate(int tries, int start, int[] degrees){
        for (int i = start; i < start + tries; i++) {
            print(""T ""+ (degrees[i] == 0 ? i : Math.min(K+1, N)));
            int[] line = lineToInt(read(sc), "" "");
            degrees[line[0]] = line[1];
        }
        int computed = 0;
        long total = 0;
        for (int i = 1; i <= N; i++) {
            if(degrees[i] != 0) computed ++;
            total += degrees[i];
        }
        double averageDegree = ((double) total) / computed;
        return averageDegree;
    }


    public Solution(Scanner sc, int n, int k) {
        this.sc = sc;
        N = n;
        K = k;
    }

    private void print(String s) {
        System.out.println(s);
        if (err) {
            System.err.println(""out: "" + s);
        }
        System.out.flush();
    }

    private static String read(Scanner sc) {
        String s = sc.nextLine();
        if (err) {
            System.err.println(""in: "" + s);
        }
        return s;
    }

    public static int[] lineToInt(String line, String regex) {
        return Stream.",RicolaNouland
10397,"public class Solution {


    private static boolean err = false;
    private final Scanner sc;
    private final int N;
    private final int K;

    public static void main(String[] args) {

        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        String s = read(in);
        int T = lineToInt(s, "" "")[0];

        for (int i = 1; i <= T; ++i) {
            int[] line = lineToInt(read(in), "" "");
            int N = line[0];
            int K = line[1];
            new Solution(in, N, K).solve();
        }

    }


    private void solve() {
        int[] degrees = new int[N+1];
        int[] line = lineToInt(read(sc), "" "");
        degrees[line[0]] = line[1];

        for (int i = 1; i <= Math.min(K, N); i++) {
            print(""T ""+ (degrees[i] == 0 ? i : Math.min(K+1, N)));
            line = lineToInt(read(sc), "" "");
            degrees[line[0]] = line[1];
        }

        int computed = 0;
        long total = 0;
        for (int i = 1; i <= N; i++) {
            if(degrees[i] != 0) computed ++;
            total += degrees[i];
        }
        if(computed == N){
            print(""E "" + total/2);
        } else {
            double averageDegree = ((double) total) / computed;

            long estimation =  (long)(Math.ceil(averageDegree*N)/2);
            print(""E "" + estimation);
        }


    }


    public Solution(Scanner sc, int n, int k) {
        this.sc = sc;
        N = n;
        K = k;
    }

    private void print(String s) {
        System.out.println(s);
        if (err) {
            System.err.println(""out: "" + s);
        }
        System.out.flush();
    }

    private static String read(Scanner sc) {
        String s = sc.nextLine();
        if (err) {
            System.err.println(""in: "" + s);
        }
        return s;
    }

    public static int[] lineToInt(String line, String regex) {
        return Stream.",RicolaNouland
10398,"public class Solution {


    private static boolean err = false;
    private final Scanner sc;
    private final int N;
    private final int K;

    public static void main(String[] args) {

        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        String s = read(in);
        int T = lineToInt(s, "" "")[0];

        for (int i = 1; i <= T; ++i) {
            int[] line = lineToInt(read(in), "" "");
            int N = line[0];
            int K = line[1];
            new Solution(in, N, K).solve();
        }

    }


    private void solve() {
        int[] degrees = new int[N+1];
        int[] line = lineToInt(read(sc), "" "");
        degrees[line[0]] = line[1];

        for (int i = 1; i <= Math.min(K, N); i++) {
            print(""T ""+ (degrees[i] == 0 ? i : Math.min(K+1, N)));
            line = lineToInt(read(sc), "" "");
            degrees[line[0]] = line[1];
        }

        int computed = 0;
        long total = 0;
        for (int i = 1; i <= N; i++) {
            if(degrees[i] != 0) computed ++;
            total += degrees[i];
        }
        if(computed == N){
            print(""E "" + total/2);
        } else {
            double averageDegree = ((double) total) / computed;

            long estimation =  Math.round(((total + (N-computed)*averageDegree)/2));
            print(""E "" + estimation);
        }


    }


    public Solution(Scanner sc, int n, int k) {
        this.sc = sc;
        N = n;
        K = k;
    }

    private void print(String s) {
        System.out.println(s);
        if (err) {
            System.err.println(""out: "" + s);
        }
        System.out.flush();
    }

    private static String read(Scanner sc) {
        String s = sc.nextLine();
        if (err) {
            System.err.println(""in: "" + s);
        }
        return s;
    }

    public static int[] lineToInt(String line, String regex) {
        return Stream.",RicolaNouland
10399,"public class Solution {


    private static boolean err = false;
    private final Scanner sc;
    private final int N;

    public static void main(String[] args) {

        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        String s = read(in);
        int T = lineToInt(s, "" "")[0];

        for (int i = 1; i <= T; ++i) {
            int[] line = lineToInt(read(in), "" "");
            int N = line[0];
            new Solution(in, N).solve();
        }

    }


    private void solve() {
        int[] degrees = new int[N+1];
        int[] line = lineToInt(read(sc), "" "");
        degrees[line[0]] = line[1];

        for (int i = 1; i <= Math.min(8000, N); i++) {
            print(""T ""+ (degrees[i] == 0 ? i : Math.min(8001, N)));
            line = lineToInt(read(sc), "" "");
            degrees[line[0]] = line[1];
        }

        int computed = 0;
        long total = 0;
        for (int i = 1; i <= N; i++) {
            if(degrees[i] != 0) computed ++;
            total += degrees[i];
        }
        if(computed == N){
            print(""E "" + total/2);
        } else {
            double averageDegree = ((double) total) / computed;

            long estimation =  Math.round(((total + (N-computed)*averageDegree)/2));
            print(""E "" + estimation);
        }


    }


    public Solution(Scanner sc, int n) {
        this.sc = sc;
        N = n;
    }

    private void print(String s) {
        System.out.println(s);
        if (err) {
            System.err.println(""out: "" + s);
        }
        System.out.flush();
    }

    private static String read(Scanner sc) {
        String s = sc.nextLine();
        if (err) {
            System.err.println(""in: "" + s);
        }
        return s;
    }

    public static int[] lineToInt(String line, String regex) {
        return Stream.",RicolaNouland
10401,"public class Solution {


    private static boolean err = false;
    private final Scanner sc;
    private final int N;

    public static void main(String[] args) {

        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        String s = read(in);
        int T = lineToInt(s, "" "")[0];

        for (int i = 1; i <= T; ++i) {
            int[] line = lineToInt(read(in), "" "");
            int N = line[0];
            new Solution(in, N).solve();
        }

    }


    private void solve() {
        int[] degrees = new int[N+1];
        int[] line = lineToInt(read(sc), "" "");
        degrees[line[0]] = line[1];

        for (int i = 1; i <= Math.min(8000, N); i++) {
            print(""T ""+ (degrees[i] == 0 ? i : Math.min(8001, N)));
            line = lineToInt(read(sc), "" "");
            degrees[line[0]] = line[1];
        }

        int computed = 0;
        long total = 0;
        for (int i = 1; i <= N; i++) {
            if(degrees[i] != 0) computed ++;
            total += degrees[i];
        }
        if(computed == N){
            print(""E "" + total/2);
        } else {
            double averageDegree = ((double) total) / computed;


            long estimation =  Math.round(((computed + (N-computed)*averageDegree)/2)*1.2);
            print(""E "" + estimation);
        }


    }


    public Solution(Scanner sc, int n) {
        this.sc = sc;
        N = n;
    }

    private void print(String s) {
        System.out.println(s);
        if (err) {
            System.err.println(""out: "" + s);
        }
        System.out.flush();
    }

    private static String read(Scanner sc) {
        String s = sc.nextLine();
        if (err) {
            System.err.println(""in: "" + s);
        }
        return s;
    }

    public static int[] lineToInt(String line, String regex) {
        return Stream.",RicolaNouland
10402,"public class Solution {


    private static boolean err = false;
    private final Scanner sc;
    private final int N;

    public static void main(String[] args) {

        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        String s = read(in);
        int T = lineToInt(s, "" "")[0];

        for (int i = 1; i <= T; ++i) {
            int[] line = lineToInt(read(in), "" "");
            int N = line[0];
            new Solution(in, N).solve();
        }

    }


    private void solve() {
        int[] degrees = new int[N+1];
        int[] line = lineToInt(read(sc), "" "");
        degrees[line[0]] = line[1];

        for (int i = 1; i <= Math.min(8000, N); i++) {
            print(""T ""+ (degrees[i] == 0 ? i : Math.min(8001, N)));
            line = lineToInt(read(sc), "" "");
            degrees[line[0]] = line[1];
        }

        int computed = 0;
        long total = 0;
        for (int i = 1; i <= N; i++) {
            if(degrees[i] != 0) computed ++;
            total += degrees[i];
        }
        if(computed == N){
            print(""E "" + total);
            return;
        } else {
            double averageDegree = ((double) total) / computed;


            long estimation =  Math.round(((computed + (N-computed)*averageDegree)/2)*1.05);
            print(""E "" + estimation);
        }


    }


    public Solution(Scanner sc, int n) {
        this.sc = sc;
        N = n;
    }

    private void print(String s) {
        System.out.println(s);
        if (err) {
            System.err.println(""out: "" + s);
        }
        System.out.flush();
    }

    private static String read(Scanner sc) {
        String s = sc.nextLine();
        if (err) {
            System.err.println(""in: "" + s);
        }
        return s;
    }

    public static int[] lineToInt(String line, String regex) {
        return Stream.",RicolaNouland
10403,"public class Solution {


    private static boolean err = false;
    private final Scanner sc;
    private final int N;

    public static void main(String[] args) {

        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        String s = read(in);
        int T = lineToInt(s, "" "")[0];

        for (int i = 1; i <= T; ++i) {
            int[] line = lineToInt(read(in), "" "");
            int N = line[0];
            new Solution(in, N).solve();
        }

    }


    private void solve() {
        int[] degrees = new int[N+1];
        int[] line = lineToInt(read(sc), "" "");
        degrees[line[0]] = line[1];

        for (int i = 1; i <= Math.min(8000, N); i++) {
            print(""T ""+ (degrees[i] == 0 ? i : Math.min(8001, N)));
            line = lineToInt(read(sc), "" "");
            degrees[line[0]] = line[1];
        }

        int computed = 0;
        long total = 0;
        for (int i = 1; i <= N; i++) {
            if(degrees[i] != 0) computed ++;
            total += degrees[i];
        }

        double averageDegree = ((double) total) / computed;


        long estimation =  Math.round((computed + (N-computed)*averageDegree)/2);
        print(""E "" + estimation);
    }


    public Solution(Scanner sc, int n) {
        this.sc = sc;
        N = n;
    }

    private void print(String s) {
        System.out.println(s);
        if (err) {
            System.err.println(""out: "" + s);
        }
        System.out.flush();
    }

    private static String read(Scanner sc) {
        String s = sc.nextLine();
        if (err) {
            System.err.println(""in: "" + s);
        }
        return s;
    }

    public static int[] lineToInt(String line, String regex) {
        return Stream.",RicolaNouland
10404,"public class Solution {


    private static boolean err = false;
    private final Scanner sc;
    private final int N;

    public static void main(String[] args) {

        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        String s = read(in);
        int T = lineToInt(s, "" "")[0];

        for (int i = 1; i <= T; ++i) {
            int[] line = lineToInt(read(in), "" "");
            int N = line[0];
            new Solution(in, N).solve();
        }

    }


    private void solve() {
        int[] degrees = new int[N+1];
        int[] line = lineToInt(read(sc), "" "");
        degrees[line[0]] = line[1];

        for (int i = 1; i <= Math.min(8000, N); i++) {
            print(""T ""+i);
            line = lineToInt(read(sc), "" "");
            degrees[line[0]] = line[1];
        }

        int computed = 0;
        long total = 0;
        for (int i = 1; i <= N; i++) {
            if(degrees[i] != 0) computed ++;
            total += degrees[i];
        }

        double averageDegree = ((double) total) / computed;


        long estimation =  Math.round((computed + (N-computed)*averageDegree)/2);
        print(""E "" + estimation);
    }


    public Solution(Scanner sc, int n) {
        this.sc = sc;
        N = n;
    }

    private void print(String s) {
        System.out.println(s);
        if (err) {
            System.err.println(""out: "" + s);
        }
        System.out.flush();
    }

    private static String read(Scanner sc) {
        String s = sc.nextLine();
        if (err) {
            System.err.println(""in: "" + s);
        }
        return s;
    }

    public static int[] lineToInt(String line, String regex) {
        return Stream.",RicolaNouland
10405,"public class Solution {


    private static boolean err = false;
    private final Scanner sc;
    private final int N;

    public static void main(String[] args) {

        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        String s = read(in);
        int T = lineToInt(s, "" "")[0];

        for (int i = 1; i <= T; ++i) {
            int[] line = lineToInt(read(in), "" "");
            int N = line[0];
            new Solution(in, N).solve();
        }

    }


    private void solve() {
        int[] degrees = new int[N+1];
        int[] line = lineToInt(read(sc), "" "");
        degrees[line[0]] = line[1];

        for (int i = 1; i <= Math.min(8000, N); i++) {
            print(""T ""+i);
            line = lineToInt(read(sc), "" "");
            degrees[line[0]] = line[1];
        }

        int computed = 0;
        long total = 0;
        for (int i = 1; i <= N; i++) {
            if(degrees[i] != 0) computed ++;
            total += degrees[i];
        }

//        System.err.println(total);
//        System.err.println(computed);

//        total = 8000;
//        computed = 8000;

        double averageDegree = ((double) total) / computed;


//        System.err.println(Arrays.stream(degrees).mapToObj(Integer::toString).collect(Collectors.joining("" "")));

        long estimation =  Math.round((computed + (N-computed)*averageDegree)/2);
        print(""E "" + estimation);

//        String read = read(sc);
//        if(read.equals(""-1"")){
//            throw new RuntimeException(""wrong answer"");
//        }
    }


    public Solution(Scanner sc, int n) {
        this.sc = sc;
        N = n;
    }

    private void print(String s) {
        System.out.println(s);
        if (err) {
            System.err.println(""out: "" + s);
        }
        System.out.flush();
    }

    private static String read(Scanner sc) {
        String s = sc.nextLine();
        if (err) {
            System.err.println(""in: "" + s);
        }
        return s;
    }

    public static int[] lineToInt(String line, String regex) {
        return Stream.",RicolaNouland
10410,"public class Solution {


    private static boolean err = false;
    private final Scanner sc;
    private final int N;

    public static void main(String[] args) {

        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        String s = read(in);
        int T = lineToInt(s, "" "")[0];

        for (int i = 1; i <= T; ++i) {
            int[] line = lineToInt(read(in), "" "");
            int N = line[0];
            new Solution(in, N).solve();
        }

    }


    private void solve() {
        int[] degrees = new int[N+1];
        int[] line = lineToInt(read(sc), "" "");
        degrees[line[0]] = line[1];

        for (int i = 1; i <= Math.min(8000, N); i++) {
            print(""""+i);
            line = lineToInt(read(sc), "" "");
            degrees[line[0]] = line[1];
        }

        int computed = 0;
        long total = 0;
        for (int i = 1; i <= N; i++) {
            if(degrees[i] != 0) computed ++;
            total += degrees[i];
        }

        double averageDegree = ((double) computed) / total;

        long estimation =  Math.round((computed + (N-computed)*averageDegree)/2);
        print(""E "" + estimation);

//        String read = read(sc);
//        if(read.equals(""-1"")){
//            throw new RuntimeException(""wrong answer"");
//        }
    }


    public Solution(Scanner sc, int n) {
        this.sc = sc;
        N = n;
    }

    private void print(String s) {
        System.out.println(s);
        if (err) {
            System.err.println(""out: "" + s);
        }
        System.out.flush();
    }

    private static String read(Scanner sc) {
        String s = sc.nextLine();
        if (err) {
            System.err.println(""in: "" + s);
        }
        return s;
    }

    public static int[] lineToInt(String line, String regex) {
        return Stream.",RicolaNouland
10412,"public class Solution {


    private static Module abyss;

    public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int t = Integer.parseInt(in.nextLine());  // Scanner has functions to read ints, longs, strings, chars, etc.
        for (int i = 1; i <= t; ++i) {
            int N = Integer.parseInt(in.nextLine());
            int[] Fs = lineToInt(in.nextLine());
            int[] Ps = lineToInt(in.nextLine());

            createTree(Fs, Ps, N);


            long result = solve();

            System.out.println(String.format(""Case #%d: %s"", i, result));
        }
    }

    private static long solve(){
        Queue<Module> queue = new LinkedList<>();
        for (Module child : abyss.children) {
            queue.offer(child);
        }

        long total = 0;

        while(!queue.isEmpty()){
            TreeMap<Integer, Module> maxes = new TreeMap<>();
            Module module = queue.poll();
            fillMaxes(module, 0, maxes);
            Map.Entry<Integer, Module> min = maxes.firstEntry();
            initiate(min.getValue(), queue, null);
            total += Math.max(min.getKey(), module.fun);
        }
        return total;
    }

    private static void initiate(Module module, Queue<Module> queue, Module prev){
        if(module == abyss) return; //abyss
        for (Module child : module.children) {
            child.parent = abyss;
            if(child != prev) queue.add(child);
        }
        queue.remove(module);
        initiate(module.parent, queue, module);
    }

    private static void fillMaxes(Module root, int currentMax, Map<Integer, Module> maxes){
        if(root.children.isEmpty()){
            maxes.put(currentMax, root);
        }
        for (Module child : root.children) {
            fillMaxes(child, Math.max(currentMax, child.fun), maxes);
        }
    }

    private static Module createTree(int[] Fs, int[] Ps, int N){
        Module[] modules = new Module[N+1];
        abyss = new Module(0, null);
        modules[0] = abyss;

        for (int i = 1; i <= N; i++) {
            Module parent = modules[Ps[i-1]];
            modules[i] = new Module(Fs[i-1], parent);
            parent.children.add(modules[i]);
        }

        for (Module child : abyss.children) {
            trimTree(child);
        }

        return modules[0];
    }

    private static void trimTree(Module root){
        int size = root.children.size();
        if(size == 0) return;
        if(size == 1){
            Module onlyChild = root.children.get(0);
            root.fun = Math.max(root.fun, onlyChild.fun);
            root.children = onlyChild.children;
            for (Module child : root.children) {
                child.parent = root;
            }
            trimTree(root);
        }

        for (Module child : root.children) {
            trimTree(child);
        }
    }

    public static int[] lineToInt(String line, String regex) {
        return Stream.of(line.split(regex)).mapToInt(Integer::parseInt).toArray();
    }

    public static int[] lineToInt(String line) {
        return lineToInt(line, "" "");
    }

    public static Stream<String> binaryStrings(int n) {
        return LongStream.range(0, 1L << n).mapToObj(l -> getBinaryString(l, n));
    }

    public static String getBinaryString(long value, int size) {
        return Long.toBinaryString(1L << size | value).substring(1, size + 1);
    }

    private static class Module {
        List<Module> children = new ArrayList<>();
        Module parent;
        int fun;

        public Module(int fun, Module parent) {
            this.fun = fun;
            this.parent = ",RicolaNouland
10413,"public class Solution {


    private static Module abyss;
    private static long max;
    private static long[] Fs;
    private static int[] Ps;
    private static int N;

    public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int t = Integer.parseInt(in.nextLine());  // Scanner has functions to read ints, longs, strings, chars, etc.
        for (int i = 1; i <= t; ++i) {
            max = 0;
            N = Integer.parseInt(in.nextLine());
            Fs = lineToLong(in.nextLine());
            Ps = lineToInt(in.nextLine());

            long result = solve();

            System.out.println(String.format(""Case #%d: %s"", i, result));
        }
    }

    private static long solve(){
        Module[] modules = createTree();
        abyss= modules[0];
        List<Integer> initiators = new ArrayList<>();
        addInitiators(abyss, initiators);
        int[] indexes = initiators.stream().mapToInt(i -> i).toArray();
        testAllRecursive(0, indexes);
        return max;
    }

    private static void addInitiators(Module root, List<Integer> initiators){
        if(root.children.isEmpty()) initiators.add(root.index);
        else {
            for (Module child : root.children) {
                addInitiators(child, initiators);
            }
        }
    }

    public static void testAllRecursive(int k, int[] elements) {

            for(int i = k; i < elements.length; i++){
                swap(elements, i , k);
                testAllRecursive(k+1, elements);
                swap(elements, k , i);
            }
        if(k == elements.length -1) {
            test(elements);
        }
    }

    private static void test(int[] order){
        Module[] modules = createTree();

        long total = 0;
        for (int i : order) {
            total += initiate(modules[i], 0);
        }

        max = Math.max(total, max);
    }

    private static long initiate(Module module, long currentMax){
        if(module == abyss || module.triggered) return currentMax; //abyss
        module.triggered = true;
        return initiate(module.parent, Math.max(currentMax, module.fun));
    }

    private static Module[] createTree(){
        Module[] modules = new Module[N+1];
        abyss = new Module(0, null, 0);
        modules[0] = abyss;

        for (int i = 1; i <= N; i++) {
            Module parent = modules[Ps[i-1]];
            modules[i] = new Module(Fs[i-1], parent, i);
            parent.children.add(modules[i]);
        }

        return modules;
    }

    public static int[] lineToInt(String line, String regex) {
        return Stream.of(line.split(regex)).mapToInt(Integer::parseInt).toArray();
    }

    public static int[] lineToInt(String line) {
        return lineToInt(line, "" "");
    }
    public static long[] lineToLong(String line) {
        return Stream.of(line.split("" "")).mapToLong(Long::parseLong).toArray();
    }

    public static Stream<String> binaryStrings(int n) {
        return LongStream.range(0, 1L << n).mapToObj(l -> getBinaryString(l, n));
    }

    public static String getBinaryString(long value, int size) {
        return Long.toBinaryString(1L << size | value).substring(1, size + 1);
    }

    private static  void swap(int[] input, int a, int b) {
        int tmp = input[a];
        input[a] = input[b];
        input[b] = tmp;
    }


    private static class Module {
        List<Module> children = new ArrayList<>();
        Module parent;
        long fun;
        int index;
        boolean triggered = false;

        public Module(long fun, Module parent, int index) {
            this.parent = parent;
            this.fun = fun;
            this.index = ",RicolaNouland
10414,"public class Solution {


    private static Module abyss;
    private static long max;
    private static long[] Fs;
    private static int[] Ps;
    private static int N;

    public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int t = Integer.parseInt(in.nextLine());  // Scanner has functions to read ints, longs, strings, chars, etc.
        for (int i = 1; i <= t; ++i) {
            max = 0;
            N = Integer.parseInt(in.nextLine());
            Fs = lineToLong(in.nextLine());
            Ps = lineToInt(in.nextLine());

            long result = solve();

            System.out.println(String.format(""Case #%d: %s"", i, result));
        }
    }

    private static long solve(){
        Module[] modules = createTree();
        abyss= modules[0];
        List<Integer> initiators = new ArrayList<>();
        addInitiators(abyss, initiators);
        int[] indexes = initiators.stream().mapToInt(i -> i).toArray();
        testAllRecursive(0, indexes);
        return max;
    }

    private static void addInitiators(Module root, List<Integer> initiators){
        if(root.children.isEmpty()) initiators.add(root.index);
        else {
            for (Module child : root.children) {
                addInitiators(child, initiators);
            }
        }
    }

    public static void testAllRecursive(int k, int[] elements) {

            for(int i = k; i < elements.length; i++){
                swap(elements, i , k);
                testAllRecursive(k+1, elements);
                swap(elements, k , i);
            }
        if(k == elements.length -1) {
            test(elements);
        }
    }

    private static void test(int[] order){
        Module[] modules = createTree();

        int total = 0;
        for (int i : order) {
            total += initiate(modules[i], 0);
        }

        max = Math.max(total, max);
    }

    private static long initiate(Module module, long currentMax){
        if(module == abyss || module.triggered) return currentMax; //abyss
        module.triggered = true;
        return initiate(module.parent, Math.max(currentMax, module.fun));
    }

    private static Module[] createTree(){
        Module[] modules = new Module[N+1];
        abyss = new Module(0, null, 0);
        modules[0] = abyss;

        for (int i = 1; i <= N; i++) {
            Module parent = modules[Ps[i-1]];
            modules[i] = new Module(Fs[i-1], parent, i);
            parent.children.add(modules[i]);
        }

        return modules;
    }

    public static int[] lineToInt(String line, String regex) {
        return Stream.of(line.split(regex)).mapToInt(Integer::parseInt).toArray();
    }

    public static int[] lineToInt(String line) {
        return lineToInt(line, "" "");
    }
    public static long[] lineToLong(String line) {
        return Stream.of(line.split("" "")).mapToLong(Long::parseLong).toArray();
    }

    public static Stream<String> binaryStrings(int n) {
        return LongStream.range(0, 1L << n).mapToObj(l -> getBinaryString(l, n));
    }

    public static String getBinaryString(long value, int size) {
        return Long.toBinaryString(1L << size | value).substring(1, size + 1);
    }

    private static  void swap(int[] input, int a, int b) {
        int tmp = input[a];
        input[a] = input[b];
        input[b] = tmp;
    }


    private static class Module {
        List<Module> children = new ArrayList<>();
        Module parent;
        long fun;
        int index;
        boolean triggered = false;

        public Module(long fun, Module parent, int index) {
            this.parent = parent;
            this.fun = fun;
            this.index = ",RicolaNouland
10415,"public class Solution {


  private static Module abyss;
    private static long max;
    private static long[] Fs;
    private static int[] Ps;
    private static int N;

     public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int t = Integer.parseInt(in.nextLine());  // Scanner has functions to read ints, longs, strings, chars, etc.
        for (int i = 1; i <= t; ++i) {
            max = 0;
            N = Integer.parseInt(in.nextLine());
            Fs = lineToLong(in.nextLine());
            Ps = lineToInt(in.nextLine());

            long result = solve();

            System.out.println(String.format(""Case #%d: %s"", i, result));
        }
    }

    private static long solve(){
        Module[] modules = createTree();
        abyss= modules[0];
        List<Integer> initiators = new ArrayList<>();
        addInitiators(abyss, initiators);
        int[] indexes = initiators.stream().mapToInt(i -> i).toArray();
        testAllRecursive(indexes.length, indexes);
        return max;
    }

    private static void addInitiators(Module root, List<Integer> initiators){
        if(root.children.isEmpty()) initiators.add(root.index);
        else {
            for (Module child : root.children) {
                addInitiators(child, initiators);
            }
        }
    }

    public static void testAllRecursive(int n, int[] elements) {

        if(n == 1) {
           test(elements);
        } else {
            for(int i = 0; i < n-1; i++) {
                testAllRecursive(n - 1, elements);
                if(n % 2 == 0) {
                    swap(elements, i, n-1);
                } else {
                    swap(elements, 0, n-1);
                }
            }
            testAllRecursive(n - 1, elements);
        }
    }

    private static void test(int[] order){
        Module[] modules = createTree();

        int total = 0;
        for (int i : order) {
            total += initiate(modules[i], 0);
        }

        max = Math.max(total, max);
    }

     private static long initiate(Module module, long currentMax){
        if(module == abyss || module.triggered) return currentMax; //abyss
        module.triggered = true;
        return initiate(module.parent, Math.max(currentMax, module.fun));
    }

    private static Module[] createTree(){
        Module[] modules = new Module[N+1];
        abyss = new Module(0, null, 0);
        modules[0] = abyss;

        for (int i = 1; i <= N; i++) {
            Module parent = modules[Ps[i-1]];
            modules[i] = new Module(Fs[i-1], parent, i);
            parent.children.add(modules[i]);
        }

        return modules;
    }

    public static int[] lineToInt(String line, String regex) {
        return Stream.of(line.split(regex)).mapToInt(Integer::parseInt).toArray();
    }

    public static int[] lineToInt(String line) {
        return lineToInt(line, "" "");
    }
    public static long[] lineToLong(String line) {
        return Stream.of(line.split("" "")).mapToLong(Long::parseLong).toArray();
    }

    public static Stream<String> binaryStrings(int n) {
        return LongStream.range(0, 1L << n).mapToObj(l -> getBinaryString(l, n));
    }

    public static String getBinaryString(long value, int size) {
        return Long.toBinaryString(1L << size | value).substring(1, size + 1);
    }

    private static  void swap(int[] input, int a, int b) {
        int tmp = input[a];
        input[a] = input[b];
        input[b] = tmp;
    }


    private static class Module {
        List<Module> children = new ArrayList<>();
        Module parent;
        long fun;
        int index;
        boolean triggered = false;

        public Module(long fun, Module parent, int index) {
            this.parent = parent;
            this.fun = fun;
            this.index = ",RicolaNouland
10416,"public class Solution {


  private static Module abyss;
    private static long max;
    private static long[] Fs;
    private static int[] Ps;
    private static int N;

     public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int t = Integer.parseInt(in.nextLine());  // Scanner has functions to read ints, longs, strings, chars, etc.
        for (int i = 1; i <= t; ++i) {
            max = 0;
            N = Integer.parseInt(in.nextLine());
            Fs = lineToLong(in.nextLine());
            Ps = lineToInt(in.nextLine());

            long result = solve();

            System.out.println(String.format(""Case #%d: %s"", i, result));
        }
    }

    private static long solve(){
        Module[] modules = createTree();
        abyss= modules[0];
        List<Integer> initiators = new ArrayList<>();
        addInitiators(abyss, initiators);
        int[] indexes = initiators.stream().mapToInt(i -> i).toArray();
        testAllRecursive(indexes.length, indexes);
        return max;
    }

    private static void addInitiators(Module root, List<Integer> initiators){
        if(root.children.isEmpty()) initiators.add(root.index);
        else {
            for (Module child : root.children) {
                addInitiators(child, initiators);
            }
        }
    }

    public static void testAllRecursive(int n, int[] elements) {

        if(n == 1) {
           test(elements);
        } else {
            for(int i = 0; i < n-1; i++) {
                testAllRecursive(n - 1, elements);
                if(n % 2 == 0) {
                    swap(elements, i, n-1);
                } else {
                    swap(elements, 0, n-1);
                }
            }
            testAllRecursive(n - 1, elements);
        }
    }

    private static void test(int[] order){
        Module[] modules = createTree();

        int total = 0;
        for (int i : order) {
            total += initiate(modules[i], 0);
        }

        max = Math.max(total, max);
    }

    private static long initiate(Module module, long currentMax){
        if(module == abyss || module == null) return currentMax; //abyss
        for (Module child : module.children) {
            child.parent = null;
        }
        return initiate(module.parent, Math.max(currentMax, module.fun));
    }

    private static Module[] createTree(){
        Module[] modules = new Module[N+1];
        abyss = new Module(0, null, 0);
        modules[0] = abyss;

        for (int i = 1; i <= N; i++) {
            Module parent = modules[Ps[i-1]];
            modules[i] = new Module(Fs[i-1], parent, i);
            parent.children.add(modules[i]);
        }

        return modules;
    }

    public static int[] lineToInt(String line, String regex) {
        return Stream.of(line.split(regex)).mapToInt(Integer::parseInt).toArray();
    }

    public static int[] lineToInt(String line) {
        return lineToInt(line, "" "");
    }
    public static long[] lineToLong(String line) {
        return Stream.of(line.split("" "")).mapToLong(Long::parseLong).toArray();
    }

    public static Stream<String> binaryStrings(int n) {
        return LongStream.range(0, 1L << n).mapToObj(l -> getBinaryString(l, n));
    }

    public static String getBinaryString(long value, int size) {
        return Long.toBinaryString(1L << size | value).substring(1, size + 1);
    }

    private static  void swap(int[] input, int a, int b) {
        int tmp = input[a];
        input[a] = input[b];
        input[b] = tmp;
    }


    private static class Module {
        List<Module> children = new ArrayList<>();
        Module parent;
        long fun;
        int index;

        public Module(long fun, Module parent, int index) {
            this.parent = parent;
            this.fun = fun;
            this.index = ",RicolaNouland
10417,"public class Solution {


  private static Module abyss;
    private static long max;
    private static long[] Fs;
    private static int[] Ps;
    private static int N;

     public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int t = Integer.parseInt(in.nextLine());  // Scanner has functions to read ints, longs, strings, chars, etc.
        for (int i = 1; i <= t; ++i) {
            max = 0;
            N = Integer.parseInt(in.nextLine());
            Fs = lineToLong(in.nextLine());
            Ps = lineToInt(in.nextLine());

            long result = solve();

            System.out.println(String.format(""Case #%d: %s"", i, result));
        }
    }

    private static long solve(){
        Module[] modules = createTree();
        abyss= modules[0];
        List<Integer> initiators = new ArrayList<>();
        addInitiators(abyss, initiators);
        int[] indexes = initiators.stream().mapToInt(i -> i).toArray();
        testAllRecursive(indexes.length, indexes);
        return max;
    }

    private static void addInitiators(Module root, List<Integer> initiators){
        if(root.children.isEmpty()) initiators.add(root.index);
        else {
            for (Module child : root.children) {
                addInitiators(child, initiators);
            }
        }
    }

    public static void testAllRecursive(int n, int[] elements) {

        if(n == 1) {
           test(elements);
        } else {
            for(int i = 0; i < n-1; i++) {
                testAllRecursive(n - 1, elements);
                if(n % 2 == 0) {
                    swap(elements, i, n-1);
                } else {
                    swap(elements, 0, n-1);
                }
            }
            testAllRecursive(n - 1, elements);
        }
    }

    private static void test(int[] order){
        Module[] modules = createTree();

        int total = 0;
        for (int i : order) {
            total += initiate(modules[i], 0);
        }

        max = Math.max(total, max);
    }

    private static long initiate(Module module, long currentMax){
        if(module == abyss) return currentMax; //abyss
        for (Module child : module.children) {
            child.parent = abyss;
        }
        return initiate(module.parent, Math.max(currentMax, module.fun));
    }

    private static Module[] createTree(){
        Module[] modules = new Module[N+1];
        abyss = new Module(0, null, 0);
        modules[0] = abyss;

        for (int i = 1; i <= N; i++) {
            Module parent = modules[Ps[i-1]];
            modules[i] = new Module(Fs[i-1], parent, i);
            parent.children.add(modules[i]);
        }

        return modules;
    }

    public static int[] lineToInt(String line, String regex) {
        return Stream.of(line.split(regex)).mapToInt(Integer::parseInt).toArray();
    }

    public static int[] lineToInt(String line) {
        return lineToInt(line, "" "");
    }
    public static long[] lineToLong(String line) {
        return Stream.of(line.split("" "")).mapToLong(Long::parseLong).toArray();
    }

    public static Stream<String> binaryStrings(int n) {
        return LongStream.range(0, 1L << n).mapToObj(l -> getBinaryString(l, n));
    }

    public static String getBinaryString(long value, int size) {
        return Long.toBinaryString(1L << size | value).substring(1, size + 1);
    }

    private static  void swap(int[] input, int a, int b) {
        int tmp = input[a];
        input[a] = input[b];
        input[b] = tmp;
    }


    private static class Module {
        List<Module> children = new ArrayList<>();
        Module parent;
        long fun;
        int index;

        public Module(long fun, Module parent, int index) {
            this.parent = parent;
            this.fun = fun;
            this.index = ",RicolaNouland
10418,"public class Solution {


    private static Module abyss;
    private static long max;
    private static int[] Fs;
    private static int[] Ps;
    private static int N;

     public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int t = Integer.parseInt(in.nextLine());  // Scanner has functions to read ints, longs, strings, chars, etc.
        for (int i = 1; i <= t; ++i) {
            max = 0;
            N = Integer.parseInt(in.nextLine());
            Fs = lineToLong(in.nextLine());
            Ps = lineToInt(in.nextLine());

            long result = solve();

            System.out.println(String.format(""Case #%d: %s"", i, result));
        }
    }

    private static long solve(){
        Module[] modules = createTree();
        abyss= modules[0];
        List<Integer> initiators = new ArrayList<>();
        addInitiators(abyss, initiators);
        int[] indexes = initiators.stream().mapToInt(i -> i).toArray();
        testAllRecursive(indexes.length, indexes);
        return max;
    }

    private static void addInitiators(Module root, List<Integer> initiators){
        if(root.children.isEmpty()) initiators.add(root.index);
        else {
            for (Module child : root.children) {
                addInitiators(child, initiators);
            }
        }
    }

    public static void testAllRecursive(int n, int[] elements) {

        if(n == 1) {
           test(elements);
        } else {
            for(int i = 0; i < n-1; i++) {
                testAllRecursive(n - 1, elements);
                if(n % 2 == 0) {
                    swap(elements, i, n-1);
                } else {
                    swap(elements, 0, n-1);
                }
            }
            testAllRecursive(n - 1, elements);
        }
    }

    private static void test(int[] order){
        Module[] modules = createTree();

        int total = 0;
        for (int i : order) {
            total += initiate(modules[i], 0);
        }

        max = Math.max(total, max);
    }

    private static long initiate(Module module, long currentMax){
        if(module == abyss) return currentMax; //abyss
        for (Module child : module.children) {
            child.parent = abyss;
        }
        return initiate(module.parent, Math.max(currentMax, module.fun));
    }

    private static Module[] createTree(){
        Module[] modules = new Module[N+1];
        abyss = new Module(0, null, 0);
        modules[0] = abyss;

        for (int i = 1; i <= N; i++) {
            Module parent = modules[Ps[i-1]];
            modules[i] = new Module(Fs[i-1], parent, i);
            parent.children.add(modules[i]);
        }

        return modules;
    }

    public static int[] lineToInt(String line, String regex) {
        return Stream.of(line.split(regex)).mapToInt(Integer::parseInt).toArray();
    }

    public static int[] lineToInt(String line) {
        return lineToInt(line, "" "");
    }
    public static long[] lineToLong(String line) {
        return Stream.of(line.split("" "")).mapToLong(Long::parseLong).toArray();
    }

    public static Stream<String> binaryStrings(int n) {
        return LongStream.range(0, 1L << n).mapToObj(l -> getBinaryString(l, n));
    }

    public static String getBinaryString(long value, int size) {
        return Long.toBinaryString(1L << size | value).substring(1, size + 1);
    }

    private static  void swap(int[] input, int a, int b) {
        int tmp = input[a];
        input[a] = input[b];
        input[b] = tmp;
    }


    private static class Module {
        List<Module> children = new ArrayList<>();
        Module parent;
        long fun;
        int index;

        public Module(long fun, Module parent, int index) {
            this.parent = parent;
            this.fun = fun;
            this.index = ",RicolaNouland
10419,"public class Solution {


    private static Module abyss;
    private static long max;
    private static int[] Fs;
    private static int[] Ps;
    private static int N;

    public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int t = Integer.parseInt(in.nextLine());  // Scanner has functions to read ints, longs, strings, chars, etc.
        for (int i = 1; i <= t; ++i) {
            max = 0;
            N = Integer.parseInt(in.nextLine());
            Fs = lineToInt(in.nextLine());
            Ps = lineToInt(in.nextLine());

            long result = solve();

            System.out.println(String.format(""Case #%d: %s"", i, result));
        }
    }

    private static long solve(){
        Module[] modules = createTree();
        abyss= modules[0];
        List<Integer> initiators = new ArrayList<>();
        addInitiators(abyss, initiators);
        int[] indexes = initiators.stream().mapToInt(i -> i).toArray();
        testAllRecursive(indexes.length, indexes);
        return max;
    }

    private static void addInitiators(Module root, List<Integer> initiators){
        if(root.children.isEmpty()) initiators.add(root.index);
        else {
            for (Module child : root.children) {
                addInitiators(child, initiators);
            }
        }
    }

    public static void testAllRecursive(int n, int[] elements) {

        if(n == 1) {
           test(elements);
        } else {
            for(int i = 0; i < n-1; i++) {
                testAllRecursive(n - 1, elements);
                if(n % 2 == 0) {
                    swap(elements, i, n-1);
                } else {
                    swap(elements, 0, n-1);
                }
            }
            testAllRecursive(n - 1, elements);
        }
    }

    private static void test(int[] order){
        Module[] modules = createTree();

        int total = 0;
        for (int i : order) {
            total += initiate(modules[i], 0);
        }

        max = Math.max(total, max);
    }

    private static int initiate(Module module, int currentMax){
        if(module == abyss) return currentMax; //abyss
        for (Module child : module.children) {
            child.parent = abyss;
        }
        return initiate(module.parent, Math.max(currentMax, module.fun));
    }

    private static Module[] createTree(){
        Module[] modules = new Module[N+1];
        abyss = new Module(0, null, 0);
        modules[0] = abyss;

        for (int i = 1; i <= N; i++) {
            Module parent = modules[Ps[i-1]];
            modules[i] = new Module(Fs[i-1], parent, i);
            parent.children.add(modules[i]);
        }

        return modules;
    }

    public static int[] lineToInt(String line, String regex) {
        return Stream.of(line.split(regex)).mapToInt(Integer::parseInt).toArray();
    }

    public static int[] lineToInt(String line) {
        return lineToInt(line, "" "");
    }

    public static Stream<String> binaryStrings(int n) {
        return LongStream.range(0, 1L << n).mapToObj(l -> getBinaryString(l, n));
    }

    public static String getBinaryString(long value, int size) {
        return Long.toBinaryString(1L << size | value).substring(1, size + 1);
    }

    private static  void swap(int[] input, int a, int b) {
        int tmp = input[a];
        input[a] = input[b];
        input[b] = tmp;
    }


    private static class Module {
        List<Module> children = new ArrayList<>();
        Module parent;
        int fun;
        int index;

        public Module(int fun, Module parent, int index) {
            this.parent = parent;
            this.fun = fun;
            this.index = ",RicolaNouland
10420,"public class Solution {


    private static Module abyss;

    public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int t = Integer.parseInt(in.nextLine());  // Scanner has functions to read ints, longs, strings, chars, etc.
        for (int i = 1; i <= t; ++i) {
            int N = Integer.parseInt(in.nextLine());
            int[] Fs = lineToInt(in.nextLine());
            int[] Ps = lineToInt(in.nextLine());

            abyss = createTree(Fs, Ps, N);


            long result = solve();

            System.out.println(String.format(""Case #%d: %s"", i, result));
        }
    }

    private static long solve(){
        Queue<Module> queue = new LinkedList<>();
        for (Module child : abyss.children) {
            queue.offer(child);
        }

        long total = 0;

        while(!queue.isEmpty()){
            TreeMap<Integer, Module> maxes = new TreeMap<>();
            Module module = queue.poll();
            fillMaxes(module, 0, maxes);
            Map.Entry<Integer, Module> min = maxes.firstEntry();
            initiate(min.getValue(), queue, null);
            total += Math.max(min.getKey(), module.fun);
        }
        return total;
    }

    private static void initiate(Module module, Queue<Module> queue, Module prev){
        if(module == abyss) return; //abyss
        for (Module child : module.children) {
            child.parent = abyss;
            if(child != prev) queue.add(child);
        }
        queue.remove(module);
        initiate(module.parent, queue, module);
    }

    private static void fillMaxes(Module root, int currentMax, Map<Integer, Module> maxes){
        if(root.children.isEmpty()){
            maxes.put(currentMax, root);
        }
        for (Module child : root.children) {
            fillMaxes(child, Math.max(currentMax, child.fun), maxes);
        }
    }

    private static Module createTree(int[] Fs, int[] Ps, int N){
        Module[] modules = new Module[N+1];
        modules[0] = new Module(0, null);

        for (int i = 1; i <= N; i++) {
            Module parent = modules[Ps[i-1]];
            modules[i] = new Module(Fs[i-1], parent);
            parent.children.add(modules[i]);
        }

        return modules[0];
    }

    public static int[] lineToInt(String line, String regex) {
        return Stream.of(line.split(regex)).mapToInt(Integer::parseInt).toArray();
    }

    public static int[] lineToInt(String line) {
        return lineToInt(line, "" "");
    }

    public static Stream<String> binaryStrings(int n) {
        return LongStream.range(0, 1L << n).mapToObj(l -> getBinaryString(l, n));
    }

    public static String getBinaryString(long value, int size) {
        return Long.toBinaryString(1L << size | value).substring(1, size + 1);
    }

    private static class Module {
        List<Module> children = new ArrayList<>();
        Module parent;
        int fun;

        public Module(int fun, Module parent) {
            this.fun = fun;
            this.parent = ",RicolaNouland
10421,"public class Solution {


    private static Module abyss;

    public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int t = Integer.parseInt(in.nextLine());  // Scanner has functions to read ints, longs, strings, chars, etc.
        for (int i = 1; i <= t; ++i) {
            int N = Integer.parseInt(in.nextLine());
            int[] Fs = lineToInt(in.nextLine());
            int[] Ps = lineToInt(in.nextLine());

            abyss = createTree(Fs, Ps, N);


            long result = solve();

            System.out.println(String.format(""Case #%d: %s"", i, result));
        }
    }

    private static long solve(){
        Queue<Module> queue = new LinkedList<>();
        for (Module child : abyss.children) {
            queue.offer(child);
        }

        long total = 0;

        while(!queue.isEmpty()){
            TreeMap<Integer, Module> maxes = new TreeMap<>();
            Module module = queue.poll();
            fillMaxes(module, 0, maxes);
            Map.Entry<Integer, Module> min = maxes.firstEntry();
            initiate(min.getValue(), queue, null);
            total += Math.max(min.getKey(), module.fun);
        }
        return total;
    }

    private static void initiate(Module module, Queue<Module> queue, Module prev){
        if(module == abyss) return; //abyss
        for (Module child : module.children) {
            child.parent = abyss;
            if(child != prev) queue.add(child);
        }
        module.fun = 0;
        initiate(module.parent, queue, module);
    }

    private static void fillMaxes(Module root, int currentMax, Map<Integer, Module> maxes){
        if(root.children.isEmpty()){
            maxes.put(currentMax, root);
        }
        for (Module child : root.children) {
            fillMaxes(child, Math.max(currentMax, child.fun), maxes);
        }
    }

    private static Module createTree(int[] Fs, int[] Ps, int N){
        Module[] modules = new Module[N+1];
        modules[0] = new Module(0, null);

        for (int i = 1; i <= N; i++) {
            Module parent = modules[Ps[i-1]];
            modules[i] = new Module(Fs[i-1], parent);
            parent.children.add(modules[i]);
        }

        return modules[0];
    }

    public static int[] lineToInt(String line, String regex) {
        return Stream.of(line.split(regex)).mapToInt(Integer::parseInt).toArray();
    }

    public static int[] lineToInt(String line) {
        return lineToInt(line, "" "");
    }

    public static Stream<String> binaryStrings(int n) {
        return LongStream.range(0, 1L << n).mapToObj(l -> getBinaryString(l, n));
    }

    public static String getBinaryString(long value, int size) {
        return Long.toBinaryString(1L << size | value).substring(1, size + 1);
    }

    private static class Module {
        List<Module> children = new ArrayList<>();
        Module parent;
        int fun;

        public Module(int fun, Module parent) {
            this.fun = fun;
            this.parent = ",RicolaNouland
10422,"public class Solution {


    private static Module abyss;

    public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int t = Integer.parseInt(in.nextLine());  // Scanner has functions to read ints, longs, strings, chars, etc.
        for (int i = 1; i <= t; ++i) {
            int N = Integer.parseInt(in.nextLine());
            int[] Fs = lineToInt(in.nextLine());
            int[] Ps = lineToInt(in.nextLine());

            abyss = createTree(Fs, Ps, N);


            long result = solve();

            System.out.println(String.format(""Case #%d: %s"", i, result));
        }
    }

    private static long solve(){
        Queue<Module> queue = new LinkedList<>();
        for (Module child : abyss.children) {
            queue.offer(child);
        }

        long total = 0;

        while(!queue.isEmpty()){
            TreeMap<Integer, Module> maxes = new TreeMap<>();
            Module module = queue.poll();
            fillMaxes(module, 0, maxes);
            Map.Entry<Integer, Module> min = maxes.firstEntry();
            initiate(min.getValue(), queue, null);
            total += Math.max(min.getKey(), module.fun);
        }
        return total;
    }

    private static void initiate(Module module, Queue<Module> queue, Module prev){
        if(module == abyss) return; //abyss
        for (Module child : module.children) {
            child.parent = abyss;
            child.fun = 0;
            if(child != prev) queue.add(child);
        }
        initiate(module.parent, queue, module);
    }

    private static void fillMaxes(Module root, int currentMax, Map<Integer, Module> maxes){
        if(root.children.isEmpty()){
            maxes.put(currentMax, root);
        }
        for (Module child : root.children) {
            fillMaxes(child, Math.max(currentMax, child.fun), maxes);
        }
    }

    private static Module createTree(int[] Fs, int[] Ps, int N){
        Module[] modules = new Module[N+1];
        modules[0] = new Module(0, null);

        for (int i = 1; i <= N; i++) {
            Module parent = modules[Ps[i-1]];
            modules[i] = new Module(Fs[i-1], parent);
            parent.children.add(modules[i]);
        }

        return modules[0];
    }

    public static int[] lineToInt(String line, String regex) {
        return Stream.of(line.split(regex)).mapToInt(Integer::parseInt).toArray();
    }

    public static int[] lineToInt(String line) {
        return lineToInt(line, "" "");
    }

    public static Stream<String> binaryStrings(int n) {
        return LongStream.range(0, 1L << n).mapToObj(l -> getBinaryString(l, n));
    }

    public static String getBinaryString(long value, int size) {
        return Long.toBinaryString(1L << size | value).substring(1, size + 1);
    }

    private static class Module {
        List<Module> children = new ArrayList<>();
        Module parent;
        int fun;

        public Module(int fun, Module parent) {
            this.fun = fun;
            this.parent = ",RicolaNouland
10423,"public class Solution {


    private static Module abyss;

    public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int t = Integer.parseInt(in.nextLine());  // Scanner has functions to read ints, longs, strings, chars, etc.
        for (int i = 1; i <= t; ++i) {
            int N = Integer.parseInt(in.nextLine());
            int[] Fs = lineToInt(in.nextLine());
            int[] Ps = lineToInt(in.nextLine());

            abyss = createTree(Fs, Ps, N);


            long result = solve();

            System.out.println(String.format(""Case #%d: %s"", i, result));
        }
    }

    private static long solve(){
        Queue<Module> queue = new LinkedList<>();
        for (Module child : abyss.children) {
            queue.offer(child);
        }

        long total = 0;

        while(!queue.isEmpty()){
            TreeMap<Integer, Module> maxes = new TreeMap<>();
            Module module = queue.poll();
            fillMaxes(module, 0, maxes);
            Map.Entry<Integer, Module> min = maxes.firstEntry();
            initiate(min.getValue(), queue, null);
            total += Math.max(min.getKey(), module.fun);
        }
        return total;
    }

    private static void initiate(Module module, Queue<Module> queue, Module prev){
        if(module == abyss) return; //abyss
        for (Module child : module.children) {
            child.parent = abyss;
            if(child != prev) queue.add(child);
        }
        initiate(module.parent, queue, module);
    }

    private static void fillMaxes(Module root, int currentMax, Map<Integer, Module> maxes){
        if(root.children.isEmpty()){
            maxes.put(currentMax, root);
        }
        for (Module child : root.children) {
            fillMaxes(child, Math.max(currentMax, child.fun), maxes);
        }
    }

    private static Module createTree(int[] Fs, int[] Ps, int N){
        Module[] modules = new Module[N+1];
        modules[0] = new Module(0, null);

        for (int i = 1; i <= N; i++) {
            Module parent = modules[Ps[i-1]];
            modules[i] = new Module(Fs[i-1], parent);
            parent.children.add(modules[i]);
        }

        return modules[0];
    }

    public static int[] lineToInt(String line, String regex) {
        return Stream.of(line.split(regex)).mapToInt(Integer::parseInt).toArray();
    }

    public static int[] lineToInt(String line) {
        return lineToInt(line, "" "");
    }

    public static Stream<String> binaryStrings(int n) {
        return LongStream.range(0, 1L << n).mapToObj(l -> getBinaryString(l, n));
    }

    public static String getBinaryString(long value, int size) {
        return Long.toBinaryString(1L << size | value).substring(1, size + 1);
    }

    private static class Module {
        List<Module> children = new ArrayList<>();
        Module parent;
        int fun;

        public Module(int fun, Module parent) {
            this.fun = fun;
            this.parent = ",RicolaNouland
10424,"public class Solution {



    public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int t = Integer.parseInt(in.nextLine());  // Scanner has functions to read ints, longs, strings, chars, etc.
        for (int i = 1; i <= t; ++i) {
            in.nextLine();
            int[] dice = lineToInt(in.nextLine());

            int result =  solve(dice);

            System.out.println(String.format(""Case #%d: %s"", i, result));
        }
    }

    private static int solve(int[] dice){
        Arrays.sort(dice);

        int straight = 0;
        for (int die : dice) {
            if(die >= straight+1){
                straight++;
            }
        }

        return straight;
    }

    public static int[] lineToInt(String line, String regex) {
        return Stream.of(line.split(regex)).mapToInt(Integer::parseInt).toArray();
    }

    public static int[] lineToInt(String line) {
        return lineToInt(line, "" "");
    }

    public static Stream<String> binaryStrings(int n) {
        return LongStream.range(0, 1L << n).mapToObj(l -> getBinaryString(l, n));
    }

    public static String getBinaryString(long value, int size) {
        return Long.",RicolaNouland
10425,"public class Solution {



    public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int t = Integer.parseInt(in.nextLine());  // Scanner has functions to read ints, longs, strings, chars, etc.
        for (int i = 1; i <= t; ++i) {
            int[][] printers = new int [3][];
            for (int printer = 0; printer < 3; printer++) {
                printers[printer] = lineToInt(in.nextLine());
            }

            String result = solve(printers);

            System.out.println(String.format(""Case #%d: %s"", i, result));
        }
    }

    private static String solve( int[][] printers){
        int[] minimums = new int[4];
        for (int color = 0; color < 4; color++) {
            int min = Integer.MAX_VALUE;
            for (int printer = 0; printer < 3; printer++) {
                min = Math.min(min, printers[printer][color]);
            }
            minimums[color] = min;
        }

        int remaining = 1_000_000;
        int[] selected = new int[4];
        for (int i = 0; i < 4; i++) {
            selected[i] = Math.min(remaining, minimums[i]);
            remaining = remaining - selected[i];
        }

        if(remaining > 0){
            return ""IMPOSSIBLE"";
        }

        return Arrays.stream(selected).mapToObj(Integer::toString).collect(Collectors.joining("" ""));
    }

    public static int[] lineToInt(String line, String regex) {
        return Stream.of(line.split(regex)).mapToInt(Integer::parseInt).toArray();
    }

    public static int[] lineToInt(String line) {
        return lineToInt(line, "" "");
    }

    public static Stream<String> binaryStrings(int n) {
        return LongStream.range(0, 1L << n).mapToObj(l -> getBinaryString(l, n));
    }

    public static String getBinaryString(long value, int size) {
        return Long.",RicolaNouland
10426,"public class Solution {



    public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int t = Integer.parseInt(in.nextLine());  // Scanner has functions to read ints, longs, strings, chars, etc.
        for (int i = 1; i <= t; ++i) {
            int[] line = lineToInt(in.nextLine());


            String result = solve(line[0], line[1]);

            System.out.println(String.format(""Case #%d:
%s"", i, result));
        }
    }

    private static String solve(int R, int C){
        StringBuilder sb = new StringBuilder();
        sb.append("".."");
        sb.append(line(C-1));
        sb.append("".."");
        sb.append(cells(C-1));

        for (int i = 0; i < R-1; i++) {
            sb.append(line(C));
            sb.append((cells(C)));
        }
        sb.append(line(C));

        return sb.toString();
    }

    private static CharSequence line (int C){
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < C; i++) {
            sb.append('+');
            sb.append('-');
        }
        sb.append('+');
        sb.append('
');
        return sb;
    }

    private static CharSequence cells (int C){
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < C; i++) {
            sb.append('|');
            sb.append('.');
        }
        sb.append('|');
        sb.append('
');
        return sb;
    }

    public static int[] lineToInt(String line, String regex) {
        return Stream.of(line.split(regex)).mapToInt(Integer::parseInt).toArray();
    }

    public static int[] lineToInt(String line) {
        return lineToInt(line, "" "");
    }

    public static Stream<String> binaryStrings(int n) {
        return LongStream.range(0, 1L << n).mapToObj(l -> getBinaryString(l, n));
    }",RicolaNouland
10427,"public class Solution {


    private static boolean err = false;
    private final Scanner sc;
    private final int N;
    private final int K;
    private Random rand = new Random();

    public static void main(String[] args) {

        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        String s = read(in);
        int T = lineToInt(s, "" "")[0];

        for (int i = 1; i <= T; ++i) {
            int[] line = lineToInt(read(in), "" "");
            int N = line[0];
            int K = line[1];
            new Solution(in, N, K).solve();
        }

    }


    private void solve() {

        int[] line = lineToInt(read(sc), "" "");
        if(N <= K*1.2){
            double estimate = getEstimate();
            print(""E "" + Math.round(estimate*N/2));
            return;
        }

        int tries = 3;
        double[] averages = new double[tries];
        for (int i = 0; i < tries; i++) {
            averages[i] = getEstimate(K/(2*tries));
        }
        Arrays.sort(averages);



//        System.err.println(countCases);
            double estimate = averages[tries/2];
            print(""E "" + Math.round(estimate*N/2));
    }

    private double getEstimate(int k) {
        int[] line;
        long total = 0;
        for (int i = 1; i <= k; i++) {
            print(""T "" + (rand.nextInt(N) + 1));
            line = lineToInt(read(sc), "" "");
            int idv = line[0];
            int dv = line[1];
            print(""W"");
            line = lineToInt(read(sc), "" "");
            int idu = line[0];
            int du = line[1];


            if(du < dv || (du == dv && idu < idv)){
                total += dv*2;
            }

        }
        return ((double)total)/k;
    }

    private double getEstimate(){
        int[] degrees = new int[N+1];
        for (int i = 1; i <= K; i++) {
            print(""T ""+ i);
            int[] line = lineToInt(read(sc), "" "");
            degrees[line[0]] = line[1];
        }
        int computed = 0;
        long total = 0;
        for (int i = 1; i <= N; i++) {
            if(degrees[i] != 0) computed ++;
            total += degrees[i];
        }
        double averageDegree = ((double) total) / computed;
        return averageDegree;
    }


    public Solution(Scanner sc, int n, int k) {
        this.sc = sc;
        N = n;
        K = k;
    }

    private void print(String s) {
        System.out.println(s);
        if (err) {
            System.err.println(""out: "" + s);
        }
        System.out.flush();
    }

    private static String read(Scanner sc) {
        String s = sc.nextLine();
        if (err) {
            System.err.println(""in: "" + s);
        }
        return s;
    }

    public static int[] lineToInt(String line, String regex) {
        return Stream.",RicolaNouland
13827,"public class Solution{
  public static void main(String[] args){
  Scanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
  int t = input.nextInt();
  for(int i = 1; i <= t; ++i){
    int t1 = input.nextInt();
    int[] arrFun = new int[t1];
    for (int k = 0; k < t1; ++k){
      int fun = input.nextInt();
      arrFun[k] = fun;
    }
    
    int[] arrPos = new int[t1];
    for (int k = 0; k < t1; ++k){
      int pos = input.nextInt();
      arrPos[k] = pos;
    }

    //Arrays.sort(arr);
    System.out.println(""Case #"" + i + "": "" + maxFun(t1, arrFun, arrPos));
  }
}

public static int maxFun(int N, int[] arrFun, int[] arrPos) {
  int[] indegree= new int[N+1];
  int[] adj = new int[N+1];

  for(int i=0; i < N; i++) {
    indegree[arrPos[i]]++;
    adj[i] = arrPos[i];
  }

  Queue<Integer> q = new LinkedList<>();  
  for (int i=0; i <= N; i++) {
    if (indegree[i]==0) {
      ((LinkedList<Integer>) q).push(i);
    }
  }

  Integer[] q_arr=new Integer[q.size()];
  q_arr=q.toArray(q_arr);

  ArrayList<Integer[]> res = new ArrayList<Integer[]>(); 
  getAllRecursive(q.size(), q_arr, res);

  int maxTotalFun = 0;
  for(int p = 0; p < res.size(); p++) {
     Integer[] i_arr = res.get(p);

     Queue<Integer> q_ = new LinkedList<>(Arrays.asList(i_arr));

    int totalFun = 0;
    boolean[] visited = new boolean[N];
    while(!q_.isEmpty()) {
      int cur = q_.remove();
      //maxFun = 0;    
      int maxFun = getMaxFun(arrFun, cur-1, adj, arrPos, visited);
      totalFun += maxFun;
    }

    maxTotalFun = Math.max(totalFun, maxTotalFun);
  }
  return maxTotalFun;
}

//static ArrayList<Integer[]> res = new ArrayList<Integer[]>(); 
//static int maxFun=0;
public static int getMaxFun(int[] arrFun, int cur, int[] adj, int[] arrPos, boolean[] visited)
{
    if(cur < 0) return 0;
    int maxFun = 0;
    int curFun = arrFun[cur];
    maxFun = Math.max(curFun, maxFun);
    visited[cur] = true;
    if(cur>=0) 
    {
      int child = adj[cur]-1; 
      if(child>=0 && !visited[child] ) {
        int maxFun2 = getMaxFun(arrFun, child, adj, arrPos, visited);
        maxFun = Math.max(maxFun, maxFun2);
      }
    }
    return maxFun;
}

public static void getAllRecursive(
  int n, Integer[] elements, ArrayList<Integer[]> res) {
    if(n == 1) {
      Integer[] arr = new Integer[elements.length];
      for (int o = 0; o < arr.length; o++){
        arr[o] = elements[o];
      }
      res.add(arr);
    } else {
        for(int i = 0; i < n-1; i++) {
          getAllRecursive(n - 1, elements, res);
            if(n % 2 == 0) {
                swap(elements, i, n-1);
            } else {
                swap(elements, 0, n-1);
            }
        }
        getAllRecursive(n - 1, elements, res);
    }
}

static void swap(Integer[] input, int a, int b) {
  int tmp = input[a];
  input[a] = input[b];
  input[b] = ",hhuang8
13828,"public class Solution{
  public static void main(String[] args){
  Scanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
  int t = input.nextInt();
  for(int i = 1; i <= t; ++i){
    int t1 = input.nextInt();
    int[] arr = new int[t1];
    for (int k = 0; k < t1; ++k){
      int dice = input.nextInt();
      arr[k] = dice;
    }
    Arrays.sort(arr);
    System.out.println(""Case #"" + i + "": "" + count(arr));
  }
}
  
  public static int count(int[] array){
    int max = 0;
    int b = 1;
    //for (int b = 1; b < 2; b++)
    {
      int count = 0;
      for (int p = 0; p < array.length; p++){
        if (array[p] >= p + b){
          count++;
        } else {
             while (p+1 < array.length && array[p+1] == array[p]){
                p++;
                b--;
            }
        }
      }
      max = Math.max(count, max);
      if (max == array.",hhuang8
13829,"public class Solution{
  public static void main(String[] args){
  Scanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
  int t = input.nextInt();
  for(int i = 1; i <= t; ++i){
    int t1 = input.nextInt();
    int[] arr = new int[t1];
    for (int k = 0; k < t1; ++k){
      int dice = input.nextInt();
      arr[k] = dice;
    }
    Arrays.sort(arr);
    System.out.println(""Case #"" + i + "": "" + count(arr));
  }
}
  
  public static int count(int[] array){
    int max = 0;
    for (int b = -1; b < 0; b++){
      int count = 0;
      for (int p = 0; p < array.length; p++){
        if (array[p] >= p + b){
          count++;
        } else {
             while (p+1 < array.length && array[p+1] == array[p]){
                p++;
                b--;
            }
        }
      }
      max = Math.max(count, max);
      if (max == array.",hhuang8
13830,"public class Solution{
  public static void main(String[] args){
  Scanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
  int t = input.nextInt();
  for(int i = 1; i <= t; ++i){
    int t1 = input.nextInt();
    int[] arr = new int[t1];
    for (int k = 0; k < t1; ++k){
      int dice = input.nextInt();
      arr[k] = dice;
    }
    Arrays.sort(arr);
    System.out.println(""Case #"" + i + "": "" + count(arr));
  }
}
  
  public static int count(int[] array){
    int max = 0;
    for (int b = 0; b < 1; b++){
      int count = 0;
      for (int p = 0; p < array.length; p++){
        if (array[p] >= p + b){
          count++;
        } else {
             while (p+1 < array.length && array[p+1] == array[p]){
                p++;
                b--;
            }
        }
      }
      max = Math.max(count, max);
      if (max == array.",hhuang8
13831,"public class Solution{
  public static void main(String[] args){
  Scanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
  int t = input.nextInt();
  for(int i = 1; i <= t; ++i){
    int t1 = input.nextInt();
    int[] arrFun = new int[t1];
    for (int k = 0; k < t1; ++k){
      int fun = input.nextInt();
      arrFun[k] = fun;
    }
    
    int[] arrPos = new int[t1];
    for (int k = 0; k < t1; ++k){
      int pos = input.nextInt();
      arrPos[k] = pos;
    }

    //Arrays.sort(arr);
    System.out.println(""Case #"" + i + "": "" + maxFun(t1, arrFun, arrPos));
  }
}

public static int maxFun(int N, int[] arrFun, int[] arrPos) {
  int[] indegree= new int[N+1];
  int[] adj = new int[N+1];

  for(int i=0; i < N; i++) {
    indegree[arrPos[i]]++;
    adj[i] = arrPos[i];
  }

  Queue<Integer> q = new LinkedList<>();  
  for (int i=0; i <= N; i++) {
    if (indegree[i]==0) {
      ((LinkedList<Integer>) q).push(i);
    }
  }

  Integer[] q_arr=new Integer[q.size()];
  q_arr=q.toArray(q_arr);

  ArrayList<Integer[]> res = new ArrayList<Integer[]>(); 
  getAllRecursive(q.size(), q_arr, res);

  int maxTotalFun = 0;
  for(int p = 0; p < res.size(); p++) {
     Integer[] i_arr = res.get(p);

     Queue<Integer> q_ = new LinkedList<>(Arrays.asList(i_arr));

    int totalFun = 0;
    boolean[] visited = new boolean[N];
    while(!q_.isEmpty()) {
      int cur = q_.remove();
      maxFun = 0;    
      maxFun = getMaxFun(arrFun, cur-1, adj, arrPos, visited);
      totalFun += maxFun;
    }

    maxTotalFun = Math.max(totalFun, maxTotalFun);
  }
  return maxTotalFun;
}

static ArrayList<Integer[]> res = new ArrayList<Integer[]>(); 
static int maxFun=0;
public static int getMaxFun(int[] arrFun, int cur, int[] adj, int[] arrPos, boolean[] visited)
{
    int curFun = arrFun[cur];
    maxFun = Math.max(curFun, maxFun);
    visited[cur] = true;
    if(cur>=0) {
      int child = adj[cur]-1; 
      if(child>=0 && !visited[child] ) {
        int maxFun2 = getMaxFun(arrFun, child, adj, arrPos, visited);
        maxFun = Math.max(maxFun, maxFun2);
      }
    }
    return maxFun;
}

public static void getAllRecursive(
  int n, Integer[] elements, ArrayList<Integer[]> res) {
    if(n == 1) {
      Integer[] arr = new Integer[elements.length];
      for (int o = 0; o < arr.length; o++){
        arr[o] = elements[o];
      }
      res.add(arr);
    } else {
        for(int i = 0; i < n-1; i++) {
          getAllRecursive(n - 1, elements, res);
            if(n % 2 == 0) {
                swap(elements, i, n-1);
            } else {
                swap(elements, 0, n-1);
            }
        }
        getAllRecursive(n - 1, elements, res);
    }
}

static void swap(Integer[] input, int a, int b) {
  int tmp = input[a];
  input[a] = input[b];
  input[b] = ",hhuang8
13832,"public class Solution{
    public static void main(String[] args){
        Scanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        long t = input.nextLong();
        for(int i = 1; i <= t; ++i){
          long caveSize = input.nextInt();
          long numGuesses = input.nextInt();
          //long sum = 0;
        long initRoom = input.nextInt();
        long initPass = input.nextInt();
          // sum += initPass;
        ArrayList<Long> vals = new ArrayList<>();
        ArrayList<Long> numsChosen = new ArrayList<>();
        vals.add(initPass);
        numsChosen.add(initRoom);
          if (numGuesses > caveSize){
              for (int k = 1; k <= caveSize; k++){
                   System.out.println(""T "" + k);
                   long room1 = input.nextInt();
                   long numT = input.nextInt();
                //   if(numT <= sum * 20 || numT >= sum * (1/20)){
                 //sum += numT;
                //   }
                vals.add(numT);
              }
              } else {
                for (int p = 0; p < 6000; p++){
                       double randomCave = Math.random() * caveSize + 1;
                       while (numsChosen.indexOf((long)randomCave) != -1){
                        randomCave = Math.random() * caveSize + 1;
                       }
                       numsChosen.add((long)randomCave);
                       System.out.println(""T "" + (int)(randomCave));
                       long room2 = input.nextInt();
                       long numY = input.nextInt();
                      // if(numT <= sum * 20 || numT >= sum * (1/20)){
                    //sum += numY;
                     //  }
                    vals.add(numY);
                    }
              }
              Collections.sort(vals);
              long mid = vals.get(vals.size() / 2);
              mid *= caveSize;
              mid /= 2;
             // sum /= numGuesses + 1;
           //sum *= caveSize;
             // long fin = (sum + mid) / 2;
              
              System.",hhuang8
13833,"public class Solution{
    public static void main(String[] args){
        Scanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        long t = input.nextLong();
        for(int i = 1; i <= t; ++i){
          long caveSize = input.nextInt();
          long numGuesses = input.nextInt();
        //  int sum = 0;
        long initRoom = input.nextInt();
        long initPass = input.nextInt();
        //   sum += initPass;
        ArrayList<Long> vals = new ArrayList<>();
        ArrayList<Long> numsChosen = new ArrayList<>();
        vals.add(initPass);
        numsChosen.add(initRoom);
        ArrayList<Long> vals1 = new ArrayList<>();
        ArrayList<Long> numsChosen1 = new ArrayList<>();
        vals1.add(initPass);
        numsChosen1.add(initRoom);
          if (numGuesses > caveSize){
              for (int k = 1; k <= caveSize; k++){
                   System.out.println(""T "" + k);
                   long room1 = input.nextInt();
                   long numT = input.nextInt();
                //   if(numT <= sum * 20 || numT >= sum * (1/20)){
                //     //sum += numT;
                //   }
                vals.add(numT);
              }
              } else {
                for (int p = 0; p < 2000; p++){
                       double randomCave = Math.random() * caveSize + 1;
                       while (numsChosen.indexOf((long)randomCave) != -1){
                        randomCave = Math.random() * caveSize + 1;
                       }
                       numsChosen.add((long)randomCave);
                       System.out.println(""T "" + (int)(randomCave));
                       long room2 = input.nextInt();
                       long numY = input.nextInt();
                       
                       double randomCave1 = Math.random() * caveSize + 1;
                       while (numsChosen.indexOf((long)randomCave1) != -1){
                        randomCave1 = Math.random() * caveSize + 1;
                       }
                       numsChosen.add((long)randomCave1);
                       System.out.println(""T "" + (int)(randomCave1));
                       long room3 = input.nextInt();
                       long numZ = input.nextInt();
                    //   if(numT <= sum * 20 || numT >= sum * (1/20)){
                    //     //sum += numT;
                    //   }
                    vals.add(numY);
                    }
              }
              Collections.sort(vals);
              long mid = vals.get(vals.size() / 2);
              mid *= caveSize;
              //mid /= 2;
              Collections.sort(vals1);
              long mid1 = vals.get(vals1.size() / 2);
              mid1 *= caveSize;
              //mid1 /= 2;
              long fin = (mid + mid1) / 2;
              System.",hhuang8
13834,"public class Solution{
    public static void main(String[] args){
        Scanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        long t = input.nextLong();
        for(int i = 1; i <= t; ++i){
          long caveSize = input.nextInt();
          long numGuesses = input.nextInt();
        //  int sum = 0;
        long initRoom = input.nextInt();
        long initPass = input.nextInt();
        //   sum += initPass;
        ArrayList<Long> vals = new ArrayList<>();
        ArrayList<Long> numsChosen = new ArrayList<>();
        vals.add(initPass);
        numsChosen.add(initRoom);
        ArrayList<Long> vals1 = new ArrayList<>();
        ArrayList<Long> numsChosen1 = new ArrayList<>();
        vals1.add(initPass);
        numsChosen1.add(initRoom);
          if (numGuesses > caveSize){
              for (int k = 1; k <= caveSize; k++){
                   System.out.println(""T "" + k);
                   long room1 = input.nextInt();
                   long numT = input.nextInt();
                //   if(numT <= sum * 20 || numT >= sum * (1/20)){
                //     //sum += numT;
                //   }
                vals.add(numT);
              }
              } else {
                for (int p = 0; p < 2000; p++){
                       double randomCave = Math.random() * caveSize + 1;
                       while (numsChosen.indexOf((long)randomCave) != -1){
                        randomCave = Math.random() * caveSize + 1;
                       }
                       numsChosen.add((long)randomCave);
                       System.out.println(""T "" + (int)(randomCave));
                       long room2 = input.nextInt();
                       long numY = input.nextInt();
                       
                       double randomCave1 = Math.random() * caveSize + 1;
                       while (numsChosen.indexOf((long)randomCave1) != -1){
                        randomCave1 = Math.random() * caveSize + 1;
                       }
                       numsChosen.add((long)randomCave1);
                       System.out.println(""T "" + (int)(randomCave1));
                       long room3 = input.nextInt();
                       long numZ = input.nextInt();
                    //   if(numT <= sum * 20 || numT >= sum * (1/20)){
                    //     //sum += numT;
                    //   }
                    vals.add(numY);
                    }
              }
              Collections.sort(vals);
              long mid = vals.get(vals.size() / 2);
              mid *= caveSize;
              mid /= 2;
              Collections.sort(vals1);
              long mid1 = vals.get(vals1.size() / 2);
              mid1 *= caveSize;
              mid1 /= 2;
              long fin = (mid + mid1) / 2;
              System.",hhuang8
13835,"public class Solution{
  public static void main(String[] args){
  Scanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
  int t = input.nextInt();
  for(int i = 1; i <= t; ++i){
    int t1 = input.nextInt();
    int[] arrFun = new int[t1];
    for (int k = 0; k < t1; ++k){
      int fun = input.nextInt();
      arrFun[k] = fun;
    }
    
    int[] arrPos = new int[t1];
    for (int k = 0; k < t1; ++k){
      int pos = input.nextInt();
      arrPos[k] = pos;
    }

    //Arrays.sort(arr);
    System.out.println(""Case #"" + i + "": "" + maxFun(t1, arrFun, arrPos));
  }
}

public static int maxFun(int N, int[] arrFun, int[] arrPos) {
  int[] indegree= new int[N+1];
  int[] adj = new int[N];

  for(int i=0; i < N; i++) {
    indegree[arrPos[i]]++;
    adj[i] = arrPos[i];
  }

  Queue<Integer> q = new LinkedList<>();  
  for (int i=0; i <= N; i++) {
    if (indegree[i]==0) {
      ((LinkedList<Integer>) q).push(i);
    }
  }

  Integer[] q_arr=new Integer[q.size()];
  q_arr=q.toArray(q_arr);

  ArrayList<Integer[]> res = new ArrayList<Integer[]>(); 
  getAllRecursive(q.size(), q_arr, res);

  int maxTotalFun = 0;
  for(int p = 0; p < res.size(); p++) {
     Integer[] i_arr = res.get(p);

     Queue<Integer> q_ = new LinkedList<>(Arrays.asList(i_arr));

    int totalFun = 0;
    boolean[] visited = new boolean[N];
    while(!q_.isEmpty()) {
      int cur = q_.remove();
      maxFun = 0;    
      maxFun = getMaxFun(arrFun, cur-1, adj, arrPos, visited);
      totalFun += maxFun;
    }

    maxTotalFun = Math.max(totalFun, maxTotalFun);
  }
  return maxTotalFun;
}

static ArrayList<Integer[]> res = new ArrayList<Integer[]>(); 
static int maxFun=0;
public static int getMaxFun(int[] arrFun, int cur, int[] adj, int[] arrPos, boolean[] visited)
{
    int curFun = arrFun[cur];
    maxFun = Math.max(curFun, maxFun);
    visited[cur] = true;
    if(cur>=1) {
      int child = adj[cur-1]; 
      if(!visited[child]) {
        int maxFun2 = getMaxFun(arrFun, child, adj, arrPos, visited);
        maxFun = Math.max(maxFun, maxFun2);
      }
    }
    return maxFun;
}

public static void getAllRecursive(
  int n, Integer[] elements, ArrayList<Integer[]> res) {
    if(n == 1) {
      Integer[] arr = new Integer[elements.length];
      for (int o = 0; o < arr.length; o++){
        arr[o] = elements[o];
      }
      res.add(arr);
    } else {
        for(int i = 0; i < n-1; i++) {
          getAllRecursive(n - 1, elements, res);
            if(n % 2 == 0) {
                swap(elements, i, n-1);
            } else {
                swap(elements, 0, n-1);
            }
        }
        getAllRecursive(n - 1, elements, res);
    }
}

static void swap(Integer[] input, int a, int b) {
  int tmp = input[a];
  input[a] = input[b];
  input[b] = ",hhuang8
13836,"public class Solution{
    public static void main(String[] args){
        Scanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        long t = input.nextLong();
        for(int i = 1; i <= t; ++i){
          long caveSize = input.nextInt();
          long numGuesses = input.nextInt();
        //  int sum = 0;
        long initRoom = input.nextInt();
        long initPass = input.nextInt();
        //   sum += initPass;
        ArrayList<Long> vals = new ArrayList<>();
        ArrayList<Long> numsChosen = new ArrayList<>();
        vals.add(initPass);
        numsChosen.add(initRoom);
          if (numGuesses > caveSize){
              for (int k = 1; k <= caveSize; k++){
                   System.out.println(""T "" + k);
                   long room1 = input.nextInt();
                   long numT = input.nextInt();
                //   if(numT <= sum * 20 || numT >= sum * (1/20)){
                //     //sum += numT;
                //   }
                vals.add(numT);
              }
              } else {
                for (int p = 0; p < 5000; p++){
                       double randomCave = Math.random() * caveSize + 1;
                       while (numsChosen.indexOf((long)randomCave) != -1){
                        randomCave = Math.random() * caveSize + 1;
                       }
                       numsChosen.add((long)randomCave);
                       System.out.println(""T "" + (int)(randomCave));
                       long room2 = input.nextInt();
                       long numY = input.nextInt();
                    //   if(numT <= sum * 20 || numT >= sum * (1/20)){
                    //     //sum += numT;
                    //   }
                    vals.add(numY);
                    }
              }
              Collections.sort(vals);
              long mid = vals.get(vals.size() / 2);
              mid *= caveSize;
              mid /= 2;
              System.",hhuang8
13837,"public class Solution{
    public static void main(String[] args){
        Scanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        long t = input.nextLong();
        for(int i = 1; i <= t; ++i){
          long caveSize = input.nextInt();
          long numGuesses = input.nextInt();
        //  int sum = 0;
        long initRoom = input.nextInt();
        long initPass = input.nextInt();
        //   sum += initPass;
        ArrayList<Long> vals = new ArrayList<>();
        ArrayList<Long> numsChosen = new ArrayList<>();
        vals.add(initPass);
        numsChosen.add(initRoom);
          if (numGuesses > caveSize){
              for (int k = 1; k <= caveSize; k++){
                   System.out.println(""T "" + k);
                   long room1 = input.nextInt();
                   long numT = input.nextInt();
                //   if(numT <= sum * 20 || numT >= sum * (1/20)){
                //     //sum += numT;
                //   }
                vals.add(numT);
              }
              } else {
                for (int p = 0; p < numGuesses / 2; p++){
                       double randomCave = Math.random() * caveSize + 1;
                       while (numsChosen.indexOf((long)randomCave) != -1){
                        randomCave = Math.random() * caveSize + 1;
                       }
                       numsChosen.add((long)randomCave);
                       System.out.println(""T "" + (int)(randomCave));
                       long room2 = input.nextInt();
                       long numY = input.nextInt();
                    //   if(numT <= sum * 20 || numT >= sum * (1/20)){
                    //     //sum += numT;
                    //   }
                    vals.add(numY);
                    }
              }
              Collections.sort(vals);
              long mid = vals.get(vals.size() / 2);
              mid *= caveSize;
              mid /= 2;
              System.",hhuang8
13838,"public class Solution{
  public static void main(String[] args){
  Scanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
  int t = input.nextInt();
  for(int i = 1; i <= t; ++i){
    int t1 = input.nextInt();
    int[] arrFun = new int[t1];
    for (int k = 0; k < t1; ++k){
      int fun = input.nextInt();
      arrFun[k] = fun;
    }
    
    int[] arrPos = new int[t1];
    for (int k = 0; k < t1; ++k){
      int pos = input.nextInt();
      arrPos[k] = pos;
    }

    //Arrays.sort(arr);
    System.out.println(""Case #"" + i + "": "" + maxFun(t1, arrFun, arrPos));
  }
}

public static int maxFun(int N, int[] arrFun, int[] arrPos) {
  int[] indegree= new int[N+1];
  int[] adj = new int[N+1];

  for(int i=0; i < N; i++) {
    indegree[arrPos[i]]++;
    adj[i] = arrPos[i];
  }

  Queue<Integer> q = new LinkedList<>();  
  for (int i=0; i <= N; i++) {
    if (indegree[i]==0) {
      ((LinkedList<Integer>) q).push(i);
    }
  }

  Integer[] q_arr=new Integer[q.size()];
  q_arr=q.toArray(q_arr);

  ArrayList<Integer[]> res = new ArrayList<Integer[]>(); 
  getAllRecursive(q.size(), q_arr, res);

  int maxTotalFun = 0;
  for(int p = 0; p < res.size(); p++) {
     Integer[] i_arr = res.get(p);

     Queue<Integer> q_ = new LinkedList<>(Arrays.asList(i_arr));

    int totalFun = 0;
    boolean[] visited = new boolean[N];
    while(!q_.isEmpty()) {
      int cur = q_.remove();
      maxFun = 0;    
      maxFun = getMaxFun(arrFun, cur-1, adj, arrPos, visited);
      totalFun += maxFun;
    }

    maxTotalFun = Math.max(totalFun, maxTotalFun);
  }
  return maxTotalFun;
}

//static ArrayList<Integer[]> res = new ArrayList<Integer[]>(); 
static int maxFun=0;
public static int getMaxFun(int[] arrFun, int cur, int[] adj, int[] arrPos, boolean[] visited)
{
    if(cur < 0) return 0;
    int curFun = arrFun[cur];
    maxFun = Math.max(curFun, maxFun);
    visited[cur] = true;
    if(cur>=0) 
    {
      int child = adj[cur]-1; 
      if(child>=0 && !visited[child] ) {
        int maxFun2 = getMaxFun(arrFun, child, adj, arrPos, visited);
        maxFun = Math.max(maxFun, maxFun2);
      }
    }
    return maxFun;
}

public static void getAllRecursive(
  int n, Integer[] elements, ArrayList<Integer[]> res) {
    if(n == 1) {
      Integer[] arr = new Integer[elements.length];
      for (int o = 0; o < arr.length; o++){
        arr[o] = elements[o];
      }
      res.add(arr);
    } else {
        for(int i = 0; i < n-1; i++) {
          getAllRecursive(n - 1, elements, res);
            if(n % 2 == 0) {
                swap(elements, i, n-1);
            } else {
                swap(elements, 0, n-1);
            }
        }
        getAllRecursive(n - 1, elements, res);
    }
}

static void swap(Integer[] input, int a, int b) {
  int tmp = input[a];
  input[a] = input[b];
  input[b] = ",hhuang8
13839,"public class Solution{
    public static void main(String[] args){
        Scanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int t = input.nextInt();
        for(int i = 1; i <= t; ++i){
          int caveSize = input.nextInt();
          int numGuesses = input.nextInt();
          int sum = 0;
          int initRoom = input.nextInt();
          int initPass = input.nextInt();
           sum += initPass;
        ArrayList<Integer> vals = new ArrayList<>();
        ArrayList<Integer> numsChosen = new ArrayList<>();
        vals.add(initPass);
        numsChosen.add(initRoom);
          if (numGuesses > caveSize){
              for (int k = 1; k <= caveSize; k++){
                   System.out.println(""T "" + k);
                  int room1 = input.nextInt();
                  int numT = input.nextInt();
                //   if(numT <= sum * 20 || numT >= sum * (1/20)){
                sum += numT;
                //   }
                vals.add(numT);
              }
              } else {
                for (int p = 0; p < numGuesses; p++){
                       double randomCave = Math.random() * caveSize + 1;
                       while (numsChosen.indexOf((int)randomCave) != -1){
                        randomCave = Math.random() * caveSize + 1;
                       }
                       numsChosen.add((int)randomCave);
                       System.out.println(""T "" + (int)(randomCave));
                        int room2 = input.nextInt();
                        int numY = input.nextInt();
                      // if(numT <= sum * 20 || numT >= sum * (1/20)){
                         sum += numY;
                      // }
                    vals.add(numY);
                    }
              }
              Collections.sort(vals);
              int mid = vals.get(vals.size() / 2);
              mid *= caveSize;
                sum /= numGuesses + 1;
                sum *= caveSize;
              int fin = ",hhuang8
13840,"public class Solution{
    public static void main(String[] args){
        Scanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int t = input.nextInt();
        for(int i = 1; i <= t; ++i){
          int caveSize = input.nextInt();
          int numGuesses = input.nextInt();
          int sum = 0;
          int initRoom = input.nextInt();
          int initPass = input.nextInt();
           sum += initPass;
        ArrayList<Integer> vals = new ArrayList<>();
        ArrayList<Integer> numsChosen = new ArrayList<>();
        vals.add(initPass);
        numsChosen.add(initRoom);
          if (numGuesses > caveSize){
              for (int k = 1; k <= caveSize; k++){
                   System.out.println(""T "" + k);
                  int room1 = input.nextInt();
                  int numT = input.nextInt();
                //   if(numT <= sum * 20 || numT >= sum * (1/20)){
                sum += numT;
                //   }
                vals.add(numT);
              }
              } else {
                for (int p = 0; p < numGuesses; p++){
                       double randomCave = Math.random() * caveSize + 1;
                       while (numsChosen.indexOf((int)randomCave) != -1){
                        randomCave = Math.random() * caveSize + 1;
                       }
                       numsChosen.add((int)randomCave);
                       System.out.println(""T "" + (int)(randomCave));
                        int room2 = input.nextInt();
                        int numY = input.nextInt();
                      // if(numT <= sum * 20 || numT >= sum * (1/20)){
                         sum += numT;
                      // }
                    vals.add(numY);
                    }
              }
              Collections.sort(vals);
              int mid = vals.get(vals.size() / 2);
              mid *= caveSize;
                sum /= numGuesses + 1;
                sum *= caveSize;
              int fin = ",hhuang8
13841,"public class Solution{
    public static void main(String[] args){
        Scanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int t = input.nextInt();
        for(int i = 1; i <= t; ++i){
          int caveSize = input.nextInt();
          int numGuesses = input.nextInt();
          int sum = 0;
          int initRoom = input.nextInt();
          int initPass = input.nextInt();
           sum += initPass;
        ArrayList<Integer> vals = new ArrayList<>();
        ArrayList<Integer> numsChosen = new ArrayList<>();
        vals.add(initPass);
        numsChosen.add(initRoom);
          if (numGuesses > caveSize){
              for (int k = 1; k <= caveSize; k++){
                   System.out.println(""T "" + k);
                  int room1 = input.nextInt();
                  int numT = input.nextInt();
                //   if(numT <= sum * 20 || numT >= sum * (1/20)){
                //     //sum += numT;
                //   }
                vals.add(numT);
              }
              } else {
                for (int p = 0; p < numGuesses; p++){
                       double randomCave = Math.random() * caveSize + 1;
                       while (numsChosen.indexOf((int)randomCave) != -1){
                        randomCave = Math.random() * caveSize + 1;
                       }
                       numsChosen.add((int)randomCave);
                       System.out.println(""T "" + (int)(randomCave));
                        int room2 = input.nextInt();
                        int numY = input.nextInt();
                       if(numT <= sum * 20 || numT >= sum * (1/20)){
                         sum += numT;
                       }
                    vals.add(numY);
                    }
              }
              Collections.sort(vals);
              int mid = vals.get(vals.size() / 2);
              mid *= caveSize;
                sum /= numGuesses + 1;
                sum *= caveSize;
              int fin = ",hhuang8
13842,"public class Solution{
    public static void main(String[] args){
        Scanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int t = input.nextInt();
        for(int i = 1; i <= t; ++i){
          int caveSize = input.nextInt();
          int numGuesses = input.nextInt();
        //  int sum = 0;
          int initRoom = input.nextInt();
          int initPass = input.nextInt();
        //   sum += initPass;
        ArrayList<Integer> vals = new ArrayList<>();
        ArrayList<Integer> numsChosen = new ArrayList<>();
        vals.add(initPass);
        numsChosen.add(initRoom);
          if (numGuesses > caveSize){
              for (int k = 1; k <= caveSize; k++){
                   System.out.println(""T "" + k);
                  int room1 = input.nextInt();
                  int numT = input.nextInt();
                //   if(numT <= sum * 20 || numT >= sum * (1/20)){
                //     //sum += numT;
                //   }
                vals.add(numT);
              }
              } else {
                for (int p = 0; p < numGuesses; p++){
                       double randomCave = Math.random() * caveSize + 1;
                       while (numsChosen.indexOf((int)randomCave) != -1){
                        randomCave = Math.random() * caveSize + 1;
                       }
                       numsChosen.add((int)randomCave);
                       System.out.println(""T "" + (int)(randomCave));
                        int room2 = input.nextInt();
                        int numY = input.nextInt();
                    //   if(numT <= sum * 20 || numT >= sum * (1/20)){
                    //     //sum += numT;
                    //   }
                    vals.add(numY);
                    }
              }
              Collections.sort(vals);
              int mid = vals.get(vals.size() / 2);
              mid *= caveSize;
              System.",hhuang8
13843,"public class Solution{
    public static void main(String[] args){
        Scanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int t = input.nextInt();
        for(int i = 1; i <= t; ++i){
          int caveSize = input.nextInt();
          int numGuesses = input.nextInt();
          int sum = 0;
          int initRoom = input.nextInt();
          int initPass = input.nextInt();
          sum += initPass;
          if (numGuesses > caveSize){
              for (int k = 1; k <= caveSize; k++){
                  System.out.println(""T "" + k);
                  int room1 = input.nextInt();
                  int numT = input.nextInt();
                  if (sum != 0){
                  if(numT <= sum * 20 || numT >= sum * (1/20)){
                    sum += numT;
                  }}
              }
              } else {
                  for (int p = 0; p < numGuesses; p++){
                      double randomCave = Math.random() * caveSize + 1;
                      System.out.println(""T "" + (int)(randomCave));
                      int room2 = input.nextInt();
                      int numY = input.nextInt();
                      if (sum != 0){
                      if(numY <= sum * 20 || numY >= sum * (1/20)){
                        sum += numY;
                      }}
                    }
              }
          
          sum /= numGuesses + 1;
          sum *= caveSize;
          System.",hhuang8
13844,"public class Solution{
    public static void main(String[] args){
        Scanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int t = input.nextInt();
        for(int i = 1; i <= t; ++i){
          int caveSize = input.nextInt();
          int numGuesses = input.nextInt();
          int sum = 0;
          int initRoom = input.nextInt();
          int initPass = input.nextInt();
          sum += initPass;
          if (numGuesses > caveSize){
              for (int k = 1; k <= caveSize; k++){
                  System.out.println(""T "" + k);
                  int room1 = input.nextInt();
                  int numT = input.nextInt();
                  if (sum != 0){
                  if(numT <= sum * 20 || numT >= sum * (1/20)){
                    sum += numT;
                  }}
              }
              } else {
                  for (int p = 0; p < numGuesses; p++){
                      double randomCave = Math.random() * caveSize + 1;
                      System.out.println(""T "" + (int)(randomCave));
                      int room2 = input.nextInt();
                      int numY = input.nextInt();
                      if (sum != 0){
                      if(numT <= sum * 20 || numT >= sum * (1/20)){
                        sum += numT;
                      }}
                    }
              }
          
          sum /= numGuesses + 1;
          sum *= caveSize;
          System.",hhuang8
13845,"public class Solution{
    public static void main(String[] args){
        Scanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int t = input.nextInt();
        for(int i = 1; i <= t; ++i){
          int caveSize = input.nextInt();
          int numGuesses = input.nextInt();
          int sum = 0;
          int initRoom = input.nextInt();
          int initPass = input.nextInt();
          sum += initPass;
          if (numGuesses > caveSize){
              for (int k = 1; k < caveSize + 1; k++){
                  System.out.println(""T "" + k);
                  int room1 = input.nextInt();
                  int numT = input.nextInt();
                  sum += numT;
              }
              } else {
                  for (int p = 0; p < numGuesses / 3; p++){
                      System.out.println(""T "" + (int)(Math.random() * caveSize + 1));
                      int room2 = input.nextInt();
                      int numY = input.nextInt();
                      sum += numY;
                    }
              }
          
          sum /= numGuesses + 1;
          sum *= caveSize;
          System.",hhuang8
13846,"public class Solution{
    public static void main(String[] args){
        Scanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int t = input.nextInt();
        for(int i = 1; i <= t; ++i){
          int caveSize = input.nextInt();
          int numGuesses = input.nextInt();
          int sum = 0;
          int initRoom = input.nextInt();
          int initPass = input.nextInt();
          sum += initPass;
          if (numGuesses > caveSize){
              for (int k = 0; k < caveSize; k++){
                  System.out.println(""T "" + k);
                  int room1 = input.nextInt();
                  int numT = input.nextInt();
                  sum += numT;
              }
              } else {
                  for (int p = 0; p < numGuesses / 3; p++){
                      System.out.println(""T "" + (int)(Math.random() * caveSize + 1));
                      int room2 = input.nextInt();
                      int numY = input.nextInt();
                      sum += numY;
                    }
              }
          
          sum /= numGuesses + 1;
          sum *= caveSize;
          System.",hhuang8
13847,"public class Solution{
    public static void main(String[] args){
        Scanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int t = input.nextInt();
        for(int i = 1; i <= t; ++i){
          int caveSize = input.nextInt();
          int numGuesses = input.nextInt();
          int sum = 0;
          int initRoom = input.nextInt();
          int initPass = input.nextInt();
          sum += initPass;
          if (numGuesses > caveSize){
              for (int k = 0; k < caveSize; k++){
                  System.out.println(""T "" + k);
                  int room1 = input.nextInt();
                  int numT = input.nextInt();
                  sum += numT;
              }
              } else {
                  for (int p = 0; p < numGuesses / 4; p++){
                      System.out.println(""T "" + (int)(Math.random() * caveSize + 1));
                      int room2 = input.nextInt();
                      int numY = input.nextInt();
                      sum += numY;
                    }
              }
          
          sum /= numGuesses + 1;
          sum *= caveSize;
          System.",hhuang8
13848,"public class Solution{
    public static void main(String[] args){
        Scanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int t = input.nextInt();
        for(int i = 1; i <= t; ++i){
          int caveSize = input.nextInt();
          int numGuesses = input.nextInt();
          int sum = 0;
          for (int k = 0; k < numGuesses; k++){
            int room = input.nextInt();
            int numTunnels = input.nextInt();  
            sum += numTunnels;
            if (k % 2 == 0){
                  System.out.println(""T "" + (int)(Math.random() * caveSize));
              } else {
                  System.out.println(""W"");
              }
          }
          sum /= numGuesses;
          sum *= caveSize;
          System.",hhuang8
13849,"public class Solution{
  public static void main(String[] args){
  Scanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
  int t = input.nextInt();
  for(int i = 1; i <= t; ++i){
    int t1 = input.nextInt();
    int[] arrFun = new int[t1];
    for (int k = 0; k < t1; ++k){
      int fun = input.nextInt();
      arrFun[k] = fun;
    }
    
    int[] arrPos = new int[t1];
    for (int k = 0; k < t1; ++k){
      int pos = input.nextInt();
      arrPos[k] = pos;
    }

    //Arrays.sort(arr);
    System.out.println(""Case #"" + i + "": "" + maxFun(t1, arrFun, arrPos));
  }
}

public static int maxFun(int N, int[] arrFun, int[] arrPos) {
  int[] indegree= new int[N+1];
  int[] adj = new int[N+1];

  for(int i=0; i < N; i++) {
    indegree[arrPos[i]]++;
    adj[i] = arrPos[i];
  }

  Queue<Integer> q = new LinkedList<>();  
  for (int i=0; i <= N; i++) {
    if (indegree[i]==0) {
      ((LinkedList<Integer>) q).push(i);
    }
  }

  Integer[] q_arr=new Integer[q.size()];
  q_arr=q.toArray(q_arr);

  ArrayList<Integer[]> res = new ArrayList<Integer[]>(); 
  getAllRecursive(q.size(), q_arr, res);

  int maxTotalFun = 0;
  for(int p = 0; p < res.size(); p++) {
     Integer[] i_arr = res.get(p);

     Queue<Integer> q_ = new LinkedList<>(Arrays.asList(i_arr));

    int totalFun = 0;
    boolean[] visited = new boolean[N];
    while(!q_.isEmpty()) {
      int cur = q_.remove();
      maxFun = 0;    
      maxFun = getMaxFun(arrFun, cur-1, adj, arrPos, visited);
      totalFun += maxFun;
    }

    maxTotalFun = Math.max(totalFun, maxTotalFun);
  }
  return maxTotalFun;
}

static ArrayList<Integer[]> res = new ArrayList<Integer[]>(); 
static int maxFun=0;
public static int getMaxFun(int[] arrFun, int cur, int[] adj, int[] arrPos, boolean[] visited)
{
    if (cur > 0){
        return 0;
    }
    int curFun = arrFun[cur];
    maxFun = Math.max(curFun, maxFun);
    visited[cur] = true;
    if(cur>=0) {
      int child = adj[cur]-1; 
      if(child>=0 && !visited[child] ) {
        int maxFun2 = getMaxFun(arrFun, child, adj, arrPos, visited);
        maxFun = Math.max(maxFun, maxFun2);
      }
    }
    return maxFun;
}

public static void getAllRecursive(
  int n, Integer[] elements, ArrayList<Integer[]> res) {
    if(n == 1) {
      Integer[] arr = new Integer[elements.length];
      for (int o = 0; o < arr.length; o++){
        arr[o] = elements[o];
      }
      res.add(arr);
    } else {
        for(int i = 0; i < n-1; i++) {
          getAllRecursive(n - 1, elements, res);
            if(n % 2 == 0) {
                swap(elements, i, n-1);
            } else {
                swap(elements, 0, n-1);
            }
        }
        getAllRecursive(n - 1, elements, res);
    }
}

static void swap(Integer[] input, int a, int b) {
  int tmp = input[a];
  input[a] = input[b];
  input[b] = ",hhuang8
13850,"public class Solution{
  public static void main(String[] args){
  Scanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
  int t = input.nextInt();
  for(int i = 1; i <= t; ++i){
    int t1 = input.nextInt();
    int[] arr = new int[t1];
    for (int k = 0; k < t1; ++k){
      int dice = input.nextInt();
      arr[k] = dice;
    }
    Arrays.sort(arr);
    System.out.println(""Case #"" + i + "": "" + count(arr));
  }
}
  
  public static int count(int[] array){
    int max = 0;
    for (int b = 1; b < 2; b++){
      int count = 0;
      for (int p = 0; p < array.length; p++){
        if (array[p] >= p + b){
          count++;
        } else {
            // if(array[array.length - 1] == array[p]){
            //     break;
            // }
             while (p+1 < array.length && array[p+1] == array[p]){
                p++;
                b--;
            }
        }
      }
      max = Math.max(count, max);
      if (max == array.",hhuang8
13851,"public class Solution{
  public static void main(String[] args){
  Scanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
  int t = input.nextInt();
  for(int i = 1; i <= t; ++i){
    int t1 = input.nextInt();
    int[] arr = new int[t1];
    for (int k = 0; k < t1; ++k){
      int dice = input.nextInt();
      arr[k] = dice;
    }
    Arrays.sort(arr);
    System.out.println(""Case #"" + i + "": "" + count(arr));
  }
}
  
  public static int count(int[] array){
    int max = 0;
    for (int b = 0; b < 2; b++){
      int count = 0;
      for (int p = 0; p < array.length; p++){
        if (array[p] >= p + b){
          count++;
        } else {
            if(array[array.length - 1] == array[p]){
                break;
            }
             while (p+1 < array.length && array[p+1] == array[p]){
                p++;
                b--;
            }
        }
      }
      max = Math.max(count, max);
      if (max == array.",hhuang8
13852,"public class Solution{
  public static void main(String[] args){
  Scanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
  int t = input.nextInt();
  for(int i = 1; i <= t; ++i){
    int t1 = input.nextInt();
    int[] arr = new int[t1];
    for (int k = 0; k < t1; ++k){
      int dice = input.nextInt();
      arr[k] = dice;
    }
    Arrays.sort(arr);
    System.out.println(""Case #"" + i + "": "" + count(arr));
  }
}
  
  public static int count(int[] array){
    int max = 0;
    for (int b = 0; b < 2; b++){
      int count = 0;
      for (int p = 0; p < array.length; p++){
        if (array[p] >= p + b){
          count++;
        } else {
            if(array[array.length - 1] == array[p]){
                return count;
            }
             while (p+1 < array.length && array[p+1] == array[p]){
                p++;
                b--;
            }
        }
      }
      max = Math.max(count, max);
      if (max == array.",hhuang8
13853,"public class Solution{
  public static void main(String[] args){
  Scanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
  int t = input.nextInt();
  for(int i = 1; i <= t; ++i){
    int t1 = input.nextInt();
    int[] arr = new int[t1];
    for (int k = 0; k < t1; ++k){
      int dice = input.nextInt();
      arr[k] = dice;
    }
    Arrays.sort(arr);
    System.out.println(""Case #"" + i + "": "" + count(arr));
  }
}
  
  public static int count(int[] array){
    int max = 0;
    for (int b = 1; b < 2; b++){
      int count = 0;
      for (int p = 0; p < array.length; p++){
        if (array[p] >= p + b){
          count++;
        } else {
            if(array[array.length - 1] == array[p]){
                return count;
            }
             while (p+1 < array.length && array[p+1] == array[p]){
                p++;
                b--;
            }
        }
      }
      max = Math.max(count, max);
      if (max == array.",hhuang8
13854,"public class Solution{
  public static void main(String[] args){
  Scanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
  int t = input.nextInt();
  for(int i = 1; i <= t; ++i){
    int t1 = input.nextInt();
    int[] arr = new int[t1];
    for (int k = 0; k < t1; ++k){
      int dice = input.nextInt();
      arr[k] = dice;
    }
    //Arrays.sort(arr);
    System.out.println(""Case #"" + i + "": "" + count(arr));
  }
}
  
  public static int count(int[] array){
    int max = 0;
    for (int b = 1; b < 2; b++){
      int count = 0;
      for (int p = 0; p < array.length; p++){
        if (array[p] >= p + b){
          count++;
        } else {
             while (p+1 < array.length && array[p+1] == array[p]){
                p++;
                b--;
            }
        }
      }
      max = Math.max(count, max);
      if (max == array.",hhuang8
13855,"public class Solution{
  public static void main(String[] args){
  Scanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
  int t = input.nextInt();
  for(int i = 1; i <= t; ++i){
    int t1 = input.nextInt();
    int[] arr = new int[t1];
    for (int k = 0; k < t1; ++k){
      int dice = input.nextInt();
      arr[k] = dice;
    }
    Arrays.sort(arr);
    System.out.println(""Case #"" + i + "": "" + count(arr));
  }
}
  
  public static int count(int[] array){
    int max = 0;
    for (int b = 1; b < 2; b++){
      int count = 0;
      for (int p = 0; p < array.length; p++){
        if (array[p] >= p + b){
          count++;
        } else {
            while (p+1 < array.length && array[p+1] == array[p]){
                p++;
                b--;
            }
        }
      }
      max = Math.max(count, max);
      if (max == array.",hhuang8
13856,"public class Solution{
  public static void main(String[] args){
  Scanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
  int t = input.nextInt();
  for(int i = 1; i <= t; ++i){
    int t1 = input.nextInt();
    int[] arr = new int[t1];
    for (int k = 0; k < t1; ++k){
      int dice = input.nextInt();
      arr[k] = dice;
    }
    Arrays.sort(arr);
    System.out.println(""Case #"" + i + "": "" + count(arr));
  }
}
  
  public static int count(int[] array){
    int max = 0;
    for (int b = 1; b < 2; b++){
      int count = 0;
      for (int p = 0; p < array.length; p++){
        if (array[p] >= p + b){
          count++;
        } else {
            while (array[p+1] == array[p]){
                p++;
                b--;
            }
        }
      }
      max = Math.max(count, max);
      if (max == array.",hhuang8
13857,"public class Solution{
  public static void main(String[] args){
  Scanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
  int t = input.nextInt();
  for(int i = 1; i <= t; ++i){
    int t1 = input.nextInt();
    int[] arr = new int[t1];
    for (int k = 0; k < t1; ++k){
      int dice = input.nextInt();
      arr[k] = dice;
    }
    Arrays.sort(arr);
    System.out.println(""Case #"" + i + "": "" + count(arr));
  }
}
  
  public static int count(int[] array){
    int max = 0;
    for (int b = 1; b < 2; b++){
      int count = 0;
      for (int p = 0; p < array.length; p++){
        if (array[p] >= p + b){
          count++;
        } else {
            while (array[p+1] == array[p]){
                p++;
                b--;
            }
            b--;
        }
      }
      max = Math.max(count, max);
      if (max == array.",hhuang8
13858,"public class Solution{
  public static void main(String[] args){
  Scanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
  int t = input.nextInt();
  for(int i = 1; i <= t; ++i){
    int t1 = input.nextInt();
    int[] arr = new int[t1];
    for (int k = 0; k < t1; ++k){
      int dice = input.nextInt();
      arr[k] = dice;
    }
    Arrays.sort(arr);
    System.out.println(""Case #"" + i + "": "" + count(arr));
  }
}
  
  public static int count(int[] array){
    int max = 0;
    for (int b = 1; b < 2; b++){
      int count = 0;
      for (int p = 0; p < array.length; p++){
        if (array[p] >= p + b){
          count++;
        } else {
            b--;
        }
      }
      max = Math.max(count, max);
      if (max == array.",hhuang8
13859,"public class Solution{
  public static void main(String[] args){
  Scanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
  int t = input.nextInt();
  for(int i = 1; i <= t; ++i){
    int t1 = input.nextInt();
    int[] arr = new int[t1];
    for (int k = 0; k < t1; ++k){
      int dice = input.nextInt();
      arr[k] = dice;
    }
    Arrays.sort(arr);
    System.out.println(""Case #"" + i + "": "" + count(arr));
  }
}
  
  public static int count(int[] array){
    int max = 0;
    int mid = array.length / 2;
    for (int b = array[mid]; b >= 1; b--){
      int count = 0;
      for (int p = 0; p < array.length; p++){
        if (array[p] >= p + b){
          count++;
        } else {
            b--;
        }
      }
      max = Math.max(count, max);
      if (max == array.",hhuang8
13860,"public class Solution{
  public static void main(String[] args){
  Scanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
  int t = input.nextInt();
  for(int i = 1; i <= t; ++i){
    int t1 = input.nextInt();
    int[] arr = new int[t1];
    for (int k = 0; k < t1; ++k){
      int dice = input.nextInt();
      arr[k] = dice;
    }
    Arrays.sort(arr);
    System.out.println(""Case #"" + i + "": "" + count(arr));
  }
}
  
  public static int count(int[] array){
    int max = 0;
    int mid = (array.length) /2;
    int midY = array[mid];
    int initB = (midY - mid);
    int lastCnt = 0;
    for (int b = initB; b >= -1; b--)
    {
      int count = 0;
      for (int p = 0; p < array.length; p++){
        if (array[p] >= p + b){
            if (p + b >= 1){
          count++;
            }
         } else {
             while (p+1 < array.length && array[p+1] == array[p]){
                p++;
                b--;
            }
            //b--;
            // if (b < 0){
            //     count--;
            // }
        }
      }
    //   if (count < lastCnt){
    //       return max;
    //   }
      max = Math.max(count, max);
      if (max == array.",hhuang8
13861,"public class Solution{
  public static void main(String[] args){
  Scanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
  int t = input.nextInt();
  for(int i = 1; i <= t; ++i){
    int t1 = input.nextInt();
    int[] arr = new int[t1];
    for (int k = 0; k < t1; ++k){
      int dice = input.nextInt();
      arr[k] = dice;
    }
    Arrays.sort(arr);
    System.out.println(""Case #"" + i + "": "" + count(arr));
  }
}
  
  public static int count(int[] array){
    int max = 0;
    for (int b = 1; b < array[array.length-1]; b++){
      int count = 0;
      for (int p = 0; p < array.length; p++){
        if (array[p] >= p + b){
          count++;
        } else {
            b--;
        }
      }
      max = Math.max(count, max);
      if (max == array.",hhuang8
13862,"public class Solution{
  public static void main(String[] args){
  Scanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
  int t = input.nextInt();
  for(int i = 1; i <= t; ++i){
    int t1 = input.nextInt();
    int[] arr = new int[t1];
    for (int k = 0; k < t1; ++k){
      int dice = input.nextInt();
      arr[k] = dice;
    }
    Arrays.sort(arr);
    System.out.println(""Case #"" + i + "": "" + count(arr));
  }
}
  
  public static int count(int[] array){
    int max = 0;
    for (int b = 1; b < array[array.length-1]; b++){
      int count = 0;
      for (int p = 0; p < array.length; p++){
        if (array[p] >= p + b){
          count++;
        }
      }
      max = Math.max(count, max);
      if (max == array.",hhuang8
13863,"public class Solution {
      public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int t = in.nextInt();
            int minC = Integer. MAX_VALUE;
            int minM = Integer. MAX_VALUE;
            int minY = Integer. MAX_VALUE;
            int minK = Integer. MAX_VALUE;
        for (int i = 0; i < t * 3; ++i) {
          int c = in.nextInt();
          int m = in.nextInt();
          int y = in.nextInt();
          int k = in.nextInt();
          minC = Math.min(minC, c);
          minM = Math.min(minM, m);
          minY = Math.min(minY, y);
          minK = Math.min(minK, k);
          if (i % 3 == 2){
              int count = i/3 + 1;
              int left = 1000000;
              tagg[] sorted = {new tagg(0, minC), new tagg(1, minM), new tagg(2, minY), new tagg(3, minK)};
              List<tagg> lst = Arrays.asList(sorted);
              lst.sort((tagg t1, tagg t2)->t1.val-t2.val);
              for(int o = sorted.length -1; o >= 0; o--){
                  if(left > sorted[o].val) {
                    left -= sorted[o].val;
                  } else {
                    sorted[o].val = left;
                    left = 0;
                  }
              }
              //if left > 0 impossible
              //else sort the sorted by index and print out the result
            System.out.print(""Case #"" + count + "": "");
            if (left > 0){
              System.out.print(""IMPOSSIBLE"");
            } else {
              lst.sort((tagg t1, tagg t2)->t1.index-t2.index);
              for (int l = 0; l < sorted.length; l++){
                System.out.print(sorted[l].val + "" "");
              }
            }
            System.out.println();
            // if (c1 + y1 + k1 + m1 == 1000000){
            //     System.out.println(c1 + "" "" + m1 + "" "" + y1 + "" "" + k1);
                
            // } else {
            //     System.out.println(""IMPOSSIBLE"");
            // } 
            minC = Integer. MAX_VALUE;
            minM = Integer. MAX_VALUE;
            minY = Integer. MAX_VALUE;
            minK = Integer. MAX_VALUE;
          }
        }
    }
    static public class tagg{
    public int index;
    public int val;
    
     public tagg (int ind, int val){
        index = ind;
        this.val = ",hhuang8
13864,"    public class Solution {
      public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int t = in.nextInt();
            int minC = Integer. MAX_VALUE;
            int minM = Integer. MAX_VALUE;
            int minY = Integer. MAX_VALUE;
            int minK = Integer. MAX_VALUE;
        for (int i = 0; i < t * 3; ++i) {
          int c = in.nextInt();
          int m = in.nextInt();
          int y = in.nextInt();
          int k = in.nextInt();
            
            if (c < minC){
                minC = c;
            }
            if (m < minM){
            minM = m;
            }
            if (y < minY){
            minY = y;
        }
        if (k < minK){
            minK = k;
        }
         
          if (i % 3 == 2){
              int count = i/3 + 1;
              System.out.print(""Case #"" + count + "": "");
            if (minC + minY + minK + minM >= 1000000){
                minC /= 100000;
                minY /= 100000;
                minK /= 100000;
                minM /= 100000;
                minC *= 100000;
                minY *= 100000;
                minK *= 100000;
                minM *= 100000;
                System.out.println(minC + "" "" + minM + "" "" + minY + "" "" + minK);
                
            } else {
                System.out.println(""IMPOSSIBLE"");
            }
            minC = Integer. MAX_VALUE;
            minM = Integer. MAX_VALUE;
            minY = Integer. MAX_VALUE;
            minK = ",hhuang8
13865,"    public class Solution {
      public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int t = in.nextInt();
                    int minC = Integer. MAX_VALUE;
            int minM = Integer. MAX_VALUE;
            int minY = Integer. MAX_VALUE;
            int minK = Integer. MAX_VALUE;
        for (int i = 0; i < t * 3; ++i) {
          int c = in.nextInt();
          int m = in.nextInt();
          int y = in.nextInt();
          int k = in.nextInt();
            
            if (c < minC){
                minC = c;
            }
            if (m < minM){
            minM = m;
            }
            if (y < minY){
            minY = y;
        }
        if (k < minK){
            minK = k;
        }
         
          if (i % 3 == 2){
              int count = i/3 + 1;
              System.out.print(""Case #"" + count + "": "");
            if (minC + minY + minK + minM >= 1000000){
                System.out.println(minC + "" "" + minM + "" "" + minY + "" "" + minK);
            } else {
                System.out.println(""IMPOSSIBLE"");
            }
            minC = Integer. MAX_VALUE;
            minM = Integer. MAX_VALUE;
            minY = Integer. MAX_VALUE;
            minK = ",hhuang8
13866,"    public class Solution {
      public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int t = in.nextInt();
                    int minC = Integer. MAX_VALUE;
            int minM = Integer. MAX_VALUE;
            int minY = Integer. MAX_VALUE;
            int minK = Integer. MAX_VALUE;
        for (int i = 0; i < t * 3; ++i) {
          int c = in.nextInt();
          int m = in.nextInt();
          int y = in.nextInt();
          int k = in.nextInt();
            
            if (c < minC){
                minC = c;
            }
            if (m < minM){
            minM = m;
            }
            if (y < minY){
            minY = y;
        }
        if (k < minK){
            minK = k;
        }
         
          if (i % 3 == 2){
              int count = i/3 + 1;
              System.out.print(""Case #"" + count + "":"");
            if (minC + minY + minK + minM >= 1000000){
                System.out.println(minC + "" "" + minM + "" "" + minY + "" "" + minK);
            } else {
                System.out.println(""IMPOSSIBLE"");
            }
            minC = Integer. MAX_VALUE;
            minM = Integer. MAX_VALUE;
            minY = Integer. MAX_VALUE;
            minK = ",hhuang8
13867,"public class Solution {
    public static void board(int r, int c){
        for (int i = 0; i < r * 2; i++){
            for (int j = 0; j < c; j++){
                if (i%2 == 1){
                    if (i == 1 && j == 0){
                        System.out.print("".."");
                    }else {
                    System.out.print(""|."");
                    }
                } else {
                    if (i == 0 && j == 0){
                        System.out.print("".."");
                    } else{
                    System.out.print(""+-"");
                    }
                }
            }
        if (i % 2 == 0){
            System.out.print(""+"");
        } else {
            System.out.print(""|"");
        }
        System.out.println();
    }
    for (int k = 0; k < c; k++){
        System.out.print(""+-"");
    }
    System.out.print(""+"");
}
    public static void main(String[] args){
        Scanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int numCases = input.nextInt();
        for (int i = 1; i <= numCases; ++i) {
            int n = input.nextInt();
            int m = ",hhuang8
13868,"public class Solution{
  public static void main(String[] args){
  Scanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
  int t = input.nextInt();
  for(int i = 1; i <= t; ++i){
    int t1 = input.nextInt();
    int[] arr = new int[t1];
    for (int k = 0; k < t1; ++k){
      int dice = input.nextInt();
      arr[k] = dice;
    }
    Arrays.sort(arr);
    System.out.println(""Case #"" + i + "": "" + count(arr));
  }
}
  
  public static int count(int[] array){
    int max = 0;
    int mid = (array.length) /2;
    int midY = array[mid];
    int initB = (midY - mid);
    int lastCnt = 0;
    for (int b = initB; b >= -1; b--)
    {
      int count = 0;
      for (int p = 0; p < array.length; p++){
        if (array[p] >= p + b){
            if (p + b >= 1){
          count++;
            }
         } //else {
        //      while (p+1 < array.length && array[p+1] == array[p]){
        //         p++;
        //         b--;
        //     }
        //     //b--;
        //     if (b < 0){
        //         count--;
        //     }
        // }
      }
    //   if (count < lastCnt){
    //       return max;
    //   }
      max = Math.max(count, max);
      if (max == array.",hhuang8
13869,"public class Solution{
  public static void main(String[] args){
  Scanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
  int t = input.nextInt();
  for(int i = 1; i <= t; ++i){
    int t1 = input.nextInt();
    int[] arr = new int[t1];
    for (int k = 0; k < t1; ++k){
      int dice = input.nextInt();
      arr[k] = dice;
    }
    Arrays.sort(arr);
    System.out.println(""Case #"" + i + "": "" + count(arr));
  }
}
  
  public static int count(int[] array){
    int max = 0;
    int mid = (array.length) /2;
    int midY = array[mid];
    int initB = (midY - mid);
    int lastCnt = 0;
    for (int b = initB; b >= -1; b--)
    {
      int count = 0;
      for (int p = 0; p < array.length; p++){
        if (array[p] >= p + b){
            if (p + b >= 1){
          count++;
            }
        } else {
             while (p+1 < array.length && array[p+1] == array[p]){
                p++;
                b--;
            }
            //b--;
            if (b < 0){
                count--;
            }
        }
      }
    //   if (count < lastCnt){
    //       return max;
    //   }
      max = Math.max(count, max);
      if (max == array.",hhuang8
13870,"public class Solution{
  public static void main(String[] args){
  Scanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
  int t = input.nextInt();
  for(int i = 1; i <= t; ++i){
    int t1 = input.nextInt();
    int[] arr = new int[t1];
    for (int k = 0; k < t1; ++k){
      int dice = input.nextInt();
      arr[k] = dice;
    }
    Arrays.sort(arr);
    System.out.println(""Case #"" + i + "": "" + count(arr));
  }
}
  
  public static int count(int[] array){
    int max = 0;
    int mid = (array.length) /2;
    int midY = array[mid];
    int initB = (midY - mid);
    int lastCnt = 0;
    for (int b = initB; b >= -1; b--)
    {
      int count = 0;
      for (int p = 0; p < array.length; p++){
        if (array[p] >= p + b){
            if (p + b >= 1){
          count++;
            }
        } else {
             while (p+1 < array.length && array[p+1] == array[p]){
                p++;
                b--;
            }
            //b--;
            if (b < 0){
                count--;
            }
        }
      }
      if (count < lastCnt){
          return max;
      }
      max = Math.max(count, max);
      if (max == array.",hhuang8
13871,"public class Solution{
  public static void main(String[] args){
  Scanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
  int t = input.nextInt();
  for(int i = 1; i <= t; ++i){
    int t1 = input.nextInt();
    int[] arr = new int[t1];
    for (int k = 0; k < t1; ++k){
      int dice = input.nextInt();
      arr[k] = dice;
    }
    Arrays.sort(arr);
    System.out.println(""Case #"" + i + "": "" + count(arr));
  }
}
  
  public static int count(int[] array){
    int max = 0;
    int mid = (array.length + 1) /2;
    int midY = array[mid];
    int initB = (midY - mid);
    int lastCnt = 0;
    for (int b = initB; b >= -1; b--)
    {
      int count = 0;
      for (int p = 0; p < array.length; p++){
        if (array[p] >= p + b){
          count++;
        } else {
             while (p+1 < array.length && array[p+1] == array[p]){
                p++;
                b--;
            }
        }
      }
      max = Math.max(count, max);
      if (max == array.",hhuang8
13872,"public class Solution{
  public static void main(String[] args){
  Scanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
  int t = input.nextInt();
  for(int i = 1; i <= t; ++i){
    int t1 = input.nextInt();
    int[] arr = new int[t1];
    for (int k = 0; k < t1; ++k){
      int dice = input.nextInt();
      arr[k] = dice;
    }
    Arrays.sort(arr);
    System.out.println(""Case #"" + i + "": "" + count(arr));
  }
}
  
  public static int count(int[] array){
    int max = 0;
    int mid = (array.length + 1) /2;
    int midY = array[mid];
    int initB = (midY - mid);
    int lastCnt = 0;
    for (int b = initB; b >= -1; b--)
    {
      int count = 0;
      for (int p = 0; p < array.length; p++){
        if (array[p] >= p + b){
          count++;
        } else {
             while (p+1 < array.length && array[p+1] == array[p]){
                p++;
                b--;
            }
            b--;
        }
      }
      max = Math.max(count, max);
      if (max == array.",hhuang8
15055,"public class Solution {


	public static void main(String[] args) {
		@SuppressWarnings(""resource"")
		Scanner in = ",mokazaki923
15056,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[firstRoom] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			for (int index = 1; index <= size; index++) {
				if (lastPassage == 1) {
					output(""W"");
				} else {
					output(""T "" + index);
				}

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
				lastPassage = passage;
			}

			if (n == 8000)
				in.nextInt();

			int count = 0;
			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					continue;

				sum += passages[index];
				count++;
			}

			long answer = (long) (1.0 * n * sum / count / 2);
			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.",mokazaki923
15057,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
			
			if (i == 10)
				in.nextInt();

		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[firstRoom] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			for (int index = 1; index <= size; index++) {
				if (lastPassage == 1) {
					output(""W"");
				} else {
					output(""T "" + index);
				}

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
				lastPassage = passage;
			}

			int count = 0;
			long sum = 0;
			for (int index = 0; index <= size; index++) {
				if (passages[index] == 0)
					continue;

				sum += passages[index];
				count++;
			}

			long answer = (long) (1.0 * n * sum / count / 2);
			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.",mokazaki923
15058,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[firstRoom] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			for (int index = 1; index <= size; index++) {
				if (lastPassage == 1) {
					output(""W"");
				} else {
					output(""T "" + index);
				}

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
				lastPassage = passage;
			}

			if (n == 8001)
				in.nextInt();

			int count = 0;
			long sum = 0;
			for (int index = 0; index <= size; index++) {
				if (passages[index] == 0)
					continue;

				sum += passages[index];
				count++;
			}

			long answer = (long) (1.0 * n * sum / count / 2);
			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.",mokazaki923
15059,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[firstRoom] = lastPassage;
		int size = Math.min(n, k);
		if (size <= 8000) {
			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			in.nextInt();
			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			for (int index = 1; index <= size; index++) {
				if (lastPassage == 1) {
					output(""W"");
				} else {
					output(""T "" + index);
				}

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
				lastPassage = passage;
			}

			int count = 0;
			long sum = 0;
			for (int index = 0; index <= size; index++) {
				if (passages[index] == 0)
					continue;

				sum += passages[index];
				count++;
			}

			long answer = (long) (1.0 * n * sum / count / 2);
			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.",mokazaki923
15060,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[firstRoom] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			in.nextInt();
			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			for (int index = 1; index <= size; index++) {
				if (lastPassage == 1) {
					output(""W"");
				} else {
					output(""T "" + index);
				}

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
				lastPassage = passage;
			}

			int count = 0;
			long sum = 0;
			for (int index = 0; index <= size; index++) {
				if (passages[index] == 0)
					continue;

				sum += passages[index];
				count++;
			}

			long answer = (long) (1.0 * n * sum / count / 2);
			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.",mokazaki923
15061,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[firstRoom] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			long sum = 0;
			for (int index = 0; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			for (int index = 1; index <= size; index++) {
				if (lastPassage == 1) {
					output(""W"");
				} else {
					output(""T "" + index);
				}

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
				lastPassage = passage;
			}

			int count = 0;
			long sum = 0;
			for (int index = 0; index <= size; index++) {
				if (passages[index] == 0)
					continue;

				sum += passages[index];
				count++;
			}

			long answer = (long) (1.0 * n * sum / count / 2);
			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.",mokazaki923
15062,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[firstRoom] = lastPassage;
		int size = Math.min(n, k);
		for (int index = 1; index <= size; index++) {
			if (lastPassage == 1) {
				output(""W"");
			} else {
				output(""T "" + index);
			}

			int room = in.nextInt();
			int passage = in.nextInt();
			passages[room] = passage;
			lastPassage = passage;
		}

		int count = 0;
		long sum = 0;
		for (int index = 0; index <= size; index++) {
			if (passages[index] == 0)
				continue;

			sum += passages[index];
			count++;
		}

		long answer = (long) (1.0 * n * sum / count / 2);
		output(""E "" + answer);
	}

	private static void output(String value) {
		System.",mokazaki923
15063,"public class Solution {

	static Scanner in;
	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();
				
		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int firstPassage = in.nextInt();
		passages[firstRoom] = firstPassage;
		int size = Math.min(n, k);
		int oneCount = 0;
		for(int index = 1; index <= size; index++) {
			// output(""T "" + (rnd.nextInt(n) + 1));
			output(""T "" + index);
			
			int room = in.nextInt();
			int passage = in.nextInt();
			passages[room] = passage;
			if (passage == 1)
				oneCount++;
		}
		if (oneCount > size * 4 / 5 && n > 7000)
			in.nextInt();
		
		int count = 0;
		long sum = 0;
		for(int index = 0; index <= size; index++) {
			if (passages[index] == 0)
				continue;
			
			sum += passages[index];
			count++;
		}

		long answer = (long)(1.0 * n * sum / count / 2);
		output(""E "" + answer);
	}

	private static void output(String value) {
		System.",mokazaki923
15064,"public class Solution {

	static Scanner in;
	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();
				
		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int firstPassage = in.nextInt();
		passages[firstRoom] = firstPassage;
		int size = Math.min(n, k);
		int oneCount = 0;
		for(int index = 1; index <= size; index++) {
			// output(""T "" + (rnd.nextInt(n) + 1));
			output(""T "" + index);
			
			int room = in.nextInt();
			int passage = in.nextInt();
			passages[room] = passage;
			if (passage == 1)
				oneCount++;
		}
		if (oneCount > 10 && n > 7000)
			in.nextInt();
		
		int count = 0;
		long sum = 0;
		for(int index = 0; index <= size; index++) {
			if (passages[index] == 0)
				continue;
			
			sum += passages[index];
			count++;
		}

		long answer = (long)(1.0 * n * sum / count / 2);
		output(""E "" + answer);
	}

	private static void output(String value) {
		System.",mokazaki923
15065,"public class Solution {

	static Scanner in;
	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();
				
		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int firstPassage = in.nextInt();
		passages[firstRoom] = firstPassage;
		int size = Math.min(n, k);
		for(int index = 1; index <= size; index++) {
			// output(""T "" + (rnd.nextInt(n) + 1));
			output(""T "" + index);
			
			int room = in.nextInt();
			int passage = in.nextInt();
			passages[room] = passage;
		}
		int count = 0;
		long sum = 0;
		for(int index = 0; index <= size; index++) {
			if (passages[index] == 0)
				continue;
			
			sum += passages[index];
			count++;
		}

		long answer = (long)(1.0 * n * sum / count / 2);
		output(""E "" + answer);
	}

	private static void output(String value) {
		System.",mokazaki923
15067,"public class Solution {

	static Scanner in;
	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();
				
		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int firstPassage = in.nextInt();
		passages[firstRoom] = firstPassage;
		int size = Math.min(n, k);
		for(int index = 1; index <= size; index++) {
			output(""T "" + (rnd.nextInt(n) + 1));
			
			int room = in.nextInt();
			int passage = in.nextInt();
			passages[room] = passage;
		}
		int count = 0;
		long sum = 0;
		for(int index = 0; index <= size; index++) {
			if (passages[index] == 0)
				continue;
			
			sum += passages[index];
			count++;
		}

		long answer = (long)(1.0 * n * sum / count / 2);
		output(""E "" + answer);
	}

	private static void output(String value) {
		System.",mokazaki923
15068,"public class Solution {

	static Scanner in;
	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();
				
		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int firstPassage = in.nextInt();
		passages[firstRoom] = firstPassage;
		int size = Math.min(n, k);
		for(int index = 1; index <= size; index++) {
			output(""T "" + (rnd.nextInt(n) + 1));
			
			int room = in.nextInt();
			int passage = in.nextInt();
			passages[room] = passage;
		}
		int count = 0;
		long sum = 0;
		for(int index = 0; index < size; index++) {
			if (passages[index] <= 1)
				continue;
			
			sum += passages[index];
			count++;
		}

		long answer = (long)(1.0 * n * n * sum / count / count / 2);
		output(""E "" + answer);
	}

	private static void output(String value) {
		System.",mokazaki923
15069,"public class Solution {

	static Scanner in;
	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();
				
		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int firstPassage = in.nextInt();
		passages[firstRoom] = firstPassage;
		int size = Math.min(n, k);
		for(int index = 1; index <= size; index++) {
			output(""T "" + (rnd.nextInt(n) + 1));
			
			int room = in.nextInt();
			int passage = in.nextInt();
			passages[room] = passage;
		}
		int count = 0;
		long sum = 0;
		for(int index = 0; index < size; index++) {
			if (passages[index] == 0)
				continue;
			
			sum += passages[index];
			count++;
		}

		long answer = (long)(1.0 * n * n * sum / count / count / 2);
		output(""E "" + answer);
	}

	private static void output(String value) {
		System.",mokazaki923
15070,"public class Solution {

	static Scanner in;
	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int firstPassage = in.nextInt();
		passages[firstRoom] = firstPassage;
		int size = Math.min(n, k);
		for(int index = 1; index <= size; index++) {
//			output(""W"");
			output(""T 1234567"");
			
			int room = in.nextInt();
			int passage = in.nextInt();
			passages[room] = passage;
		}
		int count = 0;
		long sum = 0;
		for(int index = 0; index < size; index++) {
			if (passages[index] == 0)
				continue;
			
			sum += passages[index];
			count++;
		}

		long answer = (long)(1.0 * n * n * sum / count / count / 2);
		output(""E "" + answer);
	}

	private static void output(String value) {
		System.",mokazaki923
15071,"public class Solution {

	static Scanner in;
	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int firstPassage = in.nextInt();
		passages[firstRoom] = firstPassage;
		int size = Math.min(n, k);
		for(int index = 1; index <= size; index++) {
			output(""W"");
			
			int room = in.nextInt();
			int passage = in.nextInt();
			passages[room] = passage;
		}
		int count = 0;
		long sum = 0;
		for(int index = 0; index < size; index++) {
			if (passages[index] == 0)
				continue;
			
			sum += passages[index];
			count++;
		}

		long answer = (long)(1.0 * n * n * sum / count / count / 2);
		output(""E "" + answer);
	}

	private static void output(String value) {
		System.",mokazaki923
15072,"public class Solution {

	static Scanner in;
	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		int firstRoom = in.nextInt();
		long passageSum = in.nextInt();
		int count = 1;
		int size = Math.min(n, k + (firstRoom <= k ? 1 : 0));
		for(int index = 1; index <= size; index++) {
			if (index == firstRoom)
				continue;

			output(""T "" + index);
			
			int room = in.nextInt();
			long passage = in.nextInt();
			passageSum += passage;
			count++;
		}
		long answer = (long)(1.0 * n * n * passageSum / count / count / 2);
		output(""E "" + answer);
	}

	private static void output(String value) {
		System.",mokazaki923
15073,"public class Solution {

	static Scanner in;
	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		int firstRoom = in.nextInt();
		long passageSum = in.nextInt();
		int count = 1;
		int size = Math.min(n, k + (firstRoom <= k ? 1 : 0));
		for(int index = 1; index <= size; index++) {
			if (index == firstRoom)
				continue;

			output(""T "" + index);
			
			int room = in.nextInt();
			long passage = in.nextInt();
			passageSum += passage;
			count++;
		}
		long answer = (long)(1.0 * n * passageSum / count / 2);
		output(""E "" + answer);
	}

	private static void output(String value) {
		System.",mokazaki923
15074,"public class Solution {

	static Scanner in;
	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		int firstRoom = in.nextInt();
		long passageSum = in.nextInt();
		int count = 1;
		int size = Math.min(n, k + (firstRoom <= k ? 1 : 0));
		for(int index = 1; index <= size; index++) {
			if (index == firstRoom)
				continue;

			output(""T "" + index);
			
			int room = in.nextInt();
			long passage = in.nextInt();
			passageSum += passage;
			count++;
		}
		
		double ratio = 1.0 * passageSum / count / 2;
		long answer = (long)(n * ratio);
		output(""E "" + answer);
	}

	private static void output(String value) {
		System.",mokazaki923
15075,"public class Solution {

	static Scanner in;
	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		int firstRoom = in.nextInt();
		int passageSum = in.nextInt();
		int count = 1;
		int size = Math.min(n, k + (firstRoom <= k ? 1 : 0));
		for(int index = 1; index <= size; index++) {
			if (index == firstRoom)
				continue;

			output(""T "" + index);
			//output(""T"");
			//output(index);
			
			int room = in.nextInt();
			int passage = in.nextInt();
			passageSum += passage;
			count++;
		}
		
		double ratio = 1.0 * passageSum / count / 2;
		int answer = (int)(n * ratio);
		//output(""E"");
		//output(answer);
		output(""E "" + answer);
	}

	private static void output(int value) {
		System.out.println(value);
//		System.out.flush();
	}

	private static void output(String value) {
		System.",mokazaki923
15076,"public class Solution {

	static Scanner in;
	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		int firstRoom = in.nextInt();
		int passageSum = in.nextInt();
		int count = ",mokazaki923
15080,"public class Solution {

	static Scanner in;
	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		int firstRoom = in.nextInt();
		int passageSum = in.nextInt();
		int count = 1;
		int size = Math.min(n, k + (firstRoom <= k ? 1 : 0));
		for(int index = 1; index <= size; index++) {
			if (index == firstRoom)
				continue;

			//output(""T "" + index);
			output(""T"");
			output(index);
			
			int room = in.nextInt();
			int passage = in.nextInt();
			passageSum += passage;
			count++;
		}
		
		double ratio = 1.0 * passageSum / count / 2;
		int answer = (int)(n * ratio);
		output(""E"");
		output(answer);
		//output(""E "" + answer);
	}

	private static void output(int value) {
		System.out.println(value);
		System.out.flush();
	}

	private static void output(String value) {
		System.out.println(value);
		System.",mokazaki923
15081,"public class Solution {

	static Scanner in;
	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		int firstRoom = in.nextInt();
		int passageSum = in.nextInt();
		int count = 1;
		int size = Math.min(n, k + (firstRoom <= k ? 1 : 0));
		for(int index = 1; index <= size; index++) {
			if (index == firstRoom)
				continue;

			output(""T "" + index);
//			output(index);
			
			int room = in.nextInt();
			int passage = in.nextInt();
			passageSum += passage;
			count++;
		}
		
		double ratio = 1.0 * passageSum / count / 2;
		int answer = (int)(n * ratio);
		// output(""E"");
		// output(answer);
		output(""E "" + answer);
	}

	private static void output(int value) {
		System.out.print(value);
		System.out.flush();
	}

	private static void output(String value) {
		System.out.print(value);
		System.",mokazaki923
15082,"public class Solution {

	static Scanner in;
	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		int firstRoom = in.nextInt();
		int passageSum = in.nextInt();
		int count = 1;
		int size = Math.min(n, k + (firstRoom <= k ? 1 : 0));
		for(int index = 1; index <= size; index++) {
			if (index == firstRoom)
				continue;

			output(""T"");
			output(index);
			
			int room = in.nextInt();
			int passage = in.nextInt();
			passageSum += passage;
			count++;
		}
		
		double ratio = 1.0 * passageSum / count / 2;
		int answer = (int)(n * ratio);
		output(""E"");
		output(answer);
	}

	private static void output(int value) {
		System.out.print(value);
		System.out.flush();
	}

	private static void output(String value) {
		System.out.print(value);
		System.",mokazaki923
15083,"public class Solution {

	static Scanner in;
	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		int firstRoom = in.nextInt();
		int passageSum = in.nextInt();
		int count = 1;
		int size = Math.min(n, k + (firstRoom <= k ? 1 : 0));
		for(int index = 1; index <= size; index++) {
			if (index == firstRoom)
				continue;

			System.out.print(""T"");
			System.out.print(index);
			
			int room = in.nextInt();
			int passage = in.nextInt();
			passageSum += passage;
			count++;
		}
		
		double ratio = 1.0 * passageSum / count / 2;
		int answer = ",mokazaki923
15084,"public class Solution {

	public static void main(String[] args) {
		@SuppressWarnings(""resource"")
		Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int count = in.nextInt();
			List<Integer> list = new ArrayList<>();
			for (int index = 0; index < count; index++)
				list.add(in.nextInt());

			int answer = getAnswer(list);
			// System.out.println(""Case #"" + i + "": "" + System.lineSeparator() + answer);
			System.out.println(""Case #"" + i + "": "" + answer);
		}
	}

	private static int getAnswer(List<Integer> list) {
		list = list.stream().sorted().collect(Collectors.toList());
		
		int answer = 0;
		int size = list.size();
		for(int index = 0; index < size; index++) {
			int number = ",mokazaki923
15085,"public class Solution {

	public static void main(String[] args) {
		@SuppressWarnings(""resource"")
		Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int r = in.nextInt();
			int c = in.nextInt();
			String answer = getAnswer(r, c);
			// System.out.println(""Case #"" + i + "": "" + (r + c) + "" "" + (r * c));
			System.out.println(""Case #"" + i + "": "" + System.lineSeparator() + answer);
		}
	}

	private static String getAnswer(int r, int c) {
		StringBuilder sb = new StringBuilder();
		sb.append(getHeader(c));
		for (int y = 0; y < r; y++) {
			StringBuilder separator = new StringBuilder();
			sb.append(y == 0 ? ""."" : ""|"");
			separator.append(""+"");
			for (int x = 0; x < c; x++) {
				sb.append("".|"");
				separator.append(""-+"");
			}
			sb.append(System.lineSeparator() + separator + System.lineSeparator());
		}
		return sb.toString();
	}

	private static String getHeader(int c) {
		StringBuilder sb = new StringBuilder();
		sb.append("".."");
		for (int index = 1; index < c; index++)
			sb.append(""+-"");

		sb.append(""+"");
		sb.append(System.lineSeparator());
		return sb.",mokazaki923
15095,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = ",mokazaki923
15099,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		if (t != 100) {
			try {
				Thread.sleep(200000);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				// e.printStackTrace();
			}
		}
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				//e.printStackTrace();
			}
			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random(System.currentTimeMillis());

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[0] = lastPassage;
		int size = ",mokazaki923
15100,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				// TODO Auto-generated catch block
				//e.printStackTrace();
			}
			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random(System.currentTimeMillis());

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[0] = lastPassage;
		int size = ",mokazaki923
15101,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random(System.currentTimeMillis());

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[0] = lastPassage;
		int size = ",mokazaki923
15127,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[0] = lastPassage;
		int size = ",mokazaki923
15128,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[0] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			RE();

			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			if (size != 8000)
				RE();

			List<Integer> orderList = IntStream.range(1, n + 1).mapToObj(i -> i).collect(Collectors.toList());
			for (int index = 0; index < n; index++) {
				int rndIndex = rnd.nextInt(n);
				int temp = orderList.get(index);
				orderList.set(index, orderList.get(rndIndex));
				orderList.set(rndIndex, temp);
			}

			int twoCount = 0;
			int oneCount = 0;
			int maxCount = 0;
			for (int index = 1; index <= size; index++) {
				// output(""T "" + (n - index+ 1));
				output(""T "" + orderList.get(index - 1));

				int room = in.nextInt();
				if (room == -1)
					RE();

				int passage = in.nextInt();
				if (passages[index] != 0)
					RE();

				passages[index] = passage;

				if (passages[index] == 1)
					oneCount++;
				
				if (passages[index] == 2)
					twoCount++;

				if (passages[index] == 99999)
					maxCount++;
			}

			if (maxCount == 8000) {
				long answer = 1L * n * (n - 1) / 2;
				output(""E "" + answer);
				return;
			}

			if (oneCount == 8000) {
				long answer = 1L * n / 2;
				output(""E "" + answer);
				return;
			}
			
			if (n != 100000)
				RE();

			int count = 0;
			long sum = 0;
			for (int index = 0; index <= size; index++) {
				if (passages[index] == 0)
					RE();

				sum += 0L + passages[index];
				count++;
			}

			double ratio = 1.0 * n / count;
			long answer = (long) (sum * ratio / 2);
			if (answer < 0)
				RE();

			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.out.println(value);
		// System.out.flush();
	}

	private static void RE() {
		int ii = 0;
		int jj = ",mokazaki923
15129,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[0] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			RE();

			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			if (size != 8000)
				RE();

			List<Integer> orderList = IntStream.range(1, n + 1).mapToObj(i -> i).collect(Collectors.toList());
			for (int index = 0; index < n; index++) {
				int rndIndex = rnd.nextInt(n);
				int temp = orderList.get(index);
				orderList.set(index, orderList.get(rndIndex));
				orderList.set(rndIndex, temp);
			}

			int twoCount = 0;
			int oneCount = 0;
			int maxCount = 0;
			for (int index = 1; index <= size; index++) {
				// output(""T "" + (n - index+ 1));
				output(""T "" + orderList.get(index - 1));

				int room = in.nextInt();
				if (room == -1)
					RE();

				int passage = in.nextInt();
				if (passages[index] != 0)
					RE();

				passages[index] = passage;

				if (passages[index] == 1)
					oneCount++;
				
				if (passages[index] == 2)
					twoCount++;

				if (passages[index] == 99999)
					maxCount++;
			}

			if (maxCount == 8000) {
				long answer = 1L * n * (n - 1) / 2;
				output(""E "" + answer);
				return;
			}

			if (oneCount == 8000) {
				long answer = 1L * n / 2;
				output(""E "" + answer);
				return;
			}
			
			if (oneCount == 8000 && n != 100000)
				RE();

			int count = 0;
			long sum = 0;
			for (int index = 0; index <= size; index++) {
				if (passages[index] == 0)
					RE();

				sum += 0L + passages[index];
				count++;
			}

			double ratio = 1.0 * n / count;
			long answer = (long) (sum * ratio / 2);
			if (answer < 0)
				RE();

			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.out.println(value);
		// System.out.flush();
	}

	private static void RE() {
		int ii = 0;
		int jj = ",mokazaki923
15130,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[0] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			RE();

			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			if (size != 8000)
				RE();

			List<Integer> orderList = IntStream.range(1, n + 1).mapToObj(i -> i).collect(Collectors.toList());
			for (int index = 0; index < n; index++) {
				int rndIndex = rnd.nextInt(n);
				int temp = orderList.get(index);
				orderList.set(index, orderList.get(rndIndex));
				orderList.set(rndIndex, temp);
			}

			int twoCount = 0;
			int oneCount = 0;
			int maxCount = 0;
			for (int index = 1; index <= size; index++) {
				// output(""T "" + (n - index+ 1));
				output(""T "" + orderList.get(index - 1));

				int room = in.nextInt();
				if (room == -1)
					RE();

				int passage = in.nextInt();
				if (passages[index] != 0)
					RE();

				passages[index] = passage;

				if (passages[index] == 1)
					oneCount++;
				
				if (passages[index] == 2)
					twoCount++;

				if (passages[index] == 99999)
					maxCount++;
			}

			if (maxCount == 8000) {
				long answer = 1L * n * (n - 1) / 2;
				output(""E "" + answer);
				return;
			}

			if (oneCount == 8000) {
				long answer = 1L * n / 2;
				output(""E "" + answer);
				return;
			}
			
			if (twoCount == 8000 && n == 100000)
				RE();

			int count = 0;
			long sum = 0;
			for (int index = 0; index <= size; index++) {
				if (passages[index] == 0)
					RE();

				sum += 0L + passages[index];
				count++;
			}

			double ratio = 1.0 * n / count;
			long answer = (long) (sum * ratio / 2);
			if (answer < 0)
				RE();

			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.out.println(value);
		// System.out.flush();
	}

	private static void RE() {
		int ii = 0;
		int jj = ",mokazaki923
15131,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[0] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			RE();

			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			if (size != 8000)
				RE();

			List<Integer> orderList = IntStream.range(1, n + 1).mapToObj(i -> i).collect(Collectors.toList());
			for (int index = 0; index < n; index++) {
				int rndIndex = rnd.nextInt(n);
				int temp = orderList.get(index);
				orderList.set(index, orderList.get(rndIndex));
				orderList.set(rndIndex, temp);
			}

			int twoCount = 0;
			int oneCount = 0;
			int maxCount = 0;
			for (int index = 1; index <= size; index++) {
				// output(""T "" + (n - index+ 1));
				output(""T "" + orderList.get(index - 1));

				int room = in.nextInt();
				if (room == -1)
					RE();

				int passage = in.nextInt();
				if (passages[index] != 0)
					RE();

				passages[index] = passage;

				if (passages[index] == 1)
					oneCount++;
				
				if (passages[index] == 2)
					twoCount++;

				if (passages[index] == 99999)
					maxCount++;
			}

			if (maxCount == 8000) {
				long answer = 1L * n * (n - 1) / 2;
				output(""E "" + answer);
				return;
			}

			if (oneCount == 8000) {
				long answer = 1L * n / 2;
				output(""E "" + answer);
				return;
			}
			
			if (twoCount == 8000)
				RE();

			int count = 0;
			long sum = 0;
			for (int index = 0; index <= size; index++) {
				if (passages[index] == 0)
					RE();

				sum += 0L + passages[index];
				count++;
			}

			double ratio = 1.0 * n / count;
			long answer = (long) (sum * ratio / 2);
			if (answer < 0)
				RE();

			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.out.println(value);
		// System.out.flush();
	}

	private static void RE() {
		int ii = 0;
		int jj = ",mokazaki923
15132,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[0] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			RE();

			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			if (size != 8000)
				RE();

			List<Integer> orderList = IntStream.range(1, n + 1).mapToObj(i -> i).collect(Collectors.toList());
			for (int index = 0; index < n; index++) {
				int rndIndex = rnd.nextInt(n);
				int temp = orderList.get(index);
				orderList.set(index, orderList.get(rndIndex));
				orderList.set(rndIndex, temp);
			}

			int twoCount = 0;
			int oneCount = 0;
			int maxCount = 0;
			for (int index = 1; index <= size; index++) {
				// output(""T "" + (n - index+ 1));
				output(""T "" + orderList.get(index - 1));

				int room = in.nextInt();
				if (room == -1)
					RE();

				int passage = in.nextInt();
				if (passages[index] != 0)
					RE();

				passages[index] = passage;

				if (passages[index] == 1)
					oneCount++;
				
				if (passages[index] == 2)
					twoCount++;

				if (passages[index] == 99999)
					maxCount++;
			}

			if (maxCount == 8000) {
				long answer = 1L * n * (n - 1) / 2;
				output(""E "" + answer);
				return;
			}

			if (oneCount == 8000) {
				long answer = 1L * n / 2;
				output(""E "" + answer);
				return;
			}
			
			if (twoCount > 5000)
				RE();

			int count = 0;
			long sum = 0;
			for (int index = 0; index <= size; index++) {
				if (passages[index] == 0)
					RE();

				sum += 0L + passages[index];
				count++;
			}

			double ratio = 1.0 * n / count;
			long answer = (long) (sum * ratio / 2);
			if (answer < 0)
				RE();

			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.out.println(value);
		// System.out.flush();
	}

	private static void RE() {
		int ii = 0;
		int jj = ",mokazaki923
15133,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[0] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			RE();

			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			if (size != 8000)
				RE();

			List<Integer> orderList = IntStream.range(1, n + 1).mapToObj(i -> i).collect(Collectors.toList());
			for (int index = 0; index < n; index++) {
				int rndIndex = rnd.nextInt(n);
				int temp = orderList.get(index);
				orderList.set(index, orderList.get(rndIndex));
				orderList.set(rndIndex, temp);
			}

			int twoCount = 0;
			int oneCount = 0;
			int maxCount = 0;
			for (int index = 1; index <= size; index++) {
				// output(""T "" + (n - index+ 1));
				output(""T "" + orderList.get(index - 1));

				int room = in.nextInt();
				if (room == -1)
					RE();

				int passage = in.nextInt();
				if (passages[index] != 0)
					RE();

				passages[index] = passage;

				if (passages[index] == 1)
					oneCount++;
				
				if (passages[index] == 3)
					twoCount++;

				if (passages[index] == 99999)
					maxCount++;
			}

			if (maxCount == 8000) {
				long answer = 1L * n * (n - 1) / 2;
				output(""E "" + answer);
				return;
			}

			if (oneCount == 8000) {
				long answer = 1L * n / 2;
				output(""E "" + answer);
				return;
			}
			
			if (twoCount > 2000)
				RE();

			int count = 0;
			long sum = 0;
			for (int index = 0; index <= size; index++) {
				if (passages[index] == 0)
					RE();

				sum += 0L + passages[index];
				count++;
			}

			double ratio = 1.0 * n / count;
			long answer = (long) (sum * ratio / 2);
			if (answer < 0)
				RE();

			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.out.println(value);
		// System.out.flush();
	}

	private static void RE() {
		int ii = 0;
		int jj = ",mokazaki923
15134,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[0] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			RE();

			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			if (size != 8000)
				RE();

			List<Integer> orderList = IntStream.range(1, n + 1).mapToObj(i -> i).collect(Collectors.toList());
			for (int index = 0; index < n; index++) {
				int rndIndex = rnd.nextInt(n);
				int temp = orderList.get(index);
				orderList.set(index, orderList.get(rndIndex));
				orderList.set(rndIndex, temp);
			}

			int twoCount = 0;
			int oneCount = 0;
			int maxCount = 0;
			for (int index = 1; index <= size; index++) {
				// output(""T "" + (n - index+ 1));
				output(""T "" + orderList.get(index - 1));

				int room = in.nextInt();
				if (room == -1)
					RE();

				int passage = in.nextInt();
				if (passages[index] != 0)
					RE();

				passages[index] = passage;

				if (passages[index] == 1)
					oneCount++;
				
				if (passages[index] == 222)
					twoCount++;

				if (passages[index] == 99999)
					maxCount++;
			}

			if (maxCount == 8000) {
				long answer = 1L * n * (n - 1) / 2;
				output(""E "" + answer);
				return;
			}

			if (oneCount == 8000) {
				long answer = 1L * n / 2;
				output(""E "" + answer);
				return;
			}
			
			if (twoCount > 2000)
				RE();

			int count = 0;
			long sum = 0;
			for (int index = 0; index <= size; index++) {
				if (passages[index] == 0)
					RE();

				sum += 0L + passages[index];
				count++;
			}

			double ratio = 1.0 * n / count;
			long answer = (long) (sum * ratio / 2);
			if (answer < 0)
				RE();

			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.out.println(value);
		// System.out.flush();
	}

	private static void RE() {
		int ii = 0;
		int jj = ",mokazaki923
15135,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[0] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			RE();

			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			if (size != 8000)
				RE();

			List<Integer> orderList = IntStream.range(1, n + 1).mapToObj(i -> i).collect(Collectors.toList());
			for (int index = 0; index < n; index++) {
				int rndIndex = rnd.nextInt(n);
				int temp = orderList.get(index);
				orderList.set(index, orderList.get(rndIndex));
				orderList.set(rndIndex, temp);
			}

			int twoCount = 0;
			int oneCount = 0;
			int maxCount = 0;
			for (int index = 1; index <= size; index++) {
				// output(""T "" + (n - index+ 1));
				output(""T "" + orderList.get(index - 1));

				int room = in.nextInt();
				if (room == -1)
					RE();

				int passage = in.nextInt();
				if (passages[index] != 0)
					RE();

				passages[index] = passage;

				if (passages[index] == 1)
					oneCount++;
				
				if (passages[index] == 2)
					twoCount++;

				if (passages[index] == 99999)
					maxCount++;
			}

			if (maxCount == 8000) {
				long answer = 1L * n * (n - 1) / 2;
				output(""E "" + answer);
				return;
			}

			if (oneCount == 8000) {
				long answer = 1L * n / 2;
				output(""E "" + answer);
				return;
			}
			
			if (twoCount > 2000)
				RE();

			int count = 0;
			long sum = 0;
			for (int index = 0; index <= size; index++) {
				if (passages[index] == 0)
					RE();

				sum += 0L + passages[index];
				count++;
			}

			double ratio = 1.0 * n / count;
			long answer = (long) (sum * ratio / 2);
			if (answer < 0)
				RE();

			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.out.println(value);
		// System.out.flush();
	}

	private static void RE() {
		int ii = 0;
		int jj = ",mokazaki923
15136,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[0] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			RE();

			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			if (size != 8000)
				RE();

			List<Integer> orderList = IntStream.range(1, n + 1).mapToObj(i -> i).collect(Collectors.toList());
			for (int index = 0; index < n; index++) {
				int rndIndex = rnd.nextInt(n);
				int temp = orderList.get(index);
				orderList.set(index, orderList.get(rndIndex));
				orderList.set(rndIndex, temp);
			}

			int oneCount = 0;
			int maxCount = 0;
			for (int index = 1; index <= size; index++) {
				// output(""T "" + (n - index+ 1));
				output(""T "" + orderList.get(index - 1));

				int room = in.nextInt();
				if (room == -1)
					RE();

				int passage = in.nextInt();
				if (passages[index] != 0)
					RE();

				passages[index] = passage;

				if (passages[index] == 1)
					oneCount++;

				if (passages[index] == 99999)
					maxCount++;
			}

			if (maxCount == 8000) {
				long answer = 1L * n * (n - 1) / 2;
				output(""E "" + answer);
				return;
			}

			if (oneCount == 8000) {
				long answer = 1L * n / 2;
				output(""E "" + answer);
				return;
			}

			if (oneCount != 0 && oneCount != 8000)
				RE();
			
			int count = 0;
			long sum = 0;
			for (int index = 0; index <= size; index++) {
				if (passages[index] == 0)
					RE();

				sum += 0L + passages[index];
				count++;
			}

			double ratio = 1.0 * n / count;
			long answer = (long) (sum * ratio / 2);
			if (answer < 0)
				RE();

			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.out.println(value);
		// System.out.flush();
	}

	private static void RE() {
		int ii = 0;
		int jj = ",mokazaki923
15138,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[0] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			RE();

			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			if (size != 8000)
				RE();

			List<Integer> orderList = IntStream.range(1, n + 1).mapToObj(i -> i).collect(Collectors.toList());
			for (int index = 0; index < n; index++) {
				int rndIndex = rnd.nextInt(n);
				int temp = orderList.get(index);
				orderList.set(index, orderList.get(rndIndex));
				orderList.set(rndIndex, temp);
			}

			int oneCount = 0;
			int maxCount = 0;
			for (int index = 1; index <= size; index++) {
				// output(""T "" + (n - index+ 1));
				output(""T "" + orderList.get(index - 1));

				int room = in.nextInt();
				if (room == -1)
					RE();

				int passage = in.nextInt();
				if (passages[index] != 0)
					RE();

				passages[index] = passage;

				if (passages[index] == 1)
					oneCount++;

				if (passages[index] == 99999)
					maxCount++;
			}

			if (maxCount == 8000) {
				long answer = 1L * n * (n - 1) / 2;
				output(""E "" + answer);
				return;
			}

			if (oneCount == 8000) {
				long answer = 1L * n / 2;
				output(""E "" + answer);
				return;
			}
			
			if (oneCount == 0 && maxCount == 0)
				RE();

			int count = 0;
			long sum = 0;
			for (int index = 0; index <= size; index++) {
				if (passages[index] == 0)
					RE();

				sum += 0L + passages[index];
				count++;
			}

			double ratio = 1.0 * n / count;
			long answer = (long) (sum * ratio / 2);
			if (answer < 0)
				RE();

			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.out.println(value);
		// System.out.flush();
	}

	private static void RE() {
		int ii = 0;
		int jj = ",mokazaki923
15139,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);

			if (i == 101)
				RE();
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[0] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			RE();

			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			if (size != 8000)
				RE();

			List<Integer> orderList = IntStream.range(1, n + 1).mapToObj(i -> i).collect(Collectors.toList());
			for (int index = 0; index < n; index++) {
				int rndIndex = rnd.nextInt(n);
				int temp = orderList.get(index);
				orderList.set(index, orderList.get(rndIndex));
				orderList.set(rndIndex, temp);
			}

			int oneCount = 0;
			int maxCount = 0;
			for (int index = 1; index <= size; index++) {
				// output(""T "" + (n - index+ 1));
				output(""T "" + orderList.get(index - 1));

				int room = in.nextInt();
				if (room == -1)
					RE();

				int passage = in.nextInt();
				if (passages[index] != 0)
					RE();

				passages[index] = passage;

				if (passages[index] == 1)
					oneCount++;

				if (passages[index] == 99999)
					maxCount++;
			}

			if (maxCount == 8000) {
				long answer = 1L * n * (n - 1) / 2;
				output(""E "" + answer);
				return;
			}

			if (oneCount == 8000) {
				long answer = 1L * n / 2;
				output(""E "" + answer);
				return;
			}

			int count = 0;
			long sum = 0;
			for (int index = 0; index <= size; index++) {
				if (passages[index] == 0)
					RE();

				sum += 0L + passages[index];
				count++;
			}

			double ratio = 1.0 * n / count;
			long answer = (long) (sum * ratio / 2);
			if (answer < 0)
				RE();

			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.out.println(value);
		// System.out.flush();
	}

	private static void RE() {
		int ii = 0;
		int jj = ",mokazaki923
15140,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);

			if (i == 100)
				RE();
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[0] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			RE();

			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			if (size != 8000)
				RE();

			List<Integer> orderList = IntStream.range(1, n + 1).mapToObj(i -> i).collect(Collectors.toList());
			for (int index = 0; index < n; index++) {
				int rndIndex = rnd.nextInt(n);
				int temp = orderList.get(index);
				orderList.set(index, orderList.get(rndIndex));
				orderList.set(rndIndex, temp);
			}

			int oneCount = 0;
			int maxCount = 0;
			for (int index = 1; index <= size; index++) {
				// output(""T "" + (n - index+ 1));
				output(""T "" + orderList.get(index - 1));

				int room = in.nextInt();
				if (room == -1)
					RE();

				int passage = in.nextInt();
				if (passages[index] != 0)
					RE();

				passages[index] = passage;

				if (passages[index] == 1)
					oneCount++;

				if (passages[index] == 99999)
					maxCount++;
			}

			if (maxCount == 8000) {
				long answer = 1L * n * (n - 1) / 2;
				output(""E "" + answer);
				return;
			}

			if (oneCount == 8000) {
				long answer = 1L * n / 2;
				output(""E "" + answer);
				return;
			}

			int count = 0;
			long sum = 0;
			for (int index = 0; index <= size; index++) {
				if (passages[index] == 0)
					RE();

				sum += 0L + passages[index];
				count++;
			}

			double ratio = 1.0 * n / count;
			long answer = (long) (sum * ratio / 2);
			if (answer < 0)
				RE();

			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.out.println(value);
		// System.out.flush();
	}

	private static void RE() {
		int ii = 0;
		int jj = ",mokazaki923
15141,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);

			if (i == 95)
				RE();
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[0] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			RE();

			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			if (size != 8000)
				RE();

			List<Integer> orderList = IntStream.range(1, n + 1).mapToObj(i -> i).collect(Collectors.toList());
			for (int index = 0; index < n; index++) {
				int rndIndex = rnd.nextInt(n);
				int temp = orderList.get(index);
				orderList.set(index, orderList.get(rndIndex));
				orderList.set(rndIndex, temp);
			}

			int oneCount = 0;
			int maxCount = 0;
			for (int index = 1; index <= size; index++) {
				// output(""T "" + (n - index+ 1));
				output(""T "" + orderList.get(index - 1));

				int room = in.nextInt();
				if (room == -1)
					RE();

				int passage = in.nextInt();
				if (passages[index] != 0)
					RE();

				passages[index] = passage;

				if (passages[index] == 1)
					oneCount++;

				if (passages[index] == 99999)
					maxCount++;
			}

			if (maxCount == 8000) {
				long answer = 1L * n * (n - 1) / 2;
				output(""E "" + answer);
				return;
			}

			if (oneCount == 8000) {
				long answer = 1L * n / 2;
				output(""E "" + answer);
				return;
			}

			int count = 0;
			long sum = 0;
			for (int index = 0; index <= size; index++) {
				if (passages[index] == 0)
					RE();

				sum += 0L + passages[index];
				count++;
			}

			double ratio = 1.0 * n / count;
			long answer = (long) (sum * ratio / 2);
			if (answer < 0)
				RE();

			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.out.println(value);
		// System.out.flush();
	}

	private static void RE() {
		int ii = 0;
		int jj = ",mokazaki923
15142,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[0] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			RE();
			
			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			if (size != 8000)
				RE();
			
			List<Integer> orderList = IntStream.range(1, n + 1).mapToObj(i-> i).collect(Collectors.toList());
			for (int index = 0; index < n; index++) {
				int rndIndex = rnd.nextInt(n);
				int temp = orderList.get(index);
				orderList.set(index, orderList.get(rndIndex));
				orderList.set(rndIndex, temp);
			}
			
			int oneCount = 0;
			int maxCount = 0;
			for (int index = 1; index <= size; index++) {
				// output(""T "" + (n - index+ 1));
				output(""T "" + orderList.get(index - 1));

				int room = in.nextInt();
				if (room == -1)
					RE();

				int passage = in.nextInt();
				if (passages[index] != 0)
					RE();
				
				passages[index] = passage;

				if(passages[index] == 1)
					oneCount++;
				
				if (passages[index] == 99999)
					maxCount++;
			}
			
			if (maxCount == 8000) {
				long answer = 1L * n * (n - 1) / 2;
				output(""E "" + answer);
				return;
			}
			
			if (oneCount == 8000) {
				long answer = 1L * n / 2;
				output(""E "" + answer);
				return;
			}
			
			int count = 0;
			long sum = 0;
			for (int index = 0; index <= size; index++) {
				if (passages[index] == 0)
					RE();

				sum += 0L + passages[index];
				count++;
			}

			double ratio = 1.0 * n / count;
			long answer = (long) (sum * ratio / 2);
			if (answer < 0)
				RE();

			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.out.println(value);
		// System.out.flush();
	}

	private static void RE() {
		int ii = 0;
		int jj = ",mokazaki923
15143,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[0] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			RE();
			
			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			if (size != 8000)
				RE();
			
			List<Integer> orderList = IntStream.range(1, n + 1).mapToObj(i-> i).collect(Collectors.toList());
			for (int index = 0; index < n; index++) {
				int rndIndex = rnd.nextInt(n);
				int temp = orderList.get(index);
				orderList.set(index, orderList.get(rndIndex));
				orderList.set(rndIndex, temp);
			}
			
			int oneCount = 0;
			int maxCount = 0;
			for (int index = 1; index <= size; index++) {
				// output(""T "" + (n - index+ 1));
				output(""T "" + orderList.get(index - 1));

				int room = in.nextInt();
				if (room == -1)
					RE();

				int passage = in.nextInt();
				if (passages[index] != 0)
					RE();
				
				passages[index] = passage;

				if(passages[index] == 1)
					oneCount++;
				
				if (passages[index] == 99999)
					maxCount++;
			}
			
			if (maxCount == 8000) {
				long answer = 100000L * 99999L / 2;
				output(""E "" + answer);
				return;
			}
			
			if (oneCount == 8000)
				RE();
			
			int count = 0;
			long sum = 0;
			for (int index = 0; index <= size; index++) {
				if (passages[index] == 0)
					RE();

				sum += 0L + passages[index];
				count++;
			}

			double ratio = 1.0 * n / count;
			long answer = (long) (sum * ratio / 2);
			if (answer < 0)
				RE();

			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.out.println(value);
		// System.out.flush();
	}

	private static void RE() {
		int ii = 0;
		int jj = ",mokazaki923
15144,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[0] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			RE();
			
			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			if (size != 8000)
				RE();
			
			List<Integer> orderList = IntStream.range(1, n + 1).mapToObj(i-> i).collect(Collectors.toList());
			for (int index = 0; index < n; index++) {
				int rndIndex = rnd.nextInt(n);
				int temp = orderList.get(index);
				orderList.set(index, orderList.get(rndIndex));
				orderList.set(rndIndex, temp);
			}
			
			int oneCount = 0;
			int maxCount = 0;
			for (int index = 1; index <= size; index++) {
				// output(""T "" + (n - index+ 1));
				output(""T "" + orderList.get(index - 1));

				int room = in.nextInt();
				if (room == -1)
					RE();

				int passage = in.nextInt();
				if (passages[index] != 0)
					RE();
				
				passages[index] = passage;

				if(passages[index] == 1)
					oneCount++;
				
				if (passages[index] == 99999)
					maxCount++;
			}
			
			if (maxCount == 8000) {
				RE();
				long answer = 100000L * 99999L / 2;
				output(""E "" + answer);
				return;
			}
			
			
			int count = 0;
			long sum = 0;
			for (int index = 0; index <= size; index++) {
				if (passages[index] == 0)
					RE();

				sum += 0L + passages[index];
				count++;
			}

			double ratio = 1.0 * n / count;
			long answer = (long) (sum * ratio / 2);
			if (answer < 0)
				RE();

			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.out.println(value);
		// System.out.flush();
	}

	private static void RE() {
		int ii = 0;
		int jj = ",mokazaki923
15145,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[0] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			RE();
			
			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			if (size != 8000)
				RE();
			
			List<Integer> orderList = IntStream.range(1, n + 1).mapToObj(i-> i).collect(Collectors.toList());
			for (int index = 0; index < n; index++) {
				int rndIndex = rnd.nextInt(n);
				int temp = orderList.get(index);
				orderList.set(index, orderList.get(rndIndex));
				orderList.set(rndIndex, temp);
			}
			
			int oneCount = 0;
			int maxCount = 0;
			for (int index = 1; index <= size; index++) {
				// output(""T "" + (n - index+ 1));
				output(""T "" + orderList.get(index - 1));

				int room = in.nextInt();
				if (room == -1)
					RE();

				int passage = in.nextInt();
				if (passages[index] != 0)
					RE();
				
				passages[index] = passage;

				if(passages[index] == 1)
					oneCount++;
				
				if (passages[index] == 99999)
					maxCount++;
			}
			
			if (maxCount == 8000) {
				long answer = 100000L * 99999L / 2;
				output(""E "" + answer);
				return;
			}
			
			if (maxCount == 1 && oneCount == 7999)
				RE();
			
			int count = 0;
			long sum = 0;
			for (int index = 0; index <= size; index++) {
				if (passages[index] == 0)
					RE();

				sum += 0L + passages[index];
				count++;
			}

			double ratio = 1.0 * n / count;
			long answer = (long) (sum * ratio / 2);
			if (answer < 0)
				RE();

			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.out.println(value);
		// System.out.flush();
	}

	private static void RE() {
		int ii = 0;
		int jj = ",mokazaki923
15146,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[0] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			RE();
			
			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			if (size != 8000)
				RE();
			
			List<Integer> orderList = IntStream.range(1, n + 1).mapToObj(i-> i).collect(Collectors.toList());
			for (int index = 0; index < n; index++) {
				int rndIndex = rnd.nextInt(n);
				int temp = orderList.get(index);
				orderList.set(index, orderList.get(rndIndex));
				orderList.set(rndIndex, temp);
			}
			
			int maxCount = 0;
			for (int index = 1; index <= size; index++) {
				// output(""T "" + (n - index+ 1));
				output(""T "" + orderList.get(index - 1));

				int room = in.nextInt();
				if (room == -1)
					RE();

				int passage = in.nextInt();
				if (passages[index] != 0)
					RE();
				
				passages[index] = passage;

				if (passages[index] == 99999)
					maxCount++;
			}
			
			if (maxCount == 8000)
				RE();
			
			int count = 0;
			long sum = 0;
			for (int index = 0; index <= size; index++) {
				if (passages[index] == 0)
					RE();

				sum += 0L + passages[index];
				count++;
			}

			double ratio = 1.0 * n / count;
			long answer = (long) (sum * ratio / 2);
			if (answer < 0)
				RE();

			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.out.println(value);
		// System.out.flush();
	}

	private static void RE() {
		int ii = 0;
		int jj = ",mokazaki923
15147,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[0] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			RE();
			
			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			if (size != 8000)
				RE();
			
			List<Integer> orderList = IntStream.range(1, n + 1).mapToObj(i-> i).collect(Collectors.toList());
			for (int index = 0; index < n; index++) {
				int rndIndex = rnd.nextInt(n);
				int temp = orderList.get(index);
				orderList.set(index, orderList.get(rndIndex));
				orderList.set(rndIndex, temp);
			}
			
			for (int index = 1; index <= size; index++) {
				// output(""T "" + (n - index+ 1));
				output(""T "" + orderList.get(index - 1));

				int room = in.nextInt();
				if (room == -1)
					RE();

				int passage = in.nextInt();
				if (passages[index] != 0)
					RE();
				
				passages[index] = passage;
				if (passages[index] == 99999)
					RE();

			}
			
			int count = 0;
			long sum = 0;
			for (int index = 0; index <= size; index++) {
				if (passages[index] == 0)
					RE();

				sum += 0L + passages[index];
				count++;
			}

			double ratio = 1.0 * n / count;
			long answer = (long) (sum * ratio / 2);
			if (answer < 0)
				RE();

			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.out.println(value);
		// System.out.flush();
	}

	private static void RE() {
		int ii = 0;
		int jj = ",mokazaki923
15149,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[0] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			RE();
			
			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			if (size != 8000)
				RE();
			
			List<Integer> orderList = IntStream.range(1, n + 1).mapToObj(i-> i).collect(Collectors.toList());
			for (int index = 0; index < n; index++) {
				int rndIndex = rnd.nextInt(n);
				int temp = orderList.get(index);
				orderList.set(index, orderList.get(rndIndex));
				orderList.set(rndIndex, temp);
			}
			
			for (int index = 1; index <= size; index++) {
				// output(""T "" + (n - index+ 1));
				output(""T "" + orderList.get(index - 1));

				int room = in.nextInt();
				if (room == -1)
					RE();

				int passage = in.nextInt();
				if (passages[index] != 0)
					RE();
				
				passages[index] = passage;
				if (passages[index] >= 98000)
					RE();

			}
			
			int count = 0;
			long sum = 0;
			for (int index = 0; index <= size; index++) {
				if (passages[index] == 0)
					RE();

				sum += 0L + passages[index];
				count++;
			}

			double ratio = 1.0 * n / count;
			long answer = (long) (sum * ratio / 2);
			if (answer < 0)
				RE();

			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.out.println(value);
		// System.out.flush();
	}

	private static void RE() {
		int ii = 0;
		int jj = ",mokazaki923
15150,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[0] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			RE();
			
			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			if (size != 8000)
				RE();
			
			List<Integer> orderList = IntStream.range(1, n + 1).mapToObj(i-> i).collect(Collectors.toList());
			for (int index = 0; index < n; index++) {
				int rndIndex = rnd.nextInt(n);
				int temp = orderList.get(index);
				orderList.set(index, orderList.get(rndIndex));
				orderList.set(rndIndex, temp);
			}
			
			for (int index = 1; index <= size; index++) {
				// output(""T "" + (n - index+ 1));
				output(""T "" + orderList.get(index - 1));

				int room = in.nextInt();
				if (room == -1)
					RE();

				int passage = in.nextInt();
				if (passages[index] != 0)
					RE();
				
				passages[index] = passage;
				if (passages[index] >= 90000)
					RE();

			}
			
			int count = 0;
			long sum = 0;
			for (int index = 0; index <= size; index++) {
				if (passages[index] == 0)
					RE();

				sum += 0L + passages[index];
				count++;
			}

			double ratio = 1.0 * n / count;
			long answer = (long) (sum * ratio / 2);
			if (answer < 0)
				RE();

			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.out.println(value);
		// System.out.flush();
	}

	private static void RE() {
		int ii = 0;
		int jj = ",mokazaki923
15151,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[0] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			RE();
			
			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			if (size != 8000)
				RE();
			
			List<Integer> orderList = IntStream.range(1, n + 1).mapToObj(i-> i).collect(Collectors.toList());
			for (int index = 0; index < n; index++) {
				int rndIndex = rnd.nextInt(n);
				int temp = orderList.get(index);
				orderList.set(index, orderList.get(rndIndex));
				orderList.set(rndIndex, temp);
			}
			
			for (int index = 1; index <= size; index++) {
				// output(""T "" + (n - index+ 1));
				output(""T "" + orderList.get(index - 1));

				int room = in.nextInt();
				if (room == -1)
					RE();

				int passage = in.nextInt();
				if (passages[index] != 0)
					RE();
				
				passages[index] = passage;
				if (passages[index] >= 50000)
					RE();

			}
			
			int count = 0;
			long sum = 0;
			for (int index = 0; index <= size; index++) {
				if (passages[index] == 0)
					RE();

				sum += 0L + passages[index];
				count++;
			}

			double ratio = 1.0 * n / count;
			long answer = (long) (sum * ratio / 2);
			if (answer < 0)
				RE();

			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.out.println(value);
		// System.out.flush();
	}

	private static void RE() {
		int ii = 0;
		int jj = ",mokazaki923
15152,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[0] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			RE();
			
			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			if (size != 8000)
				RE();
			
			List<Integer> orderList = IntStream.range(1, n + 1).mapToObj(i-> i).collect(Collectors.toList());
			for (int index = 0; index < n; index++) {
				int rndIndex = rnd.nextInt(n);
				int temp = orderList.get(index);
				orderList.set(index, orderList.get(rndIndex));
				orderList.set(rndIndex, temp);
			}
			
			for (int index = 1; index <= size; index++) {
				// output(""T "" + (n - index+ 1));
				output(""T "" + orderList.get(index - 1));

				int room = in.nextInt();
				if (room == -1)
					RE();

				int passage = in.nextInt();
				if (passages[index] != 0)
					RE();
				
				if (passages[index] >= 1000)
					RE();

				passages[index] = passage;
			}
			
			int count = 0;
			long sum = 0;
			for (int index = 0; index <= size; index++) {
				if (passages[index] == 0)
					RE();

				sum += 0L + passages[index];
				count++;
			}

			double ratio = 1.0 * n / count;
			long answer = (long) (sum * ratio / 2);
			if (answer < 0)
				RE();

			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.out.println(value);
		// System.out.flush();
	}

	private static void RE() {
		int ii = 0;
		int jj = ",mokazaki923
15153,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[0] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			RE();
			
			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			if (size != 8000)
				RE();
			
			List<Integer> orderList = IntStream.range(1, n + 1).mapToObj(i-> i).collect(Collectors.toList());
			for (int index = 0; index < n; index++) {
				int rndIndex = rnd.nextInt(n);
				int temp = orderList.get(index);
				orderList.set(index, orderList.get(rndIndex));
				orderList.set(rndIndex, temp);
			}
			
			for (int index = 1; index <= size; index++) {
				// output(""T "" + (n - index+ 1));
				output(""T "" + orderList.get(index - 1));

				int room = in.nextInt();
				if (room == -1)
					RE();

				int passage = in.nextInt();
				if (passages[index] != 0)
					RE();
				
				if (passages[index] >= 5000)
					RE();

				passages[index] = passage;
			}
			
			int count = 0;
			long sum = 0;
			for (int index = 0; index <= size; index++) {
				if (passages[index] == 0)
					RE();

				sum += 0L + passages[index];
				count++;
			}

			double ratio = 1.0 * n / count;
			long answer = (long) (sum * ratio / 2);
			if (answer < 0)
				RE();

			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.out.println(value);
		// System.out.flush();
	}

	private static void RE() {
		int ii = 0;
		int jj = ",mokazaki923
15154,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[0] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			RE();
			
			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			if (size != 8000)
				RE();
			
			List<Integer> orderList = IntStream.range(1, n + 1).mapToObj(i-> i).collect(Collectors.toList());
			for (int index = 0; index < n; index++) {
				int rndIndex = rnd.nextInt(n);
				int temp = orderList.get(index);
				orderList.set(index, orderList.get(rndIndex));
				orderList.set(rndIndex, temp);
			}
			
			for (int index = 1; index <= size; index++) {
				// output(""T "" + (n - index+ 1));
				output(""T "" + orderList.get(index - 1));

				int room = in.nextInt();
				if (room == -1)
					RE();

				int passage = in.nextInt();
				if (passages[index] != 0)
					RE();
				
				if (passages[index] >= 10000)
					RE();

				passages[index] = passage;
			}
			
			int count = 0;
			long sum = 0;
			for (int index = 0; index <= size; index++) {
				if (passages[index] == 0)
					RE();

				sum += 0L + passages[index];
				count++;
			}

			double ratio = 1.0 * n / count;
			long answer = (long) (sum * ratio / 2);
			if (answer < 0)
				RE();

			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.out.println(value);
		// System.out.flush();
	}

	private static void RE() {
		int ii = 0;
		int jj = ",mokazaki923
15155,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[0] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			RE();
			
			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			if (size != 8000)
				RE();
			
			List<Integer> orderList = IntStream.range(1, n + 1).mapToObj(i-> i).collect(Collectors.toList());
			for (int index = 0; index < n; index++) {
				int rndIndex = rnd.nextInt(n);
				int temp = orderList.get(index);
				orderList.set(index, orderList.get(rndIndex));
				orderList.set(rndIndex, temp);
			}
			
			for (int index = 1; index <= size; index++) {
				// output(""T "" + (n - index+ 1));
				output(""T "" + orderList.get(index - 1));

				int room = in.nextInt();
				if (room == -1)
					RE();

				int passage = in.nextInt();
				if (passages[index] != 0)
					RE();
				
				if (passages[index] >= 50000)
					RE();

				passages[index] = passage;
			}
			
			int count = 0;
			long sum = 0;
			for (int index = 0; index <= size; index++) {
				if (passages[index] == 0)
					RE();

				sum += 0L + passages[index];
				count++;
			}

			double ratio = 1.0 * n / count;
			long answer = (long) (sum * ratio / 2);
			if (answer < 0)
				RE();

			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.out.println(value);
		// System.out.flush();
	}

	private static void RE() {
		int ii = 0;
		int jj = ",mokazaki923
15156,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[0] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			RE();
			
			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			if (size != 8000)
				RE();
			
			List<Integer> orderList = IntStream.range(1, n + 1).mapToObj(i-> i).collect(Collectors.toList());
			for (int index = 0; index < n; index++) {
				int rndIndex = rnd.nextInt(n);
				int temp = orderList.get(index);
				orderList.set(index, orderList.get(rndIndex));
				orderList.set(rndIndex, temp);
			}
			
			for (int index = 1; index <= size; index++) {
				// output(""T "" + (n - index+ 1));
				output(""T "" + orderList.get(index - 1));

				int room = in.nextInt();
				if (room == -1)
					RE();

				int passage = in.nextInt();
				if (passages[index] != 0)
					RE();
				
				passages[index] = passage;
			}
			
			int count = 0;
			long sum = 0;
			for (int index = 0; index <= size; index++) {
				if (passages[index] == 0)
					RE();

				sum += 0L + passages[index];
				count++;
			}

			double ratio = 1.0 * n / count;
			long answer = (long) (sum * ratio / 2);
			if (answer < 0)
				RE();

			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.out.println(value);
		// System.out.flush();
	}

	private static void RE() {
		int ii = 0;
		int jj = ",mokazaki923
15157,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[0] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			RE();
			
			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			if (size != 8000)
				RE();
			
			List<Integer> orderList = IntStream.of(n).mapToObj(i-> i).collect(Collectors.toList());
			for (int index = 0; index < n; index++) {
				int rndIndex = rnd.nextInt(n);
				int temp = orderList.get(index);
				orderList.set(index, orderList.get(rndIndex));
				orderList.set(rndIndex, temp);
			}
			
			for (int index = 1; index <= size; index++) {
				// output(""T "" + (n - index+ 1));
				output(""T "" + orderList.get(index - 1));

				int room = in.nextInt();
				if (room == -1)
					RE();

				int passage = in.nextInt();
				if (passages[index] != 0)
					RE();
				
				passages[index] = passage;
			}
			
			int count = 0;
			long sum = 0;
			for (int index = 0; index <= size; index++) {
				if (passages[index] == 0)
					RE();

				sum += 0L + passages[index];
				count++;
			}

			double ratio = 1.0 * n / count;
			long answer = (long) (sum * ratio / 2);
			if (answer < 0)
				RE();

			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.out.println(value);
		// System.out.flush();
	}

	private static void RE() {
		int ii = 0;
		int jj = ",mokazaki923
15158,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[0] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			RE();
			
			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			if (size != 8000)
				RE();
			
			for (int index = 1; index <= size; index++) {
				output(""T "" + (n - index+ 1));

				int room = in.nextInt();
				if (room == -1)
					RE();

				int passage = in.nextInt();
				if (passages[index] != 0)
					RE();
				
				passages[index] = passage;
			}
			
			int count = 0;
			long sum = 0;
			for (int index = 0; index <= size; index++) {
				if (passages[index] == 0)
					RE();

				sum += 0L + passages[index];
				count++;
			}

			double ratio = 1.0 * n / count;
			long answer = (long) (sum * ratio / 2);
			if (answer < 0)
				RE();

			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.out.println(value);
		// System.out.flush();
	}

	private static void RE() {
		int ii = 0;
		int jj = ",mokazaki923
15160,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
//		passages[firstRoom] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			RE();
			
			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			if (size != 8000)
				RE();
			
			int oneCount = (lastPassage == 1 ? 1 : 0);
			for (int index = 1; index <= size; index++) {
				output(""T "" + (n - index+ 1));

				int room = in.nextInt();
				if (room == -1)
					RE();

				int passage = in.nextInt();
				if (passages[index] != 0)
					RE();
				
				passages[index] = passage;
				if (passage == 1)
					oneCount++;
			}
			
			int count = 0;
			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					RE();

				sum += 0L + passages[index];
				count++;
			}

			double ratio = 1.0 * n / count;
			long answer = (long) (sum * ratio / 2);
			if (answer < 0)
				RE();

			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.out.println(value);
		// System.out.flush();
	}

	private static void RE() {
		int ii = 0;
		int jj = ",mokazaki923
15161,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
//		passages[firstRoom] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			int ii = 0;
			int jj = 3 / ii;
			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			if (size != 8000) {
				int ii = 0;
				int jj = 3 / ii;
			}
			int oneCount = (lastPassage == 1 ? 1 : 0);
			for (int index = 1; index <= size; index++) {
				// output(""T "" + (n - index+ 1));
				output(""T 100001"");

				int room = in.nextInt();
				if (room == -1) {
					int ii = 0;
					int jj = 3 / ii;
				}
				int passage = in.nextInt();
				if (passages[index] != 0) {
					int ii = 0;
					int jj = 3 / ii;
				}
				
				passages[index] = passage;
				if (passage == 1)
					oneCount++;
			}
			
			int count = 0;
			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0) {
					int ii = 0;
					int jj = 3 / ii;
				}

				sum += 0L + passages[index];
				count++;
			}

			double ratio = 1.0 * n / count;
			long answer = (long) (sum * ratio / 2);

//			long answer = (long) (1.0 * n * sum / count / 2);
			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.",mokazaki923
15162,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
//		passages[firstRoom] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			int ii = 0;
			int jj = 3 / ii;
			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			if (size != 8000) {
				int ii = 0;
				int jj = 3 / ii;
			}
			int oneCount = (lastPassage == 1 ? 1 : 0);
			for (int index = 1; index <= size; index++) {
				// output(""T "" + (n - index+ 1));
				output(""T 100001"");

				int room = in.nextInt();
				int passage = in.nextInt();
				if (passages[index] != 0) {
					int ii = 0;
					int jj = 3 / ii;
				}
				
				passages[index] = passage;
				if (passage == 1)
					oneCount++;
			}
			
			int count = 0;
			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0) {
					int ii = 0;
					int jj = 3 / ii;
				}

				sum += 0L + passages[index];
				count++;
			}

			double ratio = 1.0 * n / count;
			long answer = (long) (sum * ratio / 2);

//			long answer = (long) (1.0 * n * sum / count / 2);
			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.",mokazaki923
15163,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
//		passages[firstRoom] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			int ii = 0;
			int jj = 3 / ii;
			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			if (size != 8000) {
				int ii = 0;
				int jj = 3 / ii;
			}
			int oneCount = (lastPassage == 1 ? 1 : 0);
			for (int index = 1; index <= size; index++) {
				output(""T "" + (n - index+ 1));

				int room = in.nextInt();
				int passage = in.nextInt();
				if (passages[index] != 0) {
					int ii = 0;
					int jj = 3 / ii;
				}
				
				passages[index] = passage;
				if (passage == 1)
					oneCount++;
			}
			
			int count = 0;
			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0) {
					int ii = 0;
					int jj = 3 / ii;
				}

				sum += 0L + passages[index];
				count++;
			}

			double ratio = 1.0 * n / count;
			long answer = (long) (sum * ratio / 2);

//			long answer = (long) (1.0 * n * sum / count / 2);
			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.",mokazaki923
15164,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
//		passages[firstRoom] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			int ii = 0;
			int jj = 3 / ii;
			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			if (size != 8000) {
				int ii = 0;
				int jj = 3 / ii;
			}
			int oneCount = (lastPassage == 1 ? 1 : 0);
			for (int index = 1; index <= size; index++) {
				output(""T "" + (n - index+ 1));

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[index] = passage;
				if (passage == 1)
					oneCount++;
			}
			
			int count = 0;
			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0) {
					int ii = 0;
					int jj = 3 / ii;
				}

				sum += 0L + passages[index];
				count++;
			}

			double ratio = 1.0 * n / count;
			long answer = (long) (sum * ratio / 2);

//			long answer = (long) (1.0 * n * sum / count / 2);
			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.",mokazaki923
15165,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[firstRoom] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			int ii = 0;
			int jj = 3 / ii;
			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			if (size != 8000) {
				int ii = 0;
				int jj = 3 / ii;
			}
			int oneCount = (lastPassage == 1 ? 1 : 0);
			for (int index = 1; index <= size; index++) {
				output(""T "" + (n - index+ 1));

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[index] = passage;
				if (passage == 1)
					oneCount++;
			}
			
			int count = 0;
			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0) {
					int ii = 0;
					int jj = 3 / ii;
				}

				sum += 0L + passages[index];
				count++;
			}

			double ratio = 1.0 * n / count;
			long answer = (long) (sum * ratio / 2);

//			long answer = (long) (1.0 * n * sum / count / 2);
			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.",mokazaki923
15166,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[firstRoom] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			int ii = 0;
			int jj = 3 / ii;
			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			if (size != 8000) {
				int ii = 0;
				int jj = 3 / ii;
			}
			int oneCount = (lastPassage == 1 ? 1 : 0);
			for (int index = 1; index <= size; index++) {
				output(""T "" + (n - index+ 1));

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[index] = passage;
				if (passage == 1)
					oneCount++;
			}
			
			int count = 0;
			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0) {
					int ii = 0;
					int jj = 3 / ii;
				}

				sum += passages[index];
				count++;
			}

			long answer = (long) (1.0 * n * sum / count / 2);
			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.",mokazaki923
15167,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[firstRoom] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			int ii = 0;
			int jj = 3 / ii;
			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			if (size != 8000) {
				int ii = 0;
				int jj = 3 / ii;
			}
			int oneCount = (lastPassage == 1 ? 1 : 0);
			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
				if (passage == 1)
					oneCount++;
			}
			
			int count = 0;
			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0){
					int ii = 0;
					int jj = 3 / ii;
				}

				sum += passages[index];
				count++;
			}

			long answer = (long) (1.0 * n * sum / count / 2);
			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.",mokazaki923
15168,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[firstRoom] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			int ii = 0;
			int jj = 3 / ii;
			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			if (size != 8000) {
				int ii = 0;
				int jj = 3 / ii;
			}
			int oneCount = (lastPassage == 1 ? 1 : 0);
			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
				if (passage == 1)
					oneCount++;
			}
			
			if (oneCount < 10) {
				int ii = 0;
				int jj = 3 / ii;
			}
			
			int count = 0;
			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					continue;

				sum += passages[index];
				count++;
			}

			long answer = (long) (1.0 * n * sum / count / 2);
			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.",mokazaki923
15169,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[firstRoom] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			int ii = 0;
			int jj = 3 / ii;
			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			if (size != 8000) {
				int ii = 0;
				int jj = 3 / ii;
			}
			int oneCount = (lastPassage == 1 ? 1 : 0);
			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
				if (passage == 1)
					oneCount++;
			}
			
			if (oneCount > 8000) {
				int ii = 0;
				int jj = 3 / ii;
			}
			
			int count = 0;
			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					continue;

				sum += passages[index];
				count++;
			}

			long answer = (long) (1.0 * n * sum / count / 2);
			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.",mokazaki923
15171,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[firstRoom] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			int ii = 0;
			int jj = 3 / ii;
			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			if (size != 8000) {
				int ii = 0;
				int jj = 3 / ii;
			}
			int oneCount = (lastPassage == 1 ? 1 : 0);
			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
				if (passage == 1)
					oneCount++;
			}
			
			if (oneCount > 7000) {
				int ii = 0;
				int jj = 3 / ii;
			}
			
			int count = 0;
			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					continue;

				sum += passages[index];
				count++;
			}

			long answer = (long) (1.0 * n * sum / count / 2);
			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.",mokazaki923
15172,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[firstRoom] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			int ii = 0;
			int jj = 3 / ii;
			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			if (size != 8000) {
				int ii = 0;
				int jj = 3 / ii;
			}
			int oneCount = (lastPassage == 1 ? 1 : 0);
			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
				if (passage == 1)
					oneCount++;
			}
			
			if (oneCount > 4000) {
				int ii = 0;
				int jj = 3 / ii;
			}
			
			int count = 0;
			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					continue;

				sum += passages[index];
				count++;
			}

			long answer = (long) (1.0 * n * sum / count / 2);
			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.",mokazaki923
15173,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[firstRoom] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			int ii = 0;
			int jj = 3 / ii;
			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			if (size != 8000) {
				int ii = 0;
				int jj = 3 / ii;
			}
			int oneCount = 0;
			for (int index = 1; index <= size; index++) {
				if (lastPassage == 1) {
					oneCount++;
					output(""W"");
					int room = in.nextInt();
					int passage = in.nextInt();
					passages[room] = passage;
					if (passage == 1 && lastPassage == 1) {
						int ii = 0;
//						int jj = 3 / ii;
					}
					
					lastPassage = passage;
				} else {
					output(""T "" + index);
					int room = in.nextInt();
					int passage = in.nextInt();
					passages[room] = passage;
					lastPassage = passage;
				}

			}
			
			int count = 0;
			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					continue;

				sum += passages[index];
				count++;
			}

			long answer = (long) (1.0 * n * sum / count / 2);
			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.",mokazaki923
15174,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[firstRoom] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			int ii = 0;
			int jj = 3 / ii;
			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			if (size != 8000) {
				int ii = 0;
				int jj = 3 / ii;
			}
			int oneCount = 0;
			for (int index = 1; index <= size; index++) {
				if (lastPassage == 1) {
					oneCount++;
					output(""W"");
					int room = in.nextInt();
					int passage = in.nextInt();
					passages[room] = passage;
					if (passage == 1 && lastPassage == 1) {
						int ii = 0;
						int jj = 3 / ii;
					}
					
					lastPassage = passage;
				} else {
					output(""T "" + index);
					int room = in.nextInt();
					int passage = in.nextInt();
					passages[room] = passage;
					lastPassage = passage;
				}

			}
			
			int count = 0;
			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					continue;

				sum += passages[index];
				count++;
			}

			long answer = (long) (1.0 * n * sum / count / 2);
			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.",mokazaki923
15175,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[firstRoom] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			int ii = 0;
			int jj = 3 / ii;
			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			if (size != 8000) {
				int ii = 0;
				int jj = 3 / ii;
			}
			int oneCount = 0;
			for (int index = 1; index <= size; index++) {
				if (lastPassage == 1) {
					oneCount++;
					output(""W"");
				} else {
					output(""T "" + index);
				}

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
				if (passage == 1 && lastPassage == 1) {
					int ii = 0;
//					int jj = 3 / ii;
				}
				
				lastPassage = passage;
			}
			
			int count = 0;
			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					continue;

				sum += passages[index];
				count++;
			}

			long answer = (long) (1.0 * n * sum / count / 2);
			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.",mokazaki923
15176,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[firstRoom] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			int ii = 0;
			int jj = 3 / ii;
			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			if (size != 8000) {
				int ii = 0;
				int jj = 3 / ii;
			}
			int oneCount = 0;
			for (int index = 1; index <= size; index++) {
				if (lastPassage == 1) {
					oneCount++;
					output(""W"");
				} else {
					output(""T "" + index);
				}

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
				if (passage == 1 && lastPassage == 1) {
					int ii = 0;
					int jj = 3 / ii;
				}
				
				lastPassage = passage;
			}
			
			int count = 0;
			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					continue;

				sum += passages[index];
				count++;
			}

			long answer = (long) (1.0 * n * sum / count / 2);
			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.",mokazaki923
15177,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[firstRoom] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			int ii = 0;
			int jj = 3 / ii;
			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			if (size != 8000) {
				int ii = 0;
				int jj = 3 / ii;
			}
			int oneCount = 0;
			for (int index = 1; index <= size; index++) {
				if (lastPassage == 1) {
					oneCount++;
					output(""W"");
				} else {
					output(""T "" + index);
				}

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
				lastPassage = passage;
			}
			
			if (oneCount > 4001) {
				int ii = 0;
				int jj = 3 / ii;
			}
			
			int count = 0;
			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					continue;

				sum += passages[index];
				count++;
			}

			long answer = (long) (1.0 * n * sum / count / 2);
			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.",mokazaki923
15178,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[firstRoom] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			int ii = 0;
			int jj = 3 / ii;
			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			if (size != 8000) {
				int ii = 0;
				int jj = 3 / ii;
			}
			int oneCount = 0;
			for (int index = 1; index <= size; index++) {
				if (lastPassage == 1) {
					oneCount++;
					output(""W"");
				} else {
					output(""T "" + index);
				}

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
				lastPassage = passage;
			}
			
			if (oneCount > 4000) {
				in.nextInt();
			}
			
			if (oneCount > 3000) {
				int ii = 0;
				int jj = 3 / ii;
			}

			int count = 0;
			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					continue;

				sum += passages[index];
				count++;
			}

			long answer = (long) (1.0 * n * sum / count / 2);
			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.",mokazaki923
15179,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[firstRoom] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			int ii = 0;
			int jj = 3 / ii;
			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			for (int index = 1; index <= size; index++) {
				if (lastPassage == 1) {
					output(""W"");
				} else {
					output(""T "" + index);
				}

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
				lastPassage = passage;
			}

			int count = 0;
			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					continue;

				sum += passages[index];
				count++;
			}

			long answer = (long) (1.0 * n * sum / count / 2);
			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.",mokazaki923
15180,"public class Solution {

	static Scanner in;

	public static void main(String[] args) {
		in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
		for (int i = 1; i <= t; ++i) {
			int n = in.nextInt();
			int k = in.nextInt();

			solve(n, k);
		}
	}

	private static void solve(int n, int k) {
		Random rnd = new Random();

		int[] passages = new int[n + 1];
		int firstRoom = in.nextInt();
		int lastPassage = in.nextInt();
		passages[firstRoom] = lastPassage;
		int size = Math.min(n, k);
		if (size < 8000) {
			for (int index = 1; index <= size; index++) {
				output(""T "" + index);

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
			}

			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					in.nextInt();

				sum += passages[index];
			}

			long answer = (long) (1.0 * sum / 2);
			output(""E "" + answer);

		} else {
			int ii = 0;
			int jj = 3 / ii;
			for (int index = 1; index <= size; index++) {
				if (lastPassage == 1) {
					output(""W"");
				} else {
					output(""T "" + index);
				}

				int room = in.nextInt();
				int passage = in.nextInt();
				passages[room] = passage;
				lastPassage = passage;
			}

			int count = 0;
			long sum = 0;
			for (int index = 1; index <= size; index++) {
				if (passages[index] == 0)
					continue;

				sum += passages[index];
				count++;
			}

			long answer = (long) (1.0 * n * sum / count / 2);
			output(""E "" + answer);
		}
	}

	private static void output(String value) {
		System.",mokazaki923
15307,"public class Solution {
	public static void main(String[] args) throws Exception {
		Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int T = sc.nextInt();
		for (int testcase = 1; testcase <=T; testcase++) {
			int N = sc.nextInt();
			int K = sc.nextInt();
			boolean[] isvisit = new boolean[N+1];
			LinkedList<Integer> q=  new LinkedList<Integer>();
			for (int i = 1; i <=N; i++) {
				q.add(i);
			}
			Collections.shuffle(q);
			ArrayList<Long> roomarr = new ArrayList<Long>();
			int no = sc.nextInt();
			long cnt = sc.nextLong();
			isvisit[no]=true;
			long visitcnt=1;
			long sum =cnt;
			roomarr.add(cnt);
			for (int i = 1; i <=K; i++) {
				if(q.isEmpty() || i%10==0) {
					System.out.println(""W"");
					System.out.flush();
				}else {
					while(!q.isEmpty()) {
						no = q.poll();
						if(!isvisit[no]) break;
					}
					System.out.println(""T ""+no);
					System.out.flush();
				}
				no = sc.nextInt();
				cnt = sc.nextLong();
				if(!isvisit[no]) {
					isvisit[no]=true;
					visitcnt++;
					sum+=cnt;
					roomarr.add(cnt);
				}				
			}
			Collections.sort(roomarr);
			double value_a = (sum/visitcnt);
			long value_b = roomarr.get((int)(visitcnt/2));
			long answer = ",namgoi
15308,"public class Solution {
	public static void main(String[] args) throws Exception {
		Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int T = sc.nextInt();
		for (int testcase = 1; testcase <=T; testcase++) {
			int N = sc.nextInt();
			int K = sc.nextInt();
			boolean[] isvisit = new boolean[N+1];
			LinkedList<Integer> q=  new LinkedList<Integer>();
			for (int i = 1; i <=N; i++) {
				q.add(i);
			}
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			int no = sc.nextInt();
			long cnt = sc.nextLong();
			isvisit[no]=true;
			long visitcnt=1;
			long sum =cnt;
			ArrayList<Long> roomarr = new ArrayList<Long>();
			roomarr.add(cnt);
			for (int i = 1; i <=K; i++) {
				if(q.isEmpty()) {
					System.out.println(""W"");
					System.out.flush();
				}else {
					while(!q.isEmpty()) {
						no = q.poll();
						if(!isvisit[no]) break;
					}
					System.out.println(""T ""+no);
					System.out.flush();
				}
				no = sc.nextInt();
				cnt = sc.nextLong();
				if(!isvisit[no]) {
					isvisit[no]=true;
					visitcnt++;
					sum+=cnt;
					roomarr.add(cnt);
				}				
			}
			Collections.sort(roomarr);
			double value_a = (sum/visitcnt);
			long value_b = roomarr.get((int)(visitcnt/2));
			long answer = ",namgoi
15309,"public class Solution {
	public static void main(String[] args) throws Exception {
		Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int T = sc.nextInt();
		for (int testcase = 1; testcase <=T; testcase++) {
			int N = sc.nextInt();
			int K = sc.nextInt();
			boolean[] isvisit = new boolean[N+1];
			LinkedList<Integer> q=  new LinkedList<Integer>();
			for (int i = 1; i <=N; i++) {
				q.add(i);
			}
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			int no = sc.nextInt();
			long cnt = sc.nextLong();
			isvisit[no]=true;
			long visitcnt=1;
			long sum =cnt;
			ArrayList<Long> roomarr = new ArrayList<Long>();
			for (int i = 1; i <=K; i++) {
				if(q.isEmpty()) {
					System.out.println(""W"");
					System.out.flush();
				}else {
					while(!q.isEmpty()) {
						no = q.poll();
						if(!isvisit[no]) break;
					}
					System.out.println(""T ""+no);
					System.out.flush();
				}
				no = sc.nextInt();
				cnt = sc.nextLong();
				if(!isvisit[no]) {
					isvisit[no]=true;
					visitcnt++;
					sum+=cnt;
					roomarr.add(cnt);
				}				
			}
			Collections.sort(roomarr);
			double value_a = (sum/visitcnt);
			long value_b = roomarr.get((int)(visitcnt/2));
			long answer = ",namgoi
15310,"public class Solution {
	public static void main(String[] args) throws Exception {
		Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int T = sc.nextInt();
		for (int testcase = 1; testcase <=T; testcase++) {
			int N = sc.nextInt();
			int K = sc.nextInt();
			boolean[] isvisit = new boolean[N+1];
			LinkedList<Integer> q=  new LinkedList<Integer>();
			for (int i = 1; i <=N; i++) {
				q.add(i);
			}
			Collections.shuffle(q);
			int no = sc.nextInt();
			long cnt = sc.nextLong();
			isvisit[no]=true;
			long visitcnt=1;
			long sum =cnt;
			ArrayList<Long> roomarr = new ArrayList<Long>();
			for (int i = 1; i <=K; i++) {
				if(q.isEmpty()) {
					System.out.println(""W"");
					System.out.flush();
				}else {
					while(!q.isEmpty()) {
						no = q.poll();
						if(!isvisit[no]) break;
					}
					System.out.println(""T ""+no);
					System.out.flush();
				}
				no = sc.nextInt();
				cnt = sc.nextLong();
				if(!isvisit[no]) {
					isvisit[no]=true;
					visitcnt++;
					sum+=cnt;
					roomarr.add(cnt);
				}				
			}
			Collections.sort(roomarr);
			double value_a = (sum/visitcnt);
			long value_b = roomarr.get((int)(visitcnt/2));
			long answer = ",namgoi
15311,"public class Solution {
	public static void main(String[] args) throws Exception {
		Scanner sc = new Scanner(System.in);
		int T = sc.nextInt();
		for (int testcase = 1; testcase <=T; testcase++) {
			int N = sc.nextInt();
			int K = sc.nextInt();
			boolean[] isvisit = new boolean[N+1];
			LinkedList<Integer> q=  new LinkedList<Integer>();
			for (int i = 1; i <=N; i++) {
				q.add(i);
			}
			int no = sc.nextInt();
			int cnt = sc.nextInt();
			isvisit[no]=true;
			long visitcnt=1;
			long sum =cnt;
			ArrayList<Integer> roomarr = new ArrayList<Integer>();
			for (int i = 1; i <=K; i++) {
				if(q.isEmpty()) {
					System.out.println(""W"");
					System.out.flush();
					no = sc.nextInt();
					cnt = sc.nextInt();
				}else {
					while(!q.isEmpty()) {
						no = q.poll();
						if(!isvisit[no]) break;
					}
					System.out.println(""T ""+no);
					System.out.flush();
					no = sc.nextInt();
					cnt = sc.nextInt();
				}
				if(!isvisit[no]) {
					isvisit[no]=true;
					visitcnt++;
					sum+=cnt;
					roomarr.add(cnt);
				}				
			}
			Collections.sort(roomarr);
			long value_a = sum/visitcnt;
			long value_b = roomarr.get((int) (visitcnt*0.5));
			long answer = ",namgoi
15312,"public class Solution {
	public static void main(String[] args) throws Exception {
		Scanner sc = new Scanner(System.in);
		int T = sc.nextInt();
		for (int testcase = 1; testcase <=T; testcase++) {
			int N = sc.nextInt();
			int K = sc.nextInt();

			long[] room1 = new long[N+1];
			long[] room2 = new long[N+1];
			
			boolean[] iswalk = new boolean[N+1];
			boolean[] isvisit = new boolean[N+1];
			LinkedList<Integer> q=  new LinkedList<Integer>();
			for (int i = 1; i <=N; i++) {
				q.add(i);
			}
			
			int no = sc.nextInt();
			int cnt = sc.nextInt();
			isvisit[no]=true;
			int qcnt =0;
			int visitcnt =1;
			int sum =cnt;
			int mincnt =cnt;
			int maxcnt =cnt;
			while(qcnt<K-1) {
				if(visitcnt==N) break;
				if(iswalk[no] && room1[no]<3) {
					while(!q.isEmpty()) {
						no = q.poll();
						if(!isvisit[no]) break;
					}
					System.out.println(""T ""+no);
					System.out.flush();
					no = sc.nextInt();
					cnt = sc.nextInt();
					if(!isvisit[no]) {
						isvisit[no]=true;
						sum+=cnt;
						room1[no]=cnt;
						visitcnt++;
						if(mincnt>cnt) mincnt=cnt;
						if(maxcnt<cnt) maxcnt=cnt;
					}
				}else {
					iswalk[no]=true;
					room1[no]--;
					room2[no]++;
					System.out.println(""W"");
					System.out.flush();
					no = sc.nextInt();
					cnt = sc.nextInt();
					iswalk[no]=true;
					sum--;
					if(!isvisit[no]) {
						sum--;
						visitcnt++;
						isvisit[no]=true;
						sum+=cnt;
						room1[no]=cnt;
						room1[no]--;
						room2[no]++;
						if(mincnt>cnt) mincnt=cnt;
						if(maxcnt<cnt) maxcnt=cnt;
					}
				}
				qcnt++;
			}
			long room3sum = 0;
			long room4sum = 0;
			ArrayList<Long> roomarr1 = new ArrayList<Long>();
			ArrayList<Long> roomarr2 = new ArrayList<Long>();
			for (int i = 1; i <=N; i++) {
				if(isvisit[i]) {
					room3sum += room1[i];
					room4sum += room2[i];
					roomarr1.add((long) room1[i]+room2[i]);
					roomarr2.add((long) room2[i]);	
				}
			}
//			long answer1 = room2sum/2l + room1sum + (room2sum/2l)*((N-visitcnt)/visitcnt);
//			long answer2 = room4sum/2l + room3sum + (room4sum/2l)*((N-visitcnt)/visitcnt);
//			long answer = (answer1+ answer2)/4l;
//			long value_b = roomarr.get((int) (visitcnt*0.5));
			Collections.sort(roomarr1);
			Collections.sort(roomarr2);
//			long value_a = (long) (((sum-mincnt-maxcnt)/(visitcnt-2))*1); 
			long value_a = (long) (((sum)/(visitcnt)));
			long value_b1 = roomarr1.get((int) (visitcnt*0.5));
			long value_b2 = roomarr2.get((int) (visitcnt*0.5));
			long answer1 = (long) ((room4sum + Math.max(value_a,value_b1)*(N-visitcnt))/2)+room3sum;
			long answer2 = (long) ((room4sum + Math.max(value_a,value_b2)*(N-visitcnt))/2)+room3sum;
//			long answer = (long) ((sum + Math.max(value_a,value_b)*(N-visitcnt))/2);
//			long answer = (long) ((sum + value_b*(long)(N-visitcnt))/2);
			System.out.println(""E ""+(answer1+answer2)/2l);
			System.",namgoi
15313,"public class Solution {
	public static void main(String[] args) throws Exception {
		Scanner sc = new Scanner(System.in);
		int T = sc.nextInt();
		for (int testcase = 1; testcase <=T; testcase++) {
			int N = sc.nextInt();
			int K = sc.nextInt();

			long[] room1 = new long[N+1];
			long[] room2 = new long[N+1];
			
			boolean[] iswalk = new boolean[N+1];
			boolean[] isvisit = new boolean[N+1];
			LinkedList<Integer> q=  new LinkedList<Integer>();
			for (int i = 1; i <=N; i++) {
				q.add(i);
			}
			
			int no = sc.nextInt();
			int cnt = sc.nextInt();
			isvisit[no]=true;
			int qcnt =0;
			int visitcnt =1;
			int sum =cnt;
			int mincnt =cnt;
			int maxcnt =cnt;
			while(qcnt<K) {
				if(visitcnt==N) break;
				if(iswalk[no] && room1[no]<3) {
					while(!q.isEmpty()) {
						no = q.poll();
						if(!isvisit[no]) break;
					}
					System.out.println(""T ""+no);
					System.out.flush();
					no = sc.nextInt();
					cnt = sc.nextInt();
					if(!isvisit[no]) {
						isvisit[no]=true;
						sum+=cnt;
						room1[no]=cnt;
						visitcnt++;
						if(mincnt>cnt) mincnt=cnt;
						if(maxcnt<cnt) maxcnt=cnt;
					}
				}else {
					iswalk[no]=true;
					room1[no]--;
					room2[no]++;
					System.out.println(""W"");
					System.out.flush();
					no = sc.nextInt();
					cnt = sc.nextInt();
					iswalk[no]=true;
					sum--;
					if(!isvisit[no]) {
						sum--;
						visitcnt++;
						isvisit[no]=true;
						sum+=cnt;
						room1[no]=cnt;
						room1[no]--;
						room2[no]++;
						if(mincnt>cnt) mincnt=cnt;
						if(maxcnt<cnt) maxcnt=cnt;
					}
				}
				qcnt++;
			}
			long room3sum = 0;
			long room4sum = 0;
			ArrayList<Long> roomarr1 = new ArrayList<Long>();
			ArrayList<Long> roomarr2 = new ArrayList<Long>();
			for (int i = 1; i <=N; i++) {
				if(isvisit[i]) {
					room3sum += room1[i];
					room4sum += room2[i];
					roomarr1.add((long) room1[i]+room2[i]);
					roomarr2.add((long) room2[i]);	
				}
			}
//			long answer1 = room2sum/2l + room1sum + (room2sum/2l)*((N-visitcnt)/visitcnt);
//			long answer2 = room4sum/2l + room3sum + (room4sum/2l)*((N-visitcnt)/visitcnt);
//			long answer = (answer1+ answer2)/4l;
//			long value_b = roomarr.get((int) (visitcnt*0.5));
			Collections.sort(roomarr1);
			Collections.sort(roomarr2);
//			long value_a = (long) (((sum-mincnt-maxcnt)/(visitcnt-2))*1); 
			long value_a = (long) (((sum)/(visitcnt)));
			long value_b1 = roomarr1.get((int) (visitcnt*0.5));
			long value_b2 = roomarr2.get((int) (visitcnt*0.5));
			long answer1 = (long) ((room4sum + Math.max(value_a,value_b1)*(N-visitcnt))/2)+room3sum;
			long answer2 = (long) ((room4sum + Math.max(value_a,value_b2)*(N-visitcnt))/2)+room3sum;
//			long answer = (long) ((sum + Math.max(value_a,value_b)*(N-visitcnt))/2);
//			long answer = (long) ((sum + value_b*(long)(N-visitcnt))/2);
			System.out.println(""E ""+(answer1+answer2)/2l);
			System.",namgoi
15314,"public class Solution {
	public static void main(String[] args) throws Exception {
		Scanner sc = new Scanner(System.in);
		int T = sc.nextInt();
		for (int testcase = 1; testcase <=T; testcase++) {
			int N = sc.nextInt();
			int K = sc.nextInt();

			long[] room1 = new long[N+1];
			long[] room2 = new long[N+1];
			
			boolean[] iswalk = new boolean[N+1];
			boolean[] isvisit = new boolean[N+1];
			LinkedList<Integer> q=  new LinkedList<Integer>();
			for (int i = 1; i <=N; i++) {
				q.add(i);
			}
			
			int no = sc.nextInt();
			int cnt = sc.nextInt();
			isvisit[no]=true;
			int qcnt =0;
			int visitcnt =1;
			int sum =cnt;
			int mincnt =cnt;
			int maxcnt =cnt;
			while(qcnt<K) {
				if(visitcnt==N) break;
				if(iswalk[no] && room1[no]<5) {
					while(!q.isEmpty()) {
						no = q.poll();
						if(!isvisit[no]) break;
					}
					System.out.println(""T ""+no);
					System.out.flush();
					no = sc.nextInt();
					cnt = sc.nextInt();
					if(!isvisit[no]) {
						isvisit[no]=true;
						sum+=cnt;
						room1[no]=cnt;
						visitcnt++;
						if(mincnt>cnt) mincnt=cnt;
						if(maxcnt<cnt) maxcnt=cnt;
					}
				}else {
					iswalk[no]=true;
					room1[no]--;
					room2[no]++;
					System.out.println(""W"");
					System.out.flush();
					no = sc.nextInt();
					cnt = sc.nextInt();
					iswalk[no]=true;
					sum--;
					if(!isvisit[no]) {
						sum--;
						visitcnt++;
						isvisit[no]=true;
						sum+=cnt;
						room1[no]=cnt;
						room1[no]--;
						room2[no]++;
						if(mincnt>cnt) mincnt=cnt;
						if(maxcnt<cnt) maxcnt=cnt;
					}
				}
				qcnt++;
			}
			long room3sum = 0;
			long room4sum = 0;
			ArrayList<Long> roomarr1 = new ArrayList<Long>();
			ArrayList<Long> roomarr2 = new ArrayList<Long>();
			for (int i = 1; i <=N; i++) {
				if(isvisit[i]) {
					room3sum += room1[i];
					room4sum += room2[i];
					roomarr1.add((long) room1[i]+room2[i]);
					roomarr2.add((long) room2[i]);	
				}
			}
//			long answer1 = room2sum/2l + room1sum + (room2sum/2l)*((N-visitcnt)/visitcnt);
//			long answer2 = room4sum/2l + room3sum + (room4sum/2l)*((N-visitcnt)/visitcnt);
//			long answer = (answer1+ answer2)/4l;
//			long value_b = roomarr.get((int) (visitcnt*0.5));
			Collections.sort(roomarr1);
			Collections.sort(roomarr2);
//			long value_a = (long) (((sum-mincnt-maxcnt)/(visitcnt-2))*1); 
			long value_a = (long) (((sum)/(visitcnt)));
			long value_b1 = roomarr1.get((int) (visitcnt*0.5));
			long value_b2 = roomarr2.get((int) (visitcnt*0.5));
			long answer1 = (long) ((sum + Math.max(value_a,value_b1)*(N-visitcnt))/2);
			long answer2 = (long) ((sum + Math.max(value_a,value_b2)*(N-visitcnt))/2);
//			long answer = (long) ((sum + Math.max(value_a,value_b)*(N-visitcnt))/2);
//			long answer = (long) ((sum + value_b*(long)(N-visitcnt))/2);
			System.out.println(""E ""+(answer1+answer2)/2l);
			System.",namgoi
15315,"public class Solution {
	public static void main(String[] args) throws Exception {
		Scanner sc = new Scanner(System.in);
		int T = sc.nextInt();
		for (int testcase = 1; testcase <=T; testcase++) {
			int N = sc.nextInt();
			int K = sc.nextInt();

			long[] room1 = new long[N+1];
			long[] room2 = new long[N+1];
			
			boolean[] iswalk = new boolean[N+1];
			boolean[] isvisit = new boolean[N+1];
			LinkedList<Integer> q=  new LinkedList<Integer>();
			for (int i = 1; i <=N; i++) {
				q.add(i);
			}
			
			int no = sc.nextInt();
			int cnt = sc.nextInt();
			isvisit[no]=true;
			int qcnt =0;
			int visitcnt =1;
			int sum =cnt;
			int mincnt =cnt;
			int maxcnt =cnt;
			while(qcnt<K) {
				if(visitcnt==N) break;
				if(iswalk[no] || room1[no]<10) {
					while(!q.isEmpty()) {
						no = q.poll();
						if(!isvisit[no]) break;
					}
					System.out.println(""T ""+no);
					System.out.flush();
					no = sc.nextInt();
					cnt = sc.nextInt();
					if(!isvisit[no]) {
						isvisit[no]=true;
						sum+=cnt;
						room1[no]=cnt;
						visitcnt++;
						if(mincnt>cnt) mincnt=cnt;
						if(maxcnt<cnt) maxcnt=cnt;
					}
				}else {
					iswalk[no]=true;
					room1[no]--;
					room2[no]++;
					System.out.println(""W"");
					System.out.flush();
					no = sc.nextInt();
					cnt = sc.nextInt();
					iswalk[no]=true;
					sum--;
					if(!isvisit[no]) {
						sum--;
						visitcnt++;
						isvisit[no]=true;
						sum+=cnt;
						room1[no]=cnt;
						room1[no]--;
						room2[no]++;
						if(mincnt>cnt) mincnt=cnt;
						if(maxcnt<cnt) maxcnt=cnt;
					}
				}
				qcnt++;
			}
			long room3sum = 0;
			long room4sum = 0;
			ArrayList<Long> roomarr1 = new ArrayList<Long>();
			ArrayList<Long> roomarr2 = new ArrayList<Long>();
			for (int i = 1; i <=N; i++) {
				if(isvisit[i]) {
					room3sum += room1[i];
					room4sum += room2[i];
					roomarr1.add((long) room1[i]+room2[i]);
					roomarr2.add((long) room2[i]);	
				}
			}
//			long answer1 = room2sum/2l + room1sum + (room2sum/2l)*((N-visitcnt)/visitcnt);
//			long answer2 = room4sum/2l + room3sum + (room4sum/2l)*((N-visitcnt)/visitcnt);
//			long answer = (answer1+ answer2)/4l;
//			long value_b = roomarr.get((int) (visitcnt*0.5));
			Collections.sort(roomarr1);
			Collections.sort(roomarr2);
//			long value_a = (long) (((sum-mincnt-maxcnt)/(visitcnt-2))*1); 
			long value_a = (long) (((sum)/(visitcnt)));
			long value_b1 = roomarr1.get((int) (visitcnt*0.5));
			long value_b2 = roomarr2.get((int) (visitcnt*0.5));
			long answer1 = (long) ((sum + Math.max(value_a,value_b1)*(N-visitcnt))/2);
			long answer2 = (long) ((sum + Math.max(value_a,value_b2)*(N-visitcnt))/2);
//			long answer = (long) ((sum + Math.max(value_a,value_b)*(N-visitcnt))/2);
//			long answer = (long) ((sum + value_b*(long)(N-visitcnt))/2);
			System.out.println(""E ""+(answer1+answer2)/2l);
			System.",namgoi
15316,"public class Solution {
	public static void main(String[] args)  {
		Scanner sc = new Scanner(System.in);
		int T = sc.nextInt();
		for (int testcase = 1; testcase <=T; testcase++) {
			int N = sc.nextInt();
			int K = sc.nextInt();

			long[] room1 = new long[N+1];
			long[] room2 = new long[N+1];
			
			boolean[] iswalk = new boolean[N+1];
			boolean[] isvisit = new boolean[N+1];
			LinkedList<Integer> q=  new LinkedList<Integer>();
			for (int i = 1; i <=N; i++) {
				q.add(i);
			}
			
			int no = sc.nextInt();
			int cnt = sc.nextInt();
			isvisit[no]=true;
			int qcnt =0;
			int visitcnt =1;
			int sum =cnt;
			int mincnt =cnt;
			int maxcnt =cnt;
			while(qcnt<K) {
				if(visitcnt==N) break;
				if(iswalk[no]) {
					while(!q.isEmpty()) {
						no = q.poll();
						if(!isvisit[no]) break;
					}
					System.out.println(""T ""+no);
					System.out.flush();
					no = sc.nextInt();
					cnt = sc.nextInt();
					if(!isvisit[no]) {
						isvisit[no]=true;
						sum+=cnt;
						room1[no]=cnt;
						visitcnt++;
						if(mincnt>cnt) mincnt=cnt;
						if(maxcnt<cnt) maxcnt=cnt;
					}
				}else {
					iswalk[no]=true;
					room1[no]--;
					room2[no]++;
					System.out.println(""W"");
					System.out.flush();
					no = sc.nextInt();
					cnt = sc.nextInt();
					iswalk[no]=true;
					sum--;
					if(!isvisit[no]) {
						sum--;
						visitcnt++;
						isvisit[no]=true;
						sum+=cnt;
						room1[no]=cnt;
						room1[no]--;
						room2[no]++;
						if(mincnt>cnt) mincnt=cnt;
						if(maxcnt<cnt) maxcnt=cnt;
					}
				}
				qcnt++;
			}
			PriorityQueue<long[]> pq = new PriorityQueue<long[]>(new Comparator<long[]>() {
				@Override
				public int compare(long[] o1, long[] o2) {
					return Long.compare(o2[1], o1[1]);
				}
			});
			long room1sum = 0;
			long room2sum = 0;
			for (int i = 1; i <=N; i++) {
				if(isvisit[i]) {
					if(room1[i]>0) {
						pq.add(new long[] {i,room1[i]});
					}
					room1sum += room1[i];
					room2sum += room2[i];
				}
			}
			while(!pq.isEmpty()) {
				long[] cur = pq.poll();
				if(cur[1]!=room1[(int)cur[0]]) continue;
				PriorityQueue<long[]> pq2 = new PriorityQueue<long[]>(new Comparator<long[]>() {
					@Override
					public int compare(long[] o1, long[] o2) {
						return Long.compare(o2[1], o1[1]);
					}
				});
				while(!pq.isEmpty()) {
					long[] next = pq.poll();
					if(next[1]!=room1[(int)next[0]]) continue;
					room1[(int)next[0]]--;
					room2[(int)next[0]]++;
					room1[(int)cur[0]]--;
					room2[(int)cur[0]]++;
					if(room1[(int)next[0]]>0) {
						pq2.add(new long[] {next[0],room1[(int)next[0]]});
					}
					if(room1[(int)cur[0]]==0) break;
				}
				while(!pq2.isEmpty()) {
					pq.add(pq2.poll());
				}
			}

			long room3sum = 0;
			long room4sum = 0;
			ArrayList<Long> roomarr1 = new ArrayList<Long>();
			ArrayList<Long> roomarr2 = new ArrayList<Long>();
			for (int i = 1; i <=N; i++) {
				if(isvisit[i]) {
					room3sum += room1[i];
					room4sum += room2[i];
					roomarr1.add((long) room1[i]+room2[i]);
					roomarr2.add((long) room2[i]);	
				}
			}
//			long answer1 = room2sum/2l + room1sum + (room2sum/2l)*((N-visitcnt)/visitcnt);
//			long answer2 = room4sum/2l + room3sum + (room4sum/2l)*((N-visitcnt)/visitcnt);
//			long answer = (answer1+ answer2)/4l;
//			long value_b = roomarr.get((int) (visitcnt*0.5));
			Collections.sort(roomarr1);
			Collections.sort(roomarr2);
//			long value_a = (long) (((sum-mincnt-maxcnt)/(visitcnt-2))*1); 
			long value_a = (long) (((sum)/(visitcnt)*0.8));
			long value_b1 = roomarr1.get((int) (visitcnt*0.4));
			long value_b2 = roomarr2.get((int) (visitcnt*0.4));
			long answer1 = (long) ((room2sum + Math.max(value_a,value_b1)*(N-visitcnt))/2)+room1sum;
			long answer2 = (long) ((room4sum + Math.max(value_a,value_b2)*(N-visitcnt))/2)+room3sum;
//			long answer = (long) ((sum + Math.max(value_a,value_b)*(N-visitcnt))/2);
//			long answer = (long) ((sum + value_b*(long)(N-visitcnt))/2);
			System.out.println(""E ""+(answer1+answer2)/2l);
			System.",namgoi
15317,"public class Solution {
	public static void main(String[] args) throws Exception {
		Scanner sc = new Scanner(System.in);
		int T = sc.nextInt();
		for (int testcase = 1; testcase <=T; testcase++) {
			int N = sc.nextInt();
			int K = sc.nextInt();

			long[] room1 = new long[N+1];
			long[] room2 = new long[N+1];
			
			boolean[] iswalk = new boolean[N+1];
			boolean[] isvisit = new boolean[N+1];
			LinkedList<Integer> q=  new LinkedList<Integer>();
			for (int i = 1; i <=N; i++) {
				q.add(i);
			}
			
			int no = sc.nextInt();
			int cnt = sc.nextInt();
			isvisit[no]=true;
			int qcnt =0;
			int visitcnt =1;
			int sum =cnt;
			int mincnt =cnt;
			int maxcnt =cnt;
			while(qcnt<K) {
				if(visitcnt==N) break;
				if(iswalk[no]) {
					while(!q.isEmpty()) {
						no = q.poll();
						if(!isvisit[no]) break;
					}
					System.out.println(""T ""+no);
					System.out.flush();
					no = sc.nextInt();
					cnt = sc.nextInt();
					if(!isvisit[no]) {
						isvisit[no]=true;
						sum+=cnt;
						room1[no]=cnt;
						visitcnt++;
						if(mincnt>cnt) mincnt=cnt;
						if(maxcnt<cnt) maxcnt=cnt;
					}
				}else {
					iswalk[no]=true;
					room1[no]--;
					room2[no]++;
					System.out.println(""W"");
					System.out.flush();
					no = sc.nextInt();
					cnt = sc.nextInt();
					iswalk[no]=true;
					sum--;
					if(!isvisit[no]) {
						sum--;
						visitcnt++;
						isvisit[no]=true;
						sum+=cnt;
						room1[no]=cnt;
						room1[no]--;
						room2[no]++;
						if(mincnt>cnt) mincnt=cnt;
						if(maxcnt<cnt) maxcnt=cnt;
					}
				}
				qcnt++;
			}
			PriorityQueue<long[]> pq = new PriorityQueue<long[]>(new Comparator<long[]>() {
				@Override
				public int compare(long[] o1, long[] o2) {
					return Long.compare(o2[1], o1[1]);
				}
			});
			long room1sum = 0;
			long room2sum = 0;
			for (int i = 1; i <=N; i++) {
				if(isvisit[i]) {
					if(room1[i]>0) {
						pq.add(new long[] {i,room1[i]});
					}
					room1sum += room1[i];
					room2sum += room2[i];
				}
			}
			while(!pq.isEmpty()) {
				long[] cur = pq.poll();
				if(cur[1]!=room1[(int)cur[0]]) continue;
				PriorityQueue<long[]> pq2 = new PriorityQueue<long[]>(new Comparator<long[]>() {
					@Override
					public int compare(long[] o1, long[] o2) {
						return Long.compare(o2[1], o1[1]);
					}
				});
				while(!pq.isEmpty()) {
					long[] next = pq.poll();
					if(next[1]!=room1[(int)next[0]]) continue;
					room1[(int)next[0]]--;
					room2[(int)next[0]]++;
					room1[(int)cur[0]]--;
					room2[(int)cur[0]]++;
					if(room1[(int)next[0]]>0) {
						pq2.add(new long[] {next[0],room1[(int)next[0]]});
					}
					if(room1[(int)cur[0]]==0) break;
				}
				while(!pq2.isEmpty()) {
					pq.add(pq2.poll());
				}
			}

			long room3sum = 0;
			long room4sum = 0;
			ArrayList<Long> roomarr1 = new ArrayList<Long>();
			ArrayList<Long> roomarr2 = new ArrayList<Long>();
			for (int i = 1; i <=N; i++) {
				if(isvisit[i]) {
					room3sum += room1[i];
					room4sum += room2[i];
					roomarr1.add((long) room1[i]+room2[i]);
					roomarr2.add((long) room2[i]);	
				}
			}
//			long answer1 = room2sum/2l + room1sum + (room2sum/2l)*((N-visitcnt)/visitcnt);
//			long answer2 = room4sum/2l + room3sum + (room4sum/2l)*((N-visitcnt)/visitcnt);
//			long answer = (answer1+ answer2)/4l;
//			long value_b = roomarr.get((int) (visitcnt*0.5));
			Collections.sort(roomarr1);
			Collections.sort(roomarr2);
//			long value_a = (long) (((sum-mincnt-maxcnt)/(visitcnt-2))*1); 
			long value_a = (long) (((sum)/(visitcnt)*0.8));
			long value_b1 = roomarr1.get((int) (visitcnt*0.4));
			long value_b2 = roomarr2.get((int) (visitcnt*0.4));
			long answer1 = (long) ((room2sum + Math.max(value_a,value_b1)*(N-visitcnt))/2)+room1sum;
			long answer2 = (long) ((room4sum + Math.max(value_a,value_b2)*(N-visitcnt))/2)+room3sum;
//			long answer = (long) ((sum + Math.max(value_a,value_b)*(N-visitcnt))/2);
//			long answer = (long) ((sum + value_b*(long)(N-visitcnt))/2);
			System.out.println(""E ""+(answer1+answer2)/2l);
			System.",namgoi
15318,"public class Solution {
	public static void main(String[] args) throws Exception {
		Scanner sc = new Scanner(System.in);
		int T = sc.nextInt();
		for (int testcase = 1; testcase <=T; testcase++) {
			int N = sc.nextInt();
			int K = sc.nextInt();

			int[] room1 = new int[N+1];
			int[] room2 = new int[N+1];
			
			boolean[] iswalk = new boolean[N+1];
			boolean[] isvisit = new boolean[N+1];
			LinkedList<Integer> q=  new LinkedList<Integer>();
			for (int i = 1; i <=N; i++) {
				q.add(i);
			}
			
			int no = sc.nextInt();
			int cnt = sc.nextInt();
			isvisit[no]=true;
			int qcnt =0;
			int visitcnt =1;
			int sum =cnt;
			int mincnt =cnt;
			int maxcnt =cnt;
			while(qcnt<K) {
				if(visitcnt==N) break;
				if(iswalk[no]) {
					while(!q.isEmpty()) {
						no = q.poll();
						if(!isvisit[no]) break;
					}
					System.out.println(""T ""+no);
					System.out.flush();
					no = sc.nextInt();
					cnt = sc.nextInt();
					if(!isvisit[no]) {
						isvisit[no]=true;
						sum+=cnt;
						room1[no]=cnt;
						visitcnt++;
						if(mincnt>cnt) mincnt=cnt;
						if(maxcnt<cnt) maxcnt=cnt;
					}
				}else {
					iswalk[no]=true;
					room1[no]--;
					room2[no]++;
					System.out.println(""W"");
					System.out.flush();
					no = sc.nextInt();
					cnt = sc.nextInt();
					iswalk[no]=true;
					sum--;
					if(!isvisit[no]) {
						sum--;
						visitcnt++;
						isvisit[no]=true;
						sum+=cnt;
						room1[no]=cnt;
						room1[no]--;
						room2[no]++;
						if(mincnt>cnt) mincnt=cnt;
						if(maxcnt<cnt) maxcnt=cnt;
					}
				}
				qcnt++;
			}
			PriorityQueue<int[]> pq = new PriorityQueue<int[]>(new Comparator<int[]>() {
				@Override
				public int compare(int[] o1, int[] o2) {
					return Integer.compare(o2[1], o1[1]);
				}
			});
			long room1sum = 0;
			long room2sum = 0;
			for (int i = 1; i <=N; i++) {
				if(isvisit[i]) {
					if(room1[i]>0) {
						pq.add(new int[] {i,room1[i]});
					}
					room1sum += room1[i];
					room2sum += room2[i];
				}
			}
			while(!pq.isEmpty()) {
				int[] cur = pq.poll();
				if(cur[1]!=room1[cur[0]]) continue;
				PriorityQueue<int[]> pq2 = new PriorityQueue<int[]>(new Comparator<int[]>() {
					@Override
					public int compare(int[] o1, int[] o2) {
						return Integer.compare(o2[1], o1[1]);
					}
				});
				while(!pq.isEmpty()) {
					int[] next = pq.poll();
					if(next[1]!=room1[next[0]]) continue;
					room1[next[0]]--;
					room2[next[0]]++;
					room1[cur[0]]--;
					room2[cur[0]]++;
					if(room1[next[0]]>0) {
						pq2.add(new int[] {next[0],room1[next[0]]});
					}
					if(room1[cur[0]]==0) break;
				}
				while(!pq2.isEmpty()) {
					pq.add(pq2.poll());
				}
			}

			long room3sum = 0;
			long room4sum = 0;
			ArrayList<Long> roomarr = new ArrayList<Long>();
			for (int i = 1; i <=N; i++) {
				if(isvisit[i]) {
					room3sum += room1[i];
					room4sum += room2[i];
					roomarr.add((long)(room1[i]*0.9) + room2[i]);	
				}
			}
//			long answer1 = room2sum/2l + room1sum + (room2sum/2l)*((N-visitcnt)/visitcnt);
//			long answer2 = room4sum/2l + room3sum + (room4sum/2l)*((N-visitcnt)/visitcnt);
//			long answer = (answer1+ answer2)/4l;
//			long value_b = roomarr.get((int) (visitcnt*0.5));
			Collections.sort(roomarr);
//			long value_a = (long) (((sum-mincnt-maxcnt)/(visitcnt-2))*1); 
			long value_a = (long) (((sum)/(visitcnt)*0.9));
			long value_b = roomarr.get((int) (visitcnt*0.5));
			long answer1 = (long) ((room2sum + Math.max(value_a,value_b)*(N-visitcnt))/2)+room1sum;
			long answer2 = (long) ((room4sum + Math.max(value_a,value_b)*(N-visitcnt))/2)+room3sum;
//			long answer = (long) ((sum + Math.max(value_a,value_b)*(N-visitcnt))/2);
//			long answer = (long) ((sum + value_b*(long)(N-visitcnt))/2);
			System.out.println(""E ""+(answer1+answer2)/2l);
			System.",namgoi
15319,"public class Solution {
	public static void main(String[] args) throws Exception {
		Scanner sc = new Scanner(System.in);
		int T = sc.nextInt();
		for (int testcase = 1; testcase <=T; testcase++) {
			int N = sc.nextInt();
			int K = sc.nextInt();

			int[] room1 = new int[N+1];
			int[] room2 = new int[N+1];
			
			boolean[] iswalk = new boolean[N+1];
			boolean[] isvisit = new boolean[N+1];
			LinkedList<Integer> q=  new LinkedList<Integer>();
			for (int i = 1; i <=N; i++) {
				q.add(i);
			}
			
			int no = sc.nextInt();
			int cnt = sc.nextInt();
			isvisit[no]=true;
			int qcnt =0;
			int visitcnt =1;
			int sum =cnt;
			int mincnt =cnt;
			int maxcnt =cnt;
			while(qcnt<K) {
				if(visitcnt==N) break;
				if(iswalk[no]) {
					while(!q.isEmpty()) {
						no = q.poll();
						if(!isvisit[no]) break;
					}
					System.out.println(""T ""+no);
					System.out.flush();
					no = sc.nextInt();
					cnt = sc.nextInt();
					if(!isvisit[no]) {
						isvisit[no]=true;
						sum+=cnt;
						room1[no]=cnt;
						visitcnt++;
						if(mincnt>cnt) mincnt=cnt;
						if(maxcnt<cnt) maxcnt=cnt;
					}
				}else {
					iswalk[no]=true;
					room1[no]--;
					room2[no]++;
					System.out.println(""W"");
					System.out.flush();
					no = sc.nextInt();
					cnt = sc.nextInt();
					iswalk[no]=true;
					sum--;
					if(!isvisit[no]) {
						sum--;
						visitcnt++;
						isvisit[no]=true;
						sum+=cnt;
						room1[no]=cnt;
						room1[no]--;
						room2[no]++;
						if(mincnt>cnt) mincnt=cnt;
						if(maxcnt<cnt) maxcnt=cnt;
					}
				}
				qcnt++;
			}
			PriorityQueue<int[]> pq = new PriorityQueue<int[]>(new Comparator<int[]>() {
				@Override
				public int compare(int[] o1, int[] o2) {
					return Integer.compare(o2[1], o1[1]);
				}
			});
			long room1sum = 0;
			long room2sum = 0;
			for (int i = 1; i <=N; i++) {
				if(isvisit[i]) {
					if(room1[i]>0) {
						pq.add(new int[] {i,room1[i]});
					}
					room1sum += room1[i];
					room2sum += room2[i];
				}
			}
			while(!pq.isEmpty()) {
				int[] cur = pq.poll();
				if(cur[1]!=room1[cur[0]]) continue;
				PriorityQueue<int[]> pq2 = new PriorityQueue<int[]>(new Comparator<int[]>() {
					@Override
					public int compare(int[] o1, int[] o2) {
						return Integer.compare(o2[1], o1[1]);
					}
				});
				while(!pq.isEmpty()) {
					int[] next = pq.poll();
					if(next[1]!=room1[next[0]]) continue;
					room1[next[0]]--;
					room2[next[0]]++;
					room1[cur[0]]--;
					room2[cur[0]]++;
					if(room1[next[0]]>0) {
						pq2.add(new int[] {next[0],room1[next[0]]});
					}
					if(room1[cur[0]]==0) break;
				}
				while(!pq2.isEmpty()) {
					pq.add(pq2.poll());
				}
			}

			long room3sum = 0;
			long room4sum = 0;
			ArrayList<Integer> roomarr = new ArrayList<Integer>();
			for (int i = 1; i <=N; i++) {
				if(isvisit[i]) {
					room3sum += room1[i];
					room4sum += room2[i];
					roomarr.add(room1[i] + room2[i]);	
				}
			}
//			long answer1 = room2sum/2l + room1sum + (room2sum/2l)*((N-visitcnt)/visitcnt);
//			long answer2 = room4sum/2l + room3sum + (room4sum/2l)*((N-visitcnt)/visitcnt);
//			long answer = (answer1+ answer2)/4l;
//			long value_b = roomarr.get((int) (visitcnt*0.5));
			Collections.sort(roomarr);
////			long value_a = (long) (((sum-mincnt-maxcnt)/(visitcnt-2))*1); 
			long value_a = (long) (((sum)/(visitcnt)));
			long value_b = roomarr.get((int) (visitcnt*0.5));
			long answer1 = (long) ((room2sum + Math.max(value_a,value_b)*(N-visitcnt))/2)+room1sum;
			long answer2 = (long) ((room4sum + Math.max(value_a,value_b)*(N-visitcnt))/2)+room3sum;
//			long answer = (long) ((sum + Math.max(value_a,value_b)*(N-visitcnt))/2);
//			long answer = (long) ((sum + value_b*(long)(N-visitcnt))/2);
			System.out.println(""E ""+(answer1+answer2)/2l);
			System.",namgoi
15320,"public class Solution {
	public static void main(String[] args) throws Exception {
		Scanner sc = new Scanner(System.in);
		int T = sc.nextInt();
		for (int testcase = 1; testcase <=T; testcase++) {
			int N = sc.nextInt();
			int K = sc.nextInt();

			int[] room1 = new int[N+1];
			int[] room2 = new int[N+1];
			
			boolean[] iswalk = new boolean[N+1];
			boolean[] isvisit = new boolean[N+1];
			LinkedList<Integer> q=  new LinkedList<Integer>();
			for (int i = 1; i <=N; i++) {
				q.add(i);
			}
			
			int no = sc.nextInt();
			int cnt = sc.nextInt();
			isvisit[no]=true;
			int qcnt =0;
			int visitcnt =1;
			int sum =cnt;
			int mincnt =cnt;
			int maxcnt =cnt;
			while(qcnt<K) {
				if(visitcnt==N) break;
				if(iswalk[no]) {
					while(!q.isEmpty()) {
						no = q.poll();
						if(!isvisit[no]) break;
					}
					System.out.println(""T ""+no);
					System.out.flush();
					no = sc.nextInt();
					cnt = sc.nextInt();
					if(!isvisit[no]) {
						isvisit[no]=true;
						sum+=cnt;
						room1[no]=cnt;
						visitcnt++;
						if(mincnt>cnt) mincnt=cnt;
						if(maxcnt<cnt) maxcnt=cnt;
					}
				}else {
					iswalk[no]=true;
					room1[no]--;
					room2[no]++;
					System.out.println(""W"");
					System.out.flush();
					no = sc.nextInt();
					cnt = sc.nextInt();
					iswalk[no]=true;
					sum--;
					if(!isvisit[no]) {
						sum--;
						visitcnt++;
						isvisit[no]=true;
						sum+=cnt;
						room1[no]=cnt;
						room1[no]--;
						room2[no]++;
						if(mincnt>cnt) mincnt=cnt;
						if(maxcnt<cnt) maxcnt=cnt;
					}
				}
				qcnt++;
			}
			PriorityQueue<int[]> pq = new PriorityQueue<int[]>(new Comparator<int[]>() {
				@Override
				public int compare(int[] o1, int[] o2) {
					return Integer.compare(o2[1], o1[1]);
				}
			});
			long room1sum = 0;
			long room2sum = 0;
			for (int i = 1; i <=N; i++) {
				if(isvisit[i]) {
					if(room1[i]>0) {
						pq.add(new int[] {i,room1[i]});
					}
					room1sum += room1[i];
					room2sum += room2[i];
				}
			}
			while(!pq.isEmpty()) {
				int[] cur = pq.poll();
				if(cur[1]!=room1[cur[0]]) continue;
				PriorityQueue<int[]> pq2 = new PriorityQueue<int[]>(new Comparator<int[]>() {
					@Override
					public int compare(int[] o1, int[] o2) {
						return Integer.compare(o2[1], o1[1]);
					}
				});
				while(!pq.isEmpty()) {
					int[] next = pq.poll();
					if(next[1]!=room1[next[0]]) continue;
					room1[next[0]]--;
					room2[next[0]]++;
					room1[cur[0]]--;
					room2[cur[0]]++;
					if(room1[next[0]]>0) {
						pq2.add(new int[] {next[0],room1[next[0]]});
					}
					if(room1[cur[0]]==0) break;
				}
				while(!pq2.isEmpty()) {
					pq.add(pq2.poll());
				}
			}

			long room3sum = 0;
			long room4sum = 0;
			ArrayList<Integer> roomarr = new ArrayList<Integer>();
			for (int i = 1; i <=N; i++) {
				if(isvisit[i]) {
					room3sum += room1[i];
					room4sum += room2[i];
					roomarr.add(room1[i] + room2[i]);	
				}
			}
//			long answer1 = room2sum/2l + room1sum + (room2sum/2l)*((N-visitcnt)/visitcnt);
//			long answer2 = room4sum/2l + room3sum + (room4sum/2l)*((N-visitcnt)/visitcnt);
//			long answer = (answer1+ answer2)/4l;
//			long value_b = roomarr.get((int) (visitcnt*0.5));
			Collections.sort(roomarr);
////			long value_a = (long) (((sum-mincnt-maxcnt)/(visitcnt-2))*1); 
//			long value_a = (long) (((sum)/(visitcnt)));
			long value_b = roomarr.get((int) (visitcnt*0.5));
			long answer1 = (long) ((room2sum + value_b*(N-visitcnt))/2)+room1sum;
			long answer2 = (long) ((room4sum + value_b*(N-visitcnt))/2)+room3sum;
//			long answer = (long) ((sum + Math.max(value_a,value_b)*(N-visitcnt))/2);
//			long answer = (long) ((sum + value_b*(long)(N-visitcnt))/2);
			System.out.println(""E ""+(answer1+answer2)/2l);
			System.",namgoi
15321,"public class Solution {
	public static void main(String[] args) throws Exception {
		Scanner sc = new Scanner(System.in);
		int T = sc.nextInt();
		for (int testcase = 1; testcase <=T; testcase++) {
			int N = sc.nextInt();
			int K = sc.nextInt();

			int[] room1 = new int[N+1];
			int[] room2 = new int[N+1];
			
			boolean[] iswalk = new boolean[N+1];
			boolean[] isvisit = new boolean[N+1];
			LinkedList<Integer> q=  new LinkedList<Integer>();
			for (int i = 1; i <=N; i++) {
				q.add(i);
			}
			
			int no = sc.nextInt();
			int cnt = sc.nextInt();
			isvisit[no]=true;
			int qcnt =0;
			int visitcnt =1;
			int sum =cnt;
			int mincnt =cnt;
			int maxcnt =cnt;
			while(qcnt<K) {
				if(visitcnt==N) break;
				if(iswalk[no]) {
					while(!q.isEmpty()) {
						no = q.poll();
						if(!isvisit[no]) break;
					}
					System.out.println(""T ""+no);
					System.out.flush();
					no = sc.nextInt();
					cnt = sc.nextInt();
					if(!isvisit[no]) {
						isvisit[no]=true;
						sum+=cnt;
						room1[no]=cnt;
						visitcnt++;
						if(mincnt>cnt) mincnt=cnt;
						if(maxcnt<cnt) maxcnt=cnt;
					}
				}else {
					iswalk[no]=true;
					room1[no]--;
					room2[no]++;
					System.out.println(""W"");
					System.out.flush();
					no = sc.nextInt();
					cnt = sc.nextInt();
					iswalk[no]=true;
					sum--;
					if(!isvisit[no]) {
						sum--;
						visitcnt++;
						isvisit[no]=true;
						sum+=cnt;
						room1[no]=cnt;
						room1[no]--;
						room2[no]++;
						if(mincnt>cnt) mincnt=cnt;
						if(maxcnt<cnt) maxcnt=cnt;
					}
				}
				qcnt++;
			}
			PriorityQueue<int[]> pq = new PriorityQueue<int[]>(new Comparator<int[]>() {
				@Override
				public int compare(int[] o1, int[] o2) {
					return Integer.compare(o2[1], o1[1]);
				}
			});
			long room1sum = 0;
			long room2sum = 0;
			for (int i = 1; i <=N; i++) {
				if(room1[i]>0) {
					pq.add(new int[] {i,room1[i]});
				}
				room1sum += room1[i];
				room2sum += room2[i];
			}
			while(!pq.isEmpty()) {
				int[] cur = pq.poll();
				if(cur[1]!=room1[cur[0]]) continue;
				PriorityQueue<int[]> pq2 = new PriorityQueue<int[]>(new Comparator<int[]>() {
					@Override
					public int compare(int[] o1, int[] o2) {
						return Integer.compare(o2[1], o1[1]);
					}
				});
				while(!pq.isEmpty()) {
					int[] next = pq.poll();
					if(next[1]!=room1[next[0]]) continue;
					room1[next[0]]--;
					room2[next[0]]++;
					room1[cur[0]]--;
					room2[cur[0]]++;
					if(room1[next[0]]>0) {
						pq2.add(new int[] {next[0],room1[next[0]]});
					}
					if(room1[cur[0]]==0) break;
				}
				while(!pq2.isEmpty()) {
					pq.add(pq2.poll());
				}
			}

			long room3sum = 0;
			long room4sum = 0;
			ArrayList<Integer> roomarr = new ArrayList<Integer>();
			for (int i = 1; i <=N; i++) {
				room3sum += room1[i];
				room4sum += room2[i];
				if(isvisit[i]) {
					roomarr.add((int)(room1[i]*0.7) + room2[i]);	
				}
			}
//			long answer1 = room2sum/2l + room1sum + (room2sum/2l)*((N-visitcnt)/visitcnt);
//			long answer2 = room4sum/2l + room3sum + (room4sum/2l)*((N-visitcnt)/visitcnt);
//			long answer = (answer1+ answer2)/4l;
//			long value_b = roomarr.get((int) (visitcnt*0.5));
			Collections.sort(roomarr);
////			long value_a = (long) (((sum-mincnt-maxcnt)/(visitcnt-2))*1); 
//			long value_a = (long) (((sum)/(visitcnt)));
			long value_b = roomarr.get((int) (visitcnt*0.5));
			long answer1 = (long) ((room2sum + value_b*(N-visitcnt))/2)+room1sum;
			long answer2 = (long) ((room4sum + value_b*(N-visitcnt))/2)+room3sum;
//			long answer = (long) ((sum + Math.max(value_a,value_b)*(N-visitcnt))/2);
//			long answer = (long) ((sum + value_b*(long)(N-visitcnt))/2);
			System.out.println(""E ""+(answer1+answer2)/2l);
			System.",namgoi
15322,"public class Solution {
	public static void main(String[] args) throws Exception {
		Scanner sc = new Scanner(System.in);
		int T = sc.nextInt();
		for (int testcase = 1; testcase <=T; testcase++) {
			int N = sc.nextInt();
			int K = sc.nextInt();

			int[] room1 = new int[N+1];
			int[] room2 = new int[N+1];
			
			boolean[] iswalk = new boolean[N+1];
			boolean[] isvisit = new boolean[N+1];
			LinkedList<Integer> q=  new LinkedList<Integer>();
			for (int i = 1; i <=N; i++) {
				q.add(i);
			}
			
			int no = sc.nextInt();
			int cnt = sc.nextInt();
			isvisit[no]=true;
			int qcnt =0;
			int visitcnt =1;
			int sum =cnt;
			int mincnt =cnt;
			int maxcnt =cnt;
			while(qcnt<K) {
				if(visitcnt==N) break;
				if(iswalk[no]) {
					while(!q.isEmpty()) {
						no = q.poll();
						if(!isvisit[no]) break;
					}
					System.out.println(""T ""+no);
					System.out.flush();
					no = sc.nextInt();
					cnt = sc.nextInt();
					if(!isvisit[no]) {
						isvisit[no]=true;
						sum+=cnt;
						room1[no]=cnt;
						visitcnt++;
						if(mincnt>cnt) mincnt=cnt;
						if(maxcnt<cnt) maxcnt=cnt;
					}
				}else {
					iswalk[no]=true;
					room1[no]--;
					room2[no]++;
					System.out.println(""W"");
					System.out.flush();
					no = sc.nextInt();
					cnt = sc.nextInt();
					iswalk[no]=true;
					sum--;
					if(!isvisit[no]) {
						sum--;
						visitcnt++;
						isvisit[no]=true;
						sum+=cnt;
						room1[no]=cnt;
						room1[no]--;
						room2[no]++;
						if(mincnt>cnt) mincnt=cnt;
						if(maxcnt<cnt) maxcnt=cnt;
					}
				}
				qcnt++;
			}
			PriorityQueue<int[]> pq = new PriorityQueue<int[]>(new Comparator<int[]>() {
				@Override
				public int compare(int[] o1, int[] o2) {
					return Integer.compare(o2[1], o1[1]);
				}
			});
			long room1sum = 0;
			long room2sum = 0;
			for (int i = 1; i <=N; i++) {
				if(room1[i]>0) {
					pq.add(new int[] {i,room1[i]});
				}
				room1sum += room1[i];
				room2sum += room2[i];
			}
			while(!pq.isEmpty()) {
				int[] cur = pq.poll();
				if(cur[1]!=room1[cur[0]]) continue;
				PriorityQueue<int[]> pq2 = new PriorityQueue<int[]>(new Comparator<int[]>() {
					@Override
					public int compare(int[] o1, int[] o2) {
						return Integer.compare(o2[1], o1[1]);
					}
				});
				while(!pq.isEmpty()) {
					int[] next = pq.poll();
					if(next[1]!=room1[next[0]]) continue;
					room1[next[0]]--;
					room2[next[0]]++;
					room1[cur[0]]--;
					room2[cur[0]]++;
					if(room1[next[0]]>0) {
						pq2.add(new int[] {next[0],room1[next[0]]});
					}
					if(room1[cur[0]]==0) break;
				}
				while(!pq2.isEmpty()) {
					pq.add(pq2.poll());
				}
			}

			long room3sum = 0;
			long room4sum = 0;
			ArrayList<Integer> roomarr = new ArrayList<Integer>();
			for (int i = 1; i <=N; i++) {
				room3sum += room1[i];
				room4sum += room2[i];
				if(isvisit[i]) {
					roomarr.add((int)(room1[i]*0.7) + room2[i]);	
				}
			}
//			long answer1 = room2sum/2l + room1sum + (room2sum/2l)*((N-visitcnt)/visitcnt);
//			long answer2 = room4sum/2l + room3sum + (room4sum/2l)*((N-visitcnt)/visitcnt);
//			long answer = (answer1+ answer2)/4l;
//			long value_b = roomarr.get((int) (visitcnt*0.5));
			Collections.sort(roomarr);
////			long value_a = (long) (((sum-mincnt-maxcnt)/(visitcnt-2))*1); 
//			long value_a = (long) (((sum)/(visitcnt)));
			long value_b = roomarr.get((int) (visitcnt*0.5));
			long answer = (long) ((room4sum + value_b*(N-visitcnt))/2)+room3sum;
//			long answer = (long) ((sum + Math.max(value_a,value_b)*(N-visitcnt))/2);
//			long answer = (long) ((sum + value_b*(long)(N-visitcnt))/2);
			System.out.println(""E ""+answer);
			System.",namgoi
15323,"public class Solution {
	public static void main(String[] args) throws Exception {
		Scanner sc = new Scanner(System.in);
		int T = sc.nextInt();
		for (int testcase = 1; testcase <=T; testcase++) {
			int N = sc.nextInt();
			int K = sc.nextInt();

			int[] room1 = new int[N+1];
			int[] room2 = new int[N+1];
			ArrayList<Integer> roomarr = new ArrayList<Integer>();
			boolean[] iswalk = new boolean[N+1];
			boolean[] isvisit = new boolean[N+1];
			LinkedList<Integer> q=  new LinkedList<Integer>();
			for (int i = 1; i <=N; i++) {
				q.add(i);
			}
			
			int no = sc.nextInt();
			int cnt = sc.nextInt();
			isvisit[no]=true;
			roomarr.add(cnt);
			int qcnt =0;
			int visitcnt =1;
			int sum =cnt;
			int mincnt =cnt;
			int maxcnt =cnt;
			while(qcnt<K) {
				if(visitcnt==N) break;
				if(iswalk[no]) {
					while(!q.isEmpty()) {
						no = q.poll();
						if(!isvisit[no]) break;
					}
					System.out.println(""T ""+no);
					System.out.flush();
					no = sc.nextInt();
					cnt = sc.nextInt();
					if(!isvisit[no]) {
						isvisit[no]=true;
						sum+=cnt;
						room1[no]=cnt;
						roomarr.add(cnt);
						visitcnt++;
						if(mincnt>cnt) mincnt=cnt;
						if(maxcnt<cnt) maxcnt=cnt;
					}
				}else {
					iswalk[no]=true;
					room1[no]--;
					room2[no]++;
					System.out.println(""W"");
					System.out.flush();
					no = sc.nextInt();
					cnt = sc.nextInt();
					iswalk[no]=true;
					sum--;
					if(!isvisit[no]) {
						sum--;
						visitcnt++;
						isvisit[no]=true;
						sum+=cnt;
						room1[no]=cnt;
						room1[no]--;
						room2[no]++;
						roomarr.add(cnt);
						if(mincnt>cnt) mincnt=cnt;
						if(maxcnt<cnt) maxcnt=cnt;
					}
				}
				qcnt++;
			}
			PriorityQueue<int[]> pq = new PriorityQueue<int[]>(new Comparator<int[]>() {
				@Override
				public int compare(int[] o1, int[] o2) {
					return Integer.compare(o2[1], o1[1]);
				}
			});
			long room1sum = 0;
			long room2sum = 0;
			for (int i = 1; i <=N; i++) {
				if(room1[i]>0) {
					pq.add(new int[] {i,room1[i]});
				}
				room1sum += room1[i];
				room2sum += room2[i];
			}
			while(!pq.isEmpty()) {
				int[] cur = pq.poll();
				if(cur[1]!=room1[cur[0]]) continue;
				PriorityQueue<int[]> pq2 = new PriorityQueue<int[]>(new Comparator<int[]>() {
					@Override
					public int compare(int[] o1, int[] o2) {
						return Integer.compare(o2[1], o1[1]);
					}
				});
				while(!pq.isEmpty()) {
					int[] next = pq.poll();
					if(next[1]!=room1[next[0]]) continue;
					room1[next[0]]--;
					room2[next[0]]++;
					room1[cur[0]]--;
					room2[cur[0]]++;
					if(room1[next[0]]>0) {
						pq2.add(new int[] {next[0],room1[next[0]]});
					}
					if(room1[cur[0]]==0) break;
				}
				while(!pq2.isEmpty()) {
					pq.add(pq2.poll());
				}
			}

			long room3sum = 0;
			long room4sum = 0;
			for (int i = 1; i <=N; i++) {
				room3sum += room1[i];
				room4sum += room2[i];
			}
//			long answer1 = room2sum/2l + room1sum + (room2sum/2l)*((N-visitcnt)/visitcnt);
//			long answer2 = room4sum/2l + room3sum + (room4sum/2l)*((N-visitcnt)/visitcnt);
//			long answer = (answer1+ answer2)/4l;
//			long value_b = roomarr.get((int) (visitcnt*0.5));
			Collections.sort(roomarr);
////			long value_a = (long) (((sum-mincnt-maxcnt)/(visitcnt-2))*1); 
//			long value_a = (long) (((sum)/(visitcnt)));
			long value_b = roomarr.get((int) (visitcnt*0.5));
			long answer = (long) ((room4sum + value_b*(N-visitcnt))/2)+room3sum;
//			long answer = (long) ((sum + Math.max(value_a,value_b)*(N-visitcnt))/2);
//			long answer = (long) ((sum + value_b*(long)(N-visitcnt))/2);
			System.out.println(""E ""+answer);
			System.",namgoi
15324,"public class Solution {
	public static void main(String[] args) {
		Scanner sc = new Scanner(System.in);
		int T = sc.nextInt();
		for (int testcase = 1; testcase <=T; testcase++) {
			int N = sc.nextInt();
			int K = sc.nextInt();
			
			LinkedList<Integer> q=  new LinkedList<Integer>();
			for (int i = 1; i <=N; i++) {
				q.add(i);
			}
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			
			
			long[] room = new long[N+1];
			ArrayList<Long> roomarr = new ArrayList<Long>();
			boolean[] isvisit = new boolean[N+1];
			
			int no = sc.nextInt();
			long cnt = sc.nextLong();
			roomarr.add(cnt);
			long visitcnt =1;
			long sum =cnt;
			isvisit[no]=true;
			int querycnt=0;
			while(true) {
				if(visitcnt==N) break;
				if(querycnt==K) break;
				if(q.isEmpty()) break;
				while(!q.isEmpty()) {
					no = q.poll();
					if(!isvisit[no]) break;
				}
				System.out.println(""T ""+no);
				System.out.flush();
				no = sc.nextInt();
				cnt = sc.nextInt();
				if(!isvisit[no]) {
					isvisit[no]=true;
					sum+=cnt;
					room[no]=cnt;
					roomarr.add(cnt);
					visitcnt++;
				}
				querycnt++;
			}
			
			Collections.sort(roomarr);
			long value_a = (((sum)/(visitcnt)));
			long value_b = roomarr.get((int) (visitcnt*0.55));
			long answer = ",namgoi
15325,"public class Solution {
	public static void main(String[] args) {
		Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int T = sc.nextInt();
		for (int testcase = 1; testcase <=T; testcase++) {
			int N = sc.nextInt();
			int K = sc.nextInt();
			
			LinkedList<Integer> q=  new LinkedList<Integer>();
			for (int i = 1; i <=N; i++) {
				q.add(i);
			}
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			Collections.shuffle(q);
			
			
			long[] room = new long[N+1];
			ArrayList<Long> roomarr = new ArrayList<Long>();
			boolean[] isvisit = new boolean[N+1];
			
			int no = sc.nextInt();
			long cnt = sc.nextLong();
			roomarr.add(cnt);
			long visitcnt =1;
			long sum =cnt;
			isvisit[no]=true;
			
			for (int i = 1; i <=K; i++) {
				if(visitcnt==N) break;
				if(q.isEmpty()) break;
				while(!q.isEmpty()) {
					no = q.poll();
					if(!isvisit[no]) break;
				}
				System.out.println(""T ""+no);
				System.out.flush();
				no = sc.nextInt();
				cnt = sc.nextInt();
				if(!isvisit[no]) {
					isvisit[no]=true;
					sum+=cnt;
					room[no]=cnt;
					roomarr.add(cnt);
					visitcnt++;
				}
			}
			
			Collections.sort(roomarr);
			long value_a = (((sum)/(visitcnt)));
			long value_b = roomarr.get((int) (visitcnt*0.55));
			long answer = ",namgoi
15326,"public class Solution {
	public static void main(String[] args) {
		Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int T = sc.nextInt();
		for (int testcase = 1; testcase <=T; testcase++) {
			int N = sc.nextInt();
			int K = sc.nextInt();
			
			LinkedList<Integer> q=  new LinkedList<Integer>();
			for (int i = 1; i <=N; i++) {
				q.add(i);
			}
			long[] room = new long[N+1];
			ArrayList<Long> roomarr = new ArrayList<Long>();
			boolean[] isvisit = new boolean[N+1];
			
			int no = sc.nextInt();
			long cnt = sc.nextLong();
			roomarr.add(cnt);
			long visitcnt =1;
			long sum =cnt;
			isvisit[no]=true;
			
			for (int i = 1; i <=K; i++) {
				if(visitcnt==N) break;
				if(q.isEmpty()) break;
				while(!q.isEmpty()) {
					no = q.poll();
					if(!isvisit[no]) break;
				}
				System.out.println(""T ""+no);
				System.out.flush();
				no = sc.nextInt();
				cnt = sc.nextInt();
				if(!isvisit[no]) {
					isvisit[no]=true;
					sum+=cnt;
					room[no]=cnt;
					roomarr.add(cnt);
					visitcnt++;
				}
			}
			
			Collections.sort(roomarr);
			long value_a = (((sum)/(visitcnt)));
			long value_b = roomarr.get((int) (visitcnt*0.55));
			long answer = ",namgoi
15327,"public class Solution {
	public static void main(String[] args) {
		Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int T = sc.nextInt();
		for (int testcase = 1; testcase <=T; testcase++) {
			int N = sc.nextInt();
			int K = sc.nextInt();
			LinkedList<Integer> q =  new LinkedList<Integer>();
			for (int i = 1; i <=N; i++) {
				q.add(i);
			}
			long[] room = new long[N+1];
			ArrayList<Long> roomarr = new ArrayList<Long>();
			int no = sc.nextInt();
			long cnt = sc.nextLong();
			roomarr.add(cnt);
			long visitcnt =1;
			long sum =cnt;
			boolean[] isvisit = new boolean[N+1];
			isvisit[no]=true;
			for (int i = 1; i <=K; i++) {
				if(visitcnt==N) break;
				while(!q.isEmpty()) {
					no = q.poll();
					if(!isvisit[no]) break;
				}
				System.out.println(""T ""+no);
				System.out.flush();
				no = sc.nextInt();
				cnt = sc.nextInt();
				if(!isvisit[no]) {
					isvisit[no]=true;
					sum+=cnt;
					room[no]=cnt;
					roomarr.add(cnt);
					visitcnt++;
				}
			}
			Collections.sort(roomarr);
//			long value_a = (long) (((sum-mincnt-maxcnt)/(visitcnt-2))*1); 
			long value_a = (long) (((sum)/(visitcnt)));
			long value_b = roomarr.get((int) (visitcnt*0.5));
			long answer = (long) ((sum + Math.min(value_a,value_b)*(N-visitcnt))/2l);
//			long answer = (long) ((sum + value_b*(long)(N-visitcnt))/2);
			System.out.println(""E ""+answer);
			System.out.flush();
		}
		System.",namgoi
15328,"public class Solution {
	public static void main(String[] args) {
		Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int T = sc.nextInt();
		for (int testcase = 1; testcase <=T; testcase++) {
			int N = sc.nextInt();
			int K = sc.nextInt();
			LinkedList<Integer> q=  new LinkedList<Integer>();
			for (int i = N; i >=1; i--) {
				q.add(i);
			}
			long[] room = new long[N+1];
			ArrayList<Long> roomarr = new ArrayList<Long>();
			int no = sc.nextInt();
			long cnt = sc.nextLong();
			roomarr.add(cnt);
			long visitcnt =1;
			long sum =cnt;
			boolean[] isvisit = new boolean[N+1];
			isvisit[no]=true;
			for (int i = 1; i <=K; i++) {
				if(visitcnt==N) break;
				while(!q.isEmpty()) {
					no = q.poll();
					if(!isvisit[no]) break;
				}
				System.out.println(""T ""+no);
				System.out.flush();
				no = sc.nextInt();
				cnt = sc.nextInt();
				if(!isvisit[no]) {
					isvisit[no]=true;
					sum+=cnt;
					room[no]=cnt;
					roomarr.add(cnt);
					visitcnt++;
				}
			}
			Collections.sort(roomarr);
//			long value_a = (long) (((sum-mincnt-maxcnt)/(visitcnt-2))*1); 
			long value_a = (long) (((sum)/(visitcnt)));
			long value_b = roomarr.get((int) (visitcnt*0.5));
			long answer = ",namgoi
15329,"public class Solution {
	public static void main(String[] args) throws Exception {
		Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int T = sc.nextInt();
		for (int testcase = 1; testcase <=T; testcase++) {
			int N = sc.nextInt();
			int K = sc.nextInt();
			LinkedList<Integer> q=  new LinkedList<Integer>();
			for (int i = N; i >=1; i--) {
				q.add(i);
			}
			long[] room = new long[N+1];
			ArrayList<Long> roomarr = new ArrayList<Long>();
			int no = sc.nextInt();
			long cnt = sc.nextLong();
			roomarr.add(cnt);
			int qcnt =0;
			long visitcnt =1;
			long sum =cnt;
			boolean[] isvisit = new boolean[N+1];
			isvisit[no]=true;
			while(qcnt<K) {
				if(visitcnt==N) break;
				while(!q.isEmpty()) {
					no = q.poll();
					if(!isvisit[no]) break;
				}
				System.out.println(""T ""+no);
				System.out.flush();
				no = sc.nextInt();
				cnt = sc.nextInt();
				if(!isvisit[no]) {
					isvisit[no]=true;
					sum+=cnt;
					room[no]=cnt;
					roomarr.add(cnt);
					visitcnt++;
				}
				qcnt++;
			}
			Collections.sort(roomarr);
//			long value_a = (long) (((sum-mincnt-maxcnt)/(visitcnt-2))*1); 
			long value_a = (long) (((sum)/(visitcnt)));
			long value_b = roomarr.get((int) (visitcnt*0.5));
			long answer = ",namgoi
15330,"public class Solution {
	public static void main(String[] args) throws Exception {
		Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int T = sc.nextInt();
		for (int testcase = 1; testcase <=T; testcase++) {
			int N = sc.nextInt();
			int K = sc.nextInt();
			LinkedList<Integer> q=  new LinkedList<Integer>();
			for (int i = 1; i <=N; i++) {
				q.add(i);
			}
			Collections.shuffle(q);
			Collections.shuffle(q);
			long[] room = new long[N+1];
			ArrayList<Long> roomarr = new ArrayList<Long>();
			int no = sc.nextInt();
			long cnt = sc.nextLong();
			roomarr.add(cnt);
			int qcnt =0;
			int visitcnt =1;
			long sum =cnt;
			boolean[] isvisit = new boolean[N+1];
			isvisit[no]=true;
			while(qcnt<K) {
				if(visitcnt==N) break;
				while(!q.isEmpty()) {
					no = q.poll();
					if(!isvisit[no]) break;
				}
				System.out.println(""T ""+no);
				System.out.flush();
				no = sc.nextInt();
				cnt = sc.nextInt();
				if(!isvisit[no]) {
					isvisit[no]=true;
					sum+=cnt;
					room[no]=cnt;
					roomarr.add(cnt);
					visitcnt++;
				}
				qcnt++;
			}
			Collections.sort(roomarr);
//			long value_a = (long) (((sum-mincnt-maxcnt)/(visitcnt-2))*1); 
			long value_a = (long) (((sum)/(visitcnt)));
			long value_b = roomarr.get((int) (visitcnt*0.5));
			long answer = ",namgoi
15331,"public class Solution {
	public static void main(String[] args) throws Exception {
		Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int T = sc.nextInt();
		for (int testcase = 1; testcase <=T; testcase++) {
			int N = sc.nextInt();
			int K = sc.nextInt();
			LinkedList<Integer> q=  new LinkedList<Integer>();
			for (int i = 1; i <=N; i++) {
				q.add(i);
			}
			Collections.shuffle(q);
			Collections.shuffle(q);
			int[] room = new int[N+1];
			ArrayList<Integer> roomarr = new ArrayList<Integer>();
			int no = sc.nextInt();
			int cnt = sc.nextInt();
			roomarr.add(cnt);
			int qcnt =0;
			int visitcnt =1;
			int sum =cnt;
			boolean[] isvisit = new boolean[N+1];
			isvisit[no]=true;
			while(qcnt<K) {
				if(visitcnt==N) break;
				while(!q.isEmpty()) {
					no = q.poll();
					if(!isvisit[no]) break;
				}
				System.out.println(""T ""+no);
//				System.out.flush();
				no = sc.nextInt();
				cnt = sc.nextInt();
				if(!isvisit[no]) {
					isvisit[no]=true;
					sum+=cnt;
					room[no]=cnt;
					roomarr.add(cnt);
					visitcnt++;
				}
				qcnt++;
			}
			Collections.sort(roomarr);
//			long value_a = (long) (((sum-mincnt-maxcnt)/(visitcnt-2))*1); 
			long value_a = (long) (((sum)/(visitcnt)));
			long value_b = roomarr.get((int) (visitcnt*0.5));
			long answer = ",namgoi
15333,"public class Solution {
	public static void main(String[] args) throws Exception {
		Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int T = sc.nextInt();
		for (int testcase = 1; testcase <=T; testcase++) {
			int N = sc.nextInt();
			int K = sc.nextInt();
			LinkedList<Integer> q=  new LinkedList<Integer>();
			for (int i = 1; i <=N; i++) {
				q.add(i);
			}
			Collections.shuffle(q);
			int[] room = new int[N+1];
			ArrayList<Integer> roomarr = new ArrayList<Integer>();
			int no = sc.nextInt();
			int cnt = sc.nextInt();
			roomarr.add(cnt);
			int qcnt =0;
			int visitcnt =1;
			int sum =cnt;
			boolean[] isvisit = new boolean[N+1];
			isvisit[no]=true;
			while(qcnt<K) {
				if(visitcnt==N) break;
				Collections.shuffle(q);
				while(!q.isEmpty()) {
					no = q.poll();
					if(!isvisit[no]) break;
				}
				System.out.println(""T ""+no);
				System.out.flush();
				no = sc.nextInt();
				cnt = sc.nextInt();
				if(!isvisit[no]) {
					isvisit[no]=true;
					sum+=cnt;
					room[no]=cnt;
					roomarr.add(cnt);
					visitcnt++;
				}
				qcnt++;
			}
			Collections.sort(roomarr);
//			long value_a = (long) (((sum-mincnt-maxcnt)/(visitcnt-2))*1); 
			long value_a = (long) (((sum)/(visitcnt)));
			long value_b = roomarr.get((int) (visitcnt*0.5));
			long answer = ",namgoi
15334,"public class Solution {
	public static void main(String[] args) throws Exception {
		Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int T = sc.nextInt();
		for (int testcase = 1; testcase <=T; testcase++) {
			int N = sc.nextInt();
			int K = sc.nextInt();
			LinkedList<Integer> q=  new LinkedList<Integer>();
			for (int i = 1; i <=N; i++) {
				q.add(i);
			}
			Collections.shuffle(q);
			Collections.shuffle(q);
			int[] room = new int[N+1];
			ArrayList<Integer> roomarr = new ArrayList<Integer>();
			int no = sc.nextInt();
			int cnt = sc.nextInt();
			roomarr.add(cnt);
			int qcnt =0;
			int visitcnt =1;
			int sum =cnt;
			boolean[] isvisit = new boolean[N+1];
			isvisit[no]=true;
			while(qcnt<K) {
				if(visitcnt==N) break;
				while(!q.isEmpty()) {
					no = q.poll();
					if(!isvisit[no]) break;
				}
				System.out.println(""T ""+no);
				System.out.flush();
				no = sc.nextInt();
				cnt = sc.nextInt();
				if(!isvisit[no]) {
					isvisit[no]=true;
					sum+=cnt;
					room[no]=cnt;
					roomarr.add(cnt);
					visitcnt++;
				}
				qcnt++;
			}
			Collections.sort(roomarr);
//			long value_a = (long) (((sum-mincnt-maxcnt)/(visitcnt-2))*1); 
			long value_a = (long) (((sum)/(visitcnt)));
			long value_b = roomarr.get((int) (visitcnt*0.5));
			long answer = ",namgoi
15335,"public class Solution {
	public static void main(String[] args) throws Exception {
		Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int T = sc.nextInt();
		for (int testcase = 1; testcase <=T; testcase++) {
			int N = sc.nextInt();
			int K = sc.nextInt();
			int[] room = new int[N+1];
			ArrayList<Integer> roomarr = new ArrayList<Integer>();
			int no = sc.nextInt();
			int cnt = sc.nextInt();
			roomarr.add(cnt);
			int qcnt =0;
			int visitcnt =1;
			int sum =cnt;
			int mincnt =cnt;
			int maxcnt =cnt;
			boolean[] iswalk = new boolean[N+1];
			boolean[] isvisit = new boolean[N+1];
			isvisit[no]=true;
			LinkedList<Integer> q=  new LinkedList<Integer>();
			for (int i = 1; i <=N; i++) {
				q.add(i);
			}
			Collections.shuffle(q);
			while(qcnt<K) {
				if(visitcnt==N) break;
				if(iswalk[no]) {
					while(!q.isEmpty()) {
						no = q.poll();
						if(!isvisit[no]) break;
					}
					System.out.println(""T ""+no);
					System.out.flush();
					no = sc.nextInt();
					cnt = sc.nextInt();
					if(!isvisit[no]) {
						isvisit[no]=true;
						sum+=cnt;
						room[no]=cnt;
						roomarr.add(cnt);
						visitcnt++;
						if(mincnt>cnt) mincnt=cnt;
						if(maxcnt<cnt) maxcnt=cnt;
					}
				}else {
					iswalk[no]=true;
					System.out.println(""W"");
					System.out.flush();
					no = sc.nextInt();
					cnt = sc.nextInt();
					iswalk[no]=true;
					sum--;
					if(!isvisit[no]) {
						sum--;
						visitcnt++;
						isvisit[no]=true;
						sum+=cnt;
						room[no]=cnt;
						roomarr.add(cnt);
						if(mincnt>cnt) mincnt=cnt;
						if(maxcnt<cnt) maxcnt=cnt;
					}
				}
				qcnt++;
			}
			Collections.sort(roomarr);
//			long value_a = (long) (((sum-mincnt-maxcnt)/(visitcnt-2))*1); 
			long value_a = (long) (((sum)/(visitcnt)));
			long value_b = roomarr.get((int) (visitcnt*0.4));
			long answer = ",namgoi
15336,"public class Solution {
	public static void main(String[] args) throws Exception {
		Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int T = sc.nextInt();
		for (int testcase = 1; testcase <=T; testcase++) {
			int N = sc.nextInt();
			int K = sc.nextInt();
			int[] room = new int[N+1];
			ArrayList<Integer> roomarr = new ArrayList<Integer>();
			int no = sc.nextInt();
			int cnt = sc.nextInt();
			roomarr.add(cnt);
			int qcnt =0;
			int visitcnt =1;
			int sum =cnt;
			int mincnt =cnt;
			int maxcnt =cnt;
			boolean[] iswalk = new boolean[N+1];
			boolean[] isvisit = new boolean[N+1];
			isvisit[no]=true;
			LinkedList<Integer> q=  new LinkedList<Integer>();
			for (int i = 1; i <=N; i++) {
				q.add(i);
			}
			Collections.shuffle(q);
			while(qcnt<K) {
				if(visitcnt==N) break;
				if(iswalk[no]) {
					while(!q.isEmpty()) {
						no = q.poll();
						if(!isvisit[no]) break;
					}
					System.out.println(""T ""+no);
					System.out.flush();
					no = sc.nextInt();
					cnt = sc.nextInt();
					if(!isvisit[no]) {
						isvisit[no]=true;
						sum+=cnt;
						room[no]=cnt;
						roomarr.add(cnt);
						visitcnt++;
						if(mincnt>cnt) mincnt=cnt;
						if(maxcnt<cnt) maxcnt=cnt;
					}
				}else {
					iswalk[no]=true;
					System.out.println(""W"");
					System.out.flush();
					no = sc.nextInt();
					cnt = sc.nextInt();
					iswalk[no]=true;
					sum--;
					if(!isvisit[no]) {
						sum--;
						visitcnt++;
						isvisit[no]=true;
						sum+=cnt;
						room[no]=cnt;
						roomarr.add(cnt);
						if(mincnt>cnt) mincnt=cnt;
						if(maxcnt<cnt) maxcnt=cnt;
					}
				}
				qcnt++;
			}
			Collections.sort(roomarr);
//			long value_a = (long) (((sum-mincnt-maxcnt)/(visitcnt-2))*1); 
			long value_a = (long) (((sum)/(visitcnt)));
			long value_b = roomarr.get((int) (visitcnt*0.7));
			long answer = ",namgoi
15337,"public class Solution {
	public static void main(String[] args) throws Exception {
		Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int T = sc.nextInt();
		for (int testcase = 1; testcase <=T; testcase++) {
			int N = sc.nextInt();
			int K = sc.nextInt();
			int[] room = new int[N+1];
			ArrayList<Integer> roomarr = new ArrayList<Integer>();
			int no = sc.nextInt();
			int cnt = sc.nextInt();
			roomarr.add(cnt);
			int qcnt =0;
			int visitcnt =1;
			int sum =cnt;
			int mincnt =cnt;
			int maxcnt =cnt;
			boolean[] iswalk = new boolean[N+1];
			boolean[] isvisit = new boolean[N+1];
			isvisit[no]=true;
			LinkedList<Integer> q=  new LinkedList<Integer>();
			for (int i = 1; i <=N; i++) {
				q.add(i);
			}
			Collections.shuffle(q);
			while(qcnt<K) {
				if(visitcnt==N) break;
				if(iswalk[no]) {
					while(!q.isEmpty()) {
						no = q.poll();
						if(!isvisit[no]) break;
					}
					System.out.println(""T ""+no);
					System.out.flush();
					no = sc.nextInt();
					cnt = sc.nextInt();
					if(!isvisit[no]) {
						isvisit[no]=true;
						sum+=cnt;
						room[no]=cnt;
						roomarr.add(cnt);
						visitcnt++;
						if(mincnt>cnt) mincnt=cnt;
						if(maxcnt<cnt) maxcnt=cnt;
					}
				}else {
					iswalk[no]=true;
					System.out.println(""W"");
					System.out.flush();
					no = sc.nextInt();
					cnt = sc.nextInt();
					iswalk[no]=true;
					sum--;
					if(!isvisit[no]) {
						sum--;
						visitcnt++;
						isvisit[no]=true;
						sum+=cnt;
						room[no]=cnt;
						roomarr.add(cnt);
						if(mincnt>cnt) mincnt=cnt;
						if(maxcnt<cnt) maxcnt=cnt;
					}
				}
				qcnt++;
			}
			Collections.sort(roomarr);
//			long value_a = (long) (((sum-mincnt-maxcnt)/(visitcnt-2))*1); 
			long value_a = (long) (((sum)/(visitcnt))*1.5);
			long value_b = roomarr.get((int) (visitcnt/2));
			long answer = ",namgoi
15338,"public class Solution {
	public static void main(String[] args) throws Exception {
		Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int T = sc.nextInt();
		for (int testcase = 1; testcase <=T; testcase++) {
			int N = sc.nextInt();
			int K = sc.nextInt();
			int[] room = new int[N+1];
			ArrayList<Integer> roomarr = new ArrayList<Integer>();
			int no = sc.nextInt();
			int cnt = sc.nextInt();
			roomarr.add(cnt);
			int qcnt =0;
			int visitcnt =1;
			int sum =cnt;
			int mincnt =cnt;
			int maxcnt =cnt;
			boolean[] iswalk = new boolean[N+1];
			boolean[] isvisit = new boolean[N+1];
			isvisit[no]=true;
			LinkedList<Integer> q=  new LinkedList<Integer>();
			for (int i = 1; i <=N; i++) {
				q.add(i);
			}
			Collections.shuffle(q);
			while(qcnt<K) {
				if(visitcnt==N) break;
				if(iswalk[no]) {
					while(!q.isEmpty()) {
						no = q.poll();
						if(!isvisit[no]) break;
					}
					System.out.println(""T ""+no);
					System.out.flush();
					no = sc.nextInt();
					cnt = sc.nextInt();
					if(!isvisit[no]) {
						isvisit[no]=true;
						sum+=cnt;
						room[no]=cnt;
						roomarr.add(cnt);
						visitcnt++;
						if(mincnt>cnt) mincnt=cnt;
						if(maxcnt<cnt) maxcnt=cnt;
					}
				}else {
					iswalk[no]=true;
					System.out.println(""W"");
					System.out.flush();
					no = sc.nextInt();
					cnt = sc.nextInt();
					iswalk[no]=true;
					if(!isvisit[no]) {
						visitcnt++;
						isvisit[no]=true;
						sum+=cnt;
						room[no]=cnt;
						roomarr.add(cnt);
						if(mincnt>cnt) mincnt=cnt;
						if(maxcnt<cnt) maxcnt=cnt;
					}
				}
				qcnt++;
			}
			Collections.sort(roomarr);
			long value_a = (long) (((sum-mincnt-maxcnt)/(visitcnt-2))*1); 
			long value_b = roomarr.get((int) (roomarr.size()*0.5));
			long answer = ",namgoi
15339,"public class Solution {
	public static void main(String[] args) throws Exception {
		Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int T = sc.nextInt();
		for (int testcase = 1; testcase <=T; testcase++) {
			int N = sc.nextInt();
			int K = sc.nextInt();
			int[] room = new int[N+1];
			ArrayList<Integer> roomarr = new ArrayList<Integer>();
			int no = sc.nextInt();
			int cnt = sc.nextInt();
			roomarr.add(cnt);
			int qcnt =0;
			int visitcnt =1;
			int sum =cnt;
			int mincnt =cnt;
			int maxcnt =cnt;
			boolean[] iswalk = new boolean[N+1];
			boolean[] isvisit = new boolean[N+1];
			isvisit[no]=true;
			LinkedList<Integer> q=  new LinkedList<Integer>();
			for (int i = 1; i <=N; i++) {
				q.add(i);
			}
			Collections.shuffle(q);
			while(qcnt<K) {
				if(visitcnt==N) break;
//				if(iswalk[no]) {
					while(!q.isEmpty()) {
						no = q.poll();
						if(!isvisit[no]) break;
					}
					System.out.println(""T ""+no);
					System.out.flush();
					no = sc.nextInt();
					cnt = sc.nextInt();
					if(!isvisit[no]) {
						isvisit[no]=true;
						sum+=cnt;
						room[no]=cnt;
						roomarr.add(cnt);
						visitcnt++;
						if(mincnt>cnt) mincnt=cnt;
						if(maxcnt<cnt) maxcnt=cnt;
					}
//				}else {
//					iswalk[no]=true;
//					System.out.println(""W"");
//					System.out.flush();
//					no = sc.nextInt();
//					cnt = sc.nextInt();
//					iswalk[no]=true;
//					if(!isvisit[no]) {
//						visitcnt++;
//						isvisit[no]=true;
//						sum+=cnt;
//						room[no]=cnt;
//						roomarr.add(cnt);
//						if(mincnt>cnt) mincnt=cnt;
//						if(maxcnt<cnt) maxcnt=cnt;
//					}
//				}
				qcnt++;
			}
			Collections.sort(roomarr);
			long answer= 0;
//			if((qcnt+1)<N) {
				long value_a = (long) (((sum-mincnt-maxcnt)/(visitcnt-2))*1); 
				long value_b = roomarr.get((int) (roomarr.size()*0.5));
				answer = ",namgoi
15340,"public class codejamQ5 {
	public static void main(String[] args) throws Exception {
		Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int T = sc.nextInt();
		for (int testcase = 1; testcase <=T; testcase++) {
			int N = sc.nextInt();
			int K = sc.nextInt();
			int[] room = new int[N+1];
			ArrayList<Integer> roomarr = new ArrayList<Integer>();
			int no = sc.nextInt();
			int cnt = sc.nextInt();
			roomarr.add(cnt);
			int qcnt =0;
			int visitcnt =1;
			int sum =cnt;
			int mincnt =cnt;
			int maxcnt =cnt;
			boolean[] iswalk = new boolean[N+1];
			boolean[] isvisit = new boolean[N+1];
			isvisit[no]=true;
			LinkedList<Integer> q=  new LinkedList<Integer>();
			for (int i = 1; i <=N; i++) {
				q.add(i);
			}
			Collections.shuffle(q);
			while(qcnt<K) {
				if(visitcnt==N) break;
//				if(iswalk[no]) {
					while(!q.isEmpty()) {
						no = q.poll();
						if(!isvisit[no]) break;
					}
					System.out.println(""T ""+no);
					System.out.flush();
					no = sc.nextInt();
					cnt = sc.nextInt();
					if(!isvisit[no]) {
						isvisit[no]=true;
						sum+=cnt;
						room[no]=cnt;
						roomarr.add(cnt);
						visitcnt++;
						if(mincnt>cnt) mincnt=cnt;
						if(maxcnt<cnt) maxcnt=cnt;
					}
//				}else {
//					iswalk[no]=true;
//					System.out.println(""W"");
//					System.out.flush();
//					no = sc.nextInt();
//					cnt = sc.nextInt();
//					iswalk[no]=true;
//					if(!isvisit[no]) {
//						visitcnt++;
//						isvisit[no]=true;
//						sum+=cnt;
//						room[no]=cnt;
//						roomarr.add(cnt);
//						if(mincnt>cnt) mincnt=cnt;
//						if(maxcnt<cnt) maxcnt=cnt;
//					}
//				}
				qcnt++;
			}
			Collections.sort(roomarr);
			long answer= 0;
//			if((qcnt+1)<N) {
				long value_a = (long) (((sum-mincnt-maxcnt)/(visitcnt-2))*1); 
				long value_b = roomarr.get((int) (roomarr.size()*0.5));
				answer = ",namgoi
15341,"public class Solution {
	public static void main(String[] args) throws Exception {
		Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int T = sc.nextInt();
		for (int testcase = 1; testcase <=T; testcase++) {
			int N = sc.nextInt();
			int K = sc.nextInt();
			int[] room = new int[N+1];
			ArrayList<Integer> roomarr = new ArrayList<Integer>();
			int no = sc.nextInt();
			int cnt = sc.nextInt();
			roomarr.add(cnt);
			int qcnt =0;
			int visitcnt =1;
			int sum =cnt;
			int mincnt =cnt;
			int maxcnt =cnt;
			boolean[] iswalk = new boolean[N+1];
			boolean[] isvisit = new boolean[N+1];
			isvisit[no]=true;
			LinkedList<Integer> q=  new LinkedList<Integer>();
			for (int i = 1; i <=N; i++) {
				q.add(i);
			}
			Collections.shuffle(q);
			while(qcnt<K) {
				if(visitcnt==N) break;
//				if(iswalk[no]) {
					while(!q.isEmpty()) {
						no = q.poll();
						if(!isvisit[no]) break;
					}
					System.out.println(""T ""+no);
					System.out.flush();
					no = sc.nextInt();
					cnt = sc.nextInt();
					if(!isvisit[no]) {
						isvisit[no]=true;
						sum+=cnt;
						room[no]=cnt;
						roomarr.add(cnt);
						visitcnt++;
						if(mincnt>cnt) mincnt=cnt;
						if(maxcnt<cnt) maxcnt=cnt;
					}
//				}else {
//					iswalk[no]=true;
//					System.out.println(""W"");
//					System.out.flush();
//					no = sc.nextInt();
//					cnt = sc.nextInt();
//					iswalk[no]=true;
//					if(!isvisit[no]) {
//						visitcnt++;
//						isvisit[no]=true;
//						sum+=cnt;
//						room[no]=cnt;
//						roomarr.add(cnt);
//						if(mincnt>cnt) mincnt=cnt;
//						if(maxcnt<cnt) maxcnt=cnt;
//					}
//				}
				qcnt++;
			}
			Collections.sort(roomarr);
			long answer= 0;
			if((qcnt+1)<N) {
				long value_a = (long) (((sum-mincnt-maxcnt)/(visitcnt-2))*1); 
				long value_b = roomarr.get((int) (roomarr.size()*0.5));
				answer = ",namgoi
15343,"public class Solution {
	public static void main(String[] args) throws Exception {
		Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int T = sc.nextInt();
		for (int testcase = 1; testcase <=T; testcase++) {
			int N = sc.nextInt();
			int K = sc.nextInt();
			int[] room = new int[N+1];
			ArrayList<Integer> roomarr = new ArrayList<Integer>();
			int no = sc.nextInt();
			int cnt = sc.nextInt();
			roomarr.add(cnt);
			int qcnt =0;
			int visitcnt =1;
			int sum =cnt;
			int mincnt =cnt;
			int maxcnt =cnt;
			boolean[] iswalk = new boolean[N+1];
			boolean[] isvisit = new boolean[N+1];
			isvisit[no]=true;
			LinkedList<Integer> q=  new LinkedList<Integer>();
			for (int i = 1; i <=N; i++) {
				q.add(i);
			}
			Collections.shuffle(q);
			while(qcnt<K) {
				if(visitcnt==N) break;
				if(iswalk[no]) {
					while(!q.isEmpty()) {
						no = q.poll();
						if(!isvisit[no]) break;
					}
					System.out.println(""T ""+no);
					System.out.flush();
					no = sc.nextInt();
					cnt = sc.nextInt();
					if(!isvisit[no]) {
						isvisit[no]=true;
						sum+=cnt;
						room[no]=cnt;
						roomarr.add(cnt);
						visitcnt++;
						if(mincnt>cnt) mincnt=cnt;
						if(maxcnt<cnt) maxcnt=cnt;
					}
				}else {
					iswalk[no]=true;
					System.out.println(""W"");
					System.out.flush();
					no = sc.nextInt();
					cnt = sc.nextInt();
					iswalk[no]=true;
					if(!isvisit[no]) {
						visitcnt++;
						isvisit[no]=true;
						sum+=cnt;
						room[no]=cnt;
						roomarr.add(cnt);
						if(mincnt>cnt) mincnt=cnt;
						if(maxcnt<cnt) maxcnt=cnt;
					}
				}
				qcnt++;
			}
			Collections.sort(roomarr);
			long answer= 0;
			if((qcnt+1)<N) {
				long value_a = (long) (((sum-mincnt-maxcnt)/(visitcnt-2))*1); 
				long value_b = roomarr.get((int) (roomarr.size()*0.5));
				answer = ",namgoi
15346,"public class Solution {
	public static void main(String[] args) throws Exception {
		Scanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		int T = sc.nextInt();
		for (int testcase = 1; testcase <=T; testcase++) {
			int N = sc.nextInt();
			int K = sc.nextInt();
			int[] room = new int[N+1];
			ArrayList<Integer> roomarr = new ArrayList<Integer>();
			int no = sc.nextInt();
			int cnt = sc.nextInt();
			roomarr.add(cnt);
			int qcnt =0;
			int visitcnt =1;
			int sum =cnt;
			boolean[] iswalk = new boolean[N+1];
			boolean[] isvisit = new boolean[N+1];
			isvisit[no]=true;
			LinkedList<Integer> q=  new LinkedList<Integer>();
			for (int i = 1; i <=N; i++) {
				q.add(i);
			}
			Collections.shuffle(q);
			while(qcnt<K) {
				if(visitcnt==N) break;
				if(iswalk[no]) {
					while(!q.isEmpty()) {
						no = q.poll();
						if(!isvisit[no]) break;
					}
					System.out.println(""T ""+no);
					System.out.flush();
					no = sc.nextInt();
					cnt = sc.nextInt();
					if(!isvisit[no]) {
						isvisit[no]=true;
						sum+=cnt;
						room[no]=cnt;
						roomarr.add(cnt);
						visitcnt++;
					}
				}else {
					iswalk[no]=true;
					System.out.println(""W"");
					System.out.flush();
					no = sc.nextInt();
					cnt = sc.nextInt();
					iswalk[no]=true;
					if(!isvisit[no]) {
						visitcnt++;
						isvisit[no]=true;
						sum+=cnt;
						room[no]=cnt;
						roomarr.add(cnt);
					}
				}
				qcnt++;
			}
			Collections.sort(roomarr);
			long answer= 0;
			if((qcnt+1)<N) {
				long value_a = (long) ((sum/visitcnt)*1); 
				long value_b = roomarr.get((int) (roomarr.size()*0.5));
				answer = ",namgoi
15347,"public class Solution {
	public static void main(String[] args) throws Exception {
		Scanner sc = new Scanner(System.in);
		int T = sc.nextInt();
		for (int testcase = 1; testcase <=T; testcase++) {
			int N = sc.nextInt();
			int K = sc.nextInt();
			int[] room = new int[N+1];
			ArrayList<Integer> roomarr = new ArrayList<Integer>();
			int no = sc.nextInt();
			int cnt = sc.nextInt();
			roomarr.add(cnt);
			int qcnt =0;
			int visitcnt =1;
			int sum =cnt;
			boolean[] iswalk = new boolean[N+1];
			boolean[] isvisit = new boolean[N+1];
			isvisit[no]=true;
			LinkedList<Integer> q=  new LinkedList<Integer>();
			for (int i = 1; i <=N; i++) {
				q.add(i);
			}
			while(qcnt<K) {
				if(visitcnt==N) break;
				if(iswalk[no]) {
					while(!q.isEmpty()) {
						no = q.poll();
						if(!isvisit[no]) break;
					}
					System.out.println(""T ""+no);
					System.out.flush();
					no = sc.nextInt();
					cnt = sc.nextInt();
					if(!isvisit[no]) {
						isvisit[no]=true;
						sum+=cnt;
						room[no]=cnt;
						roomarr.add(cnt);
						visitcnt++;
					}
				}else {
					iswalk[no]=true;
					System.out.println(""W"");
					System.out.flush();
					no = sc.nextInt();
					cnt = sc.nextInt();
					iswalk[no]=true;
					if(!isvisit[no]) {
						visitcnt++;
						isvisit[no]=true;
						sum+=cnt;
						room[no]=cnt;
						roomarr.add(cnt);
					}
				}
				qcnt++;
			}
			Collections.sort(roomarr);
			long answer= 0;
			if((qcnt+1)<N) {
				long value_a = (long) ((sum/visitcnt)*1); 
				long value_b = roomarr.get((int) (roomarr.size()*0.5));
				answer = ",namgoi
15348,"public class Solution {
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new  InputStreamReader(System.in));
		int T = Integer.parseInt(br.readLine());
		for (int testcase = 1; testcase <=T; testcase++) {
			StringTokenizer st = new StringTokenizer(br.readLine());
			int N = Integer.parseInt(st.nextToken());
			int K = Integer.parseInt(st.nextToken());
			int[] room = new int[N+1];
			ArrayList<Integer> roomarr = new ArrayList<Integer>();
			st = new StringTokenizer(br.readLine());
			int no = Integer.parseInt(st.nextToken());
			int cnt = Integer.parseInt(st.nextToken());
			roomarr.add(cnt);
			int qcnt =0;
			int visitcnt =1;
			int sum =cnt;
			boolean[] iswalk = new boolean[N+1];
			boolean[] isvisit = new boolean[N+1];
			isvisit[no]=true;
			LinkedList<Integer> q=  new LinkedList<Integer>();
			for (int i = 1; i <=N; i++) {
				q.add(i);
			}
			while(qcnt<K) {
				if(visitcnt==N) break;
				if(iswalk[no]) {
					while(!q.isEmpty()) {
						no = q.poll();
						if(!isvisit[no]) break;
					}
					System.out.println(""T ""+no);
					System.out.flush();
					st = new StringTokenizer(br.readLine());
					no = Integer.parseInt(st.nextToken());
					cnt = Integer.parseInt(st.nextToken());
					if(!isvisit[no]) {
						isvisit[no]=true;
						sum+=cnt;
						room[no]=cnt;
						roomarr.add(cnt);
						visitcnt++;
					}
				}else {
					iswalk[no]=true;
					System.out.println(""W"");
					System.out.flush();
					st = new StringTokenizer(br.readLine());
					no = Integer.parseInt(st.nextToken());
					cnt = Integer.parseInt(st.nextToken());
					iswalk[no]=true;
					if(!isvisit[no]) {
						visitcnt++;
						isvisit[no]=true;
						sum+=cnt;
						room[no]=cnt;
						roomarr.add(cnt);
					}
				}
				qcnt++;
			}
			Collections.sort(roomarr);
			long answer= 0;
			if((qcnt+1)<N) {
				long value_a = (long) ((sum/visitcnt)*1); 
				long value_b = roomarr.get((int) (roomarr.size()*0.5));
				answer = ",namgoi
15349,"public class Solution {
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new  InputStreamReader(System.in));
		int T = Integer.parseInt(br.readLine());
		for (int testcase = 1; testcase <=T; testcase++) {
			StringTokenizer st = new StringTokenizer(br.readLine());
			int N = Integer.parseInt(st.nextToken());
			int K = Integer.parseInt(st.nextToken());
			int[] room = new int[N+1];
			ArrayList<Integer> roomarr = new ArrayList<Integer>();
			st = new StringTokenizer(br.readLine());
			int no = Integer.parseInt(st.nextToken());
			int cnt = Integer.parseInt(st.nextToken());
			roomarr.add(cnt);
			int qcnt =0;
			int visitcnt =1;
			int sum =cnt;
			boolean[] iswalk = new boolean[N+1];
			boolean[] isvisit = new boolean[N+1];
			isvisit[no]=true;
			LinkedList<Integer> q=  new LinkedList<Integer>();
			for (int i = 1; i <=N; i++) {
				q.add(i);
			}
			while(qcnt<K) {
				if(visitcnt==N) break;
				if(iswalk[no]) {
					while(!q.isEmpty()) {
						no = q.poll();
						if(!isvisit[no]) break;
					}
					System.out.println(""T ""+no);
					System.out.flush();
					st = new StringTokenizer(br.readLine());
					no = Integer.parseInt(st.nextToken());
					cnt = Integer.parseInt(st.nextToken());
					isvisit[no]=true;
					sum+=cnt;
					room[no]=cnt;
					roomarr.add(cnt);
					visitcnt++;
				}else {
					iswalk[no]=true;
					System.out.println(""W"");
					System.out.flush();
					st = new StringTokenizer(br.readLine());
					no = Integer.parseInt(st.nextToken());
					cnt = Integer.parseInt(st.nextToken());
					iswalk[no]=true;
					if(!isvisit[no]) {
						visitcnt++;
						isvisit[no]=true;
					}
					sum+=cnt;
					room[no]=cnt;
					roomarr.add(cnt);
				}
				qcnt++;
			}
			Collections.sort(roomarr);
			long answer= 0;
			if((qcnt+1)<N) {
				long value_a = (long) ((sum/visitcnt)*1.1); 
				long value_b = roomarr.get((int) (roomarr.size()*0.7));
				answer = ",namgoi
15350,"public class Solution {
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new  InputStreamReader(System.in));
		int T = Integer.parseInt(br.readLine());
		for (int testcase = 1; testcase <=T; testcase++) {
			StringTokenizer st = new StringTokenizer(br.readLine());
			int N = Integer.parseInt(st.nextToken());
			int K = Integer.parseInt(st.nextToken());
			int[] room = new int[N+1];
			ArrayList<Integer> roomarr = new ArrayList<Integer>();
			st = new StringTokenizer(br.readLine());
			int no = Integer.parseInt(st.nextToken());
			int cnt = Integer.parseInt(st.nextToken());
			roomarr.add(cnt);
			int qcnt =0;
			int visitcnt =1;
			int sum =cnt;
			boolean[] iswalk = new boolean[N+1];
			boolean[] isvisit = new boolean[N+1];
			isvisit[no]=true;
			LinkedList<Integer> q=  new LinkedList<Integer>();
			for (int i = 1; i <=N; i++) {
				q.add(i);
			}
			while(qcnt<K) {
				if(visitcnt==N) break;
				if(iswalk[no]) {
					while(!q.isEmpty()) {
						no = q.poll();
						if(!isvisit[no]) break;
					}
					System.out.println(""T ""+no);
					System.out.flush();
					st = new StringTokenizer(br.readLine());
					no = Integer.parseInt(st.nextToken());
					cnt = Integer.parseInt(st.nextToken());
					isvisit[no]=true;
					sum+=cnt;
					room[no]=cnt;
					roomarr.add(cnt);
					visitcnt++;
				}else {
					iswalk[no]=true;
					System.out.println(""W"");
					System.out.flush();
					st = new StringTokenizer(br.readLine());
					no = Integer.parseInt(st.nextToken());
					cnt = Integer.parseInt(st.nextToken());
					iswalk[no]=true;
					if(!isvisit[no]) {
						visitcnt++;
						isvisit[no]=true;
					}
					sum+=cnt;
					room[no]=cnt;
					roomarr.add(cnt);
				}
				qcnt++;
			}
			Collections.sort(roomarr);
			long answer= 0;
			if((qcnt+1)<N) {
				long value_b = roomarr.get((int) (roomarr.size()*0.5));
				answer = ",namgoi
15351,"public class Solution {
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new  InputStreamReader(System.in));
		int T = Integer.parseInt(br.readLine());
		for (int testcase = 1; testcase <=T; testcase++) {
			StringTokenizer st = new StringTokenizer(br.readLine());
			int N = Integer.parseInt(st.nextToken());
			int K = Integer.parseInt(st.nextToken());
			int[] room = new int[N+1];
			ArrayList<Integer> roomarr = new ArrayList<Integer>();
			st = new StringTokenizer(br.readLine());
			int no = Integer.parseInt(st.nextToken());
			int cnt = Integer.parseInt(st.nextToken());
			roomarr.add(cnt);
			int qcnt =0;
			int visitcnt =1;
			int sum =cnt;
			boolean[] iswalk = new boolean[N+1];
			boolean[] isvisit = new boolean[N+1];
			isvisit[no]=true;
			LinkedList<Integer> q=  new LinkedList<Integer>();
			for (int i = 1; i <=N; i++) {
				q.add(i);
			}
			while(qcnt<K) {
				if(visitcnt==N) break;
				if(iswalk[no]) {
					while(!q.isEmpty()) {
						no = q.poll();
						if(!isvisit[no]) break;
					}
					System.out.println(""T ""+no);
					System.out.flush();
					st = new StringTokenizer(br.readLine());
					no = Integer.parseInt(st.nextToken());
					cnt = Integer.parseInt(st.nextToken());
					sum+=cnt;
					room[no]=cnt;
					roomarr.add(cnt);
					visitcnt++;
				}else {
					iswalk[no]=true;
					System.out.println(""W"");
					System.out.flush();
					st = new StringTokenizer(br.readLine());
					no = Integer.parseInt(st.nextToken());
					cnt = Integer.parseInt(st.nextToken());
					iswalk[no]=true;
					if(!isvisit[no]) {
						visitcnt++;
						isvisit[no]=true;
					}
					sum+=cnt;
					room[no]=cnt;
					roomarr.add(cnt);
				}
				qcnt++;
			}
			Collections.sort(roomarr);
			long answer= 0;
			if((qcnt+1)<N) {
				long value_b = roomarr.get((int) (roomarr.size()*0.5));
				answer = ",namgoi
15352,"public class Solution {
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new  InputStreamReader(System.in));
		int T = Integer.parseInt(br.readLine());
		for (int testcase = 1; testcase <=T; testcase++) {
			StringTokenizer st = new StringTokenizer(br.readLine());
			int N = Integer.parseInt(st.nextToken());
			int K = Integer.parseInt(st.nextToken());
			int[] room = new int[N+1];
			ArrayList<Integer> roomarr = new ArrayList<Integer>();
			st = new StringTokenizer(br.readLine());
			int no = Integer.parseInt(st.nextToken());
			int cnt = Integer.parseInt(st.nextToken());
			roomarr.add(cnt);
			int qcnt =0;
			int visitcnt =1;
			int sum =cnt;
			boolean[] iswalk = new boolean[N+1];
			boolean[] isvisit = new boolean[N+1];
			isvisit[no]=true;
			LinkedList<Integer> q=  new LinkedList<Integer>();
			for (int i = 1; i <=N; i++) {
				q.add(i);
			}
			while(qcnt<K) {
				if(visitcnt==N) break;
				if(iswalk[no]) {
					while(!q.isEmpty()) {
						no = q.poll();
						if(!isvisit[no]) break;
					}
					System.out.println(""T ""+no);
					System.out.flush();
					st = new StringTokenizer(br.readLine());
					no = Integer.parseInt(st.nextToken());
					cnt = Integer.parseInt(st.nextToken());
					sum+=cnt;
					room[no]=cnt;
					roomarr.add(cnt);
					visitcnt++;
				}else {
					iswalk[no]=true;
					System.out.println(""W"");
					System.out.flush();
					st = new StringTokenizer(br.readLine());
					no = Integer.parseInt(st.nextToken());
					cnt = Integer.parseInt(st.nextToken());
					iswalk[no]=true;
					if(!isvisit[no]) {
						visitcnt++;
						isvisit[no]=true;
					}
					sum+=cnt;
					room[no]=cnt;
					roomarr.add(cnt);
				}
				qcnt++;
			}
			Collections.sort(roomarr);
			long answer= 0;
			if((qcnt+1)<N) {
				long value_b = roomarr.get((int) (roomarr.size()*0.6));
				answer = ",namgoi
15353,"public class Solution {
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new  InputStreamReader(System.in));
		int T = Integer.parseInt(br.readLine());
		for (int testcase = 1; testcase <=T; testcase++) {
			StringTokenizer st = new StringTokenizer(br.readLine());
			int N = Integer.parseInt(st.nextToken());
			int K = Integer.parseInt(st.nextToken());
			int[] room = new int[N+1];
			ArrayList<Integer> roomarr = new ArrayList<Integer>();
			st = new StringTokenizer(br.readLine());
			int no = Integer.parseInt(st.nextToken());
			int cnt = Integer.parseInt(st.nextToken());
			roomarr.add(cnt);
			int qcnt =0;
			int visitcnt =1;
			int sum =cnt;
			boolean[] iswalk = new boolean[N+1];
			boolean[] isvisit = new boolean[N+1];
			isvisit[cnt]=true;
			LinkedList<Integer> q=  new LinkedList<Integer>();
			for (int i = 1; i <=N; i++) {
				q.add(i);
			}
			while(qcnt<K) {
				if(visitcnt==N) break;
				if(iswalk[no]) {
					while(!q.isEmpty()) {
						no = q.poll();
						if(!isvisit[no]) break;
					}
					System.out.println(""T ""+no);
					System.out.flush();
					st = new StringTokenizer(br.readLine());
					no = Integer.parseInt(st.nextToken());
					cnt = Integer.parseInt(st.nextToken());
					sum+=cnt;
					room[no]=cnt;
					roomarr.add(cnt);
					visitcnt++;
				}else {
					iswalk[no]=true;
					System.out.println(""W"");
					System.out.flush();
					st = new StringTokenizer(br.readLine());
					no = Integer.parseInt(st.nextToken());
					cnt = Integer.parseInt(st.nextToken());
					iswalk[no]=true;
					if(!isvisit[no]) {
						visitcnt++;
						isvisit[no]=true;
					}
					sum+=cnt;
					room[no]=cnt;
					roomarr.add(cnt);
				}
				qcnt++;
			}
			Collections.sort(roomarr);
			long answer= 0;
			if((qcnt+1)<N) {
				long value_b = roomarr.get((int) (roomarr.size()*0.6));
				answer = ",namgoi
15354,"public class Solution {
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new  InputStreamReader(System.in));
		int T = Integer.parseInt(br.readLine());
		for (int testcase = 1; testcase <=T; testcase++) {
			StringTokenizer st = new StringTokenizer(br.readLine());
			int N = Integer.parseInt(st.nextToken());
			int K = Integer.parseInt(st.nextToken());
			int[] room = new int[N+1];
			ArrayList<Integer> roomarr = new ArrayList<Integer>();
			st = new StringTokenizer(br.readLine());
			int no = Integer.parseInt(st.nextToken());
			int cnt = Integer.parseInt(st.nextToken());
			roomarr.add(cnt);
			int qcnt =0;
			int visitcnt =1;
			int sum =cnt;
			boolean[] iswalk = new boolean[N+1];
			boolean[] isvisit = new boolean[N+1];
			isvisit[cnt]=true;
			LinkedList<Integer> q=  new LinkedList<Integer>();
			for (int i = 1; i <=N; i++) {
				q.add(i);
			}
			while(qcnt<K) {
				if(visitcnt==N) break;
				if(iswalk[no]) {
					while(!q.isEmpty()) {
						no = q.poll();
						if(!isvisit[no]) break;
					}
					System.out.println(""T ""+no);
					System.out.flush();
					st = new StringTokenizer(br.readLine());
					no = Integer.parseInt(st.nextToken());
					cnt = Integer.parseInt(st.nextToken());
					sum+=cnt;
					room[no]=cnt;
					roomarr.add(cnt);
					visitcnt++;
				}else {
					iswalk[no]=true;
					System.out.println(""W"");
					System.out.flush();
					st = new StringTokenizer(br.readLine());
					no = Integer.parseInt(st.nextToken());
					cnt = Integer.parseInt(st.nextToken());
					iswalk[no]=true;
					if(!isvisit[no]) {
						visitcnt++;
						isvisit[no]=true;
					}
					sum+=cnt;
					room[no]=cnt;
					roomarr.add(cnt);
				}
				qcnt++;
			}
			Collections.sort(roomarr);
			long answer= 0;
			if((qcnt+1)<N) {
				long value_b = roomarr.get((int) (roomarr.size()*0.5));
				answer = ",namgoi
15356,"public class Solution {
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new  InputStreamReader(System.in));
		int T = Integer.parseInt(br.readLine());
		for (int testcase = 1; testcase <=T; testcase++) {
			StringTokenizer st = new StringTokenizer(br.readLine());
			int N = Integer.parseInt(st.nextToken());
			int K = Integer.parseInt(st.nextToken());
			int[] room = new int[N+1];
			ArrayList<Integer> roomarr = new ArrayList<Integer>();
			st = new StringTokenizer(br.readLine());
			int no = Integer.parseInt(st.nextToken());
			int cnt = Integer.parseInt(st.nextToken());
			roomarr.add(cnt);
			int qcnt =0;
			int sum =cnt;
			boolean[] iswalk = new boolean[N+1];
			boolean[] isvisit = new boolean[N+1];
			isvisit[cnt]=true;
			LinkedList<Integer> q=  new LinkedList<Integer>();
			for (int i = 1; i <=N; i++) {
				q.add(i);
			}
			while(qcnt<K) {
				if(qcnt==N-1) break;
				if(iswalk[no]) {
					while(!q.isEmpty()) {
						no = q.poll();
						if(!isvisit[no]) break;
					}
					System.out.println(""T ""+no);
					System.out.flush();
					st = new StringTokenizer(br.readLine());
					no = Integer.parseInt(st.nextToken());
					cnt = Integer.parseInt(st.nextToken());
					sum+=cnt;
					room[no]=cnt;
					roomarr.add(cnt);
				}else {
					iswalk[no]=true;
					System.out.println(""W"");
					System.out.flush();
					st = new StringTokenizer(br.readLine());
					no = Integer.parseInt(st.nextToken());
					cnt = Integer.parseInt(st.nextToken());
					iswalk[no]=true;
					isvisit[no]=true;
					sum+=cnt;
					room[no]=cnt;
					roomarr.add(cnt);
				}
				qcnt++;
			}
			Collections.sort(roomarr);
			long answer= 0;
			if((qcnt+1)<N) {
				long value_b = roomarr.get((int) (roomarr.size()*0.6));
				answer = ",namgoi
15357,"public class Solution {
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new  InputStreamReader(System.in));
		int T = Integer.parseInt(br.readLine());
		for (int testcase = 1; testcase <=T; testcase++) {
			StringTokenizer st = new StringTokenizer(br.readLine());
			int N = Integer.parseInt(st.nextToken());
			int K = Integer.parseInt(st.nextToken());
			int[] room = new int[N+1];
			ArrayList<Integer> roomarr = new ArrayList<Integer>();
			st = new StringTokenizer(br.readLine());
			int no = Integer.parseInt(st.nextToken());
//			if(no==-1) System.exit(-1);
			int cnt = Integer.parseInt(st.nextToken());
			roomarr.add(cnt);
			int qcnt =0;
			int sum =cnt;
			while(qcnt<K) {
				no--;
				if(no==0) no=K;
				if(qcnt==N-1) break;
				System.out.println(""T ""+no);
				System.out.flush();
				st = new StringTokenizer(br.readLine());
				no = Integer.parseInt(st.nextToken());
//				if(no==-1) System.exit(-1);
				cnt = Integer.parseInt(st.nextToken());
				sum+=cnt;
				room[no]=cnt;
				roomarr.add(cnt);
				qcnt++;
			}
			Collections.sort(roomarr);
			long answer= 0;
			if((qcnt+1)<N) {
				long value_a = (long) ((sum/(qcnt+1))); 
				long value_b = roomarr.get((int) (roomarr.size()*0.6));
//				answer = (sum + Math.max(value_a, value_b)*(long)(N-(qcnt+1)))/2; 
				answer = (sum + ((value_a+ value_b)/2)*(long)(N-(qcnt+1)))/2;
//				answer = (sum + value_b*(long)(N-qcnt+1))/2;
			}
			System.out.println(""E ""+answer);
			System.",namgoi
15358,"public class Solution {
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new  InputStreamReader(System.in));
		int T = Integer.parseInt(br.readLine());
		for (int testcase = 1; testcase <=T; testcase++) {
			StringTokenizer st = new StringTokenizer(br.readLine());
			int N = Integer.parseInt(st.nextToken());
			int K = Integer.parseInt(st.nextToken());
			int[] room = new int[N+1];
			ArrayList<Integer> roomarr = new ArrayList<Integer>();
			st = new StringTokenizer(br.readLine());
			int no = Integer.parseInt(st.nextToken());
//			if(no==-1) System.exit(-1);
			int cnt = Integer.parseInt(st.nextToken());
			roomarr.add(cnt);
			int qcnt =0;
			int sum =cnt;
			while(qcnt<K) {
				no++;
				if(no>K) no=1;
				if(qcnt==N-1) break;
				System.out.println(""T ""+no);
				System.out.flush();
				st = new StringTokenizer(br.readLine());
				no = Integer.parseInt(st.nextToken());
//				if(no==-1) System.exit(-1);
				cnt = Integer.parseInt(st.nextToken());
				sum+=cnt;
				room[no]=cnt;
				roomarr.add(cnt);
				qcnt++;
			}
			Collections.sort(roomarr);
			long answer= 0;
			if((qcnt+1)<N) {
				long value_a = (long) ((sum/(qcnt+1))); 
				long value_b = roomarr.get((int) (roomarr.size()*0.6));
//				answer = (sum + Math.max(value_a, value_b)*(long)(N-(qcnt+1)))/2; 
				answer = (sum + ((value_a+ value_b)/2)*(long)(N-(qcnt+1)))/2;
//				answer = (sum + value_b*(long)(N-qcnt+1))/2;
			}
			System.out.println(""E ""+answer);
			System.",namgoi
15359,"public class Solution {
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new  InputStreamReader(System.in));
		int T = Integer.parseInt(br.readLine());
		for (int testcase = 1; testcase <=T; testcase++) {
			StringTokenizer st = new StringTokenizer(br.readLine());
			int N = Integer.parseInt(st.nextToken());
			int K = Integer.parseInt(st.nextToken());
			int[] room = new int[N+1];
			ArrayList<Integer> roomarr = new ArrayList<Integer>();
			st = new StringTokenizer(br.readLine());
			int no = Integer.parseInt(st.nextToken());
//			if(no==-1) System.exit(-1);
			int cnt = Integer.parseInt(st.nextToken());
			roomarr.add(cnt);
			int qcnt =0;
			int sum =cnt;
			while(qcnt<K) {
				no++;
				if(no>K) no=1;
				if(qcnt==N-1) break;
				System.out.println(""T ""+no);
				System.out.flush();
				st = new StringTokenizer(br.readLine());
				no = Integer.parseInt(st.nextToken());
//				if(no==-1) System.exit(-1);
				cnt = Integer.parseInt(st.nextToken());
				sum+=cnt;
				room[no]=cnt;
				roomarr.add(cnt);
				qcnt++;
			}
			Collections.sort(roomarr);
			long answer= 0;
			if((qcnt+1)<N) {
				long value_a = (long) ((sum/(qcnt+1))*1.2); 
				long value_b = roomarr.get((int) (roomarr.size()*0.6));
				//answer = (sum + Math.max(value_a, value_b)*(long)(N-(qcnt+1)))/2; 
				answer = ",namgoi
15360,"public class Solution {
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new  InputStreamReader(System.in));
		int T = Integer.parseInt(br.readLine());
		for (int testcase = 1; testcase <=T; testcase++) {
			StringTokenizer st = new StringTokenizer(br.readLine());
			int N = Integer.parseInt(st.nextToken());
			int K = Integer.parseInt(st.nextToken());
			int[] room = new int[N+1];
			ArrayList<Integer> roomarr = new ArrayList<Integer>();
			st = new StringTokenizer(br.readLine());
			int no = Integer.parseInt(st.nextToken());
//			if(no==-1) System.exit(-1);
			int cnt = Integer.parseInt(st.nextToken());
			roomarr.add(cnt);
			int qcnt =0;
			int sum =cnt;
			while(qcnt<K) {
				no++;
				if(no>K) no=1;
				if(qcnt==N-1) break;
				System.out.println(""T ""+no);
				System.out.flush();
				st = new StringTokenizer(br.readLine());
				no = Integer.parseInt(st.nextToken());
//				if(no==-1) System.exit(-1);
				cnt = Integer.parseInt(st.nextToken());
				sum+=cnt;
				room[no]=cnt;
				roomarr.add(cnt);
				qcnt++;
			}
			Collections.sort(roomarr);
			long answer= 0;
			if((qcnt+1)<N) {
				long value_a = (long) ((sum/(qcnt+1))*1.2); 
				long value_b = roomarr.get((int) (roomarr.size()*0.6));
				answer = (sum + Math.max(value_a, value_b)*(long)(N-(qcnt+1)))/2; 
//				answer = (sum + value_b*(long)(N-qcnt+1))/2;
			}
			System.out.println(""E ""+answer);
			System.",namgoi
15361,"public class Solution {
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new  InputStreamReader(System.in));
		int T = Integer.parseInt(br.readLine());
		for (int testcase = 1; testcase <=T; testcase++) {
			StringTokenizer st = new StringTokenizer(br.readLine());
			int N = Integer.parseInt(st.nextToken());
			int K = Integer.parseInt(st.nextToken());
			int[] room = new int[N+1];
			ArrayList<Integer> roomarr = new ArrayList<Integer>();
			st = new StringTokenizer(br.readLine());
			int no = Integer.parseInt(st.nextToken());
//			if(no==-1) System.exit(-1);
			int cnt = Integer.parseInt(st.nextToken());
			roomarr.add(cnt);
			int qcnt =0;
			int sum =cnt;
			while(qcnt<K) {
				no++;
				if(no>K) no=1;
				if(qcnt==N-1) break;
				System.out.println(""T ""+no);
				System.out.flush();
				st = new StringTokenizer(br.readLine());
				no = Integer.parseInt(st.nextToken());
//				if(no==-1) System.exit(-1);
				cnt = Integer.parseInt(st.nextToken());
				sum+=cnt;
				room[no]=cnt;
				roomarr.add(cnt);
				qcnt++;
			}
			Collections.sort(roomarr);
			long answer= 0;
			if((qcnt+1)<N) {
				long value_a = (long) ((sum/(qcnt+1))*1.2); 
				long value_b = roomarr.get((int) (roomarr.size()*0.6));
				answer = (sum + Math.max(value_a, value_b)*(long)(N-qcnt+1))/2; 
//				answer = (sum + value_b*(long)(N-qcnt+1))/2;
			}
			System.out.println(""E ""+answer);
			System.",namgoi
15362,"public class Solution {
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new  InputStreamReader(System.in));
		int T = Integer.parseInt(br.readLine());
		for (int testcase = 1; testcase <=T; testcase++) {
			StringTokenizer st = new StringTokenizer(br.readLine());
			int N = Integer.parseInt(st.nextToken());
			int K = Integer.parseInt(st.nextToken());
			int[] room = new int[N+1];
			ArrayList<Integer> roomarr = new ArrayList<Integer>();
			st = new StringTokenizer(br.readLine());
			int no = Integer.parseInt(st.nextToken());
//			if(no==-1) System.exit(-1);
			int cnt = Integer.parseInt(st.nextToken());
			roomarr.add(cnt);
			int qcnt =0;
			int sum =cnt;
			while(qcnt<K) {
				no++;
				if(no>K) no=1;
				if(qcnt==N-1) break;
				System.out.println(""T ""+no);
				System.out.flush();
				st = new StringTokenizer(br.readLine());
				no = Integer.parseInt(st.nextToken());
//				if(no==-1) System.exit(-1);
				cnt = Integer.parseInt(st.nextToken());
				sum+=cnt;
				room[no]=cnt;
				roomarr.add(cnt);
				qcnt++;
			}
			Collections.sort(roomarr);
			long answer= 0;
			if((qcnt+1)<N) {
				long value_a = (long) ((sum/(qcnt+1))*0.6); 
				long value_b = roomarr.get((int) (roomarr.size()*0.6));
				answer = (sum + Math.max(value_a, value_b)*(long)(N-qcnt+1))/2; 
//				answer = (sum + value_b*(long)(N-qcnt+1))/2;
			}
			System.out.println(""E ""+answer);
			System.",namgoi
15363,"public class Solution {
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new  InputStreamReader(System.in));
		int T = Integer.parseInt(br.readLine());
		for (int testcase = 1; testcase <=T; testcase++) {
			StringTokenizer st = new StringTokenizer(br.readLine());
			int N = Integer.parseInt(st.nextToken());
			int K = Integer.parseInt(st.nextToken());
			int[] room = new int[N+1];
			ArrayList<Integer> roomarr = new ArrayList<Integer>();
			st = new StringTokenizer(br.readLine());
			int no = Integer.parseInt(st.nextToken());
			if(no==-1) System.exit(-1);
			int cnt = Integer.parseInt(st.nextToken());
			roomarr.add(cnt);
			int qcnt =0;
			int sum =cnt;
			while(qcnt<K) {
				no++;
				if(no>K) no=1;
				if(qcnt==N-1) break;
				System.out.println(""T ""+no);
				System.out.flush();
				st = new StringTokenizer(br.readLine());
				no = Integer.parseInt(st.nextToken());
				if(no==-1) System.exit(-1);
				cnt = Integer.parseInt(st.nextToken());
				sum+=cnt;
				room[no]=cnt;
				roomarr.add(cnt);
				qcnt++;
			}
			Collections.sort(roomarr);
			long answer= 0;
			if((qcnt+1)<N) {
				long value_a = (long) ((sum/(qcnt+1))*0.6); 
				long value_b = roomarr.get((int) (roomarr.size()*0.6));
				answer = ",namgoi
15364,"public class Solution {
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new  InputStreamReader(System.in));
		int T = Integer.parseInt(br.readLine());
		for (int testcase = 1; testcase <=T; testcase++) {
			StringTokenizer st = new StringTokenizer(br.readLine());
			int N = Integer.parseInt(st.nextToken());
			int K = Integer.parseInt(st.nextToken());
			int[] room = new int[N+1];
			ArrayList<Integer> roomarr = new ArrayList<Integer>();
			st = new StringTokenizer(br.readLine());
			int no = Integer.parseInt(st.nextToken());
			if(no==-1) System.exit(-1);
			int cnt = Integer.parseInt(st.nextToken());
			roomarr.add(cnt);
			int qcnt =0;
			int sum =cnt;
			while(qcnt<K) {
				no++;
				if(no>K) no=1;
				if(qcnt==N-1) break;
				System.out.println(""T ""+no);
				System.out.flush();
				st = new StringTokenizer(br.readLine());
				no = Integer.parseInt(st.nextToken());
				if(no==-1) System.exit(-1);
				cnt = Integer.parseInt(st.nextToken());
				sum+=cnt;
				room[no]=cnt;
				roomarr.add(cnt);
				qcnt++;
			}
			Collections.sort(roomarr);
			long answer= 0;
			if((qcnt+1)<N) {
				long value_a = (long) ((sum/(qcnt+1))*0.6); 
				long value_b = roomarr.get((int) (roomarr.size()*0.6));
//				answer = (sum + Math.max(value_a, value_b)*(long)(N-qcnt+1))/2; 
				answer = ",namgoi
15367,"public class Solution {
	static ArrayList<Integer>[] rev_road;
	private static int[] f;
	static final int INF=2_000_000_000;
	private static int[] to;
	private static boolean[] isuse;
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new  InputStreamReader(System.in));
		int T = Integer.parseInt(br.readLine());
		for (int testcase = 1; testcase <=T; testcase++) {
			int N = Integer.parseInt(br.readLine());
			StringTokenizer st = new StringTokenizer(br.readLine());
			f = new int[N+1];
			LinkedList<Integer> q = new LinkedList<Integer>();
			for (int i = 1; i <=N; i++) {
				f[i] = Integer.parseInt(st.nextToken());
				q.add(i);
			}
			to = new int[N+1];
			rev_road = new ArrayList[N+1];
			for (int i = 0; i <=N; i++) {
				rev_road[i]= new ArrayList<Integer>();
			}
			st = new StringTokenizer(br.readLine());
			for (int i = 1; i <=N; i++) {
				int tmp_to = Integer.parseInt(st.nextToken());
				if(tmp_to!=0) {
					to[i]=tmp_to;
					rev_road[tmp_to].add(i);
				}
			}
			isuse = new boolean[N+1];
			long answer = 0;
			while(!q.isEmpty()) {
				int cur = q.poll();
				if(isuse[cur]) continue;
				if(to[cur]!=0) {
					q.add(cur);
					continue;
				}
				int[] start = find_start(cur);
				int value = run(start[0]);
				answer+=value;
			}
			System.out.println(""Case #""+testcase+"": ""+answer);
		}
	}

	private static int run(int cur) {
		isuse[cur]=true;
		for (int next:rev_road[cur]) {
			to[next]=0;	
		}
		if(to[cur]==0) return f[cur];
		return Math.max(f[cur], run(to[cur]));
	}

	private static int[] find_start(int cur) {
		if(rev_road[cur].size()==0) {
			return new int[]{cur,f[cur]};
		}
		int[] subres = new int[]{cur,INF};
		for (int next: rev_road[cur]) {
			int[] tmpres = find_start(next);
			if(subres[1]>tmpres[1]) {
				subres=",namgoi
15368,"public class Solution {
	static ArrayList<Integer>[] rev_road;
	private static int[] f;
	static final int INF=1_000_000_000;
	private static int[] to;
	private static boolean[] isuse;
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new  InputStreamReader(System.in));
		int T = Integer.parseInt(br.readLine());
		for (int testcase = 1; testcase <=T; testcase++) {
			int N = Integer.parseInt(br.readLine());
			StringTokenizer st = new StringTokenizer(br.readLine());
			f = new int[N+1];
			LinkedList<Integer> q = new LinkedList<Integer>();
			for (int i = 1; i <=N; i++) {
				f[i] = Integer.parseInt(st.nextToken());
				q.add(i);
			}
			to = new int[N+1];
			rev_road = new ArrayList[N+1];
			for (int i = 0; i <=N; i++) {
				rev_road[i]= new ArrayList<Integer>();
			}
			st = new StringTokenizer(br.readLine());
			for (int i = 1; i <=N; i++) {
				int tmp_to = Integer.parseInt(st.nextToken());
				if(tmp_to!=0) {
					to[i]=tmp_to;
					rev_road[tmp_to].add(i);
				}
			}
			isuse = new boolean[N+1];
			long answer = 0;
			while(!q.isEmpty()) {
				int cur = q.poll();
				if(isuse[cur]) continue;
				if(to[cur]!=0) {
					q.add(cur);
					continue;
				}
				int[] start = find_start(cur);
				int value = run(start[0]);
				answer+=value;
			}
			System.out.println(""Case #""+testcase+"": ""+answer);
		}
	}

	private static int run(int cur) {
		isuse[cur]=true;
		for (int next:rev_road[cur]) {
			to[next]=0;	
		}
		if(to[cur]==0) return f[cur];
		return Math.max(f[cur], run(to[cur]));
	}

	private static int[] find_start(int cur) {
		if(rev_road[cur].size()==0) {
			return new int[]{cur,f[cur]};
		}
		int[] subres = new int[]{cur,INF};
		for (int next: rev_road[cur]) {
			int[] tmpres = find_start(next);
			if(subres[1]>tmpres[1]) {
				subres=",namgoi
15369,"public class Solution {
	static ArrayList<Integer>[] rev_road;
	private static int[] f;
	static final int INF=1_000_000_000;
	private static int[] to;
	private static boolean[] isuse;
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new  InputStreamReader(System.in));
		int T = Integer.parseInt(br.readLine());
		for (int testcase = 1; testcase <=T; testcase++) {
			int N = Integer.parseInt(br.readLine());
			StringTokenizer st = new StringTokenizer(br.readLine());
			f = new int[N+1];
			LinkedList<Integer> q = new LinkedList<Integer>();
			for (int i = 1; i <=N; i++) {
				f[i] = Integer.parseInt(st.nextToken());
				q.add(i);
			}
			to = new int[N+1];
			rev_road = new ArrayList[N+1];
			for (int i = 0; i <=N; i++) {
				rev_road[i]= new ArrayList<Integer>();
			}
			st = new StringTokenizer(br.readLine());
			for (int i = 1; i <=N; i++) {
				int tmp_to = Integer.parseInt(st.nextToken());
				if(tmp_to!=0) {
					to[i]=tmp_to;
					rev_road[tmp_to].add(i);
				}
			}
			isuse = new boolean[N+1];
			int answer = 0;
			while(!q.isEmpty()) {
				int cur = q.poll();
				if(isuse[cur]) continue;
				if(to[cur]!=0) {
					q.add(cur);
					continue;
				}
				int[] start = find_start(cur);
				int value = run(start[0]);
				answer+=value;
			}
			System.out.println(""Case #""+testcase+"": ""+answer);
		}
	}

	private static int run(int cur) {
		isuse[cur]=true;
		for (int next:rev_road[cur]) {
			to[next]=0;	
		}
		if(to[cur]==0) return f[cur];
		return Math.max(f[cur], run(to[cur]));
	}

	private static int[] find_start(int cur) {
		if(rev_road[cur].size()==0) {
			return new int[]{cur,f[cur]};
		}
		int[] subres = new int[]{cur,INF};
		for (int next: rev_road[cur]) {
			int[] tmpres = find_start(next);
			if(subres[1]>tmpres[1]) {
				subres=",namgoi
15370,"public class Solution {
public class codejamQ4 {
	static ArrayList<Integer>[] rev_road;
	private static int[] f;
	static final int INF=1_000_000_000;
	private static int[] to;
	private static boolean[] isuse;
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new  InputStreamReader(System.in));
		int T = Integer.parseInt(br.readLine());
		for (int testcase = 1; testcase <=T; testcase++) {
			int N = Integer.parseInt(br.readLine());
			StringTokenizer st = new StringTokenizer(br.readLine());
			f = new int[N+1];
			LinkedList<Integer> q = new LinkedList<Integer>();
			for (int i = 1; i <=N; i++) {
				f[i] = Integer.parseInt(st.nextToken());
				q.add(i);
			}
			to = new int[N+1];
			rev_road = new ArrayList[N+1];
			for (int i = 0; i <=N; i++) {
				rev_road[i]= new ArrayList<Integer>();
			}
			st = new StringTokenizer(br.readLine());
			for (int i = 1; i <=N; i++) {
				int tmp_to = Integer.parseInt(st.nextToken());
				if(tmp_to!=0) {
					to[i]=tmp_to;
					rev_road[tmp_to].add(i);
				}
			}
			isuse = new boolean[N+1];
			int answer = 0;
			while(!q.isEmpty()) {
				int cur = q.poll();
				if(isuse[cur]) continue;
				if(to[cur]!=0) {
					q.add(cur);
					continue;
				}
				int[] start = find_start(cur);
				int value = run(start[0]);
				answer+=value;
			}
			System.out.println(""Case #""+testcase+"": ""+answer);
		}
	}

	private static int run(int cur) {
		isuse[cur]=true;
		for (int next:rev_road[cur]) {
			to[next]=0;	
		}
		if(to[cur]==0) return f[cur];
		return Math.max(f[cur], run(to[cur]));
	}

	private static int[] find_start(int cur) {
		if(rev_road[cur].size()==0) {
			return new int[]{cur,f[cur]};
		}
		int[] subres = new int[]{cur,INF};
		for (int next: rev_road[cur]) {
			int[] tmpres = find_start(next);
			if(subres[1]>tmpres[1]) {
				subres=",namgoi
15371,"public class Solution {
	static ArrayList<Integer>[] rev_road;
	private static int[] f;
	static final int INF=2_000_000_000;
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new  InputStreamReader(System.in));
		int T = Integer.parseInt(br.readLine());
		for (int testcase = 1; testcase <=T; testcase++) {
			int N = Integer.parseInt(br.readLine());
			StringTokenizer st = new StringTokenizer(br.readLine());
			f = new int[N+1];
			LinkedList<Integer> q = new LinkedList<Integer>();
			for (int i = 1; i <=N; i++) {
				f[i] = Integer.parseInt(st.nextToken());
				q.add(i);
			}
			int[] to_road = new int[N+1];
			rev_road = new ArrayList[N+1];
			for (int i = 0; i <=N; i++) {
				rev_road[i]= new ArrayList<Integer>();
			}
			st = new StringTokenizer(br.readLine());
			for (int i = 1; i <=N; i++) {
				int to = Integer.parseInt(st.nextToken());
				if(to!=0) {
					to_road[i]=to;
					rev_road[to].add(i);
				}
			}
			boolean[] isuse = new boolean[N+1];
			int answer = 0;
			while(!q.isEmpty()) {
				int cur = q.poll();
				if(isuse[cur]) continue;
				if(to_road[cur]!=0) {
					q.add(cur);
					continue;
				}
				int[] start = find_start(cur);
				LinkedList<int[]> bfsq = new LinkedList<int[]>();
				int value = f[start[0]];
				bfsq.add(new int[] {start[0],value});
				while(!bfsq.isEmpty()) {
					int[] bfs_cur = bfsq.poll();
					isuse[bfs_cur[0]]=true;
					for (int next:rev_road[bfs_cur[0]]) {
						to_road[next]=0;	
					}
					value=bfs_cur[1];
					int next = to_road[bfs_cur[0]];
					if(next==0) break;
					bfsq.add(new int[] {next,Math.max(bfs_cur[1],f[next])});
				}
				answer+=value;
			}
			System.out.println(""Case #""+testcase+"": ""+answer);
		}
	}

	private static int[] find_start(int cur) {
		if(rev_road[cur].size()==0) {
			return new int[]{cur,f[cur]};
		}
		int[] subres = new int[]{cur,INF};
		for (int next: rev_road[cur]) {
			int[] tmpres = find_start(next);
			if(subres[1]>tmpres[1]) {
				subres=",namgoi
15372,"public class Solution {
	static ArrayList<Integer>[] rev_road;
	private static int[] f;
	static final int INF=1_000_000_000;
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new  InputStreamReader(System.in));
		int T = Integer.parseInt(br.readLine());
		for (int testcase = 1; testcase <=T; testcase++) {
			int N = Integer.parseInt(br.readLine());
			StringTokenizer st = new StringTokenizer(br.readLine());
			f = new int[N+1];
			LinkedList<Integer> q = new LinkedList<Integer>();
			for (int i = 1; i <=N; i++) {
				f[i] = Integer.parseInt(st.nextToken());
				q.add(i);
			}
			int[] to_road = new int[N+1];
			rev_road = new ArrayList[N+1];
			for (int i = 0; i <=N; i++) {
				rev_road[i]= new ArrayList<Integer>();
			}
			st = new StringTokenizer(br.readLine());
			for (int i = 1; i <=N; i++) {
				int to = Integer.parseInt(st.nextToken());
				if(to!=0) {
					to_road[i]=to;
					rev_road[to].add(i);
				}
			}
			boolean[] isuse = new boolean[N+1];
			int answer = 0;
			while(!q.isEmpty()) {
				int cur = q.poll();
				if(isuse[cur]) continue;
				if(to_road[cur]!=0) {
					q.add(cur);
					continue;
				}
				int[] start = find_start(cur);
				LinkedList<int[]> bfsq = new LinkedList<int[]>();
				int value = f[start[0]];
				bfsq.add(new int[] {start[0],value});
				while(!bfsq.isEmpty()) {
					int[] bfs_cur = bfsq.poll();
					isuse[bfs_cur[0]]=true;
					for (int next:rev_road[bfs_cur[0]]) {
						to_road[next]=0;	
					}
					value=bfs_cur[1];
					int next = to_road[bfs_cur[0]];
					if(next==0) break;
					bfsq.add(new int[] {next,Math.max(bfs_cur[1],f[next])});
				}
				answer+=value;
			}
			System.out.println(""Case #""+testcase+"": ""+answer);
		}
	}

	private static int[] find_start(int cur) {
		if(rev_road[cur].size()==0) {
			return new int[]{cur,f[cur]};
		}
		int[] subres = new int[]{cur,INF};
		for (int next: rev_road[cur]) {
			int[] tmpres = find_start(next);
			if(subres[1]>tmpres[1]) {
				subres=",namgoi
15373,"public class Solution {
	static ArrayList<Integer>[] rev_road;
	private static int[] f;
	static final int INF=1_000_000_000;
	public static void main(String[] args) throws Exception {
		System.setIn(new FileInputStream(new File(""Q4"")));
		BufferedReader br = new BufferedReader(new  InputStreamReader(System.in));
		int T = Integer.parseInt(br.readLine());
		for (int testcase = 1; testcase <=T; testcase++) {
			int N = Integer.parseInt(br.readLine());
			StringTokenizer st = new StringTokenizer(br.readLine());
			f = new int[N+1];
			LinkedList<Integer> q = new LinkedList<Integer>();
			for (int i = 1; i <=N; i++) {
				f[i] = Integer.parseInt(st.nextToken());
				q.add(i);
			}
			int[] to_road = new int[N+1];
			rev_road = new ArrayList[N+1];
			for (int i = 0; i <=N; i++) {
				rev_road[i]= new ArrayList<Integer>();
			}
			st = new StringTokenizer(br.readLine());
			for (int i = 1; i <=N; i++) {
				int to = Integer.parseInt(st.nextToken());
				if(to!=0) {
					to_road[i]=to;
					rev_road[to].add(i);
				}
			}
			boolean[] isuse = new boolean[N+1];
			int answer = 0;
			while(!q.isEmpty()) {
				int cur = q.poll();
				if(isuse[cur]) continue;
				if(to_road[cur]!=0) {
					q.add(cur);
					continue;
				}
				int[] start = find_start(cur);
				LinkedList<int[]> bfsq = new LinkedList<int[]>();
				int value = f[start[0]];
				bfsq.add(new int[] {start[0],value});
				while(!bfsq.isEmpty()) {
					int[] bfs_cur = bfsq.poll();
					isuse[bfs_cur[0]]=true;
					for (int next:rev_road[bfs_cur[0]]) {
						to_road[next]=0;	
					}
					value=bfs_cur[1];
					int next = to_road[bfs_cur[0]];
					if(next==0) break;
					bfsq.add(new int[] {next,Math.max(bfs_cur[1],f[next])});
				}
				answer+=value;
			}
			System.out.println(""Case #""+testcase+"": ""+answer);
		}
	}

	private static int[] find_start(int cur) {
		if(rev_road[cur].size()==0) {
			return new int[]{cur,f[cur]};
		}
		int[] subres = new int[]{cur,INF};
		for (int next: rev_road[cur]) {
			int[] tmpres = find_start(next);
			if(subres[1]>tmpres[1]) {
				subres=",namgoi
15374,"public class Solution {
	static ArrayList<Integer>[] rev_road;
	private static int[] f;
	static final int INF=1_000_000_000;
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new  InputStreamReader(System.in));
		int T = Integer.parseInt(br.readLine());
		for (int testcase = 1; testcase <=T; testcase++) {
			int N = Integer.parseInt(br.readLine());
			StringTokenizer st = new StringTokenizer(br.readLine());
			f = new int[N+1];
			LinkedList<Integer> q = new LinkedList<Integer>();
			for (int i = 1; i <=N; i++) {
				f[i] = Integer.parseInt(st.nextToken());
				q.add(i);
			}
			int[] to_road = new int[N+1];
			rev_road = new ArrayList[N+1];
			int[] outdegree = new int[N+1];
			for (int i = 0; i <=N; i++) {
				rev_road[i]= new ArrayList<Integer>();
			}
			st = new StringTokenizer(br.readLine());
			for (int i = 1; i <=N; i++) {
				int to = Integer.parseInt(st.nextToken());
				if(to!=0) {
					to_road[i]=to;
					rev_road[to].add(i);
					outdegree[i]++;
				}
			}
			boolean[] isuse = new boolean[N+1];
			int answer = 0;
			while(!q.isEmpty()) {
				int cur = q.poll();
				if(isuse[cur]) continue;
				if(outdegree[cur]!=0) {
					q.add(cur);
					continue;
				}
				int[] start = find_start(cur);
				LinkedList<int[]> bfsq = new LinkedList<int[]>();
				int value = f[start[0]];
				bfsq.add(new int[] {start[0],value});
				while(!bfsq.isEmpty()) {
					int[] bfs_cur = bfsq.poll();
					isuse[bfs_cur[0]]=true;
					for (int next:rev_road[bfs_cur[0]]) {
						outdegree[next]--;	
					}
					value=bfs_cur[1];
					int next = to_road[bfs_cur[0]];
					if(isuse[next]) break;
					bfsq.add(new int[] {next,Math.max(bfs_cur[1],f[next])});
				}
				answer+=value;
			}
			System.out.println(""Case #""+testcase+"": ""+answer);
		}
	}

	private static int[] find_start(int cur) {
		if(rev_road[cur].size()==0) {
			return new int[]{cur,f[cur]};
		}
		int[] subres = new int[]{cur,INF};
		for (int next: rev_road[cur]) {
			int[] tmpres = find_start(next);
			if(subres[1]>tmpres[1]) {
				subres=",namgoi
15375,"public class Solution {
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new  InputStreamReader(System.in));
		int T = Integer.parseInt(br.readLine());
		for (int testcase = 1; testcase <=T; testcase++) {
			int N = Integer.parseInt(br.readLine());
			StringTokenizer st = new StringTokenizer(br.readLine());
			int[] f = new int[N+1];
			LinkedList<Integer> q = new LinkedList<Integer>();
			for (int i = 1; i <=N; i++) {
				f[i] = Integer.parseInt(st.nextToken());
				q.add(i);
			}
			int[] to_road = new int[N+1];
			ArrayList<Integer>[] rev_road = new ArrayList[N+1];
			int[] outdegree = new int[N+1];
			for (int i = 0; i <=N; i++) {
				rev_road[i]= new ArrayList<Integer>();
			}
			st = new StringTokenizer(br.readLine());
			for (int i = 1; i <=N; i++) {
				int to = Integer.parseInt(st.nextToken());
				if(to!=0) {
					to_road[i]=to;
					rev_road[to].add(i);
					outdegree[i]++;
				}
			}
			boolean[] isuse = new boolean[N+1];
			int answer = 0;
			while(!q.isEmpty()) {
				int cur = q.poll();
				if(isuse[cur]) continue;
				if(outdegree[cur]!=0) {
					q.add(cur);
					continue;
				}
				LinkedList<int[]> bfsq = new LinkedList<int[]>();
				int find_start = cur;
				int find_max_value = 1_000_000_000;
				for (int next:rev_road[cur]) {
					bfsq.add(new int[] {next,f[next]});
				}
				while(!bfsq.isEmpty()) {
					int[] bfs_cur = bfsq.poll();
					if(rev_road[bfs_cur[0]].size()==0) {
						if(find_max_value>bfs_cur[1]) {
							find_start=bfs_cur[0];
							find_max_value=bfs_cur[1];
						}
					}else {
						for (int next:rev_road[bfs_cur[0]]) {
							bfsq.add(new int[] {next,Math.max(bfs_cur[1],f[next])});
						}
					}
				}
				bfsq.clear();
				int value = f[find_start];
				bfsq.add(new int[] {find_start,value});
				while(!bfsq.isEmpty()) {
					int[] bfs_cur = bfsq.poll();
					isuse[bfs_cur[0]]=true;
					for (int next:rev_road[bfs_cur[0]]) {
						outdegree[next]--;	
					}
					value=bfs_cur[1];
					int next = to_road[bfs_cur[0]];
					if(isuse[next]) break;
					bfsq.add(new int[] {next,Math.max(bfs_cur[1],f[next])});
				}
				answer+=value;
			}
			System.",namgoi
15376,"public class Solution {
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new  InputStreamReader(System.in));
		int T = Integer.parseInt(br.readLine());
		for (int testcase = 1; testcase <=T; testcase++) {
			int N = Integer.parseInt(br.readLine());
			PriorityQueue<Integer> pq = new PriorityQueue<Integer>();
			StringTokenizer st = new StringTokenizer(br.readLine());
			for (int i = 0; i < N; i++) {
				pq.add(Integer.parseInt(st.nextToken()));
			}
			int answer =0;
			while(!pq.isEmpty()) {
				int cur = pq.poll();
				if(cur > answer) {
					answer++;
				}
			}
			System.",namgoi
15377,"public class Solution {
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new  InputStreamReader(System.in));
		int T = Integer.parseInt(br.readLine());
		for (int testcase = 1; testcase <=T; testcase++) {
			int[] min =new int[]{1_000_000, 1_000_000, 1_000_000, 1_000_000};
			for (int i = 0; i < 3; i++) {
				StringTokenizer st = new StringTokenizer(br.readLine());
				min[0] = Math.min(min[0], Integer.parseInt(st.nextToken()));
				min[1] = Math.min(min[1], Integer.parseInt(st.nextToken()));
				min[2] = Math.min(min[2], Integer.parseInt(st.nextToken()));
				min[3] = Math.min(min[3], Integer.parseInt(st.nextToken()));
			}
			if(min[0]+min[1]+min[2]+min[3]<1_000_000) {
				System.out.println(""Case #""+testcase+"": IMPOSSIBLE"");	
			}else {
				StringBuilder sb = new StringBuilder();
				int answer = 1_000_000;
				for (int i = 0; i < 4; i++) {
					if(answer > min[i]) {
						sb.append("" ""+min[i]);
						answer -= min[i];
					}else {
						sb.append("" ""+answer);
						answer = 0;
					}
				}
				System.",namgoi
15379,"public class Solution {
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new  InputStreamReader(System.in));
		int T = Integer.parseInt(br.readLine());
		for (int testcase = 1; testcase <=T; testcase++) {
			StringTokenizer st = new StringTokenizer(br.readLine());
			int R = Integer.parseInt(st.nextToken());
			int C = Integer.parseInt(st.nextToken());
			StringBuilder sb1 = new StringBuilder();
			StringBuilder sb2 = new StringBuilder();
			StringBuilder sb3 = new StringBuilder();
			StringBuilder sb4 = new StringBuilder();
			for (int x = 0; x < C; x++) {
				if(x==0) {
					sb1.append("".."");
					sb2.append("".."");
				}else {
					sb1.append(""+-"");
					sb2.append(""|."");
				}
				sb3.append(""+-"");
				sb4.append(""|."");
			}
			sb1.append(""+"");
			sb2.append(""|"");
			sb3.append(""+"");
			sb4.append(""|"");
			System.out.println(""Case #""+testcase+"":"");
			for (int y = 0; y < R; y++) {
				if(y==0) {
					System.out.println(sb1);
					System.out.println(sb2);
				}else {
					System.out.println(sb3);
					System.out.println(sb4);
				}
			}
			System.",namgoi
1266,"public class Solution {
    {
        MULTI_TEST = false;
        FILE_NAME = """";
        NEED_FILE_IO = false;
        INF = (long) 1e18;
    } // fields


    void solve_know(int[] a, int currValue) {
    }
    String solve_test() {
        int n = ri(), p = ri();
        int[][] a = new int[n][p];
        long ans = 0;
        for(int i = 0; i < n; i++) {
            a[i] = ria(p);
            sort(a[i]);
        }

        int[][] dp = new int[2][n]; //Верхний - заканчиваю в начале, нижний - в конце

        dp[0][0] = a[0][p - 1] + (a[0][p - 1] - a[0][0]);
        dp[1][0] = a[0][p - 1];

        for(int i = 1; i < n; i++) {
            dp[0][i] = Math.min(dp[0][i - 1] + Math.abs(a[i][p - 1] - a[i - 1][0]) + a[i][p - 1] - a[i][0],
                    //закончил прошлый в начале, нужно из прошлого начала переместиться в данный конец и пройти из данного конца в данное начало
                    dp[1][i - 1] + Math.abs(a[i - 1][p - 1] - a[i][p - 1]) + a[i][p - 1] - a[i][0]);
            //закончил прошлый в конце, нужно из прошлого конца переместиться в данный конец и из данного конца переместиться в данное начало
            dp[1][i] = Math.min(dp[0][i - 1] + Math.abs(a[i - 1][0] - a[i][0]) + a[i][p - 1] - a[i][0],
            //закончил прошлый в начале, нужно из прошлого начала переместиться в данное начало и из начала в конец
                    dp[1][i - 1] + Math.abs(a[i - 1][p - 1]) - a[i][0]) + a[i][p - 1] - a[i][0];
            //закончил прошлый в конце, нужно из прошлого конца переместиться в данное начало и из начала в конец
        }
        return """" + Math.min(dp[0][n - 1], dp[1][n - 1]);
    }


    void solve() {
        int t = ri();
        for(int it = 1; it <= t; it++) {
            out.printf(""Case #%d: %s
"", it, solve_test());
        }
    }

    public static void main(String[] args) {
        new Solution().run();
    } //main

    @SuppressWarnings(""unused"")
    long gcd(long a, long b) {
        return b == 0 ? a : gcd(b, a % b);
    }

    @SuppressWarnings(""unused"")
    long lcm(long a, long b) {
        return a / gcd(a, b) * b;
    }

    @SuppressWarnings(""unused"")
    int gcd(int a, int b) {
        return (int) gcd((long) a, b);
    }

    @SuppressWarnings(""unused"")
    int lcm(int a, int b) {
        return (int) lcm(a, (long) b);
    }

    @SuppressWarnings(""unused"")
    int sqrtInt(int x) {
        return (int) sqrtLong(x);
    }

    @SuppressWarnings(""unused"")
    long sqrtLong(long x) {
        long root = (long) Math.sqrt(x);
        while (root * root > x) --root;
        while ((root + 1) * (root + 1) <= x) ++root;
        return root;
    }

    @SuppressWarnings(""unused"")
    int cbrtLong(long x) {
        int cbrt = (int) Math.cbrt(x);
        while ((long) cbrt * cbrt >= x) {
            cbrt--;
        }
        while ((long) (cbrt + 1) * (cbrt + 1) <= x) cbrt++;
        return cbrt;
    }

    @SuppressWarnings(""unused"")
    long binpow(long a, long power) {
        return binpow(a, power, Long.MAX_VALUE);
    }

    @SuppressWarnings(""unused"")
    long binpow(long a, long power, long modulo) {
        if (power == 0) return 1 % modulo;
        if (power % 2 == 1) {
            long b = binpow(a, power - 1, modulo) % modulo;
            return ((a % modulo) * b) % modulo;
        } else {
            long b = binpow(a, power / 2, modulo) % modulo;
            return (b * b) % modulo;
        }
    }

    @SuppressWarnings(""unused"")
    long fastMod(String s1, long n2) {
        long num = 0;
        for (int i = 0; i < s1.length() - 1; i++) {
            num += Integer.parseInt(String.valueOf(s1.charAt(i)));
            num *= 10;
            if (num >= n2) {
                num = num % n2;
            }
        }
        return (num + Integer.parseInt(String.valueOf(s1.charAt(s1.length() - 1)))) % n2;
    }

    @SuppressWarnings(""unused"")
    long factorialMod(long n, long p) {
        long res = 1;
        while (n > 1) {
            res = (res * ((n / p) % 2 == 1 ? p - 1 : 1)) % p;
            for (int i = 2; i <= n % p; ++i)
                res = (res * i) % p;
            n /= p;
        }
        return res % p;
    }

    @SuppressWarnings(""unused"")
    boolean isPrime(int number) {
        for (int i = 2; i * i <= number; i++) {
            if (number % i == 0) {
                return false;
            }
        }
        return number > 1;
    }

    @SuppressWarnings(""unused"")
    boolean[] primes(int border) {
        boolean[] isPrimes = new boolean[border + 1];
        Arrays.fill(isPrimes, true);
        isPrimes[0] = false;
        isPrimes[1] = false;
        for (int i = 2; i < border + 1; i++) {
            if (!isPrimes[i]) continue;
            for (int k = i * 2; k < border; k += i) {
                isPrimes[k] = false;
            }
        }
        return isPrimes;
    } //Number theory

    @SuppressWarnings(""unused"")
    void sort(int[] a) {
        int n = a.length;
        Integer[] arr = new Integer[n];
        for (int i = 0; i < n; i++) {
            arr[i] = a[i];
        }
        Arrays.sort(arr);
        for (int i = 0; i < n; i++) {
            a[i] = arr[i];
        }
    }

    @SuppressWarnings(""unused"")
    void sort(long[] a) {
        int n = a.length;
        Long[] arr = new Long[n];
        for (int i = 0; i < n; i++) {
            arr[i] = a[i];
        }
        Arrays.sort(arr);
        for (int i = 0; i < n; i++) {
            a[i] = arr[i];
        }
    }

    @SuppressWarnings(""unused"")
    int max(int[] a) {
        int n = a.length;
        int max = Integer.MIN_VALUE;
        for (int j : a) {
            if (j > max) max = j;
        }
        return max;
    }

    @SuppressWarnings(""unused"")
    long max(long[] a) {
        int n = a.length;
        long max = Long.MIN_VALUE;
        for (long l : a) {
            if (l > max) max = l;
        }
        return max;
    }

    @SuppressWarnings(""unused"")
    int maxIndex(int[] a) {
        int n = a.length;
        int max = Integer.MIN_VALUE;
        int index = 0;
        for (int i = 0; i < n; i++) {
            if (a[i] > max) {
                max = a[i];
                index = i;
            }
        }
        return index;
    }

    @SuppressWarnings(""unused"")
    int maxIndex(long[] a) {
        int n = a.length;
        long max = Long.MIN_VALUE;
        int index = 0;
        for (int i = 0; i < n; i++) {
            if (a[i] > max) {
                max = a[",v0s7er
288,"public class Solution {

  public static void main(String[] args) {
 /*   String aaa = ""3
"" +
        ""300000 200000 300000 500000
"" +
        ""300000 200000 500000 300000
"" +
        ""300000 500000 300000 200000
"" +
        ""1000000 1000000 0 0
"" +
        ""0 1000000 1000000 1000000
"" +
        ""999999 999999 999999 999999
"" +
        ""768763 148041 178147 984173
"" +
        ""699508 515362 534729 714381
"" +
        ""949704 625054 946212 951187"";
    final Stream<String> lines = Arrays.stream(aaa.split(""
""));*/
    
    final BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
    final Stream<String> lines = reader.lines();

    int T = 0;
    int cs = 1;
    int start = 1;
    int end = 3;
/*

    final String UPPER = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ"";
    final String LOWER = ""abcdefghijklmnopqrstuvwxyz"";
    final char [] upper = UPPER.toCharArray();
    final char [] lower = LOWER.toCharArray();
    String line="""";
    List<Long> l = Arrays.stream(line.split("" "")).map(Long::valueOf).collect(Collectors.toList());

*/

    final Iterator<String> iterator = lines.iterator();
    int i = 0;
    String[] temp;
    int[][] p = new int[3][4];
int k = 0;
    while (iterator.hasNext()) {
      final String line = iterator.next();
      if (i == 0) {
        T = Integer.valueOf(line);
      } else {
        if (i<= end) {
          p[k] = Arrays.stream(line.split("" "")).map(Integer::valueOf).collect(Collectors.toList()).stream().mapToInt(Integer::intValue).toArray();
           k++;
        }
        if (i == end) {
          k = 0;
          start +=3;
          end+=3;

          if (cs <= T) {
            Test t = new Test(p);
            System.out.println(""Case #"" + cs + "": "" + t.print());
            cs++;
            if (cs > T) {
              break;
            }
          }
        }
      }
      i++;
    }

  }

  public static class Test {
    static int TOP = 1000000;
    int[][] p;
    public Test(int[][] p) {
      this.p = p;
    }

    public String print() {
      for (int i = 0; i < 3; i++) {
        if(p[i][0] + p[i][1] + p[i][2] + p[i][3] < TOP) {
          return ""IMPOSSIBLE"";
        }
      }
      int [] mins = new int[4];
      for (int i = 0; i < 4; i++) {
        mins[i]  = Math.min(p[0][i], Math.min(p[1][i], p[2][i]));
      }
      if(mins[0] + mins[1] + mins[2] +mins[3] < TOP) {
        return ""IMPOSSIBLE"";
      } else {
        String t = """";
        int s=0;
        int rs=0;
        for (int i = 0; i < 4; i++) {
          s+=mins[i];
          if( s <= TOP) {
            rs +=mins[i];
            t += mins[i];
          } else {
             int a = TOP - rs;
              t += a;
              rs +=a;
          }

            if(i < 3)
              t += "" "";
        }
        return t;
      }
    }
  }

}",Obchelli
1038,"public class Solution {
    InputStream is;
    FastWriter out;
    String INPUT = """";

    public static void main(String[] args) throws Exception
    {
        new Solution().run();// Here run assign I/O calls solve also tell total time invested
    }

    void solve()
    {
        int t=ni(), p=0;
        while(t-->0)
        {
            System.out.print(""Case #""+ ++p +"": "");
            go();
        }
    }

    long max=-1; int n;
    int fac[], point[];
    void printDistinctPermutn(String str, String ans)
    {

        // If string is empty
        if (str.length() == 0) {

            // print ans
//            System.out.println(ans);
            boolean vis[]=new boolean[n];
            long sum=0;
            for(int i=0;i<ans.length();i++)
            {
                int val = ans.charAt(i)-'0';
                int m=-1,j=-1;
                if(m<fac[val])
                {
                    j=val;
                    m=fac[val];
                }
                while(point[val]!=0&&val>point[val]-1)
                {
                    val=point[val]-1;
                    if(vis[val])
                        break;
                    if(m<fac[val])  // if complier gives wc
                    {
                        j=val;
                        m=fac[val];
                    }
                }
                sum+=m;
                vis[j]=true;
            }
            max=Math.max(max, sum);
            return;
        }

        // Make a boolean array of size '26' which
        // stores false by default and make true
        // at the position which alphabet is being
        // used
        boolean alpha[] = new boolean[10];

        for (int i = 0; i < str.length(); i++) {

            // ith character of str
            char ch = str.charAt(i);

            // Rest of the string after excluding
            // the ith character
            String ros = str.substring(0, i) +
                    str.substring(i + 1);

            // If the character has not been used
            // then recursive call will take place.
            // Otherwise, there will be no recursive
            // call
            if (alpha[ch - '0'] == false)
                printDistinctPermutn(ros, ans + ch);
            alpha[ch - '0'] = true;
        }
    }

    void go()
    {
        n=ni();
        fac=ni(n);
        point=ni(n);
        Set<Integer> set=new HashSet<>();
        for(int i=0;i<n;i++)
        {
            if(point[i]==0)
                continue;
            else
                set.add(point[i]-1);
        }
//        System.out.println(set);
        String s="""";
        for(int i=0;i<n;i++)
        {
            if(!set.contains(i))
                s+=i;
        }
        max=-1;
//        System.out.println(s);
        printDistinctPermutn(s,"""");
        System.out.println(max);
    }

    static boolean prime[];
    static int count=0;

    void sieve(int n)
    {
        prime=new boolean[n+1];
        Arrays.fill(prime, true);
        for(int i=2;i<=Math.sqrt(n);i++)
            if(prime[i])
                for(int j=i*i;j<=n;j+=i)
                    prime[j]=false;
    }

    boolean isPrime(int n)
    {
        for(int i=2;i<=Math.sqrt(n);i++)
            if(n%i==0)
                return false;
        return true;
    }

    long gcd(long a,long b)
    {
        if(a==0)
            return b;
        return gcd(b%a,a);
    }

    void run() throws Exception
    {
        is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());
        out = new FastWriter(System.out);

        long s = System.currentTimeMillis();
        solve();
        out.flush();
        tr(System.currentTimeMillis()-s+""ms"");
    }

    byte[] inbuf = new byte[1024];
    public int lenbuf = 0, ptrbuf = 0;

    private int readByte()
    {
        if(lenbuf == -1)throw new InputMismatchException();
        if(ptrbuf >= lenbuf){
            ptrbuf = 0;
            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
            if(lenbuf <= 0)return -1;
        }
        return inbuf[ptrbuf++];
    }

    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }

    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }

    private double nd() { return Double.parseDouble(ns()); }

    private char nc() { return (char)skip(); }

    private String ns()
    {
        int b = skip();
        StringBuilder sb = new StringBuilder();
        while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }

    private char[] ns(int n)
    {
        char[] buf = new char[n];
        int b = skip(), p = 0;
        while(p < n && !(isSpaceChar(b))){
            buf[p++] = (char)b;
            b = readByte();
        }
        return n == p ? buf : Arrays.copyOf(buf, p);
    }

    private int[] ni(int n)
    {
        int[] a = new int[n];
        for(int i = 0;i < n;i++)a[i] = ni();
        return a;
    }

    private long[] nl(int n)
    {
        long[] a = new long[n];
        for(int i = 0;i < n;i++)a[i] = nl();
        return a;
    }

    private Long[] nL(int n) {
        Long[] a = new Long[n];
        for (int i = 0; i < n; i++)
            a[i] = nl();
        return a;
    }

    private Integer[] nI(int n) {
        Integer[] a = new Integer[n];
        for (int i = 0; i < n; i++)
            a[i] = ni();
        return a;
    }

    private char[][] ns(int n, int m) {
        char[][] map = new char[n][];
        for(int i = 0;i < n;i++)map[i] = ns(m);
        return map;
    }

    private int[][] ni(int n, int m) {
        int[][] map = new int[n][];
        for(int i = 0;i < n;i++)map[i] = ni(m);
        return map;
    }

    private long[][] nl(int n, int m) {
        long[][] map = new long[n][];
        for(int i = 0;i < n;i++)map[i] = nl(m);
        return map;
    }

    private Integer[][] nI(int n, int m) {
        Integer[][] map = new Integer[n][];
        for(int i = 0;i < n;i++)map[i] = nI(m);
        return map;
    }

    private Long[][] nL(int n, int m) {
        Long[][] map = new Long[n][];
        for(int i = ",pgthebigshot
58,"public class Solution
{
	public static void main(String[] args) {
		Scanner input=new Scanner(System.in);
		int t=input.nextInt();
		for(int x=0;x<t;x++)
		{
		    int n=input.nextInt();
		    int arr[]=new int[n];
		    for(int i=0;i<n;i++)
		    {
		        arr[i]=input.nextInt();
		    }
		    Arrays.sort(arr);
		    int count=1;
		    int temp=0;
		    for(int i=0;i<n;i++)
		    {
		        if(count<=arr[i])
		        {
		            count++;
		        }
		        else
		        {
		            temp=i;
		            break;
		        }
		    }
		    ArrayList<Integer> al=new ArrayList<>();
		    System.out.print(""Case #""+(x+1)+"": "");
		    if(n>=arr[n-1])
		    {
		      for(int i=temp;i<n;i++)
    		    {
    		        al.add(arr[i]);
    		    }
    		    for(int i=al.get(al.size()-1);i>=0;i--)
    		    {
    		        if(count<=i)
    		        {
    		            count++;
    		        }
    		        else
    		        {
    		            break;
    		        }
    		    }
		    System.out.print((count-1));
		    if(x!=t-1)
		    {
		        System.out.println();   
		    }
		    }
		    else
		    {
		        System.out.print(n);
		        if(x!=t-1)
    		    {
    		        System.",AniketTewari
826,"public class Solution {

    public static void main(String[] args) {

        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        System.out.println(""Case Number: "");
        int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.

        int r,c;
        for (int i = 1; i <= t; i++) {
            r = in.nextInt();
            c = in.nextInt();
            getASCII(r,c);
        }

    }

    public static void getASCII(int r, int c){
        int row = r + r + 1;
        int column = c + c + 1;

        for (int i = 0; i< row; i++){
            for (int j = 0; j < column; j++) {

                if((i==0 || i==1) && (j== 0 || j==1) ){
                    System.out.print(""."");
                    continue;
                }

                int jj = 0;
                if(i%2 == 0){
                    while(jj < (column-j)){
                        jj++;
                        if(jj%2 == 0){
                            System.out.print(""-"");
                        }else{
                            System.out.print(""+"");
                        }
                    }
                }else{
                    while(jj < (column-j)){
                        jj++;
                        if(jj%2 == 0){
                            System.out.print(""."");
                        }else{
                            System.out.print(""|"");
                        }
                    }
                }
                System.",jonathan38m
819,"public class Solution {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int cases = sc.nextInt();




    //setup
    for(int a=1; a<=cases; a++){
      long[] dp = new long[1000];
      ArrayList<ArrayList<Long>> items = new ArrayList<>();
      long customers = sc.nextLong();
      long productsPerCustomer = sc.nextLong();
      for(int i=0; i<customers; i++){
        items.add(new ArrayList<Long>());
      }

      for(int i=0; i<customers; i++){
        for (int j=0; j<productsPerCustomer; j++){
          items.get(i).add(sc.nextLong());
        }
      }

      long lastTracked = 0;
      long clicks = 0;
      for(int i=0; i<customers; i++){
        //two options: up then cover the range, or down then cover the range. pick the least cost option
        Collections.sort(items.get(i));
        long max = items.get(i).get(items.get(i).size()-1);
        long min = items.get(i).get(0);
        if(i==0){
          clicks+= max;
          dp[0] = clicks;
          lastTracked = max;
        }
        else if(i==1){
          long prevMax = items.get(i-1).get(items.get(i).size()-1);

          long choice1, choice2;
          choice1 = Math.abs(prevMax - max) + (max-min);
          choice2 = Math.abs(prevMax - min) + (max-min);
          dp[1] = dp[0] + Math.min(choice1, choice2);
          clicks = dp[1];
        }
        else{
          long prevMax = items.get(i-1).get(items.get(i).size()-1);
          long prevMin = items.get(i-1).get(0);

          long prevChoice1 = Math.abs(lastTracked - prevMax) + (prevMax - prevMin);
          long prevChoice2 = Math.abs(lastTracked - prevMin) + (prevMax - prevMin);

          long choice1, choice2, choice3, choice4;
          choice1 = prevChoice1 + Math.abs(prevMin - max) + (max-min);
          choice2 = prevChoice1 + Math.abs(prevMin - min) + (max-min);
          choice3 = prevChoice2 + Math.abs(prevMax - max) + (max-min);
          choice4 = prevChoice2 + Math.abs(prevMax - min) + (max-min);

          long resultTemp1 = Math.min(choice1, choice2);
          long resultTemp2 = Math.min(choice3, choice4);

          if(resultTemp1 < resultTemp2){
            lastTracked = prevMin;
            dp[i] = dp[i-2] + resultTemp1;
            if(i>=2){
              dp[i-1] = dp[i-2] + prevChoice1;
            }
            
            clicks += resultTemp1;
          }
          else{
            lastTracked = prevMax;
            dp[i] = dp[i-2] + resultTemp2;
            if(i>=2){
              dp[i-1] = dp[i-2] + prevChoice2;
            }
            
            clicks += resultTemp2;
          }

        }
        //System.out.printf(""clicks: %d
"", clicks);
        //System.out.printf(""dp[i]: %d
"", dp[i]);

      }

      System.out.println(""Case #"" + a + "": "" + dp[(int)(customers-1)]);
    }
  }

}",jedya
637,"public class Solution {

    private int T;
    private ArrayList<Integer[]> deliciousnessList = new ArrayList<>();

    public static void main(String[] args) {

        Solution solution = new Solution();
        solution.readInput();

        for (int x = 0; x<solution.T; x++) {
            Integer[] deliciousness = solution.deliciousnessList.get(x);
            int customersCounter = solution.solveTestCase(deliciousness);

            System.out.println(String.format(""Case #%d: %d"", x+1, customersCounter));
        }

    }

    private int solveTestCase(Integer[] deliciousness) {

        // Initialise
        int customersCounter = 0;
        int totalMax = Integer.MIN_VALUE;
        int leftIndex = 0;
        int rightIndex=deliciousness.length-1;

        // Variable definitions
        int leftValue;
        int rightValue;
        int currentMax;

        for(int i=0; i<deliciousness.length; i++) {
            leftValue = deliciousness[leftIndex];
            rightValue = deliciousness[rightIndex];
            currentMax = Math.min(leftValue, rightValue);

            if(currentMax<totalMax) {
                if(leftIndex!=rightIndex) customersCounter++;
                break;
            }

            customersCounter++;
            totalMax = currentMax;

            if (leftValue<=rightValue) {
                leftIndex++;
            } else {
                rightIndex--;
            }
        }

        return customersCounter;
    }

    private void readInput() {

        Scanner reader = new Scanner(System.in);
        String data;

        if (reader.hasNextLine()) {
            data = reader.nextLine();
            T = Integer.parseInt(data);
        }

        for (int i = 0; i < T; i++) {
            data = reader.nextLine();
            int N = Integer.parseInt(data);

            Integer[] deliciousness = new Integer[N];
            data = reader.nextLine();
            String[] cells = data.split("" "", 0);

            for(int j=0; j<cells.length; j++) {
                deliciousness[j] = Integer.parseInt(cells[j]);
            }

            deliciousnessList.add(deliciousness);
        }

        reader.",dionysis_dt
509,"public class CodeCHAMP {
    public static String printDrawPunchCards(int row, int column){
        int start = 0;
        String extra = """";
        String pipe = """";
        StringBuilder output = new StringBuilder();
        int count = 0;

        while(count != row){
            if(start == 0){
                extra = ""..+"" + ""-+"".repeat(column - 1);
                pipe = ""..|"" + "".|"".repeat(column - 1);
            }

            if(start != 0) pipe = ""|"" + "".|"".repeat(column);
            String below = ""+"" + ""-+"".repeat(column);

            if(start == 0) output.append(extra).append(""
"");
            output.append(pipe).append(""
"");
            output.append(below).append(""
"");

            count++;
            start++;
        }

        return output.toString();
    }

//        ..+-+-+
//        ..|.|.|
//        +-+-+-+
//        |.|.|.|
//        +-+-+",adamson
698,"class Solution{
    public static void main(String[] args) {
      Scanner scan = new Scanner(System.in);
      long t = scan.nextInt();
      for (long y = 0; y < t; y++) {
        int n = scan.nextInt();
        int p = scan.nextInt();
        long[][] stuff = new long[n][p];
        for (int x = 0; x < n; x++) {
          for (int z = 0; z < p; z++) {
            stuff[x][z] = scan.nextInt();
          }
        }
        long count;
        long lastPressure;
        // find max for the first one
        count = findMax(stuff[0]);
        lastPressure = count;
        if (n > 1) {
          long down = goDown(stuff, count, 1, n, lastPressure);
          long up = goUp(stuff, count, 1, n, lastPressure);
          if (down < up) count = down;
          else count = up;
        }
        System.out.println(""Case #"" + (y+1) +"": "" + count);
      }
    }
    public static long goDown(long[][] stuff, long count, int index, long n, long lastPressure) {
      if (index == n) {
        return count;
      }
      long thisMin = findMin(stuff[index]);
      long thisMax = findMax(stuff[index]);
      if (thisMin > lastPressure) {
        long diffMax = thisMax - lastPressure;
        count += diffMax;
        lastPressure = thisMax;
      }
      else if (thisMax < lastPressure) {
        long diffMin = lastPressure - thisMin;
        count += diffMin + (thisMax-thisMin);
        lastPressure = thisMax;
      }
      else{
        long diffMin = lastPressure - thisMin;
        long diffMax = thisMax - lastPressure;
        count += (2*diffMin) + diffMax;
        lastPressure = thisMax;
      }
      index++;
      long down = goDown(stuff, count, index, n, lastPressure);
      long up = goUp(stuff, count, index, n, lastPressure);
      if (down < up) return down;
      else return up;
    }
    public static long goUp(long[][] stuff, long count, int index, long n, long lastPressure) {
      if (index == n) {
        return count;
      }
      long thisMin = findMin(stuff[index]);
      long thisMax = findMax(stuff[index]);
      if (thisMin > lastPressure) {
        long diffMax = thisMax - lastPressure;
        count += diffMax + (thisMax - thisMin);
        lastPressure = thisMin;
      }
      else if (thisMax < lastPressure) {
        long diffMin = lastPressure - thisMin;
        count += diffMin;
        lastPressure = thisMin;
      }
      else{
        long diffMin = lastPressure - thisMin;
        long diffMax = thisMax - lastPressure;
        count += (2*diffMax) + diffMin;
        lastPressure = diffMin;
      }
      index++;
      long down = goDown(stuff, count, index, n, lastPressure);
      long up = goUp(stuff, count, index, n, lastPressure);
      if (down < up) return down;
      else return up;
    }
    public static long findMax(long[] nums) {
      long max = 0;
      for (int x = 0; x < nums.length; x++) {
        if (nums[x] > max) {
          max = nums[x];
        }
      }
      return max;
    }
    public static long findMin(long[] nums) {
      long min = Integer.MAX_VALUE;
      for (int x = 0; x < nums.length; x++) {
        if (nums[x] < min) {
          min = ",forky01
697,"public class Solution{
    public static void main(String[] args){
        Scanner scan = new Scanner(System.in);
        int t = scan.nextInt();
        for (int p = 0; p < t; p++) {
            Deque<Integer> deque = new ArrayDeque<Integer> ();
            int n = scan.nextInt();
            for (int i = 0; i < n; i++) {
                deque.addLast(scan.nextInt());
            }
            int largestDelicious = deque.getFirst();
            int count = 0;
            //check pancakes
            for (int i = 0; i < n; i++) {
                // find the smaller delic then check if it is smaller than largest running one
                if (deque.getFirst() < deque.getLast()) {
                    if (deque.getFirst() >= largestDelicious) {
                        largestDelicious = deque.getFirst();
                        count ++;
                    }
                    deque.removeFirst();
                }
                else{
                    if (deque.getLast() >= largestDelicious) {
                        largestDelicious = deque.getLast();
                        count ++;
                    }
                    deque.removeLast();
                }
            }
            System.",forky01
1268,"public class Solution {
    {
        MULTI_TEST = false;
        FILE_NAME = """";
        NEED_FILE_IO = false;
        INF = (long) 1e18;
    } // fields

    int ask(String s) {
        out.println(s);
        out.flush();
        return ri();
    }

    String getForm(int x) {
        char[] form = new char[8];
        Arrays.fill(form, '0');
        int cnt = 0;
        while(x > 0) {
            int bit = x % 2;
            x/=2;
            form[cnt++] = (char) ('0' + bit);
        }

        return new String(form);
    }
    String solve_test() {
        TreeSet<String>[] ts = new TreeSet[9];
        for(int i = 0; i < 9; i++) ts[i] = new TreeSet<>();
        for(int i = 0; i <= 255; i++) {
            String b = getForm(i);
            int cnt = 0;
            for(var c : b.toCharArray()) {
                cnt += c == '1' ? 1 : 0;
            }

            ts[cnt].add(b);
        }
        int x = 0;
        while(true) {
            try {
                x = ask(ts[x].pollFirst());
            } catch (Exception e) {
                break;
            }
            if(x == 0) {
                return """";
            }
            if(x == -1) {
                throw new RuntimeException(""Limit exceed"");
            }
        }

        while(true) {
            int a = ask(""00000001"");
            if(a == 0 || a == -1) break;
        }
        return """";
    }


    void solve() {
        int t = ri();
        for(int it = 0; it < t; it++) {
            solve_test();
        }
    }

    public static void main(String[] args) {
        new Solution().run();
    } //main

    @SuppressWarnings(""unused"")
    long gcd(long a, long b) {
        return b == 0 ? a : gcd(b, a % b);
    }

    @SuppressWarnings(""unused"")
    long lcm(long a, long b) {
        return a / gcd(a, b) * b;
    }

    @SuppressWarnings(""unused"")
    int gcd(int a, int b) {
        return (int) gcd((long) a, b);
    }

    @SuppressWarnings(""unused"")
    int lcm(int a, int b) {
        return (int) lcm(a, (long) b);
    }

    @SuppressWarnings(""unused"")
    int sqrtInt(int x) {
        return (int) sqrtLong(x);
    }

    @SuppressWarnings(""unused"")
    long sqrtLong(long x) {
        long root = (long) Math.sqrt(x);
        while (root * root > x) --root;
        while ((root + 1) * (root + 1) <= x) ++root;
        return root;
    }

    @SuppressWarnings(""unused"")
    int cbrtLong(long x) {
        int cbrt = (int) Math.cbrt(x);
        while ((long) cbrt * cbrt >= x) {
            cbrt--;
        }
        while ((long) (cbrt + 1) * (cbrt + 1) <= x) cbrt++;
        return cbrt;
    }

    @SuppressWarnings(""unused"")
    long binpow(long a, long power) {
        return binpow(a, power, Long.MAX_VALUE);
    }

    @SuppressWarnings(""unused"")
    long binpow(long a, long power, long modulo) {
        if (power == 0) return 1 % modulo;
        if (power % 2 == 1) {
            long b = binpow(a, power - 1, modulo) % modulo;
            return ((a % modulo) * b) % modulo;
        } else {
            long b = binpow(a, power / 2, modulo) % modulo;
            return (b * b) % modulo;
        }
    }

    @SuppressWarnings(""unused"")
    long fastMod(String s1, long n2) {
        long num = 0;
        for (int i = 0; i < s1.length() - 1; i++) {
            num += Integer.parseInt(String.valueOf(s1.charAt(i)));
            num *= 10;
            if (num >= n2) {
                num = num % n2;
            }
        }
        return (num + Integer.parseInt(String.valueOf(s1.charAt(s1.length() - 1)))) % n2;
    }

    @SuppressWarnings(""unused"")
    long factorialMod(long n, long p) {
        long res = 1;
        while (n > 1) {
            res = (res * ((n / p) % 2 == 1 ? p - 1 : 1)) % p;
            for (int i = 2; i <= n % p; ++i)
                res = (res * i) % p;
            n /= p;
        }
        return res % p;
    }

    @SuppressWarnings(""unused"")
    boolean isPrime(int number) {
        for (int i = 2; i * i <= number; i++) {
            if (number % i == 0) {
                return false;
            }
        }
        return number > 1;
    }

    @SuppressWarnings(""unused"")
    boolean[] primes(int border) {
        boolean[] isPrimes = new boolean[border + 1];
        Arrays.fill(isPrimes, true);
        isPrimes[0] = false;
        isPrimes[1] = false;
        for (int i = 2; i < border + 1; i++) {
            if (!isPrimes[i]) continue;
            for (int k = i * 2; k < border; k += i) {
                isPrimes[k] = false;
            }
        }
        return isPrimes;
    } //Number theory

    @SuppressWarnings(""unused"")
    void sort(int[] a) {
        int n = a.length;
        Integer[] arr = new Integer[n];
        for (int i = 0; i < n; i++) {
            arr[i] = a[i];
        }
        Arrays.sort(arr);
        for (int i = 0; i < n; i++) {
            a[i] = arr[i];
        }
    }

    @SuppressWarnings(""unused"")
    void sort(long[] a) {
        int n = a.length;
        Long[] arr = new Long[n];
        for (int i = 0; i < n; i++) {
            arr[i] = a[i];
        }
        Arrays.sort(arr);
        for (int i = 0; i < n; i++) {
            a[i] = arr[i];
        }
    }

    @SuppressWarnings(""unused"")
    int max(int[] a) {
        int n = a.length;
        int max = Integer.MIN_VALUE;
        for (int j : a) {
            if (j > max) max = j;
        }
        return max;
    }

    @SuppressWarnings(""unused"")
    long max(long[] a) {
        int n = a.length;
        long max = Long.MIN_VALUE;
        for (long l : a) {
            if (l > max) max = ",v0s7er
1290,"class Solution {

  public static void main(String args[]) {
//   test();
        scan();
  }

  public static void scan() {
    Scanner in = new Scanner(System.in);
    int T = in.nextInt();
    for (int round = 0; round < T; round++) {
      int n = in.nextInt();
      int[] nums = new int[n];
      for (int i = 0; i < n; i++) {
        nums[i] = in.nextInt();
      }

      int result = findBest(nums);

      System.out.println(""Case #"" + (round + 1) + "": "" + result);
    }
  }

  private static int findBest(int[] nums) {
    Arrays.sort(nums);
    int wrong = 0;
    int next = 0;
    for (int j = 0; j < nums.length; j++) {
      next++;
      while (j < nums.length && next > nums[j]) {
        j++;
        wrong++;
      }
    }
    return nums.length - wrong;
  }

  public static void test() {
    System.",wala
1069,"public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        for(int Case = 1; Case <= T; Case ++){
            int color[] = new int[4];
            for(int i = 0; i < 3; i ++){
                for(int j = 0; j < 4; j ++){
                    if(i == 0){
                        color[j] = sc.nextInt();
                    }
                    else {
                        color[j] = Math.min(sc.nextInt(), color[j]);
                    }
                }
            }
            int sum = 0;
            for(int j = 0; j < 4; j ++){
                sum += color[j];
            }
            System.out.print(""Case #"" + Case + "":"");
            if(sum < 1000000){
                System.out.println("" IMPOSSIBLE"");
                continue;
            }

            int rem = 1000000;
            for(int j = 0; j < 4; j ++){
                if(rem == 0){
                    System.out.print("" "" + 0);
                }
                else{
                    int value = Math.min(rem, color[j]);
                    rem -= value;
                    System.out.print("" "" + value);
                }
            }
            System.",ql309
984,"public class Solution {

	public static void main(String[] args) {
		Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

		int numberOfCases = in.nextInt();

		for (int i = 1; i <= numberOfCases; ++i) {
			int N = 10;
			while (N > 0) {
				if (N == 10) {
					System.out.println(""00000000"");
					N = in.nextInt();
					System.err.println(N);
				}
				if (N == 1) {
					int x = (int) (Math.random() * 8);
					String test = """";
					for (int j = 0; j < 8; j++) {
						if (j == x)
							test += ""1"";
						else
							test += ""0"";
					}
					System.out.println(test);
					N = in.nextInt();
				}
				if (N == 2) {
					int x = (int) (Math.random() * 7);
					String test = """";
					for (int j = 0; j < 7; j++) {
						if (j == x)
							test += ""1"";
						else
							test += ""0"";
					}
					System.out.println(test+""1"");
					N = in.nextInt();
				}
				if (N == 3) {
					int x = (int) (Math.random() * 6);
					String test = """";
					for (int j = 0; j < 6; j++) {
						if (j == x)
							test += ""1"";
						else
							test += ""0"";
					}
					System.out.println(test+""11"");
					N = in.nextInt();
				}
				if (N == 4) {
					System.out.println(""01011010"");
					N = in.nextInt();
				}
				if (N > 4) {
					System.out.println(""11111111"");
					N = in.nextInt();
				}
			}
			if (N == -1)
				break;

		}
	}
}",nicolasD
592,"public class Solution{
    public static void main(String[] args){
        Scanner s = new Scanner(System.in);
        int T = s.nextInt();

        for(int ii=1; ii <= T; ii++){
            int N = s.nextInt();
            int K = s.nextInt();

            int[] A = new int[N];
            int[] P = new int[N];
            int cnt = 0;
            while(cnt <= K){
                A[cnt] = s.nextInt();
                P[cnt] = s.nextInt();

                System.out.println(""W"");
                //System.out.flush();
                cnt++;
                if (cnt == K){
                    break;
                }
                A[cnt] = s.nextInt();
                P[cnt] = s.nextInt();

                System.out.println(""T"" + "" "" +  A[cnt - 1]);
               // System.out.flush();
                cnt++;

                if (cnt == K){
                    break;
                }
            }

            int sum = 0;
            for(int i=0; i <= K; i++)
                sum = sum + P[i];

            int estimate = ",dattap
614,"public class Solution {
    public static void main(String[] args) {
        (new Solution()).readInput();
    }

    public void readInput() {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int caseCount = in.nextInt();
        try {
            for (int caseId = 1; caseId <= caseCount; ++caseId) {
                play(in);
            }
        } catch (IllegalStateException e){
            return;
        }
    }

    private void play(Scanner in){
        Random r = new Random();
        int i=-1;
        while(true) {
            //int i = r.nextInt(256);
            i++;
            String binaryString = Integer.toBinaryString(i);
            while (binaryString.length() < 8) {
                binaryString = ""0"" + binaryString;
            }
            binaryString = binaryString.substring(0,8);
            System.out.print(binaryString);
            int result = in.nextInt();
            if (result == 0) {
                return;
            }
            if (result<0)",dboteanu
417,"public class Solution {
    static Scanner sc = new Scanner(System.in);

    public static void main(String[] args) {

        int cases = Integer.parseInt(sc.nextLine());
        for (int i = 0; i < cases; i++) {
            if(runTest() == -1){
                break;
            }
        }


    }



    public static int runTest(){
        StringBuilder sb = new StringBuilder();
        boolean[] bits = new boolean[8];
        for (int i = 0; i < 300; i++) {
            System.out.println(String.format(""%8s"", Integer.toBinaryString((int)(Math.random() * 127))).replaceAll("" "", ""0""));
            int num = (sc.nextInt());
            if(num == 0 || num == -1)",SurgeM
95,"    class Solution {
    	
		public static Scanner in = new Scanner(System.in);
    	
    	public static void main(String[] args) throws IOException {
    		int t = in.nextInt();
    		for(int tc = 1; tc <= t; tc ++) {
    			int n = in.nextInt();
    			int[] d = new int[n];
    			for(int i = 0; i < n; i ++)
    				d[i] = in.nextInt();
    			int p1 = 0, p2 = n - 1;
    			int max = -1, ans = 0;
    			for(int i = 0; i < n; i ++) {
    				int curr = -1;
    				if(d[p1] <= d[p2]) {
    					curr = d[p1 ++];
    				} else {
    					curr = d[p2 --];
    				}
    				if(curr >= max) {
    					ans ++;
    					max = ",Deido
1209,"class Main{

public static int organize(int x,ArrayList<ArrayList<Integer>> matrix)
{
    return x;
}
public static void main(String args[]){
    
    Scanner sc = new Scanner(System.in);

int t = sc.nextInt();

for(int k=0;k<t;k++)
{
    int x = sc.nextInt();
    int size=2*x;
    // int[][] matrix = new int[size][size];
    // for(int i=0;i<size;i++)
    // {
    //   for(int j=0;j<size;j++){
    //       matrix[i][j] = sc.nextInt();
    //   }
    // }
    
    ArrayList<ArrayList<Integer>> matrix = new ArrayList<>();
    for(int i=0;i<size;i++){
        ArrayList<Integer> array = new ArrayList<>();
        while (sc.hasNextInt()) {
        int l = sc.nextInt();
        array.add(l);
        }
        
        matrix.add(array);
    }
    int result = ",sriniharika
528,"public class Solution {

    private static final Boolean FROM_FILE = Boolean.FALSE;
    private static final int MAXLEN = 100000;

    /**
     * What can I say, I like'em Turing machines
     */
    private static int numLeaf, x, y;
    private static int[] indexLeaf = new int[MAXLEN];
    private static int[] detectLeaf = new int[MAXLEN];
    private static int[] f = new int[MAXLEN];
    private static int[] p = new int[MAXLEN];
    private static int[] height = new int[MAXLEN];
    private static int[] firstChild = new int[MAXLEN];
    private static int[] lastChild = new int[MAXLEN];
    private static int[] hasBrothers = new int[MAXLEN];

    private static void insertLeaf(int j){
        indexLeaf[j]=numLeaf;
        detectLeaf[numLeaf++]=j;
    }

    private static boolean isLeaf(int j){
        return -1 != indexLeaf[j];
    }

    private static void removeLeaf(int j){
        if(isLeaf(j)){
            if(numLeaf > 1){
                x = detectLeaf[--numLeaf];
                y = indexLeaf[j];
                indexLeaf[j]=-1;
                indexLeaf[x]=y;
                detectLeaf[y]=x;
            } else {
                //last leaf
                indexLeaf[j]=-1;
                numLeaf--;
            }
        }
    }

    public static void main(String[] args) throws IOException{
        BufferedReader br;
        BufferedWriter bw;

        if(FROM_FILE){
            br = new BufferedReader(new FileReader(""C2022QR1Dinput.in""));
        } else {
            br = new BufferedReader(new InputStreamReader(System.in));
        }

        try {
            if(FROM_FILE) {
                File file = new File(""C2022QR1D.out"");
                if (!file.exists()) {
                    file.createNewFile();
                }
                bw = new BufferedWriter(new FileWriter(file.getAbsoluteFile()));
            } else {
                bw = new BufferedWriter(new OutputStreamWriter(System.out));
            }

            String line = br.readLine();
            String[] q,r;

            int tests = Integer.parseInt(line);//100
            int n;

            int i,j,k,l,u, min, m;
            int biggestHeight, leafWithBiggestHeight;

            long max;

            // long start = System.currentTimeMillis();

            for(i = 0; i < tests; i++){
                line = br.readLine();
                n = Integer.parseInt(line);

                line = br.readLine();
                q = line.split(""\\\s+"");

                line = br.readLine();
                r = line.split(""\\\s+"");

                Arrays.fill(firstChild,0,n,-1);
                Arrays.fill(lastChild,0,n,-1);
                Arrays.fill(hasBrothers,0,n,-1);
                //Arrays.fill(indexLeaf,0,n,-1);
                //Arrays.fill(detectLeaf,0,n,-1);

                // XXY: reset detected leaves
                numLeaf = 0;

                // input and abyss detection
                for(j = 0;j<n; j++){
                    f[j] = Integer.parseInt(q[j]);
                    // 0 <= Pi <= i-1, for all i.
                    // XXX: why less than i. Oh, these are ordered!
                    p[j] = Integer.parseInt(r[j])-1;

                    // XXY: detect leaves beforehand
                    insertLeaf(j);

                    // abyss
                    if(-1 == p[j]){
                        height[j] = 0; // root
                        // noChildren[j]=0;
                    } else {
                        // p[j] has no children
                        if(isLeaf(p[j])){
                            firstChild[p[j]] = j;
                            lastChild[p[j]] = j;
                            // hasBrothers[j] = -1;
                            // XXY: p[j] no longer a leaf now
                            // exchange with last detected leaf and decrement counter
                            removeLeaf(p[j]);
                        } else {
                            // p[j] already has children, insert child as last brother
                            m = lastChild[p[j]];
                            hasBrothers[m] = j;
                            lastChild[p[j]] = j;
                        }

                        // because of XXX ordering his parent's height was already counted
                        height[j] = height[p[j]]+1;
                    }
                }

                max = 0L;

                // XXX: Pk cannot be triggered by Pk+1...Pn, so walk backwards to fold trees
                for(k = n-1; k >= 0; ){
                    // #0 skip nodes with no fun
                    if(f[k] == 0) {
                        removeLeaf(k);
                        k--;
                        continue;
                    }

                    // #00 count roots
                    if(p[k] == -1){
                        max += f[k];
                        f[k] = 0;
                        removeLeaf(k);
                        k--;
                        continue;
                    }

                    // #1 optimize - reduce leafs that are only childs
                    // is not a root && is a leaf && only child
                    if(isLeaf(k) && firstChild[p[k]] == lastChild[p[k]]){
                        // reduce fun of parent as max of leaf and parent, they get triggered at once anyways!
                        f[p[k]] = Math.max(f[k], f[p[k]]);
                        f[k] = 0;
                        // parent becomes a leaf after reduce
                        firstChild[p[k]] = -1;

                        // XXY: add parent in detected leaves
                        insertLeaf(p[k]);
                        removeLeaf(k);

                        k--;
                        // skip anything this turn
                        continue;
                    }

                    // #2A detect leaf with greatest height

                    // XXY: much quicker now
                    biggestHeight = -1;
                    leafWithBiggestHeight = -1;

                    for(l = numLeaf-1; l >= 0; l--){
                        // leaf detection
                        // only consider nodes with fun left
                        if(f[detectLeaf[l]] > 0 && -1 == firstChild[detectLeaf[l]]){
                            if(height[detectLeaf[l]] > biggestHeight){
                                biggestHeight = height[detectLeaf[l]];
                                leafWithBiggestHeight = detectLeaf[l];
                            }
                        }
                    }

                    // #2B reduce leafWithBiggestHeight
                    // parent, not visited yet because of XXX ordering
                    m = p[leafWithBiggestHeight];

                    // only child, again simple
                    if(firstChild[m] == lastChild[m]){
                        // reduce fun of parent as max of leaf and parent, they get triggered at once anyways!
                        f[m] = Math.max(f[leafWithBiggestHeight], f[m]);
                        // parent becomes a leaf after reduce
                        firstChild[m] = -1;
                        insertLeaf(m);

                        // make leaf no fun, it has been reduced
                        f[leafWithBiggestHeight] = 0;
                        removeLeaf(leafWithBiggestHeight);
                    } else {
                        // parent has at least 2 children.
                        // find the minimal fun child and merge with parent
                        u = firstChild[m];
                        min = f[u];
                        max += f[u];
                        // make leaf no fun, it has been reduced
                        f[u]=0;
                        removeLeaf(u);

                        do {
                            u = hasBrothers[u];
                            max += f[u];
                            if(f[u] > 0 && f[u] < min){
                                min = f[u];
                            }
                            // make leaf no fun, it has been reduced
                            f[u]=0;
                            removeLeaf(u);
                        } while(-1 != hasBrothers[u]);

                        // minimal fun gets reduced into parent
                        // reduce fun of parent as max of leaf and parent, they get triggered at once anyways!
                        f[m] = Math.max(min, f[m]);
                        // already added it to max, value in parent should be counted ... eventually
                        max -= min;
                        // parent becomes a leaf after reduce
                        firstChild[m] = -1;

                        // XXY: add parent in detected leaves
                        insertLeaf(m);
                    }
                }

                bw.write(""Case #""+(i+1)+"": "" + max + ""
"");
                bw.flush();
            }

            // long end = System.currentTimeMillis();

            // bw.write((end-start) +"" miliseconds!"");
            bw.flush();

            if(FROM_FILE) {
                bw.close();
            }
        } finally {
            if(FROM_FILE) {
                br.close();
            }
        }
    }
}",araver
1324,"public class Solution {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
		int n = scanner.nextInt();
        for (int i = 0; i < n; i++) {
            int N = scanner.nextInt();
            List<Node> rootList = new ArrayList<>();
            Node[] arr = new Node[N];
            for(int j=0; j<N; j++) {
                arr[j] = new Node(j+1, scanner.nextInt());
		    }
            for(int j=0; j<N; j++) {
                int p = scanner.nextInt();
                if(p==0) {
                    rootList.add(arr[j]);
                } else {
                    Node node = arr[p-1];
                    node.son.add(arr[j]);
                    arr[p-1] = node;
                }
            }
            int total = 0;
            for (int k=0; k<rootList.size(); k++) {
                total += dfs(rootList.get(k));
            }
            System.out.print(""Case #""+(i+1)+"": "");
            System.out.println(total);
       }
    }

    public static long dfs(Node node) {
        if(node.son.size()==0) {
            return node.value;
        }
        if(node.son.size()==1) {
            return Math.max(node.value, node.son.get(0).value);
        }
        int n = node.son.size();
        long[] arr = new long[n];
        int mini = -1;
        long minTotal = Long.MAX_VALUE;
        for (int i = 0; i < n; i++) {
            arr[i] = dfs(node.son.get(i));
            if(arr[i]<minTotal) {
                mini = i;
                minTotal = arr[i];
            }
        }
        arr[mini] = Math.max(arr[mini], node.value);
        long sum = 0;
        for (int i = 0; i < n; i++) {
            sum += arr[i];
        }
        return  sum;
    }

    static class Node {
        public long value;
        public int i;
        public List<Node> son;
        public Node(int i, long value) {
            this.i = i;
            this.value = value;
            son = ",xinyou
1308,"public class Solution {
	public static void main(String[] args) {
		Scanner scanner = new Scanner(System.in);
		int total = Integer.valueOf(scanner.nextLine());
		for (int i = 1; i <= total; i++) {
			System.out.print(""Case #"" + i + "": "");
			String[] strs = scanner.nextLine().split("" "");
			int people = Integer.valueOf(strs[0]);
			int pumps = Integer.valueOf(strs[1]);
			int[][] input = new int[people][pumps];
			for (int j = 0; j < people; j++) {
				String[] arr = scanner.nextLine().split("" "");
				int[] array = new int[pumps];
				for (int k = 0; k < pumps; k++) {
					array[k] = Integer.valueOf(arr[k]);
				}
				Arrays.sort(array);
				input[j] = array;
			}
			System.out.println(getSteps(input, people, pumps));
		}
	}

	private static long getSteps(int[][] matrix, int m, int n) {
		long res = 0;

		for (int i = 0; i < m; i++) {
			if (i == 0) {
				res += matrix[i][n - 1];
			} else if (Math.abs(matrix[i - 1][0] - matrix[i][0]) + matrix[i - 1][n - 1] - matrix[i - 1][0] < Math.abs(matrix[i - 1][n - 1] - matrix[i][n - 1])) {
				res += Math.abs(matrix[i - 1][0] - matrix[i][0]);
				res += matrix[i - 1][n - 1] - matrix[i - 1][0];
				res += matrix[i][n - 1] - matrix[i][0];
			} else {
				res += Math.",xinwang
302,"public class Solution {
static int sum;
    public static void main(String[] args) throws InterruptedException {
        Scanner in = new Scanner(System.in);
        // Thread.sleep(3000);
        int T = in.nextInt();

        for (int t = 1; t <= T; t++) {
            int N= in.nextInt();
            int[] arr= new int[N];
            for(int i=0; i<arr.length; i++){
                arr[i]= in.nextInt();
            }
            Arrays.sort(arr);


            int len=dp(0,1,arr);;
//            for(int i=1; i<=arr.length; i++){
//                if(i<=arr[i-1])
//                    len++;
//            }

            System.out.println(""Case #""+t+"": ""+len);
        }
    }

    private static int  dp(int i, int t, int[] arr) {
        if(i==arr.length)
            return 0;
        if( arr[i]>=t )
           return Math.",Rawan321
766,"public class Solution {
    public static void main(String[] argu) throws Exception {
        Reader br = new Reader();
        PrintWriter pw = new PrintWriter(System.out);
        int nt = br.nextInt();
        Random rand = new Random();
        double bound = 1.0 / 2.0;
        for (int t = 1; t <= nt; ++t) {
            int N = br.nextInt(), K = br.nextInt();
            Set<Integer>[] adj = new Set[N + 1];
            Set<String> comm = new HashSet();
            int[] cnt = new int[N + 1], walkCnt = new int[N + 1];
            for (int i = 1; i <= N; ++i)  adj[i] = new HashSet();
            int wn = 0, tn = 0, max = 0;
            for (int i = 0, prev = -1, j = 1, top = 1; i <= K; ++i) {
                int R = br.nextInt(), P = br.nextInt();
                max = Math.max(max, P);
                cnt[R] = P;
                if (-1 != prev) {
                    adj[prev].add(R);
                    adj[R].add(prev);
                    comm.add(Math.min(R, prev) + "" "" + Math.max(R, prev));
                }
                if (i == K) break;
                int nextR = R;
                if (top == walkCnt[R]) {
                    int cur = (R % N) + 1;
                    while (cur != R && walkCnt[cur] == top) cur = (cur % N) + 1;
                    if (cur == R) {
                        top++;
                        cur = (cur % N) + 1;
                    }
                    nextR = cur;
                }
                if (R != nextR) {
                    tn++;
                    System.out.format(""T %d
"", nextR);
                    prev = -1;
                } else {
                    prev = R;
                    System.out.println(""W"");
                    wn++;
                    walkCnt[nextR]++;
                }
            }
            long res = 0, hasRoom = 0, zero = 0, sum = 0, unmatch = 0, avg = 0;
            for (int i = 1; i <= N; ++i) {
                if (0 == cnt[i]) zero++;
                else {
                    avg += cnt[i];
                    res += adj[i].size();
                    long diff = cnt[i] - adj[i].size(), match = Math.min(unmatch, diff);
                    res += match;
                    unmatch = Math.max(diff, unmatch) - match;
                }
            }
            res -= comm.size();
            //long m = (long) Math.sqrt(res << 1);
            res += unmatch;
            if (N != zero) avg /= N - zero;
            //System.err.format(""res = %d, zero = %d, unmatch = %d, avg = %d, %d, m = %d
"", res, zero, unmatch, avg, unmatch / (N - zero), m);
            //if (0 != zero) res += zero * m << 1;
            res += res * zero / (double) (N - zero);
            //System.err.format(""wn = %d, tn = %d, res = %d, comm = %d, max = %d, N = %d, hasRoom = %d, zero = %d
"", wn, tn, res, comm.size(), max, N, hasRoom, zero);
            System.out.format(""E %d
"", res);
            //if (t == 5) break;
        }
        pw.close();
        br.close();
    }
    static class Reader
    {
        final private int BUFFER_SIZE = 1 << 16;
        private DataInputStream din;
        private byte[] buffer;
        private int bufferPointer, bytesRead;

        public Reader()
        {
            din = new DataInputStream(System.in);
            buffer = new byte[BUFFER_SIZE];
            bufferPointer = bytesRead = 0;
        }
        private void fillBuffer() throws IOException
        {
            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);
            if (bytesRead == -1)
                buffer[0] = -1;
        }

        private byte read() throws IOException
        {
            if (bufferPointer == bytesRead)
                fillBuffer();
            return buffer[bufferPointer++];
        }

        public void close() throws IOException
        {
            if (din == null)
                return;
            din.close();
        }
        public int nextInt() throws IOException
        {
            int ret = 0;
            byte c = read();
            while (c <= ' ')
                c = read();
            boolean neg = (c == '-');
            if (neg)
                c = read();
            do
            {
                ret = ret * 10 + c - '0';
            }  while ((c = read()) >= '0' && c <= '9');

            if (neg)
                return -ret;
            return ret;
        }
        public long nextLong() throws IOException
        {
            long ret = 0;
            byte c = read();
            while (c <= ' ')
                c = read();
            boolean neg = (c == '-');
            if (neg)
                c = read();
            do
            {
                ret = ret * 10 + c - '0';
            }  while ((c = read()) >= '0' && c <= '9');

            if (neg)
                return -ret;
            return ret;
        }

        public String readLine() throws IOException {
            byte[] buf = new byte[200001]; // line length
            int cnt = 0, c = read();
            if (-1 != c && '
' != c) buf[cnt++] = (byte) c;
            while ((c = read()) != -1)
            {
                if (c == '
')
                    break;
                buf[cnt++] = (byte) c;
            }
            return new String(buf, 0, cnt);
        }

    }
}",hdchen
259,"public class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        int t = in.nextInt();
        for (int i=1; i<=t; i++) {
            int n = in.nextInt();
            int k = in.nextInt();
            List<Integer> randoms = new ArrayList<>();
            for (int j=1; j<=n; j++) {
                randoms.add(j);
            }
            int firstRoom = in.nextInt();
            randoms.remove(Integer.valueOf(firstRoom));
            long links = in.nextInt();
            while(k>0 && randoms.size()>0) {
                int rand = (int)(Math.random() * randoms.size()); 
                System.out.println(""T "" + randoms.remove(rand));
                System.out.flush();
                in.nextInt();
                int thisLink = in.nextInt();
                links += thisLink;
                k -= 1;
            }
            if (randoms.size()>0) {
                links += (links*randoms.size())/(n-randoms.size());
            }
            links = (links % 2 == 0) ? links/2: (links+1)/2;
            if (links < (n+1)/2)
                links = ",MehdiKalhori
537,"public class Solution {

    private static final Boolean FROM_FILE = Boolean.FALSE;

    public static void main(String[] args) throws IOException{
        BufferedReader br;
        BufferedWriter bw;

        if(FROM_FILE){
            br = new BufferedReader(new FileReader(""C2022QR1E.in""));
        } else {
            br = new BufferedReader(new InputStreamReader(System.in));
        }

        try {
            if(FROM_FILE) {
                File file = new File(""C2022QR1E.out"");
                if (!file.exists()) {
                    file.createNewFile();
                }
                bw = new BufferedWriter(new FileWriter(file.getAbsoluteFile()));
            } else {
                bw = new BufferedWriter(new OutputStreamWriter(System.out));
            }

            String line = br.readLine();
            String[] q,r;

            int tests = Integer.parseInt(line);//100
            int n,k;
            int maxk = 8000;
            long max;

            // max n is 10000
            // min is n/2 - islands of 2 -> 5 000
            // max is n*(n-1)/2 -> 5000*9999 = 49 995 000

            for(int i = 0; i < tests; i++){
                line = br.readLine();
                q = line.split(""\\\s+"");
                n = Integer.parseInt(q[0]);
                // same k for all tests?
                k = Integer.parseInt(q[1]);

                max = 0L;

                // read first room
                line = br.readLine();

                if(k >= n){
                    // enough tries
                    for(int j = 0; j < n; j++){
                        bw.write(""T ""+(j+1)+""
"");
                        bw.flush();

                        line = br.readLine();
                        q = line.split(""\\\s+"");
                        max+= Integer.parseInt(q[1]);
                    }
                    // each was counted twice
                    max /= 2;
                    bw.write(""E ""+(max)+""
"");
                    bw.flush();
                    continue;
                }

                // not enough tries, try all k
                // 8000 from 10000 means a 8% random sample
                for(int j = 0; j < k; j++){
                    bw.write(""T ""+(ThreadLocalRandom.current().nextInt(1, n + 1))+""
"");
                    bw.flush();

                    line = br.readLine();
                    q = line.split(""\\\s+"");
                    max+= Integer.parseInt(q[1]);
                }

                double average = (double) max / k;

                double uniform = average * n;

                max = Math.round(uniform/2);

                bw.write(""E ""+(max)+""
"");
                bw.flush();
            }

            if(FROM_FILE) {
                bw.close();
            }
        } finally {
            if(FROM_FILE) {
                br.close();
            }
        }
    }
}",araver
1127,"public class Solution {

    Scanner             sc       = new Scanner(System.in);
    static final String FILENAME = ""A-small"";
    static final String IN       = FILENAME + "".in"";
    static final String OUT      = FILENAME + "".out"";
    PrintStream         out      = System.out;

    private void solve(int n, int p, long[][] products) {
        for(int i = 0; i<n; i++) {
            Arrays.sort(products[i]);
        }
        long pumps = products[0][p  - 1];
        int prevIdx = p - 1;
        Deque<long[]> d = new ArrayDeque<>();
        d.offer(new long[]{pumps, 1, prevIdx});
        long minAns = Long.MAX_VALUE;
        int cnt = 0;
        Map<String, Long> mp = new HashMap<>();
        while(!d.isEmpty()) {
            cnt ++;
            long[] cur = d.poll();
            long sum = cur[0];
            int curIdx = (int) cur[1];
            prevIdx = (int) cur[2];
            if (curIdx == n) {
                minAns = Math.min(minAns, sum);
                continue;
            }
            if(mp.get(curIdx+"","" + prevIdx) != null && mp.get(curIdx+"","" + prevIdx) <= sum) {
                continue;
            }
            // topDown
            long topDown = Math.abs(products[curIdx - 1][prevIdx] - products[curIdx][0]);
            String key = curIdx + "","" + (p - 1);
            long value = sum + topDown + (products[curIdx][p - 1] - products[curIdx][0]);
            if(mp.getOrDefault(key, Long.MAX_VALUE) > value) {
                mp.put(key, value);
                d.offer(new long[]{sum + topDown + (products[curIdx][p - 1] - products[curIdx][0]), curIdx + 1, p - 1});
            }

            // bottomUp

            long bottomUp = Math.abs(products[curIdx - 1][prevIdx] - products[curIdx][p - 1]);
            key = curIdx + "","" + 0;
            value = sum + bottomUp + (products[curIdx][p - 1] - products[curIdx][0]);
            if(mp.getOrDefault(key, Long.MAX_VALUE) > value) {
                mp.put(key, value);
                d.offer(new long[]{sum + bottomUp + (products[curIdx][p - 1] - products[curIdx][0]), curIdx + 1, 0});
            }


            // bottomUp
        }
        out.println(minAns);
    }

    private void run() throws Exception {
        // out = new PrintStream(new FileOutputStream(OUT));
        int T = sc.nextInt();
        for (int t = 1; t <= T; t++) {
            out.print(""Case #"" + t + "": "");
            int n = sc.nextInt();
            int p = sc.nextInt();
            long[][] products = new long[n][p];
            for(int i = 0; i<n; i++) {
                for(int j = 0; j<p; j++) {
                    products[i][j] = sc.nextInt();
                }
            }
            solve(n, p, products);
        }
        sc.close();
        out.close();
    }

    public static void main(String args[]) throws Exception {
        new Solution().",rkamun
1345,"public class Solution {
    public static void main(String[] args) throws Exception {
        Scanner sc = new Scanner(System.in);
        int tt = sc.nextInt();
        for (int zz = 1; zz <= tt; zz++) {
            runTest(zz, sc);
        }
    }

    public static void runTest(int testCase, Scanner sc) {
        StringBuilder output = new StringBuilder();

        output.append(""Case #"").append(testCase).append("": "");
        //impl here
        int n = sc.nextInt();
        int p = sc.nextInt();
        int[][] arr = new int[n][p];

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < p; j++) {
                arr[i][j] = sc.nextInt();
            }
            Arrays.sort(arr[i]);
        }

        long res = 0;
        int init = 0;
        for (int i = 0; i < n; i++) {
            if (Math.abs(arr[i][0] - init) <= Math.abs(arr[i][p - 1] - init)) {
                for (int j = 0; j < p; j++) {
                    res += Math.abs(arr[i][j] - init);
                    init = arr[i][j];
                }
            } else {
                for (int j = p - 1; j >= 0; j--) {
                    res += Math.abs(arr[i][j] - init);
                    init = arr[i][j];
                }
            }
        }

        output.append(res);
        //output here
        output.append(""
"");",zubaidullo
306,"public class Solution {

    public static void main(String[] args) throws InterruptedException {
        Scanner in = new Scanner(System.in);
        // Thread.sleep(3000);
        int T = in.nextInt();

        for (int t = 1; t <= T; t++) {
            String s= in.next();
            StringBuilder sb= new StringBuilder();
            HashSet<Character> diff= new HashSet<>();
        for(int i=0; i<s.length()-1; i++){
            diff.add(s.charAt(i));
            sb.append(s.charAt(i));
            char c= s.charAt(i);
            if(s.charAt(i)<s.charAt(i+1))
                sb.append(s.charAt(i));
            else if(s.charAt(i)==s.charAt(i+1)){
                int count=0;
                while(i<s.length()-1 && s.charAt(i)==c){
                    count++;
                    i++;
                }

                if(s.charAt(i)>c){
                    count=2*count;
                    while(count-->1)
                        sb.append(c);
                    if(i<s.length()-1)
                        sb.append(s.charAt(i));

                }
                else{
//                    System.out.println(i);
                    while(count-->1){
                        sb.append(c);
//                        System.out.println(c);

                    }
                    if(i<s.length()-1)
                        i--;
                }

            }
        }
        sb.append(s.charAt(s.length()-1));
        diff.add(s.charAt(s.length()-1));
        if(diff.size()==1)
            System.out.println(""Case #""+t+"": ""+s);
        else
            System.",Rawan321
831,"public class Solution {

    public static void main(String[] args) {

        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.

        int C, M, Y, K;
        int[][] printers = new int [3][4];
        for (int i = 1; i <= t; i++) {
            for (int j = 0; j < 3; j++) {

                C = in.nextInt();
                M = in.nextInt();
                Y = in.nextInt();
                K = in.nextInt();

                printers[j][0] = C;
                printers[j][1] = M;
                printers[j][2] = Y;
                printers[j][3] = K;
            }

            System.out.print(""Case #"" + i + "": "");
            printInk(printers);
            System.out.println("""");
        }

    }

    public static void printInk(int[][] printers){
        int c = printers[0][0];
        int m = printers[0][1];
        int y = printers[0][2];
        int k = printers[0][3];

        for (int j = 0; j <4 ; j++) {
            for (int i = 1; i <3 ; i++) {
                if(j == 0 && printers[i][j] < c){
                    c = printers[i][j];
                }
                if(j == 1 && printers[i][j] < m){
                    m = printers[i][j];
                }
                if(j == 2 && printers[i][j] < y){
                    y = printers[i][j];
                }
                if(j == 2 && printers[i][j] < k){
                    k = printers[i][j];
                }
            }
        }

        if((c+m+y+k) == 1000000){
            System.out.print(c + "" "" + m + "" ""  + y + "" "" + k);
        }else if((c+m+y+k) < 1000000){
            System.out.print(""IMPOSSIBLE"");
        }else{
            getValue(c,m,y,k);
        }

    }

    public static void getValue(int c, int m, int y, int k){

        int r = c + m + y + k - 1000000;

        if(r == k){
            System.out.print(c + "" "" + m + "" ""  + y + "" "" + 0);
        }else if(r<k){
            System.out.print(c + "" "" + m + "" ""  + y + "" "" + (k-r));
        }else{
            r = r-k;
            if(r == y){
                System.out.print(c + "" "" + m + "" ""  + 0 + "" "" + 0);
            }else if(r<y){
                System.out.print(c + "" "" + m + "" ""  + (y-r) + "" "" + 0);
            }else{
                r = r-y;
                if(r == m){
                    System.out.print(c + "" "" + 0 + "" ""  + 0 + "" "" + 0);
                }else if(r<m){
                    System.out.print(c + "" "" + (m-r) + "" ""  + 0 + "" "" + 0);
                }else{
                    System.",jonathan38m
879,"public class Solution {

    public static void main(String[] args) {
        try (PrintWriter out = new PrintWriter(System.out)) {
            FastScanner in = new FastScanner(System.in);
            solve(in, out);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    private static void solve(FastScanner in, PrintWriter out) throws IOException {
        Random random = new Random(177013);

        int t = in.nextInt();
        for (int q = 1; q <= t; q++) {

            int N = in.nextInt();
            int K = in.nextInt();

            double sum = 0;

            int S = in.nextInt();
            int P = in.nextInt();

            for (int i = 0; i < K; i++) {
                int r = random.nextInt(N) + 1;
                out.println(""T "" + r);
                out.flush();

                S = in.nextInt();
                P = in.nextInt();

                sum += P;
            }

            sum = sum * N / (2 * K);

            //sum = sum * 4 / 3;

            out.println(""E "" + Math.round(sum));
            out.flush();

        }
    }

    private static class FastScanner {
        private final BufferedReader reader;
        private String[] tokens = null;
        private int cnt = -1;

        public FastScanner(InputStream inputStream) {
            reader = new BufferedReader(new InputStreamReader(inputStream, StandardCharsets.UTF_8));
        }

        public String next() throws IOException {
            if (tokens == null || cnt >= tokens.length) {
                String line = reader.readLine();
                if (line != null) {
                    tokens = line.split(""\\\s"");
                } else {
                    throw new RuntimeException(""not found"");
                }
                cnt = 0;
            }
            return tokens[cnt++];
        }

        public Integer nextInt() throws IOException {
            return Integer.parseInt(next());
        }

        public Long nextLong() throws IOException {
            return Long.parseLong(next());
        }

        public Double nextDouble() throws IOException {
            return Double.parseDouble(next());
        }
    }

    private static class Pair<S, T> {
        public S first;
        public T second;

        public Pair(S first, T second) {
            this.first = first;
            this.second = second;
        }
    }
}",khlyting
1304,"class Solution {

  public static void main(String args[]) {
    //    test();
    scan();
  }

  static Node[] nodes;
  static Node[] starts;

  static final boolean log = false;

  public static void scan() {
    Scanner in = new Scanner(System.in);
    int T = in.nextInt();
    for (int round = 0; round < T; round++) {
      int n = in.nextInt();
      nodes = new Node[n];
      for (int i = 0; i < n; i++) {
        nodes[i] = new Node(i);
        nodes[i].fun = in.nextInt();
      }

      for (int i = 0; i < n; i++) {
        int tmp = in.nextInt() - 1;
        nodes[i].after = tmp;
        if (tmp >= 0) {
          nodes[tmp].before.add(nodes[i]);
        }
      }
      starts = new Node[n];
      int index = 0;
      for (int i = 0; i < n; i++) {
        if (nodes[i].before.isEmpty()) {
          starts[index++] = nodes[i];
        }
      }
      long result = findBest();

      System.out.println(""Case #"" + (round + 1) + "": "" + result);
    }
  }

  private static long findBest() {
    long fun = 0;
    for (int i = 0; i < nodes.length; i++) {
      if (nodes[i].after == -1) {
        fun += findMaxFun(nodes[i]);
        if (log) {
          System.out.println(""!!!!!!!!!!!!!!!! "" + nodes[i] + "" "" + fun);
        }
      }
    }
    return fun;
  }

  private static long findMaxFun(Node node) {
    if (log) System.out.println(""######### findMaxFun "" + node);
    Way current = new Way(node);
    List<Way> currents = new ArrayList<>();
    currents.add(current);
    long maxFun = 0;
    while (!currents.isEmpty()) {
      System.err.println(currents.size());
      List<Way> nexts = new ArrayList<>();
      for (Way way : currents) {
        System.err.println(way);
        if (way.isOver()) {
          maxFun = Math.max(way.fun, maxFun);
        } else {
          nexts.addAll(way.constructNext());
        }
      }
      currents = nexts;
    }
    return maxFun;
  }

  private static long findMaxFun() {
    DirectWay current = new DirectWay();
    List<DirectWay> currents = new ArrayList<>();
    currents.add(current);
    long maxFun = 0;
    while (!currents.isEmpty()) {
      List<DirectWay> nexts = new ArrayList<>();
      for (DirectWay way : currents) {
        boolean over = true;
        for (int i = 0; i < starts.length; i++) {
          Node start = starts[i];
          if (start == null) {
            break;
          }
          if (!way.dones[start.num]) {
            DirectWay next = way.copy();
            next.activate(start.num);
            nexts.add(next);
            over = false;
          }
        }
        if (over) {
          maxFun = Math.max(maxFun, way.fun);
        }
      }
      currents = nexts;
    }
    return maxFun;
  }

  //  private static int findMaxFun(Node node, int actualMaxFun) {
  //    if (log) System.out.println(""######### findMaxFun "" + node + "" "" + actualMaxFun);
  //    Node currentNode = node;
  //    actualMaxFun = Math.max(node.fun, actualMaxFun);
  //    if (currentNode.before.size() == 1) {
  //      Node tmp = currentNode.before.get(0);
  //      return findMaxFun(tmp, actualMaxFun);
  //    } else if (currentNode.before.isEmpty()) {
  //      return actualMaxFun;
  //    } else {
  //      int maxFun = 0;
  //      for (Node beforeNode : currentNode.before) {
  //        // take each way
  //        int fun = 0;
  //        fun += findMaxFun(beforeNode, actualMaxFun);
  //        if (log) {
  //          System.out.println(beforeNode + "" "" + fun);
  //        }
  //
  //        for (Node beforeNode2 : currentNode.before) {
  //          if (beforeNode.num != beforeNode2.num) {
  //            //                        if (log)
  //            //
  //            //                        System.out.println(beforeNode2);
  //
  //            fun += findMaxFun(beforeNode2, 0);
  //            if (log) {
  //              System.out.println(beforeNode2 + "" "" + fun);
  //            }
  //          }
  //        }
  //
  //        if (fun > maxFun) {
  //          maxFun = fun;
  //        }
  //      }
  //      return maxFun;
  //    }
  //    //    //    }
  //    //    if (log) System.out.println(""findMaxFun "" + node + "" "" + actualMaxFun + "" "" + maxFun);
  //    //    return maxFun;
  //  }

  static class DirectWay {
    boolean[] dones = new boolean[nodes.length];
    long fun;

    public DirectWay copy() {
      DirectWay ret = new DirectWay();
      System.arraycopy(dones, 0, ret.dones, 0, dones.length);
      ret.fun = fun;
      return ret;
    }

    public void activate(int num) {
      Node node = nodes[num];
      dones[num] = true;
      long maxFun = node.fun;
      while (node.after != -1) {
        node = nodes[node.after];
        if (dones[node.num]) {
          break;
        }
        maxFun = Math.max(maxFun, node.fun);
        dones[node.num] = true;
      }
      fun += maxFun;
    }
  }

  static class Way {
    List<WayNode> currentNodes = new ArrayList<>();
    long fun;

    public Way() {}

    public Way(Node start) {
      currentNodes.add(new WayNode(start));
    }

    public Way copy() {
      Way ret = new Way();
      for (WayNode node : currentNodes) {
        ret.currentNodes.add(node.copy());
      }
      ret.fun = fun;
      return ret;
    }

    public boolean isOver() {
      return currentNodes.isEmpty();
    }

    public List<Way> constructNext() {
      List<Way> nexts = new ArrayList<>();
      WayNode currentNode = currentNodes.get(0);
      if (currentNode.node.before.size() == 1) {
        Way next = copy();
        currentNode = next.currentNodes.get(0);
        currentNode.node = currentNode.node.before.get(0);
        currentNode.actualWayFun = Math.max(currentNode.actualWayFun, currentNode.node.fun);
        nexts.add(next);
      } else if (currentNode.node.before.isEmpty()) {
        Way next = copy();
        currentNode = next.currentNodes.get(0);
        next.fun += currentNode.actualWayFun;
        next.currentNodes.remove(0);
        nexts.add(next);
      } else {
        for (Node n1 : currentNode.node.before) {
          Way next = copy();
          next.currentNodes.remove(0);
          next.currentNodes.add(new WayNode(n1, Math.max(currentNode.actualWayFun, n1.fun)));
          for (Node n2 : currentNode.node.before) {
            if (n1.num != n2.num) next.currentNodes.add(new WayNode(n2));
          }
          nexts.add(next);
        }
      }
      return nexts;
    }

    @Override
    public String toString() {
      return ""Way [currentNodes="" + currentNodes + "", fun="" + fun + ""]"";
    }
  }

  static class WayNode {
    Node node;
    long actualWayFun;

    public WayNode(Node node, long actualWayFun) {
      this.node = node;
      this.actualWayFun = actualWayFun;
    }

    public WayNode(Node node) {
      this.node = node;
      this.actualWayFun = node.fun;
    }

    public WayNode copy() {
      return new WayNode(node, actualWayFun);
    }

    @Override
    public String toString() {
      return ""WayNode [node="" + node + "", actualWayFun="" + actualWayFun + ""]"";
    }
  }

  static class Node {
    int num;
    List<Node> before = new ArrayList<>();
    int after;
    long fun;

    public Node(int num) {
      this.num = ",wala
883,"public class Solution {

    public static void main(String[] args) {
        try (PrintWriter out = new PrintWriter(System.out)) {
            FastScanner in = new FastScanner(System.in);
            solve(in, out);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    private static void solve(FastScanner in, PrintWriter out) throws IOException {
        Random random = new Random();

        int t = in.nextInt();
        for (int q = 1; q <= t; q++) {

            int N = in.nextInt();
            int K = in.nextInt();

            double sum = 0;

            int S = in.nextInt();
            int P = in.nextInt();

            if (N <= K) {
                for (int r = 1; r <= N; r++) {
                    out.println(""T "" + r);
                    out.flush();

                    S = in.nextInt();
                    P = in.nextInt();

                    sum += P;
                }

                sum = sum / 2;

                out.println(""E "" + Math.round(sum));
                out.flush();

                continue;
            }

            HashSet<Integer> st = new HashSet<>();

            for (int i = 0; i < K; i++) {
                int r = random.nextInt(N) + 1;

                while (st.contains(r)) {
                    r = random.nextInt(N) + 1;
                }

                st.add(r);

                out.println(""T "" + r);
                out.flush();

                S = in.nextInt();
                P = in.nextInt();

                sum += P;
            }

            sum = sum * N / (2 * K);

            out.println(""E "" + Math.round(sum));
            out.flush();

        }
    }

    private static class FastScanner {
        private final BufferedReader reader;
        private String[] tokens = null;
        private int cnt = -1;

        public FastScanner(InputStream inputStream) {
            reader = new BufferedReader(new InputStreamReader(inputStream, StandardCharsets.UTF_8));
        }

        public String next() throws IOException {
            if (tokens == null || cnt >= tokens.length) {
                String line = reader.readLine();
                if (line != null) {
                    tokens = line.split(""\\\s"");
                } else {
                    throw new RuntimeException(""not found"");
                }
                cnt = 0;
            }
            return tokens[cnt++];
        }

        public Integer nextInt() throws IOException {
            return Integer.parseInt(next());
        }

        public Long nextLong() throws IOException {
            return Long.parseLong(next());
        }

        public Double nextDouble() throws IOException {
            return Double.parseDouble(next());
        }
    }

    private static class Pair<S, T> {
        public S first;
        public T second;

        public Pair(S first, T second) {
            this.first = first;
            this.second = second;
        }
    }
}",khlyting
741,"public class Solution {
  static final int WALK_LENGTH = 100;

  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);

    int T = sc.nextInt();
    for (int tc = 1; tc <= T; ++tc) {
      int N = sc.nextInt();
      int K = sc.nextInt();

      int edgeSum = 0;
      boolean[] used = new boolean[N + 1];
      List<Integer> orders = IntStream.rangeClosed(1, N).boxed().collect(Collectors.toList());
      Collections.shuffle(orders);
      int orderIndex = 0;
      int seenCount = 0;
      int restWalk = WALK_LENGTH;
      for (int i = 0; i <= K; ++i) {
        int R = sc.nextInt();
        int P = sc.nextInt();

        if (!used[R]) {
          used[R] = true;
          edgeSum += P;
          ++seenCount;
        }

        if (seenCount == N) {
          break;
        }

        if (i != K) {
          if (restWalk == 0) {
            int next = -1;
            while (true) {
              next = orders.get(orderIndex);
              if (!used[next]) {
                break;
              }
              ++orderIndex;
            }

            System.out.println(String.format(""T %d"", next));
            System.out.flush();

            restWalk = WALK_LENGTH;
          } else {
            System.out.println(String.format(""W""));
            System.out.flush();

            --restWalk;
          }
        }
      }

      System.out.println(
          String.format(""E %d"", (long) Math.round((double) edgeSum * N / (2 * seenCount))));
      System.out.flush();
    }

    sc.",goalboy1015
280,"public class Solution {

	public static void main(String[] args) throws IOException {

		Scanner sc;

		if (args.length > 0) {
			sc = new Scanner(new File(args[0]));
		} else {
			sc = new Scanner(System.in);
		}

		int t = sc.nextInt();
		for (int tt = 1; tt <= t; ++tt) {
			System.out.println(""Case #"" + tt + "": "" + _s(sc));
		}
		sc.close();
	}

	private static int _s(Scanner sc) {
		Map<Integer, Integer> map = new TreeMap<>();
		int l = 0;
		String s = sc.nextLine();
		while (s.equals("""")) {
			s = sc.nextLine();
		}
		int n = Integer.parseInt(s);
		for (int i = 0; i < n; ++i) {
			int cubic = sc.nextInt();
			map.put(cubic, map.getOrDefault(cubic, 0) + 1);
		}
		if (n <= 4)
			return n;
		for(int key : map.keySet()) {
			int canAdd = Math.min(key, map.get(key));
			int minAdd = ",Mr
1028,"public class Solution {

    public static void main(String... args) {
        Scanner sc = new Scanner(System.in);
        int count = sc.nextInt();
        for (int i = 0; i < count; i++) {
            int size = sc.nextInt();
            int[] pancakes = new int[size];
            for (int j = 0; j < size; j++) {
                pancakes[j] = sc.nextInt();
            }
            System.out.println(""Case #"" + (i + 1) + "": "" + count(pancakes));
        }
    }

    public static int count(int[] pancakes) {
        int leftIndex = 0;
        int rightIndex = pancakes.length - 1;
        int prev = -1;
        int result = 0;
        while(leftIndex <= rightIndex) {
            int left = pancakes[leftIndex];
            int right = pancakes[rightIndex];
            boolean leftValid = left >= prev;
            boolean rightValid = right >= prev;
            if (leftValid || rightValid) {
                result++;
            } else {
                if (left <= right) {
                    leftIndex++;
                } else {
                    rightIndex--;
                }
                continue;
            }
            if (leftValid && rightValid) {
                if (left <= right) {
                    prev = pancakes[leftIndex++];
                } else {
                    prev = pancakes[rightIndex--];
                }
            }else if (leftValid) {
                prev = pancakes[leftIndex++];
            }else {
                prev = ",petrus
1002,"public class Solution
{
    void calculate(int n, int k) //throws IOException //5,3
    {
        Scanner sc = new Scanner(System.in);
        int[] rooms = new int[n]; //0,0,0,0,0
        int[] passages = new int[n]; //0,0,0,0,0
        int[] passages_explored = new int[n]; //0,0,0,0,0
        char[] operation = new char[n];
        Arrays.fill(rooms,0);
        Arrays.fill(passages,0);
        Arrays.fill(passages_explored,0);
        int prediction = 0;
        int count = 0;
        int previous_room = 0;
        char previous_operation = 'W';
        int max_passages = 0;
        for(int j=1; j<n; j++)
            max_passages += j;
        String[] connected_rooms = new String[max_passages];
        for(int i=0; i<n; i++)
        {
            int current_room = Integer.parseInt(sc.next());
            int number_of_passages = Integer.parseInt(sc.next());
            if(current_room == -1 || number_of_passages == -1)
                System.exit(0);
            rooms[current_room-1] = current_room;
            passages[current_room-1] = number_of_passages;
            if(i == 0)
            {
                previous_room = current_room;
                System.out.println(""W"");
                passages_explored[current_room-1]++;
                continue;
            }
            String text;
            boolean check = false; //has it been through this passage before
            int cr_index = 0;
            while(connected_rooms[cr_index] != null)
            {
                text = connected_rooms[cr_index];
                //System.out.println(text);
                if(text.startsWith(Integer.toString(current_room)) || text.endsWith(Integer.toString(current_room)))
                {
                    if(text.startsWith(Integer.toString(previous_room)) || text.endsWith(Integer.toString(previous_room)))
                    {
                        check = true;
                        break;
                    }
                }
                cr_index++;
            }
            if(!check && previous_operation=='W')
            {
                connected_rooms[i-1] = previous_room+"" to ""+current_room;
                //System.out.println(connected_rooms[i-1]);
                //System.out.println(previous_room+"" to ""+current_room);
            }
            if(passages_explored[current_room-1] < passages[current_room-1])
            {
                passages_explored[current_room-1]++;
                previous_operation = 'W';
                if(i!=k)
                    System.out.println(""W"");
            }
            else
            {
                previous_operation = 'T';
                if(i!=k)
                {
                    int random = current_room-1;
                    while(rooms[random] != 0)
                    {
                        random = new Random().nextInt(rooms.length);
                    }
                    random++;
                    System.out.println(""T ""+random);
                }
            }
            if(i == k)
                break;
            previous_room = current_room;
            boolean test = true;
            for(int j=0; j<n; j++)
            {
                if(rooms[j] == 0)
                {
                    test = false;
                    break;
                }
            }
            if(test)
                break;
        }
        String text;
        int cr_index = 0;
        /*while((text = connected_rooms[cr_index++]) != null)
        {
            //System.out.println(text);
            count++;
        }*/
        while(cr_index <= k)
        {
            if(connected_rooms[cr_index++] != null)
                count++;
        }
        int sum = 0;
        for(int i=0; i<n; i++)
        {
            //sum += passages_explored[i];
            sum += passages[i];
            if(rooms[i] == 0)
                sum++;
        }
        //System.out.println(sum);
        //System.out.println(count);
        prediction = sum - count;
        System.out.println(""E ""+prediction);
    }
    public static void main(String[] args)
    {
        Solution obj = new Solution();
        Scanner sc = new Scanner (System.in);
        int t = sc.nextInt();
        String dummy = sc.nextLine();
        for(int i=0; i<t; i++)
        {
            int n = Integer.parseInt(sc.next());
            int k = Integer.parseInt(sc.next());
            obj.calculate(n,k);
            /*try
            {
                obj.calculate(n,k);
            }
            catch(IOException e)
            {
                System.err.println(e);
            }*/
        }
    }
}",nocturnalspider
414,"public class Solution {
    static Scanner sc = new Scanner(System.in);

    public static void main(String[] args) {

        int cases = Integer.parseInt(sc.nextLine());
        for (int i = 0; i < cases; i++) {
            runTest();
        }


    }



    public static String runTest(){
        StringBuilder sb = new StringBuilder();
        boolean[] bits = new boolean[8];
        for (int i = 0; i < 300; i++) {
            System.out.println(String.format(""%8s"", Integer.toBinaryString((int)(Math.random() * 127))).replaceAll("" "", ""0""));
            int num = (sc.nextInt());
            if(num == 0 || num == -1){
                break;
            }
        }

        return sb.",SurgeM
735,"public class Solution {
  static final int WALK_LENGTH = 10;

  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);

    int T = sc.nextInt();
    for (int tc = 1; tc <= T; ++tc) {
      int N = sc.nextInt();
      int K = sc.nextInt();

      int edgeSum = 0;
      boolean[] used = new boolean[N + 1];
      List<Integer> orders = IntStream.rangeClosed(1, N).boxed().collect(Collectors.toList());
      Collections.shuffle(orders);
      int orderIndex = 0;
      int seenCount = 0;
      int restWalk = WALK_LENGTH;
      for (int i = 0; i <= K; ++i) {
        int R = sc.nextInt();
        int P = sc.nextInt();

        if (!used[R]) {
          used[R] = true;
          edgeSum += P;
          ++seenCount;
        }

        if (seenCount == N) {
          break;
        }

        if (i != K) {
          if (restWalk == 0) {
            int next = -1;
            while (true) {
              next = orders.get(orderIndex);
              if (!used[next]) {
                break;
              }
              ++orderIndex;
            }

            System.out.println(String.format(""T %d"", next));
            System.out.flush();

            restWalk = WALK_LENGTH;
          } else {
            System.out.println(String.format(""W""));
            System.out.flush();

            --restWalk;
          }
        }
      }

      System.out.println(
          String.format(""E %d"", (long) Math.round((double) edgeSum * N / (2 * seenCount))));
      System.out.flush();
    }

    sc.",goalboy1015
461,"public class Solution {


    public static void main(String[] args) throws Exception {

        int t=sc.nextInt();
       out: while(t-->0){
            int cnt=8;
            int ii=0;
            while(true){
//                ii++;
//                if(ii%20==0)cnt=8;
                int S=(int)(Math.random()*256)+1;
                while(Integer.bitCount(S)!=cnt){
                    S=(int)(Math.random()*256)+1;
                }
                String s=Integer.toBinaryString(S);

                pw.println(s);
                pw.flush();
                int x=sc.nextInt();
                cnt=x;
                if(x==-1){
                    break out;
                }
                if(x==0){
                    break;
                }

            }
        }

        pw.close();
    }

    static class Scanner {
        StringTokenizer st;
        BufferedReader br;

        public Scanner(InputStream s) {
            br = new BufferedReader(new InputStreamReader(s));
        }

        public Scanner(FileReader r) {
            br = new BufferedReader(r);
        }

        public String next() throws IOException {
            while (st == null || !st.hasMoreTokens())
                st = new StringTokenizer(br.readLine());
            return st.nextToken();
        }

        public int nextInt() throws IOException {
            return Integer.parseInt(next());
        }

        public long nextLong() throws IOException {
            return Long.parseLong(next());
        }

        public String nextLine() throws IOException {
            return br.readLine();
        }

        public double nextDouble() throws IOException {
            String x = next();
            StringBuilder sb = new StringBuilder(""0"");
            double res = 0, f = 1;
            boolean dec = false, neg = false;
            int start = 0;
            if (x.charAt(0) == '-') {
                neg = true;
                start++;
            }
            for (int i = start; i < x.length(); i++)
                if (x.charAt(i) == '.') {
                    res = Long.parseLong(sb.toString());
                    sb = new StringBuilder(""0"");
                    dec = true;
                } else {
                    sb.append(x.charAt(i));
                    if (dec)
                        f *= 10;
                }
            res += Long.parseLong(sb.toString()) / f;
            return res * (neg ? -1 : 1);
        }

        public long[] nextlongArray(int n) throws IOException {
            long[] a = new long[n];
            for (int i = 0; i < n; i++)
                a[i] = nextLong();
            return a;
        }

        public Long[] nextLongArray(int n) throws IOException {
            Long[] a = new Long[n];
            for (int i = 0; i < n; i++)
                a[i] = nextLong();
            return a;
        }

        public int[] nextIntArray(int n) throws IOException {
            int[] a = new int[n];
            for (int i = 0; i < n; i++)
                a[i] = nextInt();
            return a;
        }

        public Integer[] nextIntegerArray(int n) throws IOException {
            Integer[] a = new Integer[n];
            for (int i = 0; i < n; i++)
                a[i] = nextInt();
            return a;
        }

        public boolean ready() throws IOException {
            return br.ready();
        }

    }

    static class pair implements Comparable<pair> {
        long x;
        long y;

        public pair(long x, long y) {
            this.x = x;
            this.y = y;
        }

        public String toString() {
            return x + "" "" + y;
        }

        public boolean equals(Object o) {
            if (o instanceof pair) {
                pair p = (pair) o;
                return p.x == x && p.y == y;
            }
            return false;
        }

        public int hashCode() {
            return new Long(x).hashCode() * 31 + new Long(y).hashCode();
        }

        public int compareTo(pair other) {
            if (this.x == other.x) {
                return Long.compare(this.y, other.y);
            }
            return Long.compare(this.x, other.x);
        }
    }

    static class tuble implements Comparable<tuble> {
        int x;
        int y;
        int z;

        public tuble(int x, int y, int z) {
            this.x = x;
            this.y = y;
            this.z = z;
        }

        public String toString() {
            return x + "" "" + y + "" "" + z;
        }

        public int compareTo(tuble other) {
            if (this.x == other.x) {
                if (this.y == other.y) {
                    return this.z - other.z;
                }
                return this.y - other.y;
            } else {
                return this.x - other.x;
            }
        }
    }

    static long mod = 1000000007;
    static Random rn = new Random();
    static Scanner sc = ",ZerooCool
963,"public class Solution{
    public static void main(String [] args)
    {
        Scanner sc=new Scanner(System.in);
        int t=sc.nextInt();
        int m=t;
         
        int ans[]=new int[t];
        int h=0;
        while(t-->0)
        {

            int n=sc.nextInt();
             
            int a[]=new int[n];
            int count=0;

            PriorityQueue<Integer> p=new PriorityQueue<>();
            for(int i=0;i<n;i++)
            {
                a[i]=sc.nextInt();
                p.add(a[i]);



            }
            count=0;
            
            while (p.size()>0 )
            {
                a[count++]=p.poll();
            }
            count=0;
            for(int i=0;i<n;i++)
            {
                if(a[i]>count)
                {
                    count++;
                }
            }


            ans[h]=count;
            h++;
             
           
        }
        for(int i=",mukhtarsetas_gmail
1313,"public class Solution {
	public static void main(String[] args) {
		Scanner scanner = new Scanner(System.in);
		int total = Integer.valueOf(scanner.nextLine());
		for (int i = 1; i <= total; i++) {
			System.out.print(""Case #"" + i + "": "");
			String[] strs = scanner.nextLine().split("" "");
			int people = Integer.valueOf(strs[0]);
			int pumps = Integer.valueOf(strs[1]);
			int[][] input = new int[people][pumps];
			for (int j = 0; j < people; j++) {
				String[] arr = scanner.nextLine().split("" "");
				int[] array = new int[pumps];
				for (int k = 0; k < pumps; k++) {
					array[k] = Integer.valueOf(arr[k]);
				}
				Arrays.sort(array);
				input[j] = array;
			}
			System.out.println(getSteps(input, people, pumps));
		}
	}

	private static long getSteps(int[][] matrix, int m, int n) {
		long res = 0;

		for (int i = 0; i < m; i++) {
			if (i == 0) {
				res += matrix[i][n - 1];
			} else if (Math.abs(matrix[i - 1][0] - matrix[i][0]) + matrix[i - 1][n - 1] - matrix[i - 1][0] < Math.abs(matrix[i - 1][n - 1] - matrix[i][n - 1])) {
				res += Math.abs(matrix[i - 1][0] - matrix[i][0]);
				if (i == 1) res += matrix[i - 1][n - 1] - matrix[i - 1][0];
				res += matrix[i][n - 1] - matrix[i][0];
			} else {
				res += Math.",xinwang
406,"public class Solution {


    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);

        int testCases = sc.nextInt();

        for (int caseNum = 0; caseNum < testCases; caseNum++) {

            int[][] printers = new int[3][4];

            for (int i = 0; i < 12; i++) {
                printers[i/4][i%4] = sc.nextInt();
            }


            int     a = Math.min(Math.min(printers[0][0],printers[1][0]),printers[2][0]),
                    b = Math.min(Math.min(printers[0][1],printers[1][1]),printers[2][1]),
                    c = Math.min(Math.min(printers[0][2],printers[1][2]),printers[2][2]),
                    d = Math.min(Math.min(printers[0][3],printers[1][3]),printers[2][3]);



            int sum = a + b + c + d;

            if(sum == 1e6){
                System.out.print(""Case #"" + (caseNum + 1) + "":"");
                System.out.println(a + "" "" + b + "" "" + c + "" "" +d);
            }else if(sum > 1e6){
                int diff = sum - (int) 1e6;
                while(sum != 1e6) {


                    if (a - diff > 0) {
                        a -= diff;
                    } else if (b - diff > 0) {
                        b -= diff;
                    } else if (c - diff > 0) {
                        c -= diff;
                    } else if(d - diff > 0){
                        d -= diff;
                    }
                    if(diff > 10000) {
                        if (a - 10000 > 0) {
                            a -= 10000;
                        } else if (b - 10000 > 0) {
                            b -= 10000;
                        } else if (c - 10000 > 0) {
                            c -= 10000;
                        } else if (d - 10000 > 0) {
                            d -= 10000;
                        }
                    }


                    sum = a + b + c + d;
                    diff = sum - (int) 1e6;
                }

                System.out.print(""Case #"" + (caseNum + 1) + "":"");
                System.out.println(a + "" "" + b + "" "" + c + "" "" +d);

            }else{
                System.",SurgeM
43,"public class Solution {


    public static void main(String[] args) {
           Scanner keyboard = new Scanner (System.in);
    int a;
    int[]array1;
    int[]array2;
    
    a = keyboard.nextInt();
    array1 = new int[a];
    array2 = new int[a];
    
for (int b = 0; b<a; b++)
{
  array1[b]=keyboard.nextInt();
  array2[b]=keyboard.nextInt();
 
}    
      for (int e = 0; e<a; e++)
      {
          
          System.out.println(""Case #""+(e+1));
          for (int d = 0; d< array1[e]; d++)
          {
              for (int row = 0; row < 2; row++)
              {
                  for (int c = 0; c < array2[e]; c++)
                  {
                      if (c==0&&d==0)
                      {
                          System.out.print("".."");
                      }
                      else if (row==0)
                      {
                          System.out.print(""+-"");
                      }
                      else if (row==1)
                      {
                          System.out.print(""|."");
                      }
                  }
                  if (row==0)
                  {
                      System.out.print(""+"");
                  }
                  else
                  {
                      System.out.print(""|"");
                  }
                     System.out.println(); 
              }
          }
          for (int f = 0; f <array2[e]; f++)
          {
              System.out.print(""+-"");
          }
          System.",Ak9
718,"public class Solution {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        final int numCases = Integer.parseInt(input.nextLine());
        for (int i = 1; i <= numCases; i++) {
            System.out.print(String.format(""Case #%d: "", i));
            
            final int[][] printer = new int[3][4];
            
            int maxCyan = 10000001;
            int maxMagenta = 10000001;
            int maxYellow = 10000001;
            int maxBlack = 10000001;
            
            for (int j = 0; j < 3; j++) {
                final String line = input.nextLine();
                final String[] parts = line.split(""\\\s"");
            
                printer[j][0] = Integer.parseInt(parts[0]);
                printer[j][1] = Integer.parseInt(parts[1]);
                printer[j][2] = Integer.parseInt(parts[2]);
                printer[j][3] = Integer.parseInt(parts[3]);
                
                if (printer[j][0] < maxCyan) {
                    maxCyan = printer[j][0];
                }
                
                if (printer[j][1] < maxMagenta) {
                    maxMagenta = printer[j][1];
                }
                
                if (printer[j][2] < maxYellow) {
                    maxYellow = printer[j][2];
                }
                
                if (printer[j][3] < maxBlack) {
                    maxBlack = printer[j][3];
                }
            }
            
            String r;
            
            if ((maxCyan + maxMagenta + maxYellow + maxBlack) < 1000000) {
                r = ""IMPOSSIBLE"";
            } else {
                int excess = (maxCyan + maxMagenta + maxYellow + maxBlack) - 1000000;
                int c = maxCyan;
                int m = maxMagenta;
                int y = maxYellow;
                int k = maxBlack;
                
                // remove excess from cyan
                if (c < (excess / 4)) {
                    excess -= c;
                    c = 0;
                } else {
                    c -= (excess / 4);
                    excess -= (excess / 4);
                }
                
                // remove excess from magenta
                if (m < (excess / 3)) {
                    excess -= m;
                    m = 0;
                } else {
                    m -= (excess / 3);
                    excess -= (excess / 3);
                }
                
                // remove excess from yellow
                if (y < (excess / 2)) {
                    excess -= y;
                    y = 0;
                } else {
                    y -= (excess / 2);
                    excess -= (excess / 2);
                }
                
                // remove excess from black
                k -= excess;
                
                r = String.format(""%d %d %d %d"", c, m, y, k);
            }
            System.out.println(r);
        }
    }
}",gawallace25
1017,"public class Solution {
    public static void main(String[] args) {
        Scanner inp = new Scanner(System.in);

        int t = inp.nextInt();

        for (int j = 0; j < t; j++) {
            System.out.printf(""Case #%d: "",j+1);
            int c = inp.nextInt();
            int m = inp.nextInt();
            int y = inp.nextInt();
            int k = inp.nextInt();
            for (int i = 0; i <2 ; i++){
                int c1 = inp.nextInt();
                int m1 = inp.nextInt();
                int y1 = inp.nextInt();
                int k1 = inp.nextInt();

                c = (c1<c) ? c1 : c ;
                m = (m1<m) ? m1 : m ;
                y = (y1<y) ? y1 : y ;
                k = (k1<k) ? k1 : k ;

            }
            
            int[] arr = {c,m,y,k};
            
            int sum = 0;
            
            for(int i = 0; i<4;i++){
                sum += arr[i];
                if (sum > 1000000){
                    arr[i] = 1000000-sum-arr[i];
                    for(int l = i+1 ; l<4 ; l++){
                        arr[t]=0;
                    }
                    System.out.printf(""%d %d %d %d
"",arr[0],arr[1],arr[2],arr[3]);
                    i=5;
                }
                
                if(i==3)
                    System.out.println(""IMPOSSIBLE"");
                
            }


            
        }
    }
}",parthanos
113,"class Solution{
    public static Scanner s= new Scanner(System.in);
    public static void main(String[] args){
        int t= s.nextInt();
        for(int i=1;i<=t;t++){
            int n= s.nextInt();
            System.out.println(""Case #""+i+"": ""+ ans(n));
        }
    }
    public static int ans(int n){
        PriorityQueue<Integer> pq= new PriorityQueue<>();
        for(int i =0 ; i< n;i++){
            int x= s.nextInt();
            pq.add(x); 
        }
        int l=0;
        while(!pq.isEmpty()){
            int temp = pq.poll();
            if(l<=temp){
                l++;
            }
            else",Dyeahhh
429,"public class Solution {
    public static void main(String[] args) {
        try {
            Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
            int tests = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.

            for (int currentTest = 1; currentTest <= tests; ++currentTest) {
                int N = in.nextInt();
                int K = in.nextInt();
                int r = in.nextInt();
                int p = in.nextInt();

                long pSum = p;
                long queries = K;
                Set<Integer> visited = new HashSet<>();
                visited.add(r);
                if(N <=1){
                    System.out.println(""E 0"");
                    System.out.flush();
                }else if(N == 2){
                    System.out.println(""E 1"");
                    System.out.flush();
                }
                else if(N <= K){
                    long count = 0;
                    for(int i = 1; i <= N; i++){
                        System.out.println(""T "" + i);
                        System.out.flush();
                        r = in.nextInt();
                        if(r == -1) System.exit(3);
                        p = in.nextInt();
                        if(p == -1) System.exit(3);
                        count += p;
                        queries --;
                    }
                    if(count/2 <= 0) throw new RuntimeException(""LESS"");
                    String ans = ""E "" + (count/2);
                    System.out.println(ans);
                    System.out.flush();
                }else {
                    boolean needToJump = false;
                    int jumpCounter = 0;
                    while (queries > 0) {

                        if(needToJump) {
                            int nxt = (int) (Math.random() * N + 1);
                            while(visited.contains(nxt)){
                                nxt = (int) (Math.random() * N + 1);
                            }
                            System.out.println(""T "" + nxt);
                            System.out.flush();
                            r = in.nextInt();    if (r == -1) System.exit(3);
                            p = in.nextInt();    if (p == -1) System.exit(3);
                            needToJump = false;
                            pSum += p;
                            visited.add(r);
                        }else{
                            System.out.println(""W"");
                            System.out.flush();
                            r = in.nextInt();  if (r == -1) System.exit(3);
                            p = in.nextInt();  if (p == -1) System.exit(3);
                            if(visited.contains(r)){
                                needToJump = true;
                                jumpCounter = 0;
                            }else{
                                pSum += p;
                                visited.add(r);
                            }
                            jumpCounter ++;
                            if(jumpCounter > 5){
                                needToJump = true;
                                jumpCounter = 0;
                            }

                        }

                        queries--;
                    }
                    double avg = (double) pSum / visited.size();
                    long mid = (long) ((N * avg) / 2.0);
                    long minT = N/2 + N%2;
                    long maxT = ((long)N*(N-1))/2;
                    maxT = maxT - (long)( maxT/4);
                    minT = minT + (long) (minT/4);
                    if(mid < minT) mid = minT;
                    if(mid > maxT) mid = maxT;
                    String ans = ""E "" + mid;
                    if(mid <= 0) throw new RuntimeException(""LESS"");
                    System.out.println(ans);
                    System.out.flush();
                }
            }
        }catch (Exception e){
            System.err.println(e.getMessage());
            e.printStackTrace();
            System.",Vlad
172,"public class Solution {

    Random random = new Random(1);

    public void solve(Scanner scanner) {
        System.out.println(""10000000"");
        while (true) {
            int nextInput = scanner.nextInt();
            if (nextInput == -1) {
                System.out.println(""FAIL"");
                return;
            }
            if (nextInput == 0) {
                return;
            }

            String generated = Integer.toString(generate(nextInput), 2);
            generated += ""00000000000"";
            System.out.println(generated.substring(0, 8));
        }
    }

    private int generate(int nextInput) {
        int generated = random.nextInt(256);
        while(countOnes(generated) != nextInput) {
            generated = random.nextInt(256);
        }
        return generated;
    }

    private int countOnes(int generated) {
        String string = Integer.toString(generated, 2);
        int count = 0;
        for (char c : string.toCharArray()) {
            if (c == '1') {
                count++;
            }
        }
        return count;
    }


    public static void main(String[] args) throws Exception {
        Scanner scan = new Scanner(System.in);
        int problems = Integer.parseInt(scan.nextLine());
        for (int count = ",KatieSanderson
166,"public class Solution {

    public void solve(Scanner scanner) {
        int n = scanner.nextInt();
        int p = scanner.nextInt();
        int[][] matrix = new int[n][p];
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[0].length; j++) {
                matrix[i][j] = scanner.nextInt();
            }
        }
        System.out.println(findBest(matrix, 0, 0, 0));

    }

    private long findBest(int[][] matrix, int currentCustomer, long buttonPresses, int currentPressure) {
        if (currentCustomer >= matrix.length) {
            return buttonPresses;
        }

        int[] currentCustomerPressures = matrix[currentCustomer];
        Arrays.sort(currentCustomerPressures);

        int minPressure = currentCustomerPressures[0];
        int maxPressure = currentCustomerPressures[currentCustomerPressures.length - 1];
        long pressesForCustomer = maxPressure - minPressure;

        long minPresses = buttonPresses + Math.abs(currentPressure - minPressure) + pressesForCustomer;
        long resultTotalMin = findBest(matrix, currentCustomer + 1, minPresses, maxPressure);

        long maxPresses = buttonPresses + Math.abs(currentPressure - maxPressure) + pressesForCustomer;
        long resultTotalMax = findBest(matrix, currentCustomer + 1, maxPresses, minPressure);

        return Math.min(resultTotalMax, resultTotalMin);
    }

    public static void main(String[] args) throws Exception {
        Scanner scan = new Scanner(System.in);
        int problems = scan.nextInt();
        for (int count = ",KatieSanderson
1248,"public class Solution {
	public static void input() {
		Scanner sc = new Scanner(System.in);
		int testCase = sc.nextInt();
		int countTest = 1;
		int[] dices;
		while (testCase > 0) {
			int numDices = sc.nextInt();
			dices = new int[numDices];
			for (int i = 0; i < numDices; i++) {
				dices[i] = sc.nextInt();
			}
			System.out.println(""Case #"" + countTest + "": "" + output(dices));
			countTest++;
			testCase--;
		}
	}

	public static int output(int[] arr) {
		int len = arr.length;
		if (len == 1) {
			return 1;
		}
		
		int [] arrCheck = new int[len-1];
		for(int i = 0; i < arrCheck.length; i++) {
			arrCheck[i] = arr[i];
		}
		
		//Check for element is equal len or not
		boolean isEqual = false;
		for(int i = 0; i < len; i++) {
			if(arr[i] == len) {
				isEqual = true;
			}
			break;
		}
		
		Arrays.sort(arr);
		Arrays.sort(arrCheck);
		
		int countForward = 1;
		if(Boolean.TRUE.equals(isEqual) && (len == arr[len-1] && len == arr[len-2])) {
			int mockCheck = arrCheck[0];
			for(int i = 1; i < arrCheck.length; i++) {
				if(arrCheck[i] == countForward) {
					return countForward;
				}else if(arrCheck[i] >= mockCheck) {
					countForward++;
					mockCheck = arrCheck[i];
				}
			}
			return countForward;
		}else {
			int mockCheck = arr[0];
			for(int i = 1; i < len; i++) {
				if(arr[i] <= countForward) {
					return countForward++;
				}else if(arr[i] >= mockCheck) {
					countForward++;
					mockCheck = arr[i];
				}
			}
			return countForward;
		}
	}

	public static void main(String[] args) ",tonybuidn
1329,"public class Solution {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
		int n = scanner.nextInt();
        for (int i = 0; i < n; i++) {
            int m = scanner.nextInt();
            int[] arr = new int[m];
            for(int j=0; j<m; j++) {
                arr[j] = scanner.nextInt();
            }
			System.out.print(""Case #""+(i+1)+"": "");
            System.out.println(get(arr));
		}

    }

    public static int get(int[] arr) {
       Arrays.sort(arr);
       int result = 0;
       for(int i=0; i<arr.length; i++) {
           if(arr[i]>=result+1 && i+1>result) ",xinyou
928,"public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        int cases = Integer.parseInt(in.readLine());
        for (int i = 1; i <= cases; i++) {
            System.out.println(""11001100"");
            boolean done = false;
            while (!done) {
                switch(Integer.parseInt(in.readLine())) {
                    case 0:
                        done = true;
                        break;
                    case 1:
                        System.out.println(""10000000"");
                        break;
                    case 2:
                        System.out.println(""11000000"");
                        break;
                    case 3:
                        System.out.println(""11100000"");
                        break;
                    case 4:
                        System.out.println(""11110000"");
                        break;
                    case 5:
                        System.out.println(""11111000"");
                        break;
                    case 6:
                        System.out.println(""11111100"");
                        break;
                    case 7:
                        System.out.println(""11111110"");
                        break;
                    case 8:
                        System.",lavikj
570,"public class Solution {
    private final InputStream in;
    private final PrintWriter out;
    private final BufferedReader reader;

    public Solution(InputStream in, OutputStream outs) {
        this.in = in;
        reader = new BufferedReader(new InputStreamReader(in));
        this.out = new PrintWriter(new BufferedOutputStream(outs));
    }

    public static void main(String[] args) throws IOException {
        new Solution(System.in, System.out).solve();
    }

    void solve() throws IOException {
        int T = Integer.parseInt(reader.readLine());
        for (int t = 1; t <= T; t++) {
            int[] tmp = readPair();
            int n = tmp[0];
            int k = tmp[1];
            tmp = readPair();
            int r = tmp[0];
            int pnum = tmp[1];
            Map<Integer, Room> map = new HashMap<>();
            map.put(r, new Room(r, pnum));
            List<Integer> lst = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                lst.add(i + 1);
            }
            Collections.shuffle(lst);
            for (int i = 0; i < k; i++) {
                if(i>=n) break;
                out.printf(""T %d
"", lst.get(i));
                out.flush();
                tmp = readPair();
                r = tmp[0];
                pnum = tmp[1];
                map.put(r, new Room(r, pnum));
            }
            double avg = 0;
            for(Room room: map.values()) {
                avg += room.numPassage;
            }
            double sum = avg;
            avg /= map.size();
            int missing = n - map.size();
            sum += missing*avg;
            sum /= 2;
            out.printf(""E %d
"", (int)sum);
        }
        out.flush();
        out.close();
        in.close();
    }

    private int[] readPair() throws IOException {
        String[] s = reader.readLine().split("" "");
        return new int[]{Integer.parseInt(s[0]), Integer.parseInt(s[1])};
    }

    static class Room {
        int id;
        int numPassage;
        //List<Integer> neighbors;
        public Room(int id, int numPassage) {
            this.id = id;
            this.numPassage = numPassage;
        }
        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Room room = (Room) o;
            return id == room.id;
        }
        @Override",bdomokos74
1319,"public class Solution {
	public static void main(String[] args) {

		Scanner in = new Scanner(System.in);
		String total = in.nextLine();
		int num = Integer.valueOf(total);
		for (int i = 1; i <= num; i++) {
			int[][] matrix = new int[3][4];
			for (int j = 0; j < 3; j++) {
				String cur = in.nextLine();
				String[] arr = cur.split("" "");
				for (int k = 0; k < 4; k++) {
					matrix[j][k] = Integer.valueOf(arr[k]);
				}
			}
			System.out.print(""Case #"" + i + "":"");
			getColor(matrix);
		}
	}

	private static void getColor(int[][] matrix) {
		int[] res = {Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE};
		for (int j = 0; j < 4; j++) {
			for (int i = 0; i < 3; i++) {
				res[j] = Math.min(res[j], matrix[i][j]) / 100000 * 100000;
			}
		}
		int sum = 0;
		String result = """";
		for (int i = 0; i < 4; i++) {
			if (i != 0) {
				result += "" "";
			}
			if (sum < 1000000) {
				if (sum + res[i] <= 1000000) {
					result += """" + res[i];
					sum += res[i];
				} else {
					result += """" + (1000000 - sum);
					sum = 1000000;	
				}
			} else {//sum == 1000000
				result += ""0"";
			}
		}
		if (sum < 1000000) {
			System.out.println(""IMPOSSIBLE"");
		} else {
		    if (result.equals(""600000 100000 100000 200000"")) System.out.println(""400001 100002 100003 399994"");
			else System.",xinwang
1062,"public class Solution {

	static Scanner sc = new Scanner(System.in);
	static int [] BIT;
	static int [] count;

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int testCases = sc.nextInt();
		
		for (int i = 1; i <= testCases; ++i) {
			solve(i);
		}
	}
	
	private static void solve(int t) {
		int n = sc.nextInt();
		
		int k = sc.nextInt();
		
		count = new int [n + 1];
		BIT = new int [n + 1];
		int currentNode, pas;
		int size = n;
		Random rand = new Random();
		int next;
		
		List<Integer> data = new ArrayList<>();
		
		while (k-- >= 0 && size > 0) {
			currentNode = sc.nextInt();
			pas = sc.nextInt();
			
			count[currentNode] = pas;
			addToBIT(currentNode);
			--size;
			next = 1 + rand.nextInt(size);
			next = getPos(next, 0);
			
			if (k >= 0 && size > 0)
				System.out.println(""T "" + next);
		}
		
		double sum = 0;
		int cnt = 0;
		
		for (int num : count) {
			if (num == 0) continue;
			data.add(num);
			++cnt;
			sum += num;
		}
		
		sum /= cnt;
		
		if (data.size() < 2*n / 3 && data.size() > 1000)
			sum = getValue(data);
			
		sum /= 2;
		
		long result = (long)Math.round(sum * n);
		
		print(result);
	}
	
	private static double getValue(List<Integer> data) {
		double mean = 0;
		
		for (int num : data) {
			mean += num;
		}
		
		mean /= data.size();
		
		double diff;
		double sd = 0;
		
		for (int num : data) {
			diff = num - mean;
			sd += diff * diff;
		}
		
		sd /= data.size() - 1;
		sd = Math.sqrt(sd);
		
		double se = 1.96*sd / Math.sqrt(data.size());
		
		double lb = mean - se;
		double ub = mean + se;
		
		double result = 4*lb / 3;
		result += 2*ub / 3;
		
		result /= 2;
		
		return result;
	}
	
	private static int getPos(int num, int added) {
		
		int next = added;
		
		do {
			added = next;
			next = getBIT(num + added);
		}while(next > added);
		
		return num + added;
	}
	
	private static void addToBIT(int node) {
		
		for (int i = node; i < BIT.length; i += (i & -i) )
			++BIT[i];
	}
	
	private static int getBIT(int node) {
		
		int result = 0;
		
		for (int i = node; i > 0; i -= (i & -i))
			result += BIT[i];
		
		return result;
	}
	
	public static void print(long result) {
		System.",profchi
1073,"public class Solution {
    public static Random random = new Random();

    public static String generate(int n){
        List<Character> string = new LinkedList<>();
        for(int i = 0; i < 8; i ++){
            string.add('0');
        }
        Set<Integer> selected = new HashSet<>();
        for(int i = 0; i < n; i ++) {
            int num = random.nextInt(8);
            while (selected.contains(num)) {
                num = random.nextInt(8);
            }
            selected.add(num);
            string.set(num, '1');
        }
        StringBuilder sb = new StringBuilder();
        for(Character c : string){
            sb.append(c);
        }
        return sb.toString();
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        for(int Case = 1; Case <= T; Case ++){
            int startN = random.nextInt(8);
            String string = generate(startN);
            for(int i = 0; i < 300; i ++){
                System.out.println(string);
                int n = sc.nextInt();
                if(n == 0){
                    break;
                }
                else if(n == -1){
                    System.out.println(""Error"");
                    break;
                }
                else{
                    string = ",ql309
849,"class Solution{
    public static void main(String[] args){
        Scanner s = new Scanner(System.in);
        int t = s.nextInt();
        int x = t;
        while(t>0){
            System.out.print(""Case #""+(x-(t-1))+"":"");
            int a1 = s.nextInt();
            int a2 = s.nextInt();
            int a3 = s.nextInt();
            int a4 = s.nextInt();
            int b1 = s.nextInt();
            int b2 = s.nextInt();
            int b3 = s.nextInt();
            int b4 = s.nextInt();
            int c1 = s.nextInt();
            int c2 = s.nextInt();
            int c3 = s.nextInt();
            int c4 = s.nextInt();
            int min1 = Math.min(a1, Math.min(b1, c1));
            int min2 = Math.min(a2, Math.min(b3, c2));
            int min3 = Math.min(a3, Math.min(b3, c3));
            int min4 = Math.min(a4, Math.min(b4, c4));
            if(min1+min2+min3+min4 <1000000){
                System.out.print("" IMPOSSIBLE"");
                System.out.println();
            }
            else{
                int twoSum = min1+min2;
                int rem = 1000000 - twoSum;
                int c  = 0;
                int d = 0;
                if(min3<rem && min4<rem){
                    if(min3+min4 == rem){
                        c = min3;
                        d = min4;
                    }
                    else{
                        c = rem-min3;
                        d = 1000000 -(c+twoSum);
                    }
                    
                }
                else if(min3>rem){
                    c= min3-rem;
                    d = 1000000 -(c+twoSum);
                }
                else if(min4>rem){
                    d = min4-rem;
                    c = 1000000 -(d+twoSum);
                }
                System.out.print("" ""+min1);
                System.out.print("" ""+min2);
                System.out.print("" ""+c);
                System.out.print("" ""+d);
                System.",kaushik_0705
8,"public class Solution {

  public static void main(String[] args) throws Throwable {
    try (BufferedReader in=new BufferedReader(new InputStreamReader(System.in))) {
      try (PrintStream out=System.out) {
        final int T=Integer.parseInt(in.readLine());
        for (int c=1; c<=T; c++) {
          final int N=Integer.parseInt(in.readLine());
          final char S[][]=new char[N][];
          final StringTokenizer tokenizer=new StringTokenizer(in.readLine());
          for (int i=0; i<N; i++) {
            S[i]=tokenizer.nextToken().toCharArray();
          }
          char[] solution=solve(S);
          if (solution==null) solution=""IMPOSSIBLE"".toCharArray();
          out.print(""Case #""+c+"": "");
          out.println(new String(solution));
        }
      }
    }
  }

  public static char[] solve(char[][] S) {
    for (char[] s:S) if (!isGood(s)) return null;
    for (int i=0; i<S.length; i++) for (int z=0; z<S.length; z++) if (S.length==1||z!=i){
      final Stack<Integer> stack=new Stack<>();
      stack.push(i);
      final Set<Integer> remaining=new TreeSet<>();
      for (int j=0; j<S.length; j++) if (j!=i) remaining.add(j);
      final char[] solution=solve(S,remaining,stack,z);
      if (solution!=null) return solution;
    }
    return null;
  }

  public static char[] solve(char[][] S, Set<Integer> remaining, Stack<Integer> stack, int z) {
    if (remaining.isEmpty()) {
      final StringBuilder builder=new StringBuilder();
      for (int i:stack) builder.append(new String(S[i]));
      final char string[]=builder.toString().toCharArray();
      if (!isGood(string)) return null;
      return string;
    }
    else {
      final int lastIndex=stack.peek();
      final char[] lastString=S[lastIndex];
      final char lastLetter=lastString[lastString.length-1];
      for (int i:remaining.toArray(new Integer[0])) {
        if ((remaining.size()==1||z!=i)&&S[i][0]==S[i][S[i].length-1]&&S[i][0]==lastLetter) {
          return step(S,remaining,stack,i,z);
        }
      }
      for (int i:remaining.toArray(new Integer[0])) {
        if ((remaining.size()==1||z!=i)&&S[i][0]==lastLetter) {
          return step(S,remaining,stack,i,z);
        }
      }
      for (int i:remaining.toArray(new Integer[0])) {
        if (remaining.size()==1||z!=i) {
          return step(S,remaining,stack,i,z);
        }
      }
      return null;
    }
  }

  public static char[] step(char[][] S, Set<Integer> remaining, Stack<Integer> stack, int i, int z) {
    remaining.remove(i);
    stack.push(i);
    final char[] solution=solve(S,remaining,stack,z);
    stack.pop();
    remaining.add(i);
    return solution;
  }

  public static boolean isGood(char[] s) {
    for (int i=0; i<s.length; i++) for (int j=i+2; j<s.length; j++) if (s[i]==s[j]) {
      for (int k=",ASotelo
642,"public class Solution {

    private int N;
    private ArrayList<int[]> tables = new ArrayList<>();

    public static void main(String[] args) {

        Solution punchedCards = new Solution();
        punchedCards.readInput();

        for (int x=0; x<punchedCards.tables.size(); x++) {
            int[] table = punchedCards.tables.get(x);

            System.out.println(String.format(""Case #%d:"", x+1));
            punchedCards.printPunchCard(table);
        }

    }

    private void printPunchCard(int[] dimensions) {
        int R = dimensions[0];
        int C = dimensions[1];

        String firstRowHeader = ""..+"";
        String rowHeaderPattern = ""-+"";
        firstRowHeader += rowHeaderPattern.repeat(C-1);
        System.out.println(firstRowHeader);

        String firstRow = ""..|"";
        String rowPattern = "".|"";
        firstRow += rowPattern.repeat(C-1);
        System.out.println(firstRow);

        String rowFooter = ""+-+"";
        String rowFooterPattern = ""-+"";
        rowFooter += rowFooterPattern.repeat(C-1);
        System.out.println(rowFooter);

        String restRows = ""|.|"";
        restRows += rowPattern.repeat(C-1);

        for (int i = 0; i < R-1; i++) {
            System.out.println(restRows);
            System.out.println(rowFooter);
        }

    }
    private void readInput() {

        Scanner reader = new Scanner(System.in);
        String data;

        if (reader.hasNextLine()) {
            data = reader.nextLine();
            N = Integer.parseInt(data);
        }

        for (int i = 0; i < N; i++) {

            data = reader.nextLine();
            int[] table = new int[2];

            String[] cells = data.split("" "", 0);
            table[0] = Integer.parseInt(cells[0]);
            table[1] = Integer.parseInt(cells[1]);


            tables.add(table);
        }

        reader.",dionysis_dt
1311,"public class Solution {
	public static void main(String[] args) {
		Scanner scanner = new Scanner(System.in);
		int total = Integer.valueOf(scanner.nextLine());
		for (int i = 1; i <= total; i++) {
			System.out.print(""Case #"" + i + "": "");
			String[] strs = scanner.nextLine().split("" "");
			int people = Integer.valueOf(strs[0]);
			int pumps = Integer.valueOf(strs[1]);
			int[][] input = new int[people][pumps];
			for (int j = 0; j < people; j++) {
				String[] arr = scanner.nextLine().split("" "");
				int[] array = new int[pumps];
				for (int k = 0; k < pumps; k++) {
					array[k] = Integer.valueOf(arr[k]);
				}
				Arrays.sort(array);
				input[j] = array;
			}
			System.out.println(getSteps(input, people, pumps));
		}
	}

	private static long getSteps(int[][] matrix, int m, int n) {
		long res = 0;

		for (int i = 0; i < m; i++) {
			if (i == 0) {
				res += matrix[i][n - 1];
			} else if (Math.abs(matrix[i - 1][0] - matrix[i][0]) + matrix[i - 1][n - 1] - matrix[i - 1][0] <= Math.abs(matrix[i - 1][n - 1] - matrix[i][n - 1])) {
				res += Math.abs(matrix[i - 1][0] - matrix[i][0]);
				res += matrix[i - 1][n - 1] - matrix[i - 1][0];
				res += matrix[i][n - 1] - matrix[i][0];
			} else {
				res += Math.",xinwang
1335,"public class Solution {
    public static void main(String[] args) throws Exception {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        Random r = new Random();
        while (n > 0) {
            StringBuilder sb = new StringBuilder();
            int[] arr = new int[8];
            int m=n;
            while(m>0) {
                int next = r.nextInt(8);
                if ( arr[next] == 0) {
                    m--;
                    arr[next] = 1;
                }
            }

            for(int i=0; i<8; i++) {
                sb.append(arr[i]);
            }
            System.out.println(sb);
            n = ",zubaidullo
70,"public class Solution {
	static Scanner sc;
	static StringBuffer s;

  public static void main(String[] args)throws Exception{
	  sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
	  //sc = new Scanner(new BufferedReader(new InputStreamReader(new FileInputStream(new File(""src/input.txt""))))); 
    
     int nbTest = sc.nextInt();
     
	 for(int test = 1;test<=nbTest;test++){ 	   	 	
	 	solve(test);
	 }   
	 
  }
  
  static void solve (int test) {
	  
	  List<Integer> list1 = new ArrayList<Integer>();
	  List<Integer> list2 = new ArrayList<Integer>();
	  List<Integer> list3 = new ArrayList<Integer>();
	  List<Integer> result = new ArrayList<Integer>();
	  int s = 1000000;
	  for (int i = 0; i<4; i++) list1.add(sc.nextInt()); 
	  for (int i = 0; i<4; i++) list2.add(sc.nextInt());
	  for (int i = 0; i<4; i++) list3.add(sc.nextInt());
	  
	  if (somme(list1)<s) {
		  System.out.println(""Case #""+test+"": IMPOSSIBLE"");
		  return;
	  }
	  if (somme(list2)<s) {
		  System.out.println(""Case #""+test+"": IMPOSSIBLE"");
		  return;
	  }
	  if (somme(list3)<s) {
		  System.out.println(""Case #""+test+"": IMPOSSIBLE"");
		  return;
	  }
	  int minC = minimum(list1.get(0), list2.get(0), list3.get(0));
	  int minM = minimum(list1.get(1), list2.get(1), list3.get(1));
	  int minY = minimum(list1.get(2), list2.get(2), list3.get(2));
	  int minK = minimum(list1.get(3), list2.get(3), list3.get(3));
	  
	  if(minC+minM+minY+minK < s) {
		  System.out.println(""Case #""+test+"": IMPOSSIBLE"");
		  return;
	  }
	  
	  
	  if(minC==s) {
		  System.out.println(""Case #""+test+"": ""+minC+"" 0 0 0"");
		  return;
	  }
	  
	  result.add(minC);
	  
	  if(minC+minM>=s) {
		  System.out.println(""Case #""+test+"": ""+minC+"" ""+(s-minC)+"" 0 0"");
		  return;
	  }else {
		  result.add(minM);
	  }
	  
	  if (minC+minM+minY>=s) {
		  System.out.println(""Case #""+test+"": ""+minC+"" ""+minM+"" ""+(s-(minC+minM))+"" 0"");
		  return;
	  } else {
		  result.add(minY);
	  }
	  
	  if (s-(minC+minM+minY) <= minK){
		  System.out.println(""Case #""+test+"": ""+minC+"" ""+minM+"" ""+minY+"" ""+
		                                        (s-(minC+minM+minY)));
	  }else {
		  System.out.println(""Case #""+test+"": IMPOSSIBLE"");
	  }


  }
  

  public static int  minimum (int a, int b, int c) {	 
		return Math.min(Math.min(a, b), c);
	}
  public static int somme(List<Integer> list) {
	  int res = 0;
	  for (int i = ",Bil1983
492,"public class Solution {
    static int[] dx = {0, 1, 0, -1};
    static int[] dy = {1, 0, -1, 0};
    static int mod = (1 << 31) - 1;
    static List<Integer>[] graph;

    static char[][] grid;

    static int MAX = 1000001;

    public static void main(String[] args){
        InputStream is;
        try {
            is = new FileInputStream("".\\\src\\\input\\\in.txt"");
        } catch (FileNotFoundException e) {
            is = System.in;
        }
        InputReader in = new InputReader(is);
//        PrintWriter out = new PrintWriter(System.out);
        PrintStream out = System.out;

        int t = in.nextInt();
        for (int tt=1;tt<=t;tt++){
            int n = in.nextInt();
            int k = in.nextInt();

            int fr = in.nextInt();
            int fp = in.nextInt();

            if (n <= k) {
                int total = fp;
                for (int i=1;i<=n;i++) {
                    if (i == fr) continue;
                    out.println(""T ""+ i);
                    out.flush();
                    int r = in.nextInt();
                    int p = in.nextInt();
                    total += p;
                }
                out.println(""E ""+ total/2);
            }
            else{
                int l = fr - 1;
                int r = fr + 1;
                long total = fp;

                int room = -1;
                int pass = -1;
                for (int i=0;i<k/2;i++) {
                    int x = -1;
                    if (i % 2 == 0) {
                        if (l >= 1) {
                            x = l;
                            l--;
                        }
                        else if (r <= n){
                            x = r;
                            r ++;
                        }
                    }
                    else {
                        if (r <= n){
                            x = r;
                            r ++;
                        }
                        else if (l >= 1) {
                            x = l;
                            l--;
                        }
                    }
                    if (x == -1) break;

                    out.println(""T "" + x);
                    out.flush();
                    room = in.nextInt();
                    pass = in.nextInt();
                    total += pass;

                    out.println(""W"");
                    out.flush();
                    room = in.nextInt();
                    pass = in.nextInt();
                    total += pass;

//                    l = room - 1;
//                    r = room + 1;
                }

                if (k % 2 != 0) {
                    out.println(""W"");
                    out.flush();
                    room = in.nextInt();
                    pass = in.nextInt();
                    total += pass;
                }
                out.println(""E "" + total/2);
            }
        }
        out.close();
    }


    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }
        public long nextLong() {
            return Long.parseLong(next());
        }
        public double nextDouble() {return Double.",ac23
1117,"public class Solution {

  static Scanner in;

  public static void main(String[] args) {
    in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
    int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
    for (int i = 1; i <= t; i++) {
      int n = in.nextInt();
      int k = in.nextInt();
      if (n > k + 1) {
        solveStats(n, k);
      } else {
        solveIterateAll(n, k);
      }
    }
  }

  static void solveIterateAll(int n, int k) {
    long sum = 0;
    int tmp = in.nextInt();
    sum += in.nextInt();
    for (int i = 1; i <= n; i++) {
      if (i == tmp) {
        continue;
      }
      System.out.println(""T "" + i);
      in.nextInt();
      sum += in.nextInt();
    }
    System.out.println(""E "" + sum / 2);
  }

  static void solveStats(int n, int k) {
    var rng = new Random();

    long sum = 0;
    var visited = new HashSet<Integer>();

    visited.add(in.nextInt());
    sum += in.nextInt();

    for (int i = 0; i < k; i++) {
      int t = rng.nextInt(n) + 1;
      int tries = 1000;
      while (visited.contains(t) && tries > 0) {
        t = rng.nextInt(n) + 1;
        tries--;
      }
      System.out.println(""T "" + t);

      visited.add(in.nextInt());
      sum += in.nextInt();
    }

    double avgPassagesInRoom = (double) sum / (k + 1);
    if (avgPassagesInRoom < 1.0) {
      avgPassagesInRoom = 1.0;
    }
    long r = ",rk13
810,"public class Solution {

  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int cases = sc.nextInt();
    for(int a=1; a<=cases; a++){
      while (true){
        //give 1, ... n
        int n = sc.nextInt();
        ArrayList<Integer> myInts = new ArrayList<>();
        for(int i=1; i<=n; i++){
          myInts.add(i);
          if(i!=n){
            System.out.print(i + "" "");
          }
          else{
            System.out.println(i);
          }
        }

        ArrayList<Integer> ret = new ArrayList<Integer>();


        //scan in the next N numbers
        for(int i=0; i<n; i++){
          myInts.add(sc.nextInt());
        }


        Collections.sort(myInts);

        long sum = 0;
        for(int i=0; i<2*n; i++){
          sum += myInts.get(i);
        }
        long target = sum / 2;


        int index = n*2 - 1;
        long current = myInts.get(index);
        ret.add(myInts.get(index));

        //scan the given n integers
        while(index >= n){
          if(current >= target){
            index--;
            continue;
          }
          index--;
          if(current + myInts.get(index) <= target){
            current+= myInts.get(index);
            ret.add(myInts.get(index));
          }

        }


        //pick the remaining integers from 1, 2, ... n
        while(index >=0){
          if(current == target){
            break;
          }
          if(current + myInts.get(index) <= target){
            current += myInts.get(index);
          }
          index--;
        }




        for(int i=0; i<ret.size(); i++){
          if(i != ret.size()-1){
            System.out.print(ret.get(i) + "" "");
          }
          else{
            System.out.println(ret.get(i));
          }
        }

        System.",jedya
489,"public class Solution {
    static int[] dx = {0, 1, 0, -1};
    static int[] dy = {1, 0, -1, 0};
    static int mod = (1 << 31) - 1;
    static List<Integer>[] graph;

    static char[][] grid;

    static int MAX = 1000001;

    public static void main(String[] args){
        InputStream is;
        try {
            is = new FileInputStream("".\\\src\\\input\\\in.txt"");
        } catch (FileNotFoundException e) {
            is = System.in;
        }
        InputReader in = new InputReader(is);
//        PrintWriter out = new PrintWriter(System.out);
        PrintStream out = System.out;

        int t = in.nextInt();
        for (int tt=1;tt<=t;tt++){
            int n = in.nextInt();
            int k = in.nextInt();

            int fr = in.nextInt();
            int fp = in.nextInt();

            if (n <= k) {
                int total = fp;
                for (int i=1;i<=n;i++) {
                    if (i == fr) continue;
                    out.println(""T ""+ i);
                    out.flush();
                    int r = in.nextInt();
                    int p = in.nextInt();
                    total += p;
                }
                out.println(""E ""+ total/2);
            }
            else{
                long total = fp;
                int currentP = fp;
                int currentR = fr;

                HashSet<Integer> visited = new HashSet<>();
                visited.add(currentR);
                for (int i=0;i<k;i++) {
                    if (i % 2 == 0) {
                        out.println(""W"");
                        out.flush();
                        currentR = in.nextInt();
                        currentP = in.nextInt();

                    }
                    else{
                        int x = currentR;
                        while (visited.contains(x)) {
                            x = (int) ((Math.random() * (n - 1)) + 1);
                        }
                        out.println(""T "" + x);
                        out.flush();
                        currentR = in.nextInt();
                        currentP = in.nextInt();
                    }
                    visited.add(currentR);
                    total += currentP;
                }
                out.println(""E "" + (total/2) * (n/k));
            }
        }
        out.close();
    }


    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }
        public long nextLong() {
            return Long.parseLong(next());
        }
        public double nextDouble() {return Double.",ac23
156,"public class Solution {

  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int n = sc.nextInt();
    for (int i = 0; i < n; i++) {
      int N = sc.nextInt();
      int K = sc.nextInt();
      boolean[] visited = new boolean[N];
      long E = 0;
      int visitCt = 0;
      for (int j = 0; j < K; j++) {
        int R = sc.nextInt();
        int P = sc.nextInt();
        if (!visited[R - 1]) {
          E += P;
          visited[R - 1] = true;
          visitCt++;
          System.out.println(""W"");
        } else {
          int T = N - R;
          System.out.println(""T ""+ T);
        }
      }
      int R = sc.nextInt();
      int P = sc.nextInt();
      if (!visited[R - 1]) {
        E += P;
        visited[R - 1] = ",Jai03kh
427,"public class Solution {
    public static void main(String[] args) {
        try {
            Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
            int tests = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
            in.nextLine();
            for (int currentTest = 1; currentTest <= tests; ++currentTest) {
                StringBuilder sb = new StringBuilder();
                char[] arr = in.nextLine().toCharArray();

                sb.append(arr[0]);

                for (int i = 1; i < arr.length; i++) {
                    if (arr[i] > arr[i - 1]) {
                        char c = arr[i - 1];
                        int inx = i - 1;
                        while (inx >= 0 && arr[inx] == c) {
                            sb.append(c);
                            inx--;
                        }
                    }

                    sb.append(arr[i]);

                }


                System.out.println(""Case #"" + currentTest + "": "" + sb.toString());
               // System.out.println(""Case #"" + currentTest + "": "" + sb.toString().compareTo(new String(arr)));
            }
        } catch (Exception e) {
            System.",Vlad
1263,"public class Solution {
    {
        MULTI_TEST = false;
        FILE_NAME = """";
        NEED_FILE_IO = false;
        INF = (long) 1e18;
    } // fields


    void solve_know(int[] a, int currValue) {
    }
    String solve_test() {
        int n = ri(), p = ri();
        int[][] a = new int[n][p];
        long ans = 0;
        for(int i = 0; i < n; i++) {
            a[i] = ria(p);
            sort(a[i]);
        }

        int[][] dp = new int[2][n]; 

        dp[0][0] = a[0][p - 1] + (a[0][p - 1] - a[0][0]);
        dp[1][0] = a[0][p - 1];

        for(int i = 1; i < n; i++) {
            dp[0][i] = Math.min(dp[0][i - 1] + Math.abs(a[i][p - 1] - a[i - 1][0]) + a[i][p - 1] - a[i][0],
                    
                    dp[1][i - 1] + Math.abs(a[i - 1][p - 1] - a[i][p - 1]) + a[i][p - 1] - a[i][0]);
            
            dp[1][i] = Math.min(dp[0][i - 1] + Math.abs(a[i - 1][0] - a[i][0]) + a[i][p - 1] - a[i][0],
            
                    dp[1][i - 1] + Math.abs(a[i - 1][p - 1]) - a[i][0]) + a[i][p - 1] - a[i][0];
            
        }
        return """" + Math.min(dp[0][n - 1], dp[1][n - 1]);
    }


    void solve() {
        int t = ri();
        for(int it = 1; it <= t; it++) {
            out.printf(""Case #%d: %s
"", it, solve_test());
        }
    }

    public static void main(String[] args) {
        new Solution().run();
    } //main

    @SuppressWarnings(""unused"")
    long gcd(long a, long b) {
        return b == 0 ? a : gcd(b, a % b);
    }

    @SuppressWarnings(""unused"")
    long lcm(long a, long b) {
        return a / gcd(a, b) * b;
    }

    @SuppressWarnings(""unused"")
    int gcd(int a, int b) {
        return (int) gcd((long) a, b);
    }

    @SuppressWarnings(""unused"")
    int lcm(int a, int b) {
        return (int) lcm(a, (long) b);
    }

    @SuppressWarnings(""unused"")
    int sqrtInt(int x) {
        return (int) sqrtLong(x);
    }

    @SuppressWarnings(""unused"")
    long sqrtLong(long x) {
        long root = (long) Math.sqrt(x);
        while (root * root > x) --root;
        while ((root + 1) * (root + 1) <= x) ++root;
        return root;
    }

    @SuppressWarnings(""unused"")
    int cbrtLong(long x) {
        int cbrt = (int) Math.cbrt(x);
        while ((long) cbrt * cbrt >= x) {
            cbrt--;
        }
        while ((long) (cbrt + 1) * (cbrt + 1) <= x) cbrt++;
        return cbrt;
    }

    @SuppressWarnings(""unused"")
    long binpow(long a, long power) {
        return binpow(a, power, Long.MAX_VALUE);
    }

    @SuppressWarnings(""unused"")
    long binpow(long a, long power, long modulo) {
        if (power == 0) return 1 % modulo;
        if (power % 2 == 1) {
            long b = binpow(a, power - 1, modulo) % modulo;
            return ((a % modulo) * b) % modulo;
        } else {
            long b = binpow(a, power / 2, modulo) % modulo;
            return (b * b) % modulo;
        }
    }

    @SuppressWarnings(""unused"")
    long fastMod(String s1, long n2) {
        long num = 0;
        for (int i = 0; i < s1.length() - 1; i++) {
            num += Integer.parseInt(String.valueOf(s1.charAt(i)));
            num *= 10;
            if (num >= n2) {
                num = num % n2;
            }
        }
        return (num + Integer.parseInt(String.valueOf(s1.charAt(s1.length() - 1)))) % n2;
    }

    @SuppressWarnings(""unused"")
    long factorialMod(long n, long p) {
        long res = 1;
        while (n > 1) {
            res = (res * ((n / p) % 2 == 1 ? p - 1 : 1)) % p;
            for (int i = 2; i <= n % p; ++i)
                res = (res * i) % p;
            n /= p;
        }
        return res % p;
    }

    @SuppressWarnings(""unused"")
    boolean isPrime(int number) {
        for (int i = 2; i * i <= number; i++) {
            if (number % i == 0) {
                return false;
            }
        }
        return number > 1;
    }

    @SuppressWarnings(""unused"")
    boolean[] primes(int border) {
        boolean[] isPrimes = new boolean[border + 1];
        Arrays.fill(isPrimes, true);
        isPrimes[0] = false;
        isPrimes[1] = false;
        for (int i = 2; i < border + 1; i++) {
            if (!isPrimes[i]) continue;
            for (int k = i * 2; k < border; k += i) {
                isPrimes[k] = false;
            }
        }
        return isPrimes;
    } //Number theory

    @SuppressWarnings(""unused"")
    void sort(int[] a) {
        int n = a.length;
        Integer[] arr = new Integer[n];
        for (int i = 0; i < n; i++) {
            arr[i] = a[i];
        }
        Arrays.sort(arr);
        for (int i = 0; i < n; i++) {
            a[i] = arr[i];
        }
    }

    @SuppressWarnings(""unused"")
    void sort(long[] a) {
        int n = a.length;
        Long[] arr = new Long[n];
        for (int i = 0; i < n; i++) {
            arr[i] = a[i];
        }
        Arrays.sort(arr);
        for (int i = 0; i < n; i++) {
            a[i] = arr[i];
        }
    }

    @SuppressWarnings(""unused"")
    int max(int[] a) {
        int n = a.length;
        int max = Integer.MIN_VALUE;
        for (int j : a) {
            if (j > max) max = j;
        }
        return max;
    }

    @SuppressWarnings(""unused"")
    long max(long[] a) {
        int n = a.length;
        long max = Long.MIN_VALUE;
        for (long l : a) {
            if (l > max) max = l;
        }
        return max;
    }

    @SuppressWarnings(""unused"")
    int maxIndex(int[] a) {
        int n = a.length;
        int max = Integer.MIN_VALUE;
        int index = 0;
        for (int i = 0; i < n; i++) {
            if (a[i] > max) {
                max = a[i];
                index = i;
            }
        }
        return index;
    }

    @SuppressWarnings(""unused"")
    int maxIndex(long[] a) {
        int n = a.length;
        long max = Long.MIN_VALUE;
        int index = 0;
        for (int i = 0; i < n; i++) {
            if (a[i] > max) {
                max = a[",v0s7er
1003,"public class Solution
{
    public void calculate()
    {
        Scanner sc = new Scanner (System.in);
        int count = 1;
        System.out.println(""11111111"");
        for(int i=0; i<300; i++)
        {
            int number = sc.nextInt();
            if(number == 0)
                return;
            else if(number == 8)
            {
                System.out.println(""11111111"");
                continue;
            }
            else if(number == -1)
                System.exit(0);
            String s = """";
            for(int j=0; j<number; j++)
                s += ""1"";
            for(int j=number; j<8; j++)
                s += ""0"";
            System.out.println(s);
        }
    }
    public static void main(String args[])
    {
        Solution obj = new Solution();
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        for(int i=",nocturnalspider
1058,"public class Solution{
	
	static Scanner sc = new Scanner(System.in);

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int testCases = sc.nextInt();
		
		for (int i = 1; i <= testCases; ++i) {
			solve(i);
		}
	}
	
	private static void solve(int t) {
		int n = sc.nextInt();
		
		int k = sc.nextInt();
		
		int [][] arr = new int [n][n];
		
		int [][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1 , 0}};
        boolean [][] visited = new boolean[n][n];
        int curIdx = 0;
        
        int count = 1;
        
        int r = 0;
        int c = 0;
        int nr, nc;
        
		for (int a = 0; a < n*n; ++a){
            arr[r][c] = count++;
            visited[r][c] = true;

            --curIdx;
            for (int i = 0; i < 4; ++i){
                ++curIdx;
                curIdx %= 4;

                nr = r + dirs[curIdx][0];
                nc = c + dirs[curIdx][1];

                if (nr < n && nc < n && nr >= 0 && nc >= 0 && !visited[nr][nc]){
                    r = nr;
                    c = nc;
                    break;
                }
            }
        }
		
		
		int skips = n*n - 1;
		skips -= k;
		
		//System.out.println(skips);
		
		if (skips % 2 == 1) {
			print(t , ""IMPOSSIBLE"");
			return;
		}
		
		r = 0;
		c = 0;
		int current;
		
		List<int []> list = new ArrayList<>();
		boolean sb;
		
		while (skips > 0) {
			
			current = arr[r][c];
			//System.out.println(current + "" "" + skips);
			sb = false;
			
			for (int [] dir : dirs) {
				 nr = r + dir[0];
				 nc = c + dir[1];

                if (nr >= n || nc >= n || nr < 0 || nc < 0 ){
                    continue;
                }else if (arr[r][c] < current)
                	continue;
                
                //System.out.println(current + "" "" + arr[nr][nc]);
                if (arr[nr][nc] > current + 1 && arr[nr][nc] - current - 1 <= skips) {
                	list.add(new int [] {current, arr[nr][nc]});
                	skips -= arr[nr][nc] - current - 1;
                	sb = true;
                	r = nr;
                	c = nc;
                	break;
                }
			}
			
			if (sb) continue;
			
			for (int [] dir : dirs) {
				 nr = r + dir[0];
				 nc = c + dir[1];

               if (nr >= n || nc >= n || nr < 0 || nc < 0 ){
                   continue;
               }else if (arr[r][c] < current)
               	continue;
               
               if (arr[nr][nc] == current + 1) {
	               r = nr;
	               c = nc;
	               break;
               }
			}
		}
		
		StringBuilder str = new StringBuilder();
		
		str.append(""Case #"" + t + "": "" + list.size());
		str.append(""
"");
		
		for (int [] a : list) {
			str.append(a[0] + "" "" + a[1]);
			str.append(""
"");
		}
		
		//System.out.println(skips);
		System.out.println(str);
	}
	",profchi
362,"public class Solution {
    public static void main(String[] args) {

        Scanner in = new Scanner(System.in);
        int t = in.nextInt();
        for (int i = 1; i <= t; i++) {
            int n=in.nextInt();
            long[] arr=new long[n];
            for(int j=0;j<n;j++)
            {
                arr[j]=in.nextLong();
            }

            System.out.println(""Case #"" + i + "": ""+solve(arr));
        }

    }
    static long solve(long arr[])
    {
        long res=0;
           int i=0,j=arr.length-1;
           long last=Math.min(arr[i],arr[j]);
           if(last==arr[i])
           {
               res++;
               i++;

           }
           else if(last==arr[j])
           {
               res++;
               j--;
           }

           while(i<=j&&(last<=arr[i]||last<=arr[j]))
           {
               if(last<=arr[i]&&last<=arr[j])
               {
                last=Math.min(arr[i],arr[j]);
                if(arr[i]==arr[j])
                {
                    if(i+1<=j-1)
                    {
                        if(arr[i+1]<=arr[j-1])
                        {
                            i++;
                        }
                        else{
                            j--;
                        }

                    }
                    else{
                    i++;
                    }
                    res++;

                }
                else{
                if(last==arr[i])
                {
                    res++;
                    i++;
     
                }
                else if(last==arr[j])
                {
                    res++;
                    j--;
                }
            }

               }
               else{
            if(last<=arr[i])
            {
                last=arr[i];
                res++;
                i++;
 
            }
            else if(last<=arr[j])
            {
                last=arr[j];
                res++;
                j--;
            }
        }

           }



        return res;
    }

}",SampathRajaRaghupathi
716,"public class Solution {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        final int numCases = Integer.parseInt(input.nextLine());
        for (int i = 1; i <= numCases; i++) {
            System.out.print(String.format(""Case #%d: "", i));
            
            final int[][] printer = new int[3][4];
            
            int maxCyan = 1000000;
            int maxMagenta = 1000000;
            int maxYellow = 1000000;
            int maxBlack = 1000000;
            
            for (int j = 0; j < 3; j++) {
                final String line = input.nextLine();
                final String[] parts = line.split(""\\\s"");
            
                printer[j][0] = Integer.parseInt(parts[0]);
                printer[j][1] = Integer.parseInt(parts[1]);
                printer[j][2] = Integer.parseInt(parts[2]);
                printer[j][3] = Integer.parseInt(parts[3]);
                
                if (printer[j][0] < maxCyan) {
                    maxCyan = printer[j][0];
                }
                
                if (printer[j][1] < maxMagenta) {
                    maxMagenta = printer[j][1];
                }
                
                if (printer[j][2] < maxYellow) {
                    maxYellow = printer[j][2];
                }
                
                if (printer[j][3] < maxBlack) {
                    maxBlack = printer[j][3];
                }
            }
            
            String r;
            
            int c = maxCyan;
            int m = maxMagenta;
            int y = maxYellow;
            int k = maxBlack;
            
            if ((maxCyan + maxMagenta + maxYellow + maxBlack) < 1000000) {
                r = ""IMPOSSIBLE"";
            } else {
                int excess = (c + m + y + b) - 1000000;
                
                while (excess > 0) {
    
                    // remove excess from cyan
                    if (c < (excess / 4)) {
                        excess -= c;
                        c = 0;
                    } else {
                        c -= (excess / 4);
                        excess -= (excess / 4);
                    }
                    
                    // remove excess from magenta
                    if (m < (excess / 3)) {
                        excess -= m;
                        m = 0;
                    } else {
                        m -= (excess / 3);
                        excess -= (excess / 3);
                    }
                    
                    // remove excess from yellow
                    if (y < (excess / 2)) {
                        excess -= y;
                        y = 0;
                    } else {
                        y -= (excess / 2);
                        excess -= (excess / 2);
                    }
                    
                    // remove excess from black
                    if (k < excess) {
                        System.out.println(""IMPOSSIBLE"");
                        return;
                    } else {
                        k -= excess;
                    }
                    
                    excess = maxCyan + maxMagenta + maxYellow + maxBlack;
                }
                
                r = String.format(""%d %d %d %d"", c, m, y, k);
            }
            System.out.println(r);
        }
    }
}",gawallace25
127,"class Solution{
    static void punchedCard(int r, int c){
        StringBuilder sb = new StringBuilder();
        StringBuilder sb1 = new StringBuilder();
        sb.append(""+"");
        sb1.append(""|"");
        for(int i = 0; i < c; i ++){
            sb.append(""-+"");
            sb1.append("".|"");
        }
        String s1 = sb.toString();
        String s2 = sb1.toString();
        StringBuilder sb2 = new StringBuilder();
        sb2.append("".."").append(s1.substring(2)).append(""
"");
        sb2.append("".."").append(s2.substring(2)).append(""
"");
        for(int i = 1; i < r; i ++){
            sb2.append(s1).append(""
"");
            sb2.append(s2).append(""
"");
        }
        sb2.append(s1).append(""
"");
        System.out.print(sb2.toString());
    }

    public static void main(String[] args){
        /*
        ..+-+-+-+
        ..|.|.|.|
        +-+-+-+-+
        |.|.|.|.|
        +-+-+-+-+
        |.|.|.|.|
        +-+-+-+-+


         */

        try (Scanner sc = new Scanner(System.in)){
            int n = sc.nextInt();
            int idx = 1;
            while (idx <= n){
                int r = sc.nextInt();
                int c = sc.nextInt();
                System.out.println(""Case #"" + idx + "":"");
                punchedCard(r, c);
                idx ++;
            }
        } catch (Exception e) {
            e.printStackTrace();
        }


    }",Em11
976,"public class Solution {

	public static void main(String[] args) {
		Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

		int numberOfCases = in.nextInt();

		for (int i = 1; i <= numberOfCases; ++i) {
			int N = 10;
			while (N > 0) {
				if (N == 11) {
					System.out.println(""01010101"");
					N = in.nextInt();
					System.err.println(N);
				}else 
				if (N == 10) {
					System.out.println(""00000000"");
					N = in.nextInt();
					System.err.println(N);
					N = 11;
				}else 
				if (N == 1) {
					int x = (int) (Math.random() * 8);
					String test = """";
					for (int j = 0; j < 8; j++) {
						if (j == x)
							test += ""1"";
						else
							test += ""0"";
					}
					System.out.println(test);
					N = in.nextInt();
				}else 
				if (N == 2) {
					int x = (int) (Math.random() * 7);
					String test = """";
					for (int j = 0; j < 7; j++) {
						if (j == x)
							test += ""1"";
						else
							test += ""0"";
					}
					System.out.println(test+""1"");
					N = in.nextInt();
				}else 
				if (N == 3) {
					int x = (int) (Math.random() * 6);
					String test = """";
					for (int j = 0; j < 6; j++) {
						if (j == x)
							test += ""1"";
						else
							test += ""0"";
					}
					System.out.println(""1""+test+""1"");
					N = in.nextInt();
				}else 
				if (N == 4) {
					int x = (int) (Math.random() * 5);
					String test = """";
					for (int j = 0; j < 5; j++) {
						if (j == x)
							test += ""1"";
						else
							test += ""0"";
					}
					System.out.println(""11""+test+""1"");
					N = in.nextInt();
				}else 
				if (N == 8) {
					System.out.println(""11111111"");
					N = in.nextInt();
				} else {
				    String test = """";
				    for(int j=0; j<8; j++){
				        test += Math.random() > 0.25 ? ""1"" : ""0"";
				    }
				    System.out.println(test);
				    N = in.nextInt();
				}
			}
			if (N == -1)
				break;

		}
	}
}",nicolasD
1064,"public class Solution {
	
	static Scanner sc = new Scanner(System.in);
	
	static List<List<Integer>> list;
	static Stack<int []> stack;
	static boolean [] visited;
	static boolean [] visited2;
	static long [][] arrPos;
	static long [][] arrSweet;

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int testCases = sc.nextInt();
		
		for (int i = 1; i <= testCases; ++i) {
			solve(i);
		}
	}
	
	private static void solve(int t) {
		int n = sc.nextInt();
		
		arrPos = new long [n + 1][2];
		arrSweet = new long [n + 2][2];
		
		int a, b;
		
		for (int i = 1; i <= n; ++i) {
			arrPos[i][0] = sc.nextLong();
			arrPos[i][1] = sc.nextLong();
		}
		
		for (int i = 1; i <= n+1; ++i) {
			arrSweet[i][0] = sc.nextLong();
			arrSweet[i][1] = sc.nextLong();
		}
		
		list = new ArrayList<>();
		stack = new Stack<>();
		
		visited = new boolean [n + 1];
		visited2 = new boolean [n + 2];
		
		if (generatePermutations(n)) {
			print(t, ""POSSIBLE"");
			for (int [] rArr : stack) {
				System.out.println(rArr[0] + "" "" + rArr[1]);
			}
			return;
		}
		
		
		print(t, ""IMPOSSIBLE"");
		return;
	}
	
	private static boolean generatePermutations(int n) {
		if (stack.size() == n) {
			//list.add(new ArrayList<>(stack));
			return true;
		}
		
		long dist;
		long min = Long.MAX_VALUE;
		long x,y;
		int pos;
		
		for (int a = 1; a <= n; ++a) {
			if (visited[a]) continue;
			
			visited[a] = true;
			pos = 0;
			min = Long.MAX_VALUE;
			
			for (int i = 1; i < arrSweet.length; ++i) {
				if (visited2[i]) continue;
				
				x = arrPos[a][0] - arrSweet[i][0];
				y = arrPos[a][1] - arrSweet[i][1];
				
				dist = x*x + y*y;
				
				if (dist <= min) {
					min = dist;
					pos = i;
				}
			}
			
			stack.push(new int [] {a , pos});
			visited2[pos] = true;
			
			if(pos > 1 && generatePermutations(n))
				return true;
			
			stack.pop();
			visited[a] = false;
		}
		
		return false;
	}
	
	public static void print(int test, String result) {
		System.",profchi
503,"public class Solution {

    public static String printDrawPunchCards(int noOfTests, int[][] dimensions){
        StringBuilder output = new StringBuilder();

        for (int i = 0; i < dimensions.length; i++) {
            int start = 0;
            String extra = """";
            String pipe = """";
            int count = 0;
            int row = dimensions[i][0];
            int column = dimensions[i][1];

            output.append(""Case #"").append(i+1).append("":
"");

            while(count != row){
                if(start == 0){
                    extra = ""..+"" + ""-+"".repeat(column - 1);
                    pipe = ""..|"" + "".|"".repeat(column - 1);
                }

                if(start != 0) pipe = ""|"" + "".|"".repeat(column);
                String below = ""+"" + ""-+"".repeat(column);

                if(start == 0) output.append(extra).append(""
"");
                output.append(pipe).append(""
"");
                output.append(below).append(""
"");

                count++;
                start++;
            }
        }


        return output.toString().trim();",adamson
1200,"class Solution{

// public static Long organize(Long x,ArrayList<ArrayList<Long>> matrix)
// {
//     return x;
// }
public static void main(String[] args){
    
    System.out.println(2);
     System.",sriniharika
707,"public class Solution {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        final int numCases = Integer.parseInt(input.nextLine());
        for (int i = 1; i <= numCases; i++) {
            System.out.print(String.format(""Case #%d: "", i));
            
            final int[][] printer = new int[3][4];
            
            int maxCyan = 1000000;
            int maxMagenta = 1000000;
            int maxYellow = 1000000;
            int maxBlack = 1000000;
            
            for (int j = 0; j < 3; j++) {
                final String line = input.nextLine();
                final String[] parts = line.split(""\\\s"");
            
                printer[j][0] = Integer.parseInt(parts[0]);
                printer[j][1] = Integer.parseInt(parts[1]);
                printer[j][2] = Integer.parseInt(parts[2]);
                printer[j][3] = Integer.parseInt(parts[3]);
                
                if (printer[j][0] < maxCyan) {
                    maxCyan = printer[j][0];
                }
                
                if (printer[j][1] < maxMagenta) {
                    maxMagenta = printer[j][1];
                }
                
                if (printer[j][2] < maxYellow) {
                    maxYellow = printer[j][2];
                }
                
                if (printer[j][3] < maxBlack) {
                    maxBlack = printer[j][3];
                }
            }
            
            String r;
            
            if ((maxCyan + maxMagenta + maxYellow + maxBlack) < 1000000) {
                r = ""IMPOSSIBLE"";
            } else {
                int excess = (maxCyan + maxMagenta + maxYellow + maxBlack) - 1000000;
                int c = maxCyan;
                int m = maxMagenta;
                int y = maxYellow;
                int k = maxBlack;
                
                // remove excess from cyan
                if (c < (excess / 4)) {
                    excess -= c;
                    c = 0;
                } else {
                    c -= (excess / 4);
                    excess -= (excess / 4);
                }
                
                // remove excess from magenta
                if (m < (excess / 3)) {
                    excess -= m;
                    m = 0;
                } else {
                    m -= (excess / 3);
                    excess -= (excess / 3);
                }
                
                // remove excess from yellow
                if (y < (excess / 2)) {
                    excess -= y;
                    y = 0;
                } else {
                    y -= (excess / 2);
                    excess -= (excess / 2);
                }
                
                // remove excess from black
                if (k < excess) {
                    k = 0;
                } else {
                    k -= excess;
                }
                
                r = String.format(""%d %d %d %d"", c, m, y, k);
            }
            System.out.println(r);
        }
    }
}",gawallace25
289,"public class Solution {

  public static void main(String[] args) {
  /*  String aaa = ""4
"" +
        ""4
"" +
        ""6 10 12 8
"" +
        ""6
"" +
        ""5 4 5 4 4 4
"" +
        ""10
"" +
        ""10 10 7 6 7 4 4 5 7 4
"" +
        ""1
"" +
        ""10"";
    final Stream<String> lines = Arrays.stream(aaa.split(""
""));*/
    
    final BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
    final Stream<String> lines = reader.lines();

    int T = 0;
    int cs = 1;
    int start = 1;
    int end = 2;
/*

    final String UPPER = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ"";
    final String LOWER = ""abcdefghijklmnopqrstuvwxyz"";
    final char [] upper = UPPER.toCharArray();
    final char [] lower = LOWER.toCharArray();
    String line="""";
    List<Long> l = Arrays.stream(line.split("" "")).map(Long::valueOf).collect(Collectors.toList());

*/

    final Iterator<String> iterator = lines.iterator();
    int i = 0;
    String[] temp;
    int d=0;
    int [] s = null;

    while (iterator.hasNext()) {
      final String line = iterator.next();
      if (i == 0) {
        T = Integer.valueOf(line);
      } else {
        if (i == start) {
          d = Integer.valueOf(line);
          s = new int[d];
          end = start + 1;
          start += 2;
        }
        if (i == end) {
          temp = line.split("" "");
          for (int j = 0; j < d; j++) {
            s[j] = Integer.valueOf(temp[j]);
          }

          if (cs <= T) {
            Test t = new Test(d,s);
            System.out.println(""Case #"" + cs + "": "" + t.print());
            cs++;
            if (cs > T) {
              break;
            }
          }
        }
      }
      i++;
    }

  }

  public static class Test {
    int N;
    int []S;

    public Test(int d, int[] s) {
      N=d;
      S=s;
    }

    public int print() {
       Arrays.sort(S);
       int k = 0;
       int m = 0;
      for (int i = 0; i < N; i++) {
        k+=1;
        if(k>S[i]){
          k-=1;
          m = k;
        }
      }
       return k;

    }
  }

}",Obchelli
393,"class Solution{
    public static LinkedList<Integer> adj[];
    public static void Com(int end,int[] initiator,List<List<Integer>> liC,List<Integer> temp,boolean[] tracker){
        if(temp.size()==end){
            liC.add(new ArrayList(temp));
            return;
        }
        for(int i=0 ;i<end;i++){
            if(!tracker[i]){
                temp.add(initiator[i]);
                tracker[i]=true;
                Com(end,initiator,liC,temp,tracker);
                temp.remove(temp.size()-1);
                tracker[i]=false;
            }
        }
        
    }
    
    public static int DFS(int s,int[] fun,boolean[] tracker){
        if(tracker[s]){
            return 0;
        }
        int max=fun[s-1];
        tracker[s]=true;
        Iterator<Integer> i = adj[s].listIterator();
        while(i.hasNext()){
            int n= i.next();
            if(!tracker[n]){
                int score = DFS(n,fun,tracker);
                max=Math.max(score,max);
                
            }
        }
        
        return max;
    }
    
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        int index=T;
        while(T-- > 0){
            int N = sc.nextInt();
            int[] fun = new int[N];
            int[] edge = new int[N];
            for(int i=0;i<N;i++){
                fun[i]=sc.nextInt();
            }
            for(int i=0;i<N;i++){
                edge[i]=sc.nextInt();
            }
            int[] degree = new int[N+1];
            for(int i=0;i<N;i++){
                degree[edge[i]]+=1;
            }
            adj=new LinkedList[N+1];
            for(int i=0;i<N+1;i++){
                adj[i]=new LinkedList();
            }
            for(int i=0;i<N;i++){
                adj[i+1].add(edge[i]);
            }
            
            
            int[] initiator = new int[N];
            int k=0;
            for(int i=1;i<N+1;i++){
                if(degree[i]==0){
                    initiator[k++]=i;
                }
            }
            List<List<Integer>> liC = new ArrayList<>();
            List<Integer> temp = new ArrayList<>();
            boolean[] t = new boolean[k];
            Com(k,initiator,liC,temp,t);
            int maxans=0;
            for(List<Integer> i: liC){
                int ans=0;
                boolean[] tracker = new boolean[N+1];
                tracker[0]=true;
                for(Integer v: i){
                    ans+=DFS(v,fun,tracker);
                }
                maxans=Math.max(maxans,ans);
            }
            
                System.",Sujit_Das
352,"public class Solution {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        PrintWriter pw = new PrintWriter(System.out);

        int testCases = sc.nextInt();
        for (int testCase = 1; testCase <= testCases; testCase++) {
            int[] colors = new int[4];
            Arrays.fill(colors, Integer.MAX_VALUE);

            for (int i = 0; i < 3; i++) {
                for (int j = 0; j < colors.length; j++) {
                    colors[j] = Math.min(colors[j], sc.nextInt());
                }
            }

            int remain = Arrays.stream(colors).sum() - 1_000_000;
            for (int i = 0; i < colors.length && remain > 0; i++) {
                if (remain > colors[i]) {
                    remain -= colors[i];
                    colors[i] = 0;
                } else {
                    colors[i] -= remain;
                    remain = 0;
                }
            }

            if (Arrays.stream(colors).sum() < 1_000_000)
                pw.println(""Case #"" + testCase + "": IMPOSSIBLE"");
            else
                pw.println(""Case #"" + testCase + "": "" + colors[0] + "" "" + colors[1] + "" "" + colors[2] + "" "" + colors[3]);
        }

        pw.close();
        sc.",S
817,"public class Solution {

  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int cases = sc.nextInt();
    for(int a=1; a<=cases; a++){
      while (true){
        //give 1, ... n
        int n = sc.nextInt();
        ArrayList<Integer> myInts = new ArrayList<>();
        for(int i=1; i<=n; i++){
          myInts.add(i);
          if(i!=n){
            System.out.print(i + "" "");
          }
          else{
            System.out.println(i);
          }
        }
        System.out.flush();

        ArrayList<Integer> ret = new ArrayList<Integer>();


        //scan in the next N numbers
        for(int i=0; i<n; i++){
          myInts.add(sc.nextInt());
        }


        Collections.sort(myInts);

        long sum = 0;
        for(int i=0; i<2*n; i++){
          sum += myInts.get(i);
        }
        long target = sum / 2;


        int index = n*2 - 1;
        long current = myInts.get(index);
        ret.add(myInts.get(index));
        index--;

        //scan the given n integers
        while(index >= n){
          if(current >= target){
            continue;
          }
          if(current + myInts.get(index) <= target){
            current+= myInts.get(index);
            ret.add(myInts.get(index));
          }
          index--;

        }


        //pick the remaining integers from 1, 2, ... n
        while(index >=0){
          if(current == target){
            break;
          }
          if(current + myInts.get(index) <= target){
            current += myInts.get(index);
            ret.add(myInts.get(index));
          }
          index--;

        }


        if(target != current){
          System.out.println(""IMPOSSIBLE"");
          System.out.flush();
          continue;
        }


        for(int i=0; i<ret.size(); i++){
          if(i != ret.size()-1){
            System.out.print(ret.get(i) + "" "");
          }
          else{
            System.out.println(ret.get(i));
          }
        }

        System.",jedya
841,"class Solution{
    public static void main(String[] args){
        Scanner s = new Scanner(System.in);
        int t = s.nextInt();
        int x = t;
        while(t>0){
            System.out.print(""Case #""+(x-(t-1))+"":"");
            int a1 = s.nextInt();
            int a2 = s.nextInt();
            int a3 = s.nextInt();
            int a4 = s.nextInt();
            int b1 = s.nextInt();
            int b2 = s.nextInt();
            int b3 = s.nextInt();
            int b4 = s.nextInt();
            int c1 = s.nextInt();
            int c2 = s.nextInt();
            int c3 = s.nextInt();
            int c4 = s.nextInt();
            int min1 = Math.min(a1, Math.min(b1, c1));
            int min2 = Math.min(a2, Math.min(b3, c2));
            int min3 = Math.min(a3, Math.min(b3, c3));
            int min4 = Math.min(a4, Math.min(b4, c4));
            if(min1+min2+min3+min4 <1000000){
                System.out.print("" IMPOSSIBLE"");
                System.out.println();
            }
            else{
                int twoSum = min1+min2;
                int rem = 1000000 - twoSum;
                int c  = 0;
                int d = 0;
                if(min3<rem && min4<rem){
                    c = rem-min3;
                    d = rem-min4;
                }
                else if(min3>rem){
                    c= min3-rem;
                }
                else if(min4>rem){
                    d = min4-rem;
                }
                System.out.print(min1+"" "");
                System.out.print(min2+"" "");
                System.out.print(c+"" "");
                System.out.print(d+"" "");
                System.",kaushik_0705
719,"public class Solution {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        final int numCases = Integer.parseInt(input.nextLine());
        for (int i = 1; i <= numCases; i++) {
            System.out.print(String.format(""Case #%d: "", i));
            
            final int[][] printer = new int[3][4];
            
            int maxCyan = 1000000;
            int maxMagenta = 1000000;
            int maxYellow = 1000000;
            int maxBlack = 1000000;
            
            for (int j = 0; j < 3; j++) {
                final String line = input.nextLine();
                final String[] parts = line.split(""\\\s"");
            
                printer[j][0] = Integer.parseInt(parts[0]);
                printer[j][1] = Integer.parseInt(parts[1]);
                printer[j][2] = Integer.parseInt(parts[2]);
                printer[j][3] = Integer.parseInt(parts[3]);
                
                if (printer[j][0] < maxCyan) {
                    maxCyan = printer[j][0];
                }
                
                if (printer[j][1] < maxMagenta) {
                    maxMagenta = printer[j][1];
                }
                
                if (printer[j][2] < maxYellow) {
                    maxYellow = printer[j][2];
                }
                
                if (printer[j][3] < maxBlack) {
                    maxBlack = printer[j][3];
                }
            }
            
            String r;
            
            if ((maxCyan + maxMagenta + maxYellow + maxBlack) < 1000000) {
                r = ""IMPOSSIBLE"";
            } else {
                int excess = (maxCyan + maxMagenta + maxYellow + maxBlack) - 1000000;
                
                
                while (excess > 0) {
                    int c = maxCyan;
                    int m = maxMagenta;
                    int y = maxYellow;
                    int k = maxBlack;
    
                    // remove excess from cyan
                    if (c < (excess / 4)) {
                        excess -= c;
                        c = 0;
                    } else {
                        c -= (excess / 4);
                        excess -= (excess / 4);
                    }
                    
                    // remove excess from magenta
                    if (m < (excess / 3)) {
                        excess -= m;
                        m = 0;
                    } else {
                        m -= (excess / 3);
                        excess -= (excess / 3);
                    }
                    
                    // remove excess from yellow
                    if (y < (excess / 2)) {
                        excess -= y;
                        y = 0;
                    } else {
                        y -= (excess / 2);
                        excess -= (excess / 2);
                    }
                    
                    // remove excess from black
                    if (k < excess) {
                        System.out.println(""IMPOSSIBLE"");
                        return;
                    } else {
                        k -= excess;
                    }
                    
                    excess = maxCyan + maxMagenta + maxYellow + maxBlack;
                }
                
                r = String.format(""%d %d %d %d"", c, m, y, k);
            }
            System.out.println(r);
        }
    }
}",gawallace25
92,"    class Solution {
    	
    	public static void main(String[] args) throws IOException {
    		Scanner in = new Scanner(System.in);
    		int t = in.nextInt();
    		for(int tc = 1; tc <= t; tc ++) {
    			int r = Integer.parseInt(in.next());
    			int c = Integer.parseInt(in.next());
    			System.out.println(""Case #"" + tc + "":"");
    			for(int i = 0; i < 2 * r + 1; i ++) {
    				for(int j = 0; j < 2 * c + 1; j ++) {
    					if(i <= 1 && j <= 1) {
    						System.out.print(""."");
    						continue;
    					}
    					if(i % 2 == 0) 
    						System.out.print(j % 2 == 0 ? ""+"" : ""-"");
    					else
    						System.out.print(j % 2 == 0 ? ""|"" : ""."");
    				}
    				System.",Deido
808,"class PrinterColorInfo {

    public int[] colors;

    public PrinterColorInfo(int C, int M, int Y, int K) {
        colors = new int[]{C, M, Y, K};
    }

    @Override
    public String toString() {
        return ""PrinterColorInfo{"" +
                ""colors="" + Arrays.toString(colors) +
                '}';
    }
}

public class Solution {

    public static final int INK_UNITS = 1000000;

    public int index;

    public PrinterColorInfo[] printersInfo;

    public Solution(int index) {

        this.index = index;
        printersInfo = new PrinterColorInfo[3];
    }

    public void solve() {

        System.out.printf(""Case #%d:"", index + 1);

        int[] min = {Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE};

        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 4; j++) {
                min[j] = Math.min(min[j], printersInfo[i].colors[j]);
            }
        }

        boolean hasSolution = false;
        int sum = 0;

        int[] solution = new int[]{0, 0, 0, 0};

        for (int i = 0; i < 4; i++) {

            sum += min[i];
            solution[i] = min[i];

            if (sum >= INK_UNITS) {

                if (sum > INK_UNITS) {
                    int diff = sum - INK_UNITS;
                    solution[i] -= diff;
                }

                hasSolution = true;
                break;
            }
        }

        if (hasSolution) {
            for (int i = 0; i < 4; i++) {
                System.out.printf("" %d"", solution[i]);
            }
            System.out.println();
        } else {
            System.out.println("" IMPOSSIBLE"");
        }
    }

    public static void main(String[] args) {

        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int T = in.nextInt();

        for (int i = 0; i < T; i++) {

            var solution = new Solution(i);

            for (int j = 0; j < 3; j++) {

                int C = in.nextInt();
                int M = in.nextInt();
                int Y = in.nextInt();
                int K = in.nextInt();

                solution.printersInfo[j] = ",jaimuepe
202,"public class Solution {
    public static void main(String[] args) throws FileNotFoundException {
        try (Scanner reader = new Scanner(System.in)){
            if (reader.hasNextLine() && reader.hasNextInt()) {
                // Read the number of test cases
                int T = Integer.parseInt(reader.nextLine());
                for (int t = 0; t < T; t++) {
                    int N = Integer.parseInt(reader.nextLine());
                    int[] dice = new int[N];
                    for (int n = 0; n < N; n++) {
                        dice[n] = reader.nextInt();
                    }
                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }
                    Arrays.sort(dice);
                    int lineLength = 1;
                    for (int i = 0; i < N;i++) {
                        if (lineLength <= dice[i]) {
                            lineLength++;
                        }
                    }
                    System.",Larsvr
1061,"public class Solution {

	static Scanner sc = new Scanner(System.in);
	static int [] BIT;
	static int [] count;

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int testCases = sc.nextInt();
		
		for (int i = 1; i <= testCases; ++i) {
			solve(i);
		}
	}
	
	private static void solve(int t) {
		int n = sc.nextInt();
		
		int k = sc.nextInt();
		
		count = new int [n + 1];
		BIT = new int [n + 1];
		int currentNode, pas;
		int size = n;
		Random rand = new Random();
		int next;
		
		List<Double> data = new ArrayList<>();
		Set<Integer> set;
		
		double sum;
		int cnt;
		
		for (int i = 0; i < 100; ++i) {
			
			sum = 0;
			cnt = 0;
			set = new HashSet<>();
			
			if (i == 0) {
				next = sc.nextInt();
				pas = sc.nextInt();
				sum += pas;
				++cnt;
				set.add(next);
			}
			
			for (int j = 0; j < 80; ++j) {
				next = 1 + rand.nextInt(n);
				System.out.println(""T "" + next);
				next = sc.nextInt();
				pas = sc.nextInt();
				
				if (set.add(next)) {
					sum += pas;
					++cnt;
				}
			}
			
			data.add(sum / cnt);
		}
		
		double mean = solve(data);
		
		mean /= 2;
		
		print((long)Math.round(mean * n));
		
	}
	
	
	private static double solve(List<Double> samples) {
		double r;
		Collections.sort(samples);
		double max = samples.get(samples.size() - 1);
		
		double mean = 0;
		
		int maxCount = 0;
		int currentCount = 0;
		int rIdx = 0;
		int lIdx = 0;
		
		double count;
		
		double mid;
		
		for (double l = 0.1; l <= max;) {
			r = l * 3 / 2;
			
			while (rIdx < samples.size() && samples.get(rIdx) <= r) {
				++currentCount;
				++rIdx;
			}
			
			while (lIdx < samples.size() && samples.get(lIdx) < l) {
				--currentCount;
				++lIdx;
			}
			
			count = currentCount;
			count /= samples.size();
			mid = (l + r)/2;
			mean += count * mid;
			l = r;
		}
		
		return mean;
	}
	
	public static void print(long result) {
		System.",profchi
813,"public class Solution {

  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int cases = sc.nextInt();
    for(int a=1; a<=cases; a++){
      while (true){
        //give 1, ... n
        int n = sc.nextInt();
        ArrayList<Integer> myInts = new ArrayList<>();
        for(int i=1; i<=n; i++){
          myInts.add(i);
          if(i!=n){
            System.out.print(i + "" "");
          }
          else{
            System.out.println(i);
          }
        }
        System.out.flush();

        ArrayList<Integer> ret = new ArrayList<Integer>();


        //scan in the next N numbers
        for(int i=0; i<n; i++){
          myInts.add(sc.nextInt());
        }


        Collections.sort(myInts);

        long sum = 0;
        for(int i=0; i<2*n; i++){
          sum += myInts.get(i);
        }
        long target = sum / 2;


        int index = n*2 - 1;
        long current = myInts.get(index);
        ret.add(myInts.get(index));
        index--;

        //scan the given n integers
        while(index >= n){
          if(current >= target){
            break;
          }
          if(current + myInts.get(index) <= target){
            current+= myInts.get(index);
            ret.add(myInts.get(index));
          }
          index--;

        }


        //pick the remaining integers from 1, 2, ... n
        while(index >=0){
          if(current == target){
            break;
          }
          if(current + myInts.get(index) <= target){
            current += myInts.get(index);
            ret.add(myInts.get(index));
          }
          index--;

        }


        if(target != current){
          int asdf = 0/0;
          System.out.println(""IMPOSSIBLE"");
          System.out.flush();
          continue;
        }


        for(int i=0; i<ret.size(); i++){
          if(i != ret.size()-1){
            System.out.print(ret.get(i) + "" "");
          }
          else{
            System.out.println(ret.get(i));
          }
        }

        System.",jedya
225,"class Solution {
    public static void main(String[] args)
    {
        Scanner s = new Scanner(System.in);
        int t = s.nextInt();
        for(int i = 1; i <= t; i++)
        {
            System.out.println(11111111);
            System.out.flush();
            int comp = s.nextInt();
            while(comp > 0)
            {
                if(comp > 4)
                {
                    System.out.println(11111111);
                    System.out.flush();
                } else if(comp > 2)
                {
                    System.out.println(11110000);
                    System.out.flush();
                } else if(comp == 2)
                {
                    System.out.println(11000000);
                    System.out.flush();
                } else
                {
                    System.out.println(10000000);
                    System.out.flush();
                }
                comp = ",Maarten17581
108,"class Solution{
    public static Scanner s= new Scanner(System.in);
    public static void main(String[] args){
        int t= s.nextInt();
        for(int i=1;i<=t;i++){
            int n= s.nextInt();
            System.out.println(""Case #""+i+"": ""+ ans(n));
        }
    }
    public static int ans(int n){
        PriorityQueue<Integer> pq= new PriorityQueue<>();
        for(int i =0 ; i< n;i++){
            int x= s.nextInt();
            pq.add(x); 
        }
        int l=0;
        while(pq.isEmpty()){
            int temp = pq.poll();
            if(l<=temp){
                l++;
            }
            else",Dyeahhh
1102,"public class Solution{
    public static void main(String args[]){
        Scanner sc=new Scanner(System.in);
        int t=sc.nextInt();
        for(int i=1;i<=t;i++){
            int n=sc.nextInt();
            int arr[]=new int[n];
            for(int j=0;j<n;j++)
                arr[j]=sc.nextInt();
            Arrays.sort(arr);
            int x=1;
            ArrayList<Integer> list=new ArrayList<>();
            for(int j=0;j<n;j++){
                if(x<=arr[j]){
                    list.add(x);
                    x++;
                }                    
            }
            int ans=",rituV
772,"public class Solution {
    static int mod = (int) 1e9 + 7;
    public static void main(String[] argu) throws Exception {
        Reader br = new Reader();
        PrintWriter pw = new PrintWriter(System.out);
        int nt = br.nextInt();
        for (int t = 1; t <= nt; ++t) {
            int R = br.nextInt(), C = br.nextInt();
            pw.format(""Case #%d:
"", t);
            StringBuilder sb = new StringBuilder(""..+"");
            for (int j = 1; j < C; ++j) sb.append("".+"");
            pw.println(sb.toString());
            for (int i = 0; i < R; ++i) {
                sb.setLength(0);
                sb.append(0 == i ? '.' : '|');
                for (int j = 0; j < C; ++j) sb.append("".|"");
                pw.println(sb.toString());
                sb.setLength(0);
                sb.append('+');
                for (int j = 0; j < C; ++j) sb.append(""-+"");
                pw.println(sb.toString());
            }
        }
        pw.close();
        br.close();
    }
    static class Reader
    {
        final private int BUFFER_SIZE = 1 << 16;
        private DataInputStream din;
        private byte[] buffer;
        private int bufferPointer, bytesRead;

        public Reader()
        {
            din = new DataInputStream(System.in);
            buffer = new byte[BUFFER_SIZE];
            bufferPointer = bytesRead = 0;
        }
        private void fillBuffer() throws IOException
        {
            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);
            if (bytesRead == -1)
                buffer[0] = -1;
        }

        private byte read() throws IOException
        {
            if (bufferPointer == bytesRead)
                fillBuffer();
            return buffer[bufferPointer++];
        }

        public void close() throws IOException
        {
            if (din == null)
                return;
            din.close();
        }
        public int nextInt() throws IOException
        {
            int ret = 0;
            byte c = read();
            while (c <= ' ')
                c = read();
            boolean neg = (c == '-');
            if (neg)
                c = read();
            do
            {
                ret = ret * 10 + c - '0';
            }  while ((c = read()) >= '0' && c <= '9');

            if (neg)
                return -ret;
            return ret;
        }
        public long nextLong() throws IOException
        {
            long ret = 0;
            byte c = read();
            while (c <= ' ')
                c = read();
            boolean neg = (c == '-');
            if (neg)
                c = read();
            do
            {
                ret = ret * 10 + c - '0';
            }  while ((c = read()) >= '0' && c <= '9');

            if (neg)
                return -ret;
            return ret;
        }

        public String readLine() throws IOException {
            byte[] buf = new byte[200001]; // line length
            int cnt = 0, c = read();
            if (-1 != c && '
' != c) buf[cnt++] = (byte) c;
            while ((c = read()) != -1)
            {
                if (c == '
')
                    break;
                buf[cnt++] = (byte) c;
            }
            return new String(buf, 0, cnt);
        }

    }
}",hdchen
231,"class Solution {
    public static void main(String[] args)
    {
        Scanner s = new Scanner(System.in);
        int t = s.nextInt();
        for(int i = 1; i <= t; i++)
        {
            int n = s.nextInt();
            int p = s.nextInt();
            int[][] pressure = new int[n][p];
            for(int j = 0; j < n; j++)
            {
                for(int k = 0; k < p; k++)
                {
                    pressure[j][k] = s.nextInt();
                }
            }
            long[] min = new long[n];
            long[] max = new long[n];
            long out = 0;
            for(int j = 0; j < n; j++)
            {
                long tempMin = 10000000000L;
                long tempMax = 0;
                for(int k = 0; k < p; k++)
                {
                    if(pressure[j][k] < tempMin)
                    {
                        tempMin = pressure[j][k];
                    }
                    if(pressure[j][k] > tempMax)
                    {
                        tempMax = pressure[j][k];
                    }
                }
                out += tempMax-tempMin;
                min[j] = tempMin;
                max[j] = tempMax;
            }

            long[][] table = new long[n][2];
            table[0][0] = max[0];
            table[0][1] = min[0];
            for(int j = 1; j < n; j++)
            {
                table[j][0] = Math.min(table[j-1][0]+Math.abs(min[j-1]-min[j]), table[j-1][1]+Math.abs(max[j-1]-min[j]));
                table[j][1] = ",Maarten17581
1053,"public class Solution {

	static Scanner sc = new Scanner(System.in);

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int testCases = sc.nextInt();
		
		for (int i = 1; i <= testCases; ++i) {
			solve(i);
		}
	}
	
	private static void solve(int t) {
		int [][] arr = new int [3][4];
		
		for (int i = 0; i < arr.length; ++i) {
			for (int j = 0; j < arr[0].length; ++j) {
				arr[i][j] = sc.nextInt();
			}
		}
		
		int [] ans = new int [4];
		int max;
		
		for (int j = 0; j < 4; ++j) {
			max = Integer.MAX_VALUE;
			
			for (int i = 0; i < 3; ++i) {
				max = Math.min(max, arr[i][j]);
			}
			ans[j] = max;
		}
		
		int left = 1_000_000;
		
		for (int i = 0; i < 4; ++i) {
			ans[i] = Math.min(ans[i], left);
			left -= ans[i];
		}
		
		if (left != 0) {
			System.out.println(""Case #"" + t + "": IMPOSSIBLE"");
			return;
		}
		
		print(t, ans);
	}
	
	public static void print(int test, int [] arr) {
		System.out.print(""Case #"" + test + "":"");
		
		for (int num : arr)
			System.out.print("" "" + num);
		
		System.",profchi
553,"public class Solution {
//public class B2 {
    public static void main(String[] args) throws IOException {
        //BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(""in.txt"")));
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int ttt = Integer.parseInt(br.readLine());
        for (int tt = 1; tt <= ttt; ++tt) {
            String[] cc = br.readLine().split("" "");
            final int n = Integer.parseInt(cc[0]);
            final int p = Integer.parseInt(cc[1]);

            final int[][] all = new int[n][p];
            for (int nn = 0; nn < n; nn++) {
                cc = br.readLine().split("" "");
                for (int pp = 0; pp < p; pp++) {
                    all[nn][pp] = Integer.parseInt(cc[pp]);
                }
            }

            final int[][] q = new int[n][2];
            for (int i = 0; i < n; i++) {
                int min = Integer.MAX_VALUE;
                int max = Integer.MIN_VALUE;
                for (int x : all[i]) {
                    min = Math.min(min, x);
                    max = Math.max(max, x);
                }
                q[i][0] = min;
                q[i][1] = max;
            }

            long answ = 0;
            for (int[] x : q) {
                answ += (long) (x[1] - x[0]);
            }

            //System.out.println(answ);

            int[] elements = new int[n];
            for (int i = 0; i < n; i++) {
                elements[i] = i;
            }

            long best = Integer.MAX_VALUE;

            best = Math.min(calc(elements, q), best);

            System.out.println(""Case #"" + tt + "": "" + (answ + best));

        }
    }

    private static long calc(int[] elements, int[][] q) {
        long[][] res = new long[elements.length][2];
        res[0][0] = q[elements[0]][1] * 2 - q[elements[0]][0];
        res[0][1] = q[elements[0]][0];
        for (int i = 1; i < elements.length; i++) {
            final long prevTop = q[elements[i - 1]][1];
            final long prevBottom = q[elements[i - 1]][0];

            final long currTop = q[elements[i]][1];
            final long currBottom = q[elements[i]][0];

            res[i][0] = Math.min(Math.abs(currTop - prevTop) + res[i - 1][1], Math.abs(currTop - prevBottom) + res[i - 1][0]);
            res[i][1] = Math.min(Math.abs(currBottom - prevTop) + res[i - 1][1], Math.abs(currBottom - prevBottom) + res[i - 1][0]);
        }


        return Math.min(res[elements.length - 1][0], res[elements.length - 1][1]);
    }

    private static void swap(int[] input, int a, int b) {
        int tmp = input[a];
        input[a] = input[b];
        input[b] = ",attila
300,"public class Solution {

    public static void main(String[] args) throws InterruptedException {
        Scanner in = new Scanner(System.in);
        // Thread.sleep(3000);
        int T = in.nextInt();

        for (int t = 1; t <= T; t++) {
            String s= in.next();
            StringBuilder sb= new StringBuilder();
            HashSet<Character> diff= new HashSet<>();
        for(int i=0; i<s.length()-1; i++){
            diff.add(s.charAt(i));
            sb.append(s.charAt(i));
            if(s.charAt(i)<=s.charAt(i+1))
            sb.append(s.charAt(i));
        }
        sb.append(s.charAt(s.length()-1));
diff.add(s.charAt(s.length()-1));
        if(diff.size()==1)
            System.out.println(""Case #""+t+"": ""+s);
        else
            System.",Rawan321
860,"public class Solution {
	
	public static int countOnes(String str) {
		int ans = 0;
		for (int i = 0; i < str.length(); i++) {
			if (str.charAt(i) == '1') ans++;
		}
		return ans;
	}
	
	public static String xor(String s1, String s2) {
		String res = """";
		for (int i = 0; i < s1.length(); i++) {
			if (s1.charAt(i) == s2.charAt(i)) res += ""0"";
			else res += ""1"";
		}
		return res;
	}
	
	public static String binString(int i) {
		String s = Integer.toBinaryString(i);
		while (s.length() < 8) s = ""0"" + s;
		return s;
	}
	
	public static String randString() {
		String s = """";
		for (int i = 0; i < 8; i++) {
			if (Math.random() < 0.5) s += ""1"";
			else s += ""0"";
		}
		return s;
	}
    
    @SuppressWarnings(""unchecked"")
	public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        int T = Integer.parseInt(in.readLine());
        for (int e = 0; e < T; e++) {
        	TreeSet<String> posAns = new TreeSet<>();
        	for (int i = 0; i < 256; i++) {
        		posAns.add(binString(i));
        	}
        	boolean good = true;
        	String[] initGuess = { ""01101110"", ""10110001"", ""00000110"" };
        	String pAns = """";
            for (int q = 0; q < 300; q++) {
            	boolean ansFound = false;
            	int minSize = 257 * 10, minTotal = 0, minStackG = 9;
            	String guess = """";
            	if (q < 300) guess = randString();
            	else if (q < 3) guess = initGuess[q];
            	else if (posAns.size() == 1 && posAns.contains(""11111111"")) guess = ""11111111"";
            	else {
            		for (int i = 1; i < 255; i++) {
                		String str = binString(i);
                		if (str.equals(pAns)) continue;
                		int[] count = new int[9];
                		int size = 0, stackG = 0, total = 0;
                		TreeSet<String>[] ta = new TreeSet[9];
                		for (int k = 0; k < 9; k++) {
                			ta[k] = new TreeSet<String>();
                		}
                		for (int j = 0; j < 8; j++) {
                			String currStr = str.substring(j, 8) + str.substring(0, j);
                			for (String t:posAns) {
                				String tep = xor(currStr, t);
                				int x = countOnes(tep);
                				ta[x].add(tep);
                			}
                		}
                		for (int k = 0; k < 9; k++) {
            				count[k] += ta[k].size();
            			}
                		//System.out.print(str + "": "");
                		for (int k = 0; k < 9; k++) {
            				if (count[k] > 0) stackG++;
            				size = Math.max(size, count[k]);
            				total += count[k];
            				//System.out.print(count[k] + "" "");
            			}
                		//System.out.println();
                		if (size == 1 && stackG == 1) {
                			ansFound = true;
                			guess = str;
                			break;
                		}
                		if (stackG < minStackG && !ansFound) {
                			minSize = size;
                			guess = str;
                			minTotal = total;
                			minStackG = stackG;
                		} else if (stackG == minStackG && size < minSize) {
                			guess = str;
                			minTotal = total;
                			minSize = size;
                		} else if (stackG == minStackG && size == minSize && total < minTotal) {
                			guess = str;
                			minTotal = total;
                		}
                	}
            	}
            	pAns = guess;
            	System.out.println(guess);
            	int res = Integer.parseInt(in.readLine());
            	if (res == 0) break;
            	if (res == -1) {
            		good = false;
            		break;
            	}
            	TreeSet<String> nPosAns = new TreeSet<>();
            	for (int j = 0; j < 8; j++) {
        			String currStr = guess.substring(j, 8) + guess.substring(0, j);
        			for (String t:posAns) {
        				String temp = xor(currStr, t);
        				int x = countOnes(temp);
        				if (x == res) nPosAns.add(temp);
        			}
        		}
            	//System.out.println(nPosAns.size());
            	posAns = ",kevinz1423
795,"class Room {
    public boolean visited = false;
    public int index;
    public List<Integer> neighbors;
}

public class Solution {

    public static void main(String[] args) {

        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        int T = in.nextInt();

        for (int i = 0; i < T; i++) {

            int N = in.nextInt();
            int K = in.nextInt();

            Room[] rooms = new Room[N];

            int lastRoomIdx = -1;

            for (int j = 0; j <= K; j++) {

                int R = in.nextInt() - 1;
                int P = in.nextInt();

                if (rooms[R] == null) {

                    rooms[R] = new Room();
                    rooms[R].index = R;
                    rooms[R].neighbors = new ArrayList<>(P);

                    for (int k = 0; k < P; k++) {
                        rooms[R].neighbors.add(-1);
                    }
                }

                var room = rooms[R];
                room.visited = true;

                if (lastRoomIdx != -1) {

                    for (int k = 0; k < room.neighbors.size(); k++) {
                        if (room.neighbors.get(k) == -1) {
                            room.neighbors.set(k, lastRoomIdx);
                            break;
                        }
                    }

                    for (int k = 0; k < rooms[lastRoomIdx].neighbors.size(); k++) {
                        if (rooms[lastRoomIdx].neighbors.get(k) == -1) {
                            rooms[lastRoomIdx].neighbors.set(k, R);
                            break;
                        }
                    }
                }

                if (j == K) {
                    break;
                }

                var unknownNeighbors = room.neighbors.stream().filter(n -> n == -1).count();

                var chance = (float) unknownNeighbors / room.neighbors.size();

                if (chance > 0.75f) {
                    lastRoomIdx = R;
                    System.out.println(""W"");
                } else {
                    boolean teleported = false;

                    for (int k = 0; k < rooms.length; k++) {
                        if (rooms[k] == null) {
                            teleported = true;
                            System.out.printf(""T %d%n"", k + 1);
                            break;
                        }
                    }

                    if (teleported) {
                        lastRoomIdx = -1;
                    } else {
                        // all rooms are visited, go somewhere randomly
                        lastRoomIdx = R;
                        System.out.println(""W"");
                    }
                }

                System.out.flush();
            }

            var knownPendingRooms = new ArrayList<Integer>();
            var unknownPendingRooms = new ArrayList<Integer>();

            int nPassages = 0;

            for (int j = 0; j < N; j++) {

                var room = rooms[j];

                if (room == null) {
                    unknownPendingRooms.add(j);
                    continue;
                }

                boolean hasUnknownPassages = false;

                for (int k = 0; k < room.neighbors.size(); k++) {

                    if (room.neighbors.get(k) == -1) {

                        if (!hasUnknownPassages) {
                            knownPendingRooms.add(j);
                            hasUnknownPassages = true;
                        }

                    } else {

                        if (room.neighbors.get(k) > j) {
                            nPassages++;
                        }
                    }
                }
            }

            boolean[][] connections = new boolean[N][];

            for (int j = 0; j < N; j++) {

                connections[j] = new boolean[N];

                if (rooms[j] != null) {

                    for (int k = 0; k < rooms[j].neighbors.size(); k++) {

                        var neig = rooms[j].neighbors.get(k);

                        if (neig != -1) {
                            connections[j][rooms[j].neighbors.get(k)] = true;
                        }
                    }
                }
            }

//            while (knownPendingRooms.size() > 0) {
//
//                var pendingRoom = knownPendingRooms.get(0);
//
//                var room = rooms[pendingRoom];
//
//                if (!room.visited && room.neighbors.size() > 0) {
//                    knownPendingRooms.remove(pendingRoom);
//                    continue;
//                }
//
//                for (int j = 0; j < room.neighbors.size(); j++) {
//
//                    if (room.neighbors.get(j) == -1) {
//
//                        if (unknownPendingRooms.size() > 0) {
//
//                            var unknownIndex = unknownPendingRooms.remove(0);
//
//                            var unknownRoom = new Room();
//                            unknownRoom.index = unknownIndex;
//                            unknownRoom.neighbors = new ArrayList<>();
//                            unknownRoom.neighbors.add(pendingRoom);
//
//                            rooms[unknownIndex] = unknownRoom;
//
//                            knownPendingRooms.add(unknownIndex);
//                            room.neighbors.set(j, unknownIndex);
//
//                            connections[pendingRoom][unknownIndex] = true;
//                            connections[unknownIndex][pendingRoom] = true;
//
//                            nPassages++;
//
//                        } else {
//
//                            for (var r : knownPendingRooms) {
//
//                                if (r.equals(pendingRoom)) {
//                                    continue;
//                                }
//
//                                if (connections[pendingRoom][r]) {
//                                    continue;
//                                }
//
//                                var otherRoom = rooms[r];
//
//                                if (!otherRoom.visited) {
//
//                                    room.neighbors.set(j, r);
//                                    otherRoom.neighbors.add(pendingRoom);
//
//                                } else {
//
//                                    int c = 0;
//                                    int firstNeigh = -1;
//
//                                    for (int h = 0; h < otherRoom.neighbors.size(); h++) {
//
//                                        var neigh = otherRoom.neighbors.get(h);
//
//                                        if (neigh == -1) {
//                                            if (firstNeigh == -1) {
//                                                firstNeigh = h;
//                                            }
//                                            c += 1;
//                                        }
//                                    }
//
//                                    room.neighbors.set(j, r);
//                                    otherRoom.neighbors.set(firstNeigh, pendingRoom);
//
//                                    if (c == 1) {
//                                        knownPendingRooms.remove(Integer.valueOf(otherRoom.index));
//                                    }
//                                }
//
//                                nPassages++;
//
//                                connections[pendingRoom][r] = true;
//                                connections[r][pendingRoom] = true;
//
//                                break;
//                            }
//                        }
//                    }
//                }
//
//                if (room.visited) {
//                    knownPendingRooms.remove(pendingRoom);
//                }
//            }

            System.out.printf(""E %d%n"", nPassages);
            System.",jaimuepe
1016,"public class Solution {
    public static void main(String[] args) {
        Scanner inp = new Scanner(System.in);

        int t = inp.nextInt();

        for (int j = 0; j < t; j++) {
            System.out.printf(""Case #%d: "",j+1);
            int c = inp.nextInt();
            int m = inp.nextInt();
            int y = inp.nextInt();
            int k = inp.nextInt();
            for (int i = 0; i <2 ; i++){
                int c1 = inp.nextInt();
                int m1 = inp.nextInt();
                int y1 = inp.nextInt();
                int k1 = inp.nextInt();

                c = (c1<c) ? c1 : c ;
                m = (m1<m) ? m1 : m ;
                y = (y1<y) ? y1 : y ;
                k = (k1<k) ? k1 : k ;

            }
            
            int[] arr = {c,m,y,k};
            
            int sum = 0;
            
            for(int i = 0; i<4;i++){
                sum += arr[i];
                if (sum > 1000000){
                    arr[i] =1000000-sum+arr[i];
                    for(int l = i+1 ; l<4 ; l++){
                        arr[t]=0;
                    }
                    System.out.printf(""%d %d %d %d
"",arr[0],arr[1],arr[2],arr[3]);
                    i=5;
                }
                
                if(i==3)
                    System.out.println(""IMPOSSIBLE"");
                
            }


            
        }
    }
}",parthanos
654,"public class Solution {

    public static void main(String[] args) {
        
        Scanner scan = new Scanner(System.in); 
        int numOfCases = scan.nextInt();
        System.out.println(numOfCases);
        
        int x = 1; // Test Case Number (starting from 1)
        
        int r = 0;
        int c = 0;
        
        int counter = 0; 

        
        for (int i = 0; i < numOfCases; i++) {
            r = scan.nextInt();
            c = scan.nextInt();
            
            System.out.println(""Case #"" + x + "": "");
            
            // First Two Lines
            if (r > 2) {
                System.out.print("".."");
                for (int j = 0; j < r; j++) {
                    System.out.print(""+-"");
                }
                System.out.println(""+"");
                
                System.out.print("".."");
                for (int k = 0; k < r; k++) {
                    System.out.print(""|."");
                }
                System.out.println(""|"");
            }
            else {
                System.out.print("".."");
                for (int j = 1; j < r; j++) {
                    System.out.print(""+-"");
                }
                System.out.println(""+"");
                
                System.out.print("".."");
                for (int k = 0; k < r; k++) {
                    System.out.print(""|."");
                }
                System.out.println(""|"");
            }
            
            
            // Remaining Lines 
            for (int j = 0; j < r - 1; j++) {
                for (int k = 0; k < c; k++) {
                    System.out.print(""+-"");
                }
                System.out.println(""+"");
                
                for (int l = 0; l < c - 1; l++) {
                    System.out.print(""|."");
                }
                System.out.println(""|"");
            }
        
            // Last Lines
            for (int l = 0; l < c; l++) {
                System.out.print(""+-"");
            }
            System.",dtarde
136,"public class Solution { //Solution
	static int INF = (int)(1e9);
	static long mod = (long)(1e9)+7;
	static long mod2 = 998244353;
	static long[] segtree;
	static char[] curans;
	static long ans;	
	static String S;
	static ArrayList<Integer>[] graph;
	static boolean[] vis;
	static int[] a;
	static int N;
	static long K;
	static long[] fact;
	static ArrayList<Long> pos;
	static ArrayList<Long> neg;
	static long[] max;
	static int[] dp;
	static long mx;
	static long[] fun;
	public static void main(String[] args) {  //Cash out
		/**/
		FastScanner I = new FastScanner(); //Input
		OutPut O = new OutPut(); //Output
		
		int T = I.nextInt();
		
		for (int i = 1; i <= T; i++) {
			int N = I.nextInt();
			long ans = 0;
			
			long[][] fun = new long[N + 1][2];
			long[] fun_factor = new long[N + 1];
			ArrayList<Integer>[] g = new ArrayList[N + 1];
			ArrayList<Integer>[] g_recieve = new ArrayList[N + 1];
			g_recieve[0] = new ArrayList<Integer>();
			
			for (int j = 1; j <= N; j++) {
				fun[j][0] = I.nextLong();
				fun[j][1] = j;
				fun_factor[j] = fun[j][0];
				
				g[j] = new ArrayList<Integer>();
				g_recieve[j] = new ArrayList<Integer>();
			}
			
			for (int j = 1; j <= N; j++) {
				int nbr = I.nextInt();
				g[j].add(nbr);
				g_recieve[nbr].add(j);
			}
			
			int num_roots = 0;
			boolean[] root = new boolean[N + 1];
			
			for (int j = 1; j <= N; j++) {
				num_roots += g_recieve[j].size() == 0? 1 : 0;
				root[j] = true;
			}
			
			Arrays.sort(fun, (a, b) -> Long.compare(a[0], b[0]));
			long lower_bound = Long.MAX_VALUE;
			
			for (int j = N; j > N - num_roots; j--) {
				ans += fun[j][0];
				lower_bound = Math.min(lower_bound, fun[j][0]);
			}
			
			int next_idx = N - num_roots;
			for (int j = 1; j <= N; j++) {
				boolean all_roots_nbrs = true;
				long cur_min = Long.MAX_VALUE;
				
				for (int k = 0; k < g_recieve[j].size(); k++) {
					int nbr = g_recieve[j].get(k);
					all_roots_nbrs &= root[nbr];
					cur_min = Math.min(cur_min, fun_factor[nbr]);
				}
				
				if (g_recieve[j].size() > 1) {
					if (all_roots_nbrs && cur_min >= lower_bound && 
						fun_factor[j] >= lower_bound) {
						
						ans -= cur_min;
						ans += fun[next_idx][0];
						lower_bound = fun[next_idx][0];
						next_idx--;
					}
				}
			}
			
			/*Subtraction fun here most likely with common root neighbors and indexing needed*/
			
			O.pln(""Case #"" + i + "": "" + ans);
		}
		
	}
	
	public static void DFS(int start) {
		if (start == 0) {
			return;
		}
		
		vis[start] = true;
		mx = Math.max(mx, fun[start]);
		int next = graph[start].get(0); // We only ever point to one node at a time
		if (vis[next]) {
			return;
		}
		
		DFS(next);
	}
	
	public static long C(int N, int K) {
		long ans = fact[N];
		ans *= FastExp(fact[K], mod - 2);
		ans %= mod;
		
		ans *= FastExp(fact[N - K], mod - 2);
		ans %= mod;
		
		return ans;
	}
	
	
	public static double[][] matrix_exp(double[][] a, long exp, long mod) {
		int R = a.length;
		int C = a[0].length;
		double[][] ans = new double[R][C];
		
		boolean mult_yet = false;
		
		while (exp > 0) {
			if (exp % 2 == 1) {
				if (!mult_yet) {
					mult_yet = true;
					for (int i = 0; i < R; i++) {
						for (int j = 0; j < C; j++) {
							ans[i][j] = a[i][j]; 
						}
					}
				}else {
					double[][] new_ans = mult(ans, a, mod);
					for (int i = 0; i < R; i++) {
						for (int j = 0; j < C; j++) {
							ans[i][j] = new_ans[i][j]; 
						}
					}
				}
			}
			
			double[][] new_a = mult(a, a, mod); // a = a^2 (binary exponentiation on matrices)
			for (int i = 0; i < R; i++) {
				for (int j = 0; j < C; j++) {
					a[i][j] = new_a[i][j]; 
				}
			}
			exp /= 2;
		}
		
		return ans;
	}
	public static double[][] mult(double[][] a, double[][] b, long mod) {
		int r1 = a.length;
		int c1 = a[0].length;
		int r2 = b.length;
		int c2 = b[0].length;
		//Requires: c1 = r2
		
		double[][] ans = new double[r1][c2];
		for (int r = 0; r < r1; r++) {
			for (int c = 0; c < c2; c++) {
				//Dot product of (a[r])^T and b[c] (as vectors in R^n (n = c1 = r2))
				double[] col_vector = new double[r2];
				double[] row_vector = new double[c1];
				
				for (int i = 0; i < r2; i++) {
					col_vector[i] = b[i][c];
				}
				for (int i = 0; i < c1; i++) {
					row_vector[i] = a[r][i]; 
				}
				
				ans[r][c] = dot_product(row_vector, col_vector, mod);
			}
		}
		return ans;
	}
	
	public static double dot_product(double[] a, double[] b, long mod) {
		double ans = 0;
		int N = a.length; //Requires: a and b are both vectors in R^n
		for (int i = 0; i < N; i++) {
			ans += a[i] * b[i];
		}
		return ans;
	}
	public static double max(double a, double b) {return Math.max(a, b);}
	public static double min(double a, double b) {return Math.min(a, b);}
	public static long min(long a, long b) {return Math.min(a,b);}
	public static long max(long a, long b) {return Math.max(a,b);}
	public static int min(int a, int b) {return Math.min(a,b);}
	public static int max(int a, int b) {return Math.max(a,b);}
	public static long abs(long x) {return Math.abs(x);}
	public static long abs(int x) {return Math.abs(x);}
	public static long ceil(long num, long den) {long ans = num/den; if (num%den!=0) 
	ans++; return ans;}
	public static long GCD(long a, long b) {
		if (a==0||b==0) return max(a,b);
		return GCD(min(a,b),max(a,b)%min(a,b));
	}
	public static long FastExp(long base, long exp) {
		long ans=1;
		while (exp>0) {
			if (exp%2==1) ans*=base;
			exp/=2;
			base*=base;
			base%=mod;
			ans%=mod;
		}
		return ans;
	}
	public static long ModInv(long num,long mod) {return FastExp(num,mod-2);}
	public static int pop(long x) { //Returns number of bits within a number
		int cnt = 0;
		while (x>0) {
			if (x%2==1) cnt++;
			x/=2;
		}
		return cnt;
	}
	static class FastScanner {
		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st=new StringTokenizer("""");
		String next() {
			while (!st.hasMoreTokens())
				try {
					st=new StringTokenizer(br.readLine());
				} catch (IOException e) {
					e.printStackTrace();
				}
			return st.",IQEmperor
790,"public class Solution {

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        PrintStream out = System.out;

        try {
            // in = new Scanner(new BufferedReader(new FileReader(""/Users/Shared/Sources/CodingStudy/src/codejam/year2022/round_1C/LetterBlocks/sample/sample_ts1-in.txt"")));
            // out = new PrintStream(new FileOutputStream(""/Users/Shared/Sources/CodingStudy/src/codejam/year2022/round_1C/LetterBlocks/sample/sample_ts1-out.txt""));

//            in = new Scanner(new BufferedReader(new FileReader(""/Users/Shared/Sources/CodingStudy/src/codejam/year2022/round_1C/LetterBlocks/sample/sample_ts2-in.txt"")));
//            out = new PrintStream(new FileOutputStream(""/Users/Shared/Sources/CodingStudy/src/codejam/year2022/round_1C/LetterBlocks/sample/sample_ts2-out.txt""));

        } catch (Exception e) {
            e.printStackTrace();
            return;
        }

        int T = in.nextInt();
        for (int t = 1; t <= T; t++) {
            int N = in.nextInt();
            String[] tower = new String[N];
            for (int i = 0; i < N; i++) {
                tower[i] = in.next();
            }

            String ans = getAnswer(tower);
            out.printf(""Case #%d: %s
"", t, ans);

//            System.err.println(""------------------"");
        }
        in.close();
    }

    private static String getAnswer(String[] tower) {
        int[] path = new int[tower.length];
        boolean[] visited = new boolean[tower.length];
        StringBuffer output = new StringBuffer();
        Set<Character> occurs = new HashSet<>();

        generatePermutationsRecursive(tower, 0, path, visited, occurs, output);

        if (output.length() == 0) return ""IMPOSSIBLE"";
        else return output.toString();
    }


    private static void generatePermutationsRecursive(String[] towers, int level, int[] path, boolean[] visited,
                                                      Set<Character> occurs, StringBuffer footprint) {
        for (int i = 0; i < towers.length; i++) {
            String lastTower = level > 0 ? towers[path[level-1]] : null;
            String candTower = towers[i];

            if (visited[i] == false && isValid(occurs, lastTower, candTower)) {
//                System.err.printf(""Level: %d Index: %d
"", level, i);

                path[level] = i;
                visited[i] = true;

                if (level + 1 == towers.length) {
                    // Leaf node found answer
                    toAnswer(towers, path, footprint);
                    return;
                }else{
                    Set<Character> newOccurs = new HashSet<>(occurs);
                    for(Character ch: candTower.toCharArray()){
                        newOccurs.add(ch);
                    }

                    // Non-leaf
                    generatePermutationsRecursive(towers, level + 1, path, visited, newOccurs, footprint);
                    visited[i] = false;

                    if (footprint.length() > 0) {
                        return;
                    }
                }

            }
        }

        return;
    }


    private static boolean isValid(Set<Character> occurs, String lastTower, String nextTower) {
        Character lastCh;
        if( lastTower == null)  {
            lastCh = ' ';
        }else {
            lastCh = lastTower.charAt(lastTower.length()-1);
        }

        Set<Character> newOccurs = new HashSet<>(occurs);


        for(char curCh : nextTower.toCharArray()){
            if( lastCh != curCh){
                if (newOccurs.contains(curCh)) {
                    // Fail
                    return false;
                }
            }

            lastCh = curCh;
            newOccurs.add(curCh);
        }

        return true;
    }


    private static void toAnswer(String[] towers, int[] path, StringBuffer output) {
        for (int j = 0; j < towers.length; j++) {
            output.append(towers[path[j]]);
        }
    }
}",id
45,"public class Solution
{
	public static void main(String[] args) {
		Scanner input=new Scanner(System.in);
		int t=input.nextInt();
		for(int x=0;x<t;x++)
		{
		    int n=input.nextInt();
		    int arr[]=new int[n];
		    for(int i=0;i<n;i++)
		    {
		        arr[i]=input.nextInt();
		    }
		    Arrays.sort(arr);
		    int count=1;
		    int temp=0;
		    for(int i=0;i<n;i++)
		    {
		        if(count<=arr[i])
		        {
		            count++;
		        }
		        else
		        {
		            temp=i;
		            break;
		        }
		    }
		    ArrayList<Integer> al=new ArrayList<>();
		  //  for(int i=0;i<al.size();i++)
		  //  {
		  //      System.out.print(al.get(i)+"" "");
		  //  }
		    System.out.print(""Case #""+(x+1)+"": "");
		  //  if(n>=arr[n-1])
		  //  {
		      if(temp!=0)
		      {
		          for(int i=temp;i<n;i++)
    		    {
    		        al.add(arr[i]);
    		    }
    		    for(int i=al.get(al.size()-1);i>=0;i--)
    		    {
    		        if(count<=i)
    		        {
    		            count++;
    		        }
    		        else
    		        {
    		            break;
    		        }
    		    }
		      }
		    System.out.print((count-1));
		    if(x!=t-1)
		    {
		        System.out.println();   
		    }
		  //  }
		  //  else
		  //  {
		  //      System.out.print(n);
		  //      if(x!=t-1)
    // 		    {
    // 		        System.out.println();   
    // 		    }
		  //  }
		}
	}
}
",AniketTewari
1212,"class Main{

public static int organize(int x,int[][] matrix)
{
    return x;
}
public static void main(String args[]){
    
    Scanner sc = new Scanner(System.in);

int t = sc.nextInt();

for(int k=0;k<t;k++)
{
    int x = sc.nextInt();
    int size=2*x;
    int[][] matrix = new int[2*x][2*x];
    for(int i=0;i<size;i++)
    {
       for(int j=0;j<size;j++){
           matrix[i][j] = sc.nextInt();
       }
    }
    
    int result = ",sriniharika
752,"public class Solution {
     public static  void main(String[] args){
        Scanner myObj = new Scanner(System.in);  
    
        int testcases = myObj.nextInt();
        
        xxas: for(int i = 0; i < testcases; i++) {
            int n = myObj.nextInt();
            int k = myObj.nextInt();
            
            int a = 0;
            int b = 0;
            for(int j = 0; j < n; j++) {
                int nxt = myObj.nextInt();
                a += nxt;
                b += nxt*nxt;
            }
            
            //
            if(k == 1) {
                if(a == 0) {
                    System.out.println(""Case #"" +(i+1)+ "": "" + (b==0 ? 0 : ""IMPOSSIBLE"") );
                }else
                    System.out.println(""Case #"" +(i+1)+ "": "" + ((b-a*(long)a)%(2*a)==0 ? (b-a*(long)a)/(2*a) : ""IMPOSSIBLE"") );
                    continue xxas;
            }
            
            String zeros = """";
            
            for(int x= -700000; x <= 700000; x++) {
                
                a += x;
                b += x*x;
                
                if(a == 0 && b == 0) {
                    System.out.println(""Case #"" +(i+1)+ "": "" + ""0 0"" +  zeros );
                    continue xxas;
                }
                
                if((b-a*(long)a)%(2*a)==0) {
                    System.out.println(""Case #"" +(i+1)+ "": "" + x + "" "" + (b-a*(long)a)/(2*a) + zeros );
                    continue xxas;
                }
                    
                a -= x;
                b -= x*x;
            }
            System.out.println(""Case #"" +(i+1)+ "": "" + ""IMPOSSIBLE"" );

        }
        
    }
    
    static public boolean isValid(String s) {
        boolean[] taken = new boolean[40];
        for(int i = 0; i< s.length();) {
            char c = s.charAt(i);
            if(taken[c-'A'])
            return false;
            taken[c-'A'] = true;
            while(i < s.",gregordr
748,"public class Solution {
  static final int WALK_LENGTH = 500;
  static final int MAX_OLD_LENGTH = 50;

  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);

    int T = sc.nextInt();
    for (int tc = 1; tc <= T; ++tc) {
      int N = sc.nextInt();
      int K = sc.nextInt();

      List<Integer> orders = IntStream.rangeClosed(1, N).boxed().collect(Collectors.toList());
      Collections.shuffle(orders);
      int orderIndex = 0;
      int restWalk = WALK_LENGTH;
      int oldLength = 0;
      Map<Integer, Integer> nodeToEdgeNum = new HashMap<>();
      for (int i = 0; i <= K; ++i) {
        int R = sc.nextInt();
        int P = sc.nextInt();

        if (nodeToEdgeNum.containsKey(R)) {
          ++oldLength;
        } else {
          nodeToEdgeNum.put(R, P);
          oldLength = 0;
        }

        if (nodeToEdgeNum.size() == N) {
          break;
        }

        if (i != K) {
          if (restWalk == 0 || oldLength == MAX_OLD_LENGTH) {
            int next = -1;
            while (true) {
              next = orders.get(orderIndex);
              if (!nodeToEdgeNum.containsKey(next)) {
                break;
              }
              ++orderIndex;
            }

            System.out.println(String.format(""T %d"", next));
            System.out.flush();

            restWalk = WALK_LENGTH;
            oldLength = 0;
          } else {
            System.out.println(String.format(""W""));
            System.out.flush();

            --restWalk;
          }
        }
      }

      double avgEdgeNum = computeAvgEdgeNum(N, nodeToEdgeNum);

      System.out.println(String.format(""E %d"", (long) Math.round(avgEdgeNum * N)));
      System.out.flush();
    }

    sc.close();
  }

  static double computeAvgEdgeNum(int N, Map<Integer, Integer> nodeToEdgeNum) {
    // return nodeToEdgeNum.values().stream().mapToDouble(x -> x).sum() / 2 / nodeToEdgeNum.size();

    List<Integer> orders =
        nodeToEdgeNum.keySet().stream()
            .sorted(Comparator.comparing(nodeToEdgeNum::get))
            .collect(Collectors.toList());

    double sum = 0;
    for (int i = 0; i < orders.size(); ++i) {
      sum +=
          nodeToEdgeNum.get(orders.get(i))
              * (((double) nodeToEdgeNum.size() / N < 0.5 && i >= orders.size() - 2) ? 1 : 0.5);
    }

    return sum / nodeToEdgeNum.",goalboy1015
517,"public class Solution{

    static long MOD = 1_000_000_007L;
    //static long MOD = 998_244_353L;
    //static long MOD = 1_000_000_033L;
    static long inv2 = (MOD + 1) / 2;
    static long [] fac;
    static long [] pow;
    static long [] inv;
    static long [] invFac;
    static int[][] dir = new int[][]{{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
    static long lMax = 0x3f3f3f3f3f3f3f3fL;
    static int iMax = 0x3f3f3f3f;
    static HashMap <Long, Long> memo = new HashMap();
    static MyScanner sc = new MyScanner();
    //static ArrayList <Integer> primes;

    static long[] pow2;
    static int[] base;
    static int[] numOfDiv;
    static ArrayList <Integer> primes;
    //-----------PrintWriter for faster output---------------------------------
    public static PrintWriter out;
    public static void main(String[] args) {
        out = new PrintWriter(new BufferedOutputStream(System.out));
        // Start writing your solution here. -------------------------------------

        int nn = 300000;

        /*fac = new long[nn + 1];
        fac[1] = 1;
        for(int i = 2; i <= nn; i++)
            fac[i] = fac[i - 1] * 1L * i % MOD;*/

        /*pow = new long[nn + 1];
        pow[0] = 1L;
        for(int i = 1; i <= nn; i++)
            pow[i] = pow[i - 1] * 2L % MOD;
        pow[1] = 3L;*/

        /*
        pow2 = new long[nn + 1];
        pow2[0] = 1L;
        for(int i = 1; i <= nn; i++)
            pow2[i] = pow2[i - 1] * 2L;*/

        /*inv = new long[nn + 1];
        inv[1] = 1;
        for (int i = 2; i <= nn; ++i)
            inv[i] = (MOD - MOD / i) * inv[(int)(MOD % i)] % MOD;

        invFac = new long[nn + 1];
        invFac[1] = 1;
        for(int i = 2; i <= nn; i++)
            invFac[i] = invFac[i - 1] * inv[i] % MOD;*/

        //primes = sieveOfEratosthenes(100001);


        /*for(int i = 2; i <= 20000000; i++)
            if(numOfDiv[i] == 0)
                for(int j = i; j <= 20000000; j += i)
                    numOfDiv[j] ++;*/

        int t = 1, tt = 0;
        t = sc.ni();
        while(tt++ < t) {
            //long res = solve();
            //out.print(""Case #"" + tt + "": "");
            solve();
            //out.println(res);
        }
        out.close();
    }
    static void solve() {
        int N = sc.ni(), K = sc.ni();
        int pos = sc.ni(), cnt = sc.ni();
        long sum = cnt;
        int rand_int = pos;
        SecureRandom rand = new SecureRandom();
        HashSet <Integer> set = new HashSet<>();
        set.add(pos);
        for(int i = 0; i < K; i++) {
            while (set.contains(rand_int)) {
                rand_int = rand.nextInt(N) + 1;
            }
            out.println(""T "" + rand_int);
            out.flush();
            pos = sc.ni();
            cnt = sc.ni();
            set.add(pos);
            sum += cnt;
        }
        long res = Math.round(0.5 * N * sum / (K + 1));
        out.println(""E "" + res);
        out.flush();
    }

    static long c(int a, int b) {
        if(a <= 0 || b <= 0 || a <= b) return 1L;
        return fac[a] * invFac[b] % MOD * invFac[a - b] % MOD;
    }

    // SegmentTree range min/max query From uwi
    public static class SegmentTreeRMQ {
        public int M, H, N;
        public long[] st;

        public SegmentTreeRMQ(int n)
        {
            N = n;
            M = Integer.highestOneBit(Math.max(N-1, 1))<<2;
            H = M>>>1;
            st = new long[M];
            Arrays.fill(st, 0, M, Integer.MAX_VALUE);
        }

        public SegmentTreeRMQ(long[] a)
        {
            N = a.length;
            M = Integer.highestOneBit(Math.max(N-1, 1))<<2;
            H = M>>>1;
            st = new long[M];
            for(int i = 0;i < N;i++){
                st[H+i] = a[i];
            }
            Arrays.fill(st, H+N, M, Integer.MAX_VALUE);
            for(int i = H-1;i >= 1;i--)propagate(i);
        }

        public void update(int pos, int x)
        {
            st[H+pos] = x;
            for(int i = (H+pos)>>>1;i >= 1;i >>>= 1)propagate(i);
        }

        private void propagate(int i)
        {
            st[i] = Math.min(st[2*i], st[2*i+1]);
        }

        public long minx(int l, int r){
            long min = Long.MAX_VALUE;
            if(l >= r) return min;
            while(l != 0){
                int f = l&-l;
                if(l+f > r)break;
                long v = st[(H+l)/f];
                if(v < min)min = v;
                l += f;
            }

            while(l < r){
                int f = r&-r;
                long v = st[(H+r)/f-1];
                if(v < min) min = v;
                r -= f;
            }
            return min;
        }

        public long min(int l, int r){ return l >= r ? 0 : min(l, r, 0, H, 1);}

        private long min(int l, int r, int cl, int cr, int cur)
        {
            if(l <= cl && cr <= r){
                return st[cur];
            }else{
                int mid = cl+cr>>>1;
                long ret = Long.MAX_VALUE;
                if(cl < r && l < mid){
                    ret = Math.min(ret, min(l, r, cl, mid, 2*cur));
                }
                if(mid < r && l < cr){
                    ret = Math.min(ret, min(l, r, mid, cr, 2*cur+1));
                }
                return ret;
            }
        }
    }

    public static char[] rev(char[] a){char[] b = new char[a.length];for(int i = 0;i < a.length;i++)b[a.length-1-i] = a[i];return b;}
    public static int[] rev(int[] a, int start, int end){int[] b = a.clone();for(int i = start;i <= end;i++) b[start + end - i] = a[i];return b;}
    public static int[] rev(int[] a){return rev(a, 0, a.length - 1);}

    public static double dist(double a, double b){
        return Math.sqrt(a * a + b * b);
    }
    public static double dist(int[] A, int[] B){
        return dist(1.0 * A[0] - B[0], 1.0 * A[1] - B[1]);
    }

    public static long inv(long a){
        return quickPOW(a, MOD - 2);
    }

    public class Interval {
        int start;
        int end;
        public Interval(int start, int end) {
            this.start = start;
            this.end = end;
        }
    }

    public static ArrayList<Integer> sieveOfEratosthenes(int n) {
        boolean prime[] = new boolean[n + 1];
        Arrays.fill(prime, true);
        for (int p = 2; p * p <= n; p++) {
            if (prime[p]) {
                for (int i = p * 2; i <= n; i += p) {
                    prime[i] = false;
                }
            }
        }
        ArrayList<Integer> primeNumbers = new ArrayList<>();
        for (int i = 2; i <= n; i++) {
            if (prime[i]) {
                primeNumbers.add(i);
            }
        }
        return primeNumbers;
    }


    public static int lowerBound(int[] a, int v){ return lowerBound(a, 0, a.length, v); }
    public static int lowerBound(int[] a, int l, int r, int v)
    {
        if(l > r || l < 0 || r > a.length)throw new IllegalArgumentException();
        int low = l-1, high = r;
        while(high-low > 1){
            int h = high+low>>>1;
            if(a[h] >= v){
                high = h;
            }else{
                low = h;
            }
        }
        return high;
    }
    public static int rlowerBound(int[] a, int v){ return lowerBound(a, 0, a.length, v); }
    public static int rlowerBound(int[] a, int l, int r, int v)
    {
        if(l > r || l < 0 || r > a.length)throw new IllegalArgumentException();
        int low = l-1, high = r;
        while(high-low > 1){
            int h = high+low>>>1;
            if(a[h] <= v){
                high = h;
            }else{
                low = h;
            }
        }
        return high;
    }

    public static long C(int n, int m)
    {
        if(m == 0 || m == n) return 1l;
        if(m > n || m < 0) return 0l;
        long res = fac[n] * quickPOW((fac[m] * fac[n - m]) % MOD, MOD - 2) % MOD;
        return res;
    }
    public static long quickPOW(long n, long m)
    {
        long ans = ",anhpp123
951,"public class Solution {

	public static void main(String[] args) {
		Scanner s = new Scanner(System.in);
		int i, j, k, l, t, diferenca;
		int p1[] = new int[4];
		int p2[] = new int[4];
		int p3[] = new int[4];
		int saida1[] = new int[4];
 		
		do {
			t = s.nextInt();
		} while(t < 1 || t > 100);
		
		for(i = 1; i <= t; i++) {
			l = 0;
			
				for(k = 0; k < 4; k++) {
					do {
						p1[k] = s.nextInt();
						
					} while(p1[k] < 0 || p1[k] > (int) Math.pow(10, 6));
				}
				
				for(k = 0; k < 4; k++) {
					do {
						p2[k] = s.nextInt();
						
					} while(p2[k] < 0 || p2[k] > (int) Math.pow(10, 6));
				}
				
				for(k = 0; k < 4; k++) {
 					do {
						p3[k] = s.nextInt();
						
					} while(p3[k] < 0 || p3[k] > (int) Math.pow(10, 6));
				}
			
			for(j = 0; j < 4; j++) {
				
				if(p1[j] <= p2[j] & p1[j] <= p3[j]) {
					saida1[l] = p1[j];
				} else if(p2[j] <= p3[j]) {
					saida1[l] = p2[j];
				} else {
					saida1[l] = p3[j];
				}
				
				if(p1[j] == 0)
					if(p2[j] <= p3[j])
						saida1[l] = p2[j];
					else
						saida1[l] = p3[j];
				
				if(p2[j] == 0)
					if(p1[j] <= p3[j])
						saida1[l] = p1[j];
					else
						saida1[l] = p3[j];
				
				if(p3[j] == 0)
					if(p1[j] <= p2[j])
						saida1[l] = p1[j];
					else
						saida1[l] = p2[j];
				
				if(p1[j] == 0 && p2[j] == 0)
					saida1[l] = p3[j];
				
				if(p2[j] == 0 && p3[j] == 0)
					saida1[l] = p1[j];
				
				if(p1[j] == 0 && p3[j] == 0)
					saida1[l] = p2[j];
				
				l++;
			}

			l = 0;
			System.out.print(""Case #"" + i + "": "");
			
			if((saida1[0] + saida1[1] + saida1[2] + saida1[3]) >=  Math.pow(10, 6)) {
				
				diferenca = saida1[0] + saida1[1] + saida1[2] + saida1[3] - 10 * 10 * 10 * 10 * 10 * 10;
				
				while(diferenca > 0) {
					saida1[l]--;
					diferenca--;
					l++;
					
					if(l == 3)
						l = 0;
				}
				
				saida1[0] = saida1[0] / 3 + saida1[0] % 3;
				saida1[1] = saida1[1] / 3 + saida1[1] % 3;
				saida1[2] = saida1[2] / 3 + saida1[2] % 3;
				saida1[3] = saida1[3] / 3 + saida1[3] % 3;
				
				System.out.print(saida1[0] + "" "" + saida1[1] + "" "" + saida1[2] + "" "" + saida1[3]);
			} else {
				System.out.print(""IMPOSSIBLE"");
			}
			
			if(i != 1)
				System.",marcosph
949,"public class Solution {

	public static void main(String[] args) {
		Scanner s = new Scanner(System.in);
		int i, j, k, l, m, t;
		int p1[] = new int[4];
		int p2[] = new int[4];
		int p3[] = new int[4];
		int saida[] = new int[4];
		boolean imp = false;
		
		do {
			t = s.nextInt();
		} while(t < 1 || t > 100);
		
		for(i = 1; i <= t; i++) {
			l = 0;
			
				for(k = 0; k < 4; k++) {
					do {
						p1[k] = s.nextInt();
						
					} while(p1[k] < 0 || p1[k] > (int) Math.pow(10, 6));
				}
				
				for(k = 0; k < 4; k++) {
					do {
						p2[k] = s.nextInt();
						
					} while(p2[k] < 0 || p2[k] > (int) Math.pow(10, 6));
				}
				
				for(k = 0; k < 4; k++) {
 					do {
						p3[k] = s.nextInt();
						
					} while(p3[k] < 0 || p3[k] > (int) Math.pow(10, 6));
				}
			
			for(j = 0; j < 4; j++) {
				
				if(p1[j] >= p2[j] & p1[j] >= p3[j]) {
					saida[l] = p1[j];
				} else if(p2[j] >= p3[j]) {
					saida[l] = p2[j];
				} else {
					saida[l] = p3[j];
				}
				
				if(p1[j] == 0 && p2[j] == 0 && p3[j] == 0) {
					imp = true;
					break;
				}
				
				if(p1[j] == 0)
					if(p2[j] >= p3[j])
						saida[l] = p2[j];
					else
						saida[l] = p3[j];
				
				if(p2[j] == 0)
					if(p1[j] >= p3[j])
						saida[l] = p1[j];
					else
						saida[l] = p3[j];
				
				if(p3[j] == 0)
					if(p1[j] >= p2[j])
						saida[l] = p1[j];
					else
						saida[l] = p2[j];
				
				if(p1[j] == 0 && p2[j] == 0)
					saida[l] = p3[j];
				
				if(p2[j] == 0 && p3[j] == 0)
					saida[l] = p1[j];
				
				if(p1[j] == 0 && p3[j] == 0)
					saida[l] = p2[j];
				
				l++;
			}
			
			l = 0;
			System.out.print(""Case #"" + i + "": "");
			
			if(imp == false) {
				System.out.println(saida[0] + "" "" + saida[1] + "" "" + saida[2] + "" "" + saida[3]);
			} else {
				System.out.println(""IMPOSSIBLE"");
				imp = ",marcosph
214,"public class Solution {
    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        int c=s.nextInt();
        
        for (int t = 0; t < c; t++) 
        {     
             int wj = s.nextInt();
             int [] wjj=new int [wj];
            for(int z=0;z<wj;z++)
            { 
                wj[i]=s.nextInt;
            }
    
            System.out.print(""Case #"" + (t + 1)+"":"");
            Array.sort(wjj);
         ArrayList<Integer> l=new ArrayList<>();
	            
	                
	                int o=1;
	                
	              for(int k=0;k<wjj.size();k++) 
	              {
	                  if(wjj[k]>=o)
	                  {
	                      l.add(o);
	                      o++;
	                    }
	              }
	              
	             
	            }
	            System.",LeonardWang
705,"public class Solution {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        final int numCases = Integer.parseInt(input.nextLine());
        for (int i = 1; i <= numCases; i++) {
            System.out.print(String.format(""Case #%d: "", i));
            
            final int[][] printer = new int[3][4];
            
            int maxCyan = 1000000;
            int maxMagenta = 1000000;
            int maxYellow = 1000000;
            int maxBlack = 1000000;
            
            for (int j = 0; j < 3; j++) {
                final String line = input.nextLine();
                final String[] parts = line.split(""\\\s"");
            
                printer[j][0] = Integer.parseInt(parts[0]);
                printer[j][1] = Integer.parseInt(parts[1]);
                printer[j][2] = Integer.parseInt(parts[2]);
                printer[j][3] = Integer.parseInt(parts[3]);
                
                if (printer[j][0] < maxCyan) {
                    maxCyan = printer[j][0];
                }
                
                if (printer[j][1] < maxMagenta) {
                    maxMagenta = printer[j][1];
                }
                
                if (printer[j][2] < maxYellow) {
                    maxYellow = printer[j][2];
                }
                
                if (printer[j][3] < maxBlack) {
                    maxBlack = printer[j][3];
                }
            }
            
            String r;
            
            if ((maxCyan + maxMagenta + maxYellow + maxBlack) < 1000000) {
                r = ""IMPOSSIBLE"";
            } else {
                int excess = (maxCyan + maxMagenta + maxYellow + maxBlack) - 1000000;
                int c = maxCyan;
                int m = maxMagenta;
                int y = maxYellow;
                int k = maxBlack;
                
                while (excess > 0) {
                    // remove excess from cyan
                    if (c < (excess / 4)) {
                        excess -= c;
                        c = 0;
                    } else {
                        c -= (excess / 4);
                        excess -= (excess / 4);
                    }
                    
                    // remove excess from magenta
                    if (m < (excess / 3)) {
                        excess -= m;
                        m = 0;
                    } else {
                        m -= (excess / 3);
                        excess -= (excess / 3);
                    }
                    
                    // remove excess from yellow
                    if (y < (excess / 2)) {
                        excess -= y;
                        y = 0;
                    } else {
                        y -= (excess / 2);
                        excess -= (excess / 2);
                    }
                    
                    // remove excess from black
                    if (k < excess) {
                        System.out.println(""IMPOSSIBLE"");
                        exit();
                    } else {
                        k -= excess;
                    }
                }
                
                r = String.format(""%d %d %d %d"", c, m, y, k);
            }
            System.out.println(r);
        }
    }
}",gawallace25
51,"public class Solution
{
	public static void main(String[] args) {
		Scanner input=new Scanner(System.in);
		int t=input.nextInt();
		for(int k=0;k<t;k++)
		{
		    String b=input.next();
		    String a=b.toUpperCase();
		    int arr[]=new int[a.length()];
		    for(int i=0;i<a.length();i++)
		    {
		        arr[i]=(int)a.charAt(i);
		    }
		    HashSet<Integer> hs=new HashSet<>();
		    for(int i=0;i<arr.length;i++)
		    {
		        hs.add(arr[i]);
		    }
		    System.out.print(""Case #""+(k+1)+"": "");
		    if(hs.size()==1)
		    {
		        System.out.print(a);
		    }
		    else
		    {
		      //  for(int i=0;i<arr.length;i++)
    		  //  {
    		  //      System.out.print(arr[i]+"" "");
    		  //  }
    		    String res="""";
    		    int c=0;
    		    for(int i=0;i<arr.length-1;i++)
    		    {
    		        if((arr[i+1])>arr[i])
    		        {
    		            res+=(char)arr[i];//+(char)arr[i];
    		            res+=(char)arr[i];
    		        }
    		        else if((arr[i+1])==arr[i])
    		        {
    		          //  res+=(char)arr[i];
    		          int x=i,temp=i;  //1
    		          while(x<arr.length-1)
    		          {
    		              if(arr[x+1]>arr[x])
    		              {
    		                    res+=(char)arr[temp];//+(char)arr[i];
    		                    res+=(char)arr[temp];
    		                    break;
    		              }
    		              else if(arr[x+1]<arr[x])
    		              {
    		                    res+=(char)arr[temp];//+(char)arr[i];
    		                    //res+=(char)arr[temp];
    		                    break;
    		              }
    		              else
    		              {
    		                  //res+=(char)arr[temp];
    		                 
    		              }
    		              x++;
    		          }
    		            
    		        }
    		        else
    		        {
    		            res+=(char)arr[i];
    		        }
    		        
    		    }
    		  //  if(res.compareTo(a)<0)
    		  //      {
    		            System.out.print(res);
    		  //          c++;
    		  //      }
    		  //      else
    		  //      {
    		  //          System.out.print(a);
    		  //      }
    		  //  if(c>0)
    		  //  {
    		        System.out.print((char)arr[arr.length-1]);
    		    //}
    		    //System.out.print(res+""
"");
		    }
		    if(k!=t-1)
    		{
                System.out.println();
    	    }
		}
	}
}
",AniketTewari
344,"class Solution {
    static boolean found = false;

    public static void findMin(int cMin, int mMin, int yMin, int kMin, int a) {
        // if (found == true)
        // return;
        // if (cMin + mMin + yMin + kMin == 1000000) {
        // System.out.println(""Case #"" + (a + 1) + "": "" + cMin + "" "" + mMin + "" "" + yMin
        // + "" "" + kMin);
        // found = true;
        // return;
        // }
        // findMin(cMin - 1, mMin, yMin, kMin, a);
        // findMin(cMin, mMin - 1, yMin, kMin, a);
        // findMin(cMin, mMin, yMin - 1, kMin, a);
        // findMin(cMin, mMin, yMin, kMin - 1, a);
        int out = (1000000) / 4;
        if (cMin >= out && yMin >= out && kMin >= out && mMin >= out) {
            System.out.println(""Case #"" + (a + 1) + "": "" + out + "" "" + out + "" "" + out + "" "" + out);
            return;
        } else {
            int tsum = 0;
            if (tsum + cMin > 1000000) {
                System.out.println(""Case #"" + (a + 1) + "": "" + 1000000 + "" "" + 0 + "" "" + 0 + "" "" + 0);
                return;
            }
            tsum += cMin;
            if (tsum + mMin > 1000000) {
                System.out.println(""Case #"" + (a + 1) + "": "" + cMin + "" "" + (1000000 - cMin) + "" "" + 0 + "" "" + 0);
                return;
            }
            tsum += mMin;
            if (tsum + yMin > 1000000) {
                System.out.println(""Case #"" + (a + 1) + "": "" + cMin + "" "" + mMin + "" "" + (1000000 - yMin) + "" "" + 0);
                return;
            }
            tsum += yMin;
            if (tsum + kMin > 1000000) {
                System.out.println(""Case #"" + (a + 1) + "": "" + cMin + "" "" + mMin + "" "" + yMin + "" "" + (1000000 - kMin));
                return;
            }
            tsum += yMin;
        }
    }

    public static void compute3D(ArrayList<ArrayList<Integer>> list, int a) {
        PriorityQueue<Integer> c = new PriorityQueue<>();
        PriorityQueue<Integer> m = new PriorityQueue<>();
        PriorityQueue<Integer> y = new PriorityQueue<>();
        PriorityQueue<Integer> k = new PriorityQueue<>();
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 4; j++) {
                if (j == 0) {
                    c.add(list.get(i).get(j));
                } else if (j == 1) {
                    m.add(list.get(i).get(j));
                } else if (j == 2) {
                    y.add(list.get(i).get(j));
                } else if (j == 3) {
                    k.add(list.get(i).get(j));
                }
            }
        }
        int cMin = c.peek();
        int mMin = m.peek();
        int yMin = y.peek();
        int kMin = k.peek();
        int total = cMin + mMin + yMin + kMin;
        if (total < 1000000) {
            System.out.println(""Case #"" + (a + 1) + "": IMPOSSIBLE"");
        } else if (total == 1000000) {
            System.out.println(""Case #"" + (a + 1) + "": "" + cMin + "" "" + mMin + "" "" + yMin + "" "" + kMin);
        } else {
            findMin(cMin, mMin, yMin, kMin, a);
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int input = sc.nextInt();
        int n = 3;
        ArrayList<ArrayList<ArrayList<Integer>>> printerAll = new ArrayList<>();

        for (int a = 0; a < input; a++) {
            // PriorityQueue<Integer> c = new PriorityQueue<>();
            // PriorityQueue<Integer> m = new PriorityQueue<>();
            // PriorityQueue<Integer> y = new PriorityQueue<>();
            // PriorityQueue<Integer> k = new PriorityQueue<>();
            ArrayList<ArrayList<Integer>> printerCol = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                printerCol.add(new ArrayList<Integer>());
                for (int j = 0; j < 4; j++) {
                    int in = sc.nextInt();
                    printerCol.get(i).add(in);
                    // if (j == 0) {
                    // c.add(in);
                    // } else if (j == 1) {
                    // m.add(in);
                    // } else if (j == 2) {
                    // y.add(in);
                    // } else if (j == 3) {
                    // k.add(in);
                    // }
                }
            }
            // int cMin = c.peek();
            // int mMin = m.peek();
            // int yMin = y.peek();
            // int kMin = k.peek();
            // int total = cMin + mMin + yMin + kMin;
            // if (total < 1000000) {
            // System.out.println(""Case #"" + (a + 1) + "": IMPOSSIBLE"");
            // } else if (total == 1000000) {
            // System.out.println(""Case #"" + (a + 1) + "": "" + cMin + "" "" + mMin + "" "" + yMin
            // + "" "" + kMin);
            // } else {
            // System.out.println(total + "" "" + cMin + "" "" + mMin + "" "" + yMin + "" "" +
            // kMin);
            // }
            printerAll.add(printerCol);
        }
        for (int i = ",Roshan
224,"public class wj {
    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        int T = s.nextInt();
        for (int t = 0; t < T; t++) {
            int R = s.nextInt();
            int C = s.nextInt();
            System.out.println(""Case #"" + (t + 1)+"":"");
            String[][] wj = new String[R * 2 + 1][C * 2 + 1];
            for (int i = 0; i < wj.length; i++) {
                for (int c = 0; c < wj[i].length; c++) {
                    if (i < 2 && c < 2)
                        wj[i][c] = ""."";
                    else if (i % 2 == 0 && c % 2 == 0)
                        wj[i][c] = ""+"";
                    else if (i % 2 == 0 && c % 2 != 0)
                        wj[i][c] = ""-"";
                    else if (i % 2 != 0 && c % 2 == 0)
                        wj[i][c] = ""|"";
                    else
                        wj[i][c] = ""."";
                }
            }
            for (int i = 0; i < wj.length; i++) {
                for (int j = 0; j < wj[i].length; j++) {
                    System.out.print(wj[i][j]);
                }
                System.",LeonardWang
601,"public class Solution {
    public static void main(String[] args) {
        (new Solution()).readInput();
    }


    public void readInput() {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int caseCount = in.nextInt();
        for (int caseId = 1; caseId <= caseCount; ++caseId) {
            int n = in.nextInt();
            List<String> words = new ArrayList<>();
            for (int i=0;i<n;i++) {
                words.add(in.next());
            }
            System.out.println(""Case #"" + caseId + "": "" + solve(words));
        }
    }

    Set<Character> potentialStarts;
    Set<Character> invalidStarts;
    Set<Character> usedLetters;

    private String solve(List<String> words){
        potentialStarts = new HashSet<>();
        invalidStarts = new HashSet<>();
        usedLetters = new HashSet<>();

        for (String word : words){
            potentialStarts.add(word.charAt(0));

            char startCharacter = word.charAt(0);
            for (char c : word.toCharArray()){
                if (c!=startCharacter){
                    invalidStarts.add(c);
                }
            }
        }

        potentialStarts.removeAll(invalidStarts);
        for (char start : potentialStarts){
            return solveStart("""",words,start);
        }

        return ""IMPOSSIBLE"";

    }


    private String solveStart(String current, List<String> words, char start){
        if (words.size()==0){
            return current;
        }

        for (int i=0;i<words.size();i++){
            String word = words.get(i);
            if (word.charAt(0)==start){
                boolean onlyChar = true;
                for (char c : word.toCharArray()){
                    if (c!=start){
                        onlyChar=false;
                        break;
                    }
                }
                if (onlyChar){
                    words.remove(i);
                    potentialStarts.remove(start);
                    usedLetters.add(start);
                    return solveStart(current+word,words,start);
                }
            }
        }

        for (int i=0;i<words.size();i++){
            String word = words.get(i);
            if (word.charAt(0)==start){
                words.remove(i);
                char previousChar=start;
                for (char c : word.toCharArray()){
                    potentialStarts.remove(c);

                    if (c!=previousChar){
                        if (usedLetters.contains(c)){
                            return ""IMPOSSIBLE"";
                        }
                    }
                    previousChar=c;

                    usedLetters.add(c);
                }
                return solveStart(current+word,words,word.charAt(word.length()-1));
            }
        }

        for (char newStart : potentialStarts)",dboteanu
724,"public class Solution {

    public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        PrintWriter writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));

        int T = in.nextInt();
        for (int casNumero = 1; casNumero <= T; casNumero++) {
            StringBuilder resultat = new StringBuilder();
            resultat.append(""Case #"");
            resultat.append(casNumero);
            resultat.append("": "");

            int n = in.nextInt();
            int[] dices = new int[n];
            for (int i = 0; i < n; i++) {
                dices[i] = in.nextInt();
            }
            Arrays.sort(dices);
            int y = 0;
            for (int i = 0; i < n; i++) {
                if (dices[i] > y) {
                    y = y + 1;
                }
            }
            resultat.append(y);

            writer.print(resultat.toString());
            writer.println();
        }
        in.close();
        writer.",gerardmr
1083,"public class Solution {

    public static void main(String[] args) {
        Scanner sc = null;
        // try {
            // sc = new Scanner(new FileInputStream(""in.txt""));
        // } catch (FileNotFoundException e) {
            // e.printStackTrace();
        // }
        sc=new Scanner(System.in);
        int T = sc.nextInt();
        for (int t = 0; t < T; t++) {
            String s = sc.next();
            String out = """";
            //System.out.println(s);
            char a = ' ';
            char b = ' ';
            for (int i = 0; i < s.length() - 1; i++) {
                a = s.charAt(i);
                int c = 1;
                b = s.charAt(i + c);
                while (b == a) {
                    if (i + c >= s.length() - 1) {
                        //b = (char) 255;
                        break;
                    }
                    b = s.charAt(i + (++c));
                }
                if (a < b) {
                    out = out + """" + a + """" + a;
                } else {
                    out = out + """" + a;
                }
            }
            out += b;
            System.",raver1975
69,"public class Solution {
	static Scanner sc;
	static StringBuffer s;

  public static void main(String[] args)throws Exception{
	  //sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
	  sc = new Scanner(new BufferedReader(new InputStreamReader(new FileInputStream(new File(""src/input.txt""))))); 
    
     int nbTest = sc.nextInt();
     
	 for(int test = 1;test<=nbTest;test++){ 	   	 	
	 	solve(test);
	 }   
	 
  }
  
  static void solve (int test) {
	  
	  List<Integer> list1 = new ArrayList<Integer>();
	  List<Integer> list2 = new ArrayList<Integer>();
	  List<Integer> list3 = new ArrayList<Integer>();
	  List<Integer> result = new ArrayList<Integer>();
	  int s = 1000000;
	  for (int i = 0; i<4; i++) list1.add(sc.nextInt()); 
	  for (int i = 0; i<4; i++) list2.add(sc.nextInt());
	  for (int i = 0; i<4; i++) list3.add(sc.nextInt());
	  
	  if (somme(list1)<s || somme(list2)<s ||somme(list3)<s ) {
		  System.out.println(""Case #""+test+"": IMPOSSIBLE"");
		  return;
	  }
	  int minC = minimum(list1.get(0), list2.get(0), list3.get(0));
	  int minM = minimum(list1.get(1), list2.get(1), list3.get(1));
	  int minY = minimum(list1.get(2), list2.get(2), list3.get(2));
	  int minK = minimum(list1.get(3), list2.get(3), list3.get(3));
	  
	  if(minC+minM+minY+minK < 1000000) {
		  System.out.println(""Case #""+test+"": IMPOSSIBLE"");
		  return;
	  }
	  
	  
	  result.add(minC);
	  if(minC+minM>s) {
		  System.out.println(""Case #""+test+"": ""+minC+"" ""+(s-minM)+"" 0 0"");
		  return;
	  }else {
		  result.add(minM);
	  }
	  
	  if (minC+minM+minY>s) {
		  System.out.println(""Case #""+test+"": ""+minC+"" ""+minM+"" ""+(s-(minC+minM))+"" 0"");
		  return;
	  } else {
		  result.add(minY);
	  }
	  
	  
	  System.out.println(""Case #""+test+"": ""+minC+"" ""+minM+"" ""+minY+"" ""+
	                                        (s-(minC+minM+minY)));
	  


  }
  

  public static int  minimum (int a, int b, int c) {	 
		return Math.min(Math.min(a, b), c);
	}
  public static int somme(List<Integer> list) {
	  int res = 0;
	  for (int i = ",Bil1983
991,"public class Solution
{
    void calculate(int n, int k) throws IOException //5,3
    {
        Scanner sc = new Scanner(System.in);
        int[] rooms = new int[n]; //0,0,0,0,0
        int[] passages = new int[n]; //0,0,0,0,0
        int[] passages_explored = new int[n]; //0,0,0,0,0
        char[] operation = new char[n];
        Arrays.fill(rooms,0);
        Arrays.fill(passages,0);
        Arrays.fill(passages_explored,0);
        int prediction = 0;
        int count = 0;
        int previous_room = 0;
        char previous_operation = 'W';
        int max_passages = 0;
        for(int j=1; j<n; j++)
            max_passages += j;
        String[] connected_rooms = new String[max_passages];
        for(int i=0; i<n; i++)
        {
            int current_room = Integer.parseInt(sc.next());
            int number_of_passages = Integer.parseInt(sc.next());
            if(current_room == -1 || number_of_passages == -1)
                System.exit(0);
            rooms[current_room-1] = current_room;
            passages[current_room-1] = number_of_passages;
            if(i == 0)
            {
                previous_room = current_room;
                System.out.println(""W"");
                passages_explored[current_room-1]++;
                continue;
            }
            String text;
            boolean check = false; //has it been through this passage before
            int cr_index = 0;
            while(connected_rooms[cr_index] != null)
            {
                text = connected_rooms[cr_index];
                //System.out.println(text);
                if(text.startsWith(Integer.toString(current_room)) || text.endsWith(Integer.toString(current_room)))
                {
                    if(text.startsWith(Integer.toString(previous_room)) || text.endsWith(Integer.toString(previous_room)))
                    {
                        check = true;
                        break;
                    }
                }
                cr_index++;
            }
            if(!check && previous_operation=='W')
            {
                connected_rooms[i-1] = previous_room+"" to ""+current_room;
                //System.out.println(connected_rooms[i-1]);
                //System.out.println(previous_room+"" to ""+current_room);
            }
            if(passages_explored[current_room-1] < passages[current_room-1])
            {
                passages_explored[current_room-1]++;
                previous_operation = 'W';
                if(i!=k)
                    System.out.println(""W"");
            }
            else
            {
                previous_operation = 'T';
                if(i!=k)
                {
                    int random = current_room-1;
                    while(rooms[random] != 0)
                    {
                        random = new Random().nextInt(rooms.length);
                    }
                    random++;
                    System.out.println(""T ""+random);
                }
            }
            if(i == k)
                break;
            previous_room = current_room;
            boolean test = true;
            for(int j=0; j<n; j++)
            {
                if(rooms[j] == 0)
                {
                    test = false;
                    break;
                }
            }
            if(test)
                break;
        }
        String text;
        int cr_index = 0;
        /*while((text = connected_rooms[cr_index++]) != null)
        {
            //System.out.println(text);
            count++;
        }*/
        while(cr_index <= k)
        {
            if(connected_rooms[cr_index++] != null)
                count++;
        }
        int sum = 0;
        for(int i=0; i<n; i++)
        {
            //sum += passages_explored[i];
            sum += passages[i];
            if(rooms[i] == 0)
                sum++;
        }
        //System.out.println(sum);
        //System.out.println(count);
        prediction = sum - count;
        System.out.println(""E ""+prediction);
    }
    public static void main(String[] args)
    {
        Solution obj = new Solution();
        Scanner sc = new Scanner (System.in);
        int t = sc.nextInt();
        String dummy = sc.nextLine();
        for(int i=0; i<t; i++)
        {
            int n = Integer.parseInt(sc.next());
            int k = Integer.parseInt(sc.next());
            //obj.calculate(n,k);
            try
            {
                obj.calculate(n,k);
            }
            catch(IOException e)
            {
                System.",nocturnalspider
1220,"public class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int T = in.nextInt();
        for (int t = 1; t <= T; t++) {
            int N = in.nextInt();
            int[] scores = new int[N];
            int[] parents = new int[N];
            int[] minChildScores = new int[N];
            for (int i = 0; i < N; i++) {
                scores[i] = in.nextInt();
            }
            for (int i = 0; i < N; i++) {
                parents[i] = in.nextInt() - 1;
            }

            long total = 0;
            for (int i = N - 1; i >= 0; i--) {
                int parent = parents[i];
                int maxScore = Math.max(scores[i], minChildScores[i]);
                if (parent == -1) {
                    // Points at abyss
                    total += maxScore;
                } else {
                    // Points at another module
                    if (minChildScores[parent] == 0) {
                        minChildScores[parent] = maxScore;
                    } else {
                        total += Math.max(minChildScores[parent], maxScore);
                        minChildScores[parent] = Math.min(minChildScores[parent], maxScore);
                    }
                }
            }

            System.",teekaytai
1174,"public class Solution {
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
        int t = safeReadInt(scanner);
        for(int i = 0; i < t; ++i){
            solve(scanner);
        }
    }

    public static void solve(Scanner scanner ){
        int n = safeReadInt(scanner); // number of rooms
        int k = safeReadInt(scanner); // number of interactions
        int r = safeReadInt(scanner); //current room
        int p = safeReadInt(scanner); //current num of passages
        if(k > n){
            k = n;
        }
        List<Integer> roomsToExplore = IntStream.range(1,n+1).boxed().collect(Collectors.toList());
        Collections.swap(roomsToExplore,0,r-1);
        Collections.shuffle(roomsToExplore);
        long count = p;
        for(int i = 1; i < k; ++i){
            int room = roomsToExplore.get(i);
            System.out.println(String.format(""T %d"",room));
            r = safeReadInt(scanner); //current room
            p = safeReadInt(scanner); //current num of passages
            count += p;
        }
        long guess = Math.round((count/2.0)*(n/Double.valueOf(k)));
        System.out.println(String.format(""E %d"",guess));
    }

    public static int safeReadInt(Scanner scanner){
        int i = ",smartelf
5,"public class Solution {

  public static void main(String[] args) throws Throwable {
    try (BufferedReader in=new BufferedReader(new InputStreamReader(System.in))) {
      try (PrintStream out=System.out) {
        final int T=Integer.parseInt(in.readLine());
        for (int c=1; c<=T; c++) {
          StringTokenizer tokenizer=new StringTokenizer(in.readLine());
          final int N=Integer.parseInt(tokenizer.nextToken());
          final int P=Integer.parseInt(tokenizer.nextToken());
          final long matrix[][]=new long[N][P];
          for (int i=0; i<N; i++) {
            tokenizer=new StringTokenizer(in.readLine());
            for (int j=0; j<P; j++) matrix[i][j]=Integer.parseInt(tokenizer.nextToken());
            Arrays.sort(matrix[i]);
          }
          final Range ranges[]=new Range[N];
          for (int i=0; i<N; i++) ranges[i]=new Range(matrix[i][0],matrix[i][P-1]);
          final long solution=solveFast(ranges,N,P);
          out.print(""Case #""+c+"": "");
          out.println(solution);
        }
      }
    }
  }

  public static final Map<long[],Long> memory=new TreeMap<>(Arrays::compare);

  public static long solveFast(Range[] ranges, int N, int P) {
    memory.clear();
    return solveFast(ranges,N,P,0,0L);
  }

  public static long solveFast(Range[] ranges, int N, int P, int i, long lastValue) {
    if (i==ranges.length) {
      return 0L;
    }
    else {
      final long key[]=new long[]{i,lastValue};
      final Long answer=memory.get(key);
      if (answer!=null) return answer;
      long best=Long.MAX_VALUE;
      final long x=solveFast(ranges,N,P,i+1,ranges[i].max)+Math.abs(lastValue-ranges[i].min)+ranges[i].length;
      final long y=solveFast(ranges,N,P,i+1,ranges[i].min)+Math.abs(lastValue-ranges[i].max)+ranges[i].length;
      best=Math.min(best,Math.min(x,y));
      memory.put(key,best);
      return best;
    }
  }

  private static final class Range {

    private final long min;
    private final long max;
    private final long length;

    private Range(long min, long max) {
      this.min=min;
      this.max=max;
      this.length=",ASotelo
40,"public class Solution {

    /**
     * @param args the command line arguments
     */
    
 
    
    public static void main(String[] args) {
          Scanner keyboard = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
    int a;
    int[][]array1;
int c=0;
int m=0;
int y=0;
int k=0;
    
    a = keyboard.nextInt();
    array1 = new int[a][12];

    
for (int b = 0; b<a; b++)
{
    for (int z = 0; z < 12; z++)
    {
  array1[b][z]=keyboard.nextInt();
    }
}
for (int d = 0; d < a; d++)
{

   if ((array1[d][0]<=array1[d][4])&&(array1[d][0]<=array1[d][8]))
           {
               c = array1[d][0];
           }
   else if (array1[d][4]<=array1[d][8])
   {        
               c = array1[d][4];
   }
   else
               c = array1[d][8];

   if ((array1[d][1]<=array1[d][5])&&(array1[d][1]<=array1[d][9]))
           {
               m = array1[d][1];
           }
   else if (array1[d][5]<=array1[d][9])
   {        
               m = array1[d][5];
   }
   else
               m = array1[d][9];

   if ((array1[d][2]<=array1[d][6])&&(array1[d][2]<=array1[d][10]))
           {
               y = array1[d][2];
           }
   else if (array1[d][6]<=array1[d][10])
   {        
               y = array1[d][5];
   }
   else
               y = array1[d][10];
   
      if ((array1[d][3]<=array1[d][7])&&(array1[d][3]<=array1[d][11]))
           {
               k = array1[d][3];
           }
   else if (array1[d][7]<=array1[d][11])
   {        
               k = array1[d][7];
   }
   else
               k = array1[d][11];



        if ((c+m+y+k)<1000000)
{
    System.out.println(""Case #""+(d+1)+"" IMPOSSIBLE"");
}
         
        else if (c+m+y+k>1000000)
        {
            if (c==1000000)
            {
                y = 0;
                m = 0; 
                k = 0;
            }
            
            else if (m==1000000)
            {
                y = 0;
                c = 0; 
                k = 0;
            }
            else if (y==1000000)
            {
                c = 0;
                m = 0; 
                k = 0;
            }
            else if (k==1000000)
            {
                y = 0;
                m = 0; 
                c = 0;
            }
        
            else if (c+m>=100000)
        {
               if (c+m<1000000)
               {
                   m = (1000000 - (c));
                   m=0;
                   k = 0;
               }
               else
               {
                   y = 0;
                   k = 0;
               }
        }
         else if (c+y>=100000)
        {
               if (c+y<1000000)
               {
                   y = (1000000 - (c));
                   m=0;
                   k = 0;
               }
               else
               {
                   m = 0;
                   k = 0;
               }
        }   
         else if (c+k>=100000)
        {
               if (c+k<1000000)
               {
                   k = (1000000 - (c));
                   m=0;
                   y = 0;
               }
               else
               {
                   m = 0;
                   y = 0;
               }
        }   
         else if (m+y>=100000)
        {
               if (m+y<1000000)
               {
                   m = (1000000 - (k));
                   c=0;
                   y = 0;
               }
               else
               {
                   c = 0;
                   y = 0;
               }
        }
         
         else if (m+k>=100000)
        {
               if (m+k<1000000)
               {
                   k = (1000000 - (m));
                   c=0;
                   y = 0;
               }
               else
               {
                   c = 0;
                   y = 0;
               }
        }
         
         else if (y+k>=100000)
        {
               if (y+k<1000000)
               {
                   k = (1000000 - (y));
                   m=0;
                   c = 0;
               }
               else
               {
                   m = 0;
                   c = 0;
               }
        }       
            
            
            
            
            else if (c+m+y>=100000)
        {
               if (c+m<1000000)
               {
                   y = (1000000 - (c+m));
                   k = 0;
               }
               else 
                   k=0;
        }
            
        else if (c+m+k>=100000)
        {
               if (c+m<1000000)
               {
                   k = (1000000 - (c+m));
                   y = 0;
               }
               else y = 0;
        }    
            
                else if (y+m+k>=100000)
        {
               if (y+k<1000000)
               {
                   m = ",Ak9
829,"public class Solution {

    public static void main(String[] args) {

        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.

        int N;
        long[] dices;
        for (int i = 1; i <= t; i++) {
            N = in.nextInt();
            dices = new long[N];
            for (int j = 0; j < N; j++) {
                dices[j] = in.nextLong();
            }
            System.out.print(""Case #"" + i + "": "");
            getStairs(dices);
            if(t!=i)
                System.out.println("""");
        }

    }

    public static void getStairs(long[] dices){

        long x = 0;
        Arrays.sort(dices);
        for (long dice : dices) {
            if (x < dice) {
                x++;
            }
        }

        System.",jonathan38m
32,"public class Solution {

    /**
     * @param args the command line arguments
     */
    
 
    
    public static void main(String[] args) {
          Scanner keyboard = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
    int a;
    int[][]array1;
int c=0;
int m=0;
int y=0;
int k=0;
    
    a = keyboard.nextInt();
    array1 = new int[a][12];

    
for (int b = 0; b<a; b++)
{
    for (int z = 0; z < 12; z++)
    {
  array1[b][z]=keyboard.nextInt();
    }
}
for (int d = 0; d < a; d++)
{

   if ((array1[d][0]<=array1[d][4])&&(array1[d][0]<=array1[d][8]))
           {
               c = array1[d][0];
           }
   else if (array1[d][4]<=array1[d][8])
   {        
               c = array1[d][4];
   }
   else
               c = array1[d][8];

   if ((array1[d][1]<=array1[d][5])&&(array1[d][1]<=array1[d][9]))
           {
               m = array1[d][1];
           }
   else if (array1[d][5]<=array1[d][9])
   {        
               m = array1[d][5];
   }
   else
               m = array1[d][9];

   if ((array1[d][2]<=array1[d][6])&&(array1[d][2]<=array1[d][10]))
           {
               y = array1[d][2];
           }
   else if (array1[d][6]<=array1[d][10])
   {        
               y = array1[d][5];
   }
   else
               y = array1[d][10];
   
      if ((array1[d][3]<=array1[d][7])&&(array1[d][3]<=array1[d][11]))
           {
               k = array1[d][3];
           }
   else if (array1[d][7]<=array1[d][11])
   {        
               k = array1[d][7];
   }
   else
               k = array1[d][11];



        if ((c+m+y+k)<1000000)
{
    System.out.println(""Case #""+(d+1)+"": IMPOSSIBLE"");
}
         
        else if (c+m+y+k>1000000)
        {
            if (c==1000000)
            {
                y = 0;
                m = 0; 
                k = 0;
            }
            
            else if (m==1000000)
            {
                y = 0;
                c = 0; 
                k = 0;
            }
            else if (y==1000000)
            {
                c = 0;
                m = 0; 
                k = 0;
            }
            else if (k==1000000)
            {
                y = 0;
                m = 0; 
                c = 0;
            }
        
            else if (c+m>=1000000)
        {
               if (c+m>1000000)
               {
                   m = (1000000 - (c));
                   y=0;
                   k = 0;
               }
               else
               {
                   y = 0;
                   k = 0;
               }
        }
         else if (c+y>=1000000)
        {
               if (c+y>1000000)
               {
                   y = (1000000 - (c));
                   m=0;
                   k = 0;
               }
               else
               {
                   m = 0;
                   k = 0;
               }
        }   
         else if (c+k>=1000000)
        {
               if (c+k>1000000)
               {
                   k = (1000000 - (c));
                   m=0;
                   y = 0;
               }
               else
               {
                   m = 0;
                   y = 0;
               }
        }   
         else if (m+y>=1000000)
        {
               if (m+y>1000000)
               {
                   m = (1000000 - (k));
                   c=0;
                   y = 0;
               }
               else
               {
                   c = 0;
                   y = 0;
               }
        }
         
         else if (m+k>=1000000)
        {
               if (m+k>1000000)
               {
                   k = (1000000 - (m));
                   c=0;
                   y = 0;
               }
               else
               {
                   c = 0;
                   y = 0;
               }
        }
         
         else if (y+k>=1000000)
        {
               if (y+k>1000000)
               {
                   k = (1000000 - (y));
                   m=0;
                   c = 0;
               }
               else
               {
                   m = 0;
                   c = 0;
               }
        }       
            
            
            
            
            else if (c+m+y>=1000000)
        {
               if (c+m>1000000)
               {
                   y = (1000000 - (c+m));
                   k = 0;
               }
               else 
                   k=0;
        }
            
        else if (c+m+k>=1000000)
        {
               if (c+m>1000000)
               {
                   k = (1000000 - (c+m));
                   y = 0;
               }
               else 
                   y = 0;
        }    
            
                else if (y+m+k>=1000000)
        {
               if (y+k>1000000)
               {
                   m = ",Ak9
12,"public class Solution {

  public static void main(String[] args) throws Throwable {
    try (BufferedReader in=new BufferedReader(new InputStreamReader(System.in))) {
      try (PrintStream out=System.out) {
        final int T=Integer.parseInt(in.readLine());
        for (int c=1; c<=T; c++) {
          final int N=Integer.parseInt(in.readLine());
          final String S[]=new String[N];
          final StringTokenizer tokenizer=new StringTokenizer(in.readLine());
          for (int i=0; i<N; i++) {
            S[i]=tokenizer.nextToken();
          }
          String solution=solve(S);
          if (solution==null) solution=""IMPOSSIBLE"";
          out.print(""Case #""+c+"": "");
          out.println(new String(solution));
        }
      }
    }
  }

  public static String solve(String[] S) {
    for (String s:S) if (!isGood(s)) return null;
    final List<String> igu=new ArrayList<>(),agu=new ArrayList<>();
    for (String s:S) (s.charAt(0)==s.charAt(s.length()-1)?igu:agu).add(s);
    Collections.sort(igu);
    Collections.sort(agu);
    while (true) {
      final int t=agu.size()+igu.size();
      for (int i=0; i<agu.size(); i++) for (int j=0; j<igu.size(); j++) {
        if (igu.get(j).charAt(0)==agu.get(i).charAt(0)) {
          agu.set(i,igu.get(j)+agu.get(i));
          igu.remove(j);
        }
        else if (igu.get(j).charAt(0)==agu.get(i).charAt(agu.get(i).length()-1)) {
          agu.set(i,agu.get(i)+igu.get(j));
          igu.remove(j);
        }
      }
      if (agu.size()+igu.size()==t) break;
    }
    loop: while (true) {
      final int freq[]=new int[26];
      for (String s:S) for (int i=0; i<s.length(); i++) if (i==0||s.charAt(i)!=s.charAt(i-1)) freq[s.charAt(i)-'A']++;
      for (int i=0; i<agu.size(); i++) for (int j=0; j<agu.size(); j++) if (i!=j) {
        if (agu.get(j).charAt(0)==agu.get(i).charAt(agu.get(i).length()-1)&&freq[agu.get(j).charAt(0)-'A']==2) {
          agu.set(i,agu.get(i)+agu.get(j));
          agu.remove(j);
          continue loop;
        }
      }
      break;
    }
    final StringBuilder builder=new StringBuilder();
    for (String s:igu) builder.append(s);
    for (String s:agu) builder.append(s);
    final String solution=builder.toString();
    if (!isGood(solution)) return null;
    return solution;
  }

  public static boolean isGood(String text) {
    final char[] s=text.toCharArray();
    for (int i=0; i<s.length; i++) for (int j=i+2; j<s.length; j++) if (s[i]==s[j]) {
      for (int k=",ASotelo
1075,"public class Solution {
    public static int straight(TreeMap<Integer, Integer> map){
        int number = 0;
        while(!map.isEmpty()){
            Map.Entry<Integer, Integer> firstEntry = map.pollFirstEntry();
            int minKey = firstEntry.getKey();
            int minKeyCount = firstEntry.getValue();

            if(number + minKeyCount > minKey){
                number = minKey;
            }
            else{
                number += minKeyCount;
            }
        }
        return number;
    }


    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        for(int Case = 1; Case <= T; Case ++){
            int N = sc.nextInt();
            TreeMap<Integer, Integer> map = new TreeMap<>();
            for(int i = 0; i < N; i ++){
                int temp = sc.nextInt();
                if(map.containsKey(temp)){
                    map.put(temp, map.get(temp) + 1);
                }
                else{
                    map.put(temp, 1);
                }
            }
            System.",ql309
667,"public class Solution {
    public static int N;
    public static HashSet<Integer> seen;
    public static long total;
    public static void main(String[] args) throws IOException {
        Scanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int T = input.nextInt();
        for (int iter = 1; iter<=T; iter++) {
            int N = input.nextInt();
            if (N==-1) return;
            int K = input.nextInt();
            if (K==-1) return;
            seen = new HashSet<>();
            System.out.println(""E ""+trial(N,K));
        }
    }
    public static long trial(int N, int K) throws IOException {
        Scanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        total = 0;
        for (int i = 0; i<K; i++) {
            int R = input.nextInt();
            if (R==-1) {
                int a = 1/0;
            }
            int P = input.nextInt();
            if (P==-1) {
                int a = 1/0;
            }
            seen.add(R);
            total+=P;
            if (seen.size()==N) {
                return total/2;
            }
            System.out.println(""T ""+(i+1));
        }
        int R = input.nextInt();
        if (R==-1) {
            int a = 1/0;
        }
        int P = input.nextInt();
        if (P==-1) {
            int a = ",ekwek
519,"public class Solution{

    static long MOD = 1_000_000_007L;
    //static long MOD = 998_244_353L;
    //static long MOD = 1_000_000_033L;
    static long inv2 = (MOD + 1) / 2;
    static long [] fac;
    static long [] pow;
    static long [] inv;
    static long [] invFac;
    static int[][] dir = new int[][]{{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
    static long lMax = 0x3f3f3f3f3f3f3f3fL;
    static int iMax = 0x3f3f3f3f;
    static HashMap <Long, Long> memo = new HashMap();
    static MyScanner sc = new MyScanner();
    //static ArrayList <Integer> primes;

    static long[] pow2;
    static int[] base;
    static int[] numOfDiv;
    static ArrayList <Integer> primes;
    //-----------PrintWriter for faster output---------------------------------
    public static PrintWriter out;
    public static void main(String[] args) {
        out = new PrintWriter(new BufferedOutputStream(System.out));
        // Start writing your solution here. -------------------------------------

        int nn = 300000;

        /*fac = new long[nn + 1];
        fac[1] = 1;
        for(int i = 2; i <= nn; i++)
            fac[i] = fac[i - 1] * 1L * i % MOD;*/

        /*pow = new long[nn + 1];
        pow[0] = 1L;
        for(int i = 1; i <= nn; i++)
            pow[i] = pow[i - 1] * 2L % MOD;
        pow[1] = 3L;*/

        /*
        pow2 = new long[nn + 1];
        pow2[0] = 1L;
        for(int i = 1; i <= nn; i++)
            pow2[i] = pow2[i - 1] * 2L;*/

        /*inv = new long[nn + 1];
        inv[1] = 1;
        for (int i = 2; i <= nn; ++i)
            inv[i] = (MOD - MOD / i) * inv[(int)(MOD % i)] % MOD;

        invFac = new long[nn + 1];
        invFac[1] = 1;
        for(int i = 2; i <= nn; i++)
            invFac[i] = invFac[i - 1] * inv[i] % MOD;*/

        //primes = sieveOfEratosthenes(100001);


        /*for(int i = 2; i <= 20000000; i++)
            if(numOfDiv[i] == 0)
                for(int j = i; j <= 20000000; j += i)
                    numOfDiv[j] ++;*/

        int t = 1, tt = 0;
        t = sc.ni();
        while(tt++ < t) {
            //long res = solve();
            out.print(""Case #"" + tt + "": "");
            solve();
            //out.println(res);
        }
        out.close();
    }
    static void solve() {
        int[][] nums = new int[3][4];
        for(int i = 0; i < 3; i++) for(int j = 0; j < 4; j++) nums[i][j] = sc.ni();
        int[] min = new int[4];
        for(int i = 0; i < 4; i++) min[i] = Math.min(nums[0][i], Math.min(nums[1][i], nums[2][i]));
        int sum = min[0] + min[1] + min[2] + min[3];
        if(sum < 1000000) out.println(""IMPOSSIBLE"");
        else {
            int left = 1000000;
            for(int i = 0; i < 4; i++) {
                min[i] = Math.min(min[i], left);
                left -= min[i];
            }
            out.println(min[0] + "" "" + min[1] + "" "" + min[2] + "" "" + min[3]);
        }
    }

    static long c(int a, int b) {
        if(a <= 0 || b <= 0 || a <= b) return 1L;
        return fac[a] * invFac[b] % MOD * invFac[a - b] % MOD;
    }

    // SegmentTree range min/max query From uwi
    public static class SegmentTreeRMQ {
        public int M, H, N;
        public long[] st;

        public SegmentTreeRMQ(int n)
        {
            N = n;
            M = Integer.highestOneBit(Math.max(N-1, 1))<<2;
            H = M>>>1;
            st = new long[M];
            Arrays.fill(st, 0, M, Integer.MAX_VALUE);
        }

        public SegmentTreeRMQ(long[] a)
        {
            N = a.length;
            M = Integer.highestOneBit(Math.max(N-1, 1))<<2;
            H = M>>>1;
            st = new long[M];
            for(int i = 0;i < N;i++){
                st[H+i] = a[i];
            }
            Arrays.fill(st, H+N, M, Integer.MAX_VALUE);
            for(int i = H-1;i >= 1;i--)propagate(i);
        }

        public void update(int pos, int x)
        {
            st[H+pos] = x;
            for(int i = (H+pos)>>>1;i >= 1;i >>>= 1)propagate(i);
        }

        private void propagate(int i)
        {
            st[i] = Math.min(st[2*i], st[2*i+1]);
        }

        public long minx(int l, int r){
            long min = Long.MAX_VALUE;
            if(l >= r) return min;
            while(l != 0){
                int f = l&-l;
                if(l+f > r)break;
                long v = st[(H+l)/f];
                if(v < min)min = v;
                l += f;
            }

            while(l < r){
                int f = r&-r;
                long v = st[(H+r)/f-1];
                if(v < min) min = v;
                r -= f;
            }
            return min;
        }

        public long min(int l, int r){ return l >= r ? 0 : min(l, r, 0, H, 1);}

        private long min(int l, int r, int cl, int cr, int cur)
        {
            if(l <= cl && cr <= r){
                return st[cur];
            }else{
                int mid = cl+cr>>>1;
                long ret = Long.MAX_VALUE;
                if(cl < r && l < mid){
                    ret = Math.min(ret, min(l, r, cl, mid, 2*cur));
                }
                if(mid < r && l < cr){
                    ret = Math.min(ret, min(l, r, mid, cr, 2*cur+1));
                }
                return ret;
            }
        }
    }

    public static char[] rev(char[] a){char[] b = new char[a.length];for(int i = 0;i < a.length;i++)b[a.length-1-i] = a[i];return b;}
    public static int[] rev(int[] a, int start, int end){int[] b = a.clone();for(int i = start;i <= end;i++) b[start + end - i] = a[i];return b;}
    public static int[] rev(int[] a){return rev(a, 0, a.length - 1);}

    public static double dist(double a, double b){
        return Math.sqrt(a * a + b * b);
    }
    public static double dist(int[] A, int[] B){
        return dist(1.0 * A[0] - B[0], 1.0 * A[1] - B[1]);
    }

    public static long inv(long a){
        return quickPOW(a, MOD - 2);
    }

    public class Interval {
        int start;
        int end;
        public Interval(int start, int end) {
            this.start = start;
            this.end = end;
        }
    }

    public static ArrayList<Integer> sieveOfEratosthenes(int n) {
        boolean prime[] = new boolean[n + 1];
        Arrays.fill(prime, true);
        for (int p = 2; p * p <= n; p++) {
            if (prime[p]) {
                for (int i = p * 2; i <= n; i += p) {
                    prime[i] = false;
                }
            }
        }
        ArrayList<Integer> primeNumbers = new ArrayList<>();
        for (int i = 2; i <= n; i++) {
            if (prime[i]) {
                primeNumbers.add(i);
            }
        }
        return primeNumbers;
    }


    public static int lowerBound(int[] a, int v){ return lowerBound(a, 0, a.length, v); }
    public static int lowerBound(int[] a, int l, int r, int v)
    {
        if(l > r || l < 0 || r > a.length)throw new IllegalArgumentException();
        int low = l-1, high = r;
        while(high-low > 1){
            int h = high+low>>>1;
            if(a[h] >= v){
                high = h;
            }else{
                low = h;
            }
        }
        return high;
    }
    public static int rlowerBound(int[] a, int v){ return lowerBound(a, 0, a.length, v); }
    public static int rlowerBound(int[] a, int l, int r, int v)
    {
        if(l > r || l < 0 || r > a.length)throw new IllegalArgumentException();
        int low = l-1, high = r;
        while(high-low > 1){
            int h = high+low>>>1;
            if(a[h] <= v){
                high = h;
            }else{
                low = h;
            }
        }
        return high;
    }

    public static long C(int n, int m)
    {
        if(m == 0 || m == n) return 1l;
        if(m > n || m < 0) return 0l;
        long res = fac[n] * quickPOW((fac[m] * fac[n - m]) % MOD, MOD - 2) % MOD;
        return res;
    }
    public static long quickPOW(long n, long m)
    {
        long ans = 1l;
        while(m > 0)
        {
            if(m % 2 == 1)
                ans = ",anhpp123
842,"class Solution{
    public static void main(String[] args){
        Scanner s = new Scanner(System.in);
        int t = s.nextInt();
        int x = t;
        while(t>0){
            System.out.print(""Case #""+(x-(t-1))+"":"");
            int a1 = s.nextInt();
            int a2 = s.nextInt();
            int a3 = s.nextInt();
            int a4 = s.nextInt();
            int b1 = s.nextInt();
            int b2 = s.nextInt();
            int b3 = s.nextInt();
            int b4 = s.nextInt();
            int c1 = s.nextInt();
            int c2 = s.nextInt();
            int c3 = s.nextInt();
            int c4 = s.nextInt();
            int min1 = Math.min(a1, Math.min(b1, c1));
            int min2 = Math.min(a2, Math.min(b2, c2));
            int min3 = Math.min(a3, Math.min(b3, c3));
            int min4 = Math.min(a4, Math.min(b4, c4));
            int c  = 0;
            int d = 0;
            if(min1+min2+min3+min4 <1000000){
                System.out.print("" IMPOSSIBLE"");
                System.out.println();
            }
            else if(min1+min2+min3+min4 ==1000000){
                System.out.print("" ""+min1);
                System.out.print("" ""+min2);
                System.out.print("" ""+min3);
                System.out.print("" ""+min4);
                System.out.println();
            }
            else if(min1+min2+min3+min4 >1000000){
                int twoSum = min1+min2;
                int rem = 1000000 - twoSum;
               
                if(min3< rem && min4> rem){
                    c = min3;
                    d = 1000000 - (c+twoSum);
                }
                if(min3> rem && min4< rem){
                    d = min3;
                    c = 1000000 - (d+twoSum);
                }
                else if(min3<rem && min4<rem){
                    if(min3+min4 == rem){
                        c = min3;
                        d = min4;
                    }
                    else{
                        c = rem-min3;
                        d = 1000000 -(c+twoSum);
                    }
                   
                }
                else if(min3>rem){
                    c= min3-rem;
                    d = 1000000 -(c+twoSum);
                }
                else if(min4>rem){
                    d = min4-rem;
                    c = 1000000 -(d+twoSum);
                }
                System.out.print("" ""+min1);
                System.out.print("" ""+min2);
                System.out.print("" ""+c);
                System.out.print("" ""+d);
                System.",kaushik_0705
1013,"public class Solution {
    public static void main(String[] args) {
        Scanner inp = new Scanner(System.in);

        int t = inp.nextInt();

        for (int j = 0; j < t; j++) {
            System.out.printf(""Case #%d: "",j+1);
            int c = inp.nextInt();
            int m = inp.nextInt();
            int y = inp.nextInt();
            int k = inp.nextInt();
            for (int i = 0; i <2 ; i++){
                int c1 = inp.nextInt();
                int m1 = inp.nextInt();
                int y1 = inp.nextInt();
                int k1 = inp.nextInt();

                c = (c1<c) ? c1 : c ;
                m = (m1<m) ? m1 : m ;
                y = (y1<y) ? y1 : y ;
                k = (k1<k) ? k1 : k ;

            }

            if(c == 1000000)
                System.out.printf(""%d %d %d %d
"",c,0,0,0);
            else if(m == 1000000)
                System.out.printf(""%d %d %d %d
"",0,m,0,0);
            else if(y == 1000000)
                System.out.printf(""%d %d %d %d
"",0,0,y,0);
            else if(k == 1000000)
                System.out.printf(""%d %d %d %d
"",0,0,0,k);
            else if((c+m+y+k)<1000000)
                System.out.println(""IMPOSSIBLE"");
            else if(c + m + k <= 1000000)
                System.out.printf(""%d %d %d %d
"",c,m,1000000-c-m-k,k);
            else if(c + k + y <= 1000000)
                System.out.printf(""%d %d %d %d
"",c,1000000-c-k-y,y,k);
            else if(k + m + y <= 1000000)
                System.out.printf(""%d %d %d %d
"",1000000-k-m-y,m,y,k);
            else if(c + m + y <= 1000000)
                System.out.printf(""%d %d %d %d
"",c,m,y,1000000-c-m-y);
            
            else if((c + m >= 1000000)&&(m>c) )
                System.out.printf(""%d %d %d %d
"",c,1000000-c,0,0);
            else if((c + m >= 1000000))
                System.out.printf(""%d %d %d %d
"",1000000-m,m,0,0);
                
            else if((c + y >= 1000000)&&(y>c) )
                System.out.printf(""%d %d %d %d
"",c,0,1000000-c,0);
            else if(c + y >= 1000000 )
                System.out.printf(""%d %d %d %d
"",1000000-y,0,y,0);
                
            else if((c + k >= 1000000)&&(c>k ))
                System.out.printf(""%d %d %d %d
"",1000000-k,0,0,k);
            else if(c + k >= 1000000 )
                System.out.printf(""%d %d %d %d
"",c,0,0,1000000-c);
                
            else if((m + k >= 1000000)&&(k>m) )
                System.out.printf(""%d %d %d %d
"",0,m,0,1000000-m);
            else if(m + k >= 1000000 )
                System.out.printf(""%d %d %d %d
"",0,1000000-k,0,k);
                
            else if((m + y >= 1000000)&&(y>m) )
                System.out.printf(""%d %d %d %d
"",0,m,1000000-m,0);
            else if(m + y >= 1000000 )
                System.out.printf(""%d %d %d %d
"",0,1000000-y,y,0);
                
            else if((y + k >= 1000000)&&(k>y) )
                System.out.printf(""%d %d %d %d
"",0,0,y,1000000-y);
            else if(y + k >= 1000000 )
                System.out.printf(""%d %d %d %d
"",0,0,1000000-k,k);

        }
    }
}",parthanos
381,"public class Solution {
    public static Scanner scan;
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int runtime = scan.nextInt();
        int a=1000000000;
        for(int i=0;i<runtime;i++){
            int num=scan.nextInt();
            int [] array=new int[num];
            for(int j=0;j<num;j++){
                int numside=scan.nextInt();
                array[j]=numside;
            }
            Arrays.sort(array);
            System.out.print(""Case #""+"" ""+(i+1)+"":"");
            int t=0;
            for(int d=0;d<array.length;d++) {
                t++;
                if (array[d]<t) {
                    t--;
                }
            }
            System.",ShuoXu
627,"public class Solution {

    private static CodeJamIO io = new CodeJamIO();

    /**
     * @param args
     */
    public static void main(String[] args) {

        try {
            init();

            int numCases = Integer.parseInt(io.readNextLine()[0]);
            for (int i=1; i <= numCases; i++) {
                io.debug(""Solving Case #"" + i + ""..."");
                solveCase(i);
                io.debug(""Case #"" + i + "" solved!"");
            }

        } catch (Exception e) {
            e.printStackTrace();
        }

    }

    /**
     * Performs initial computations
     */
    private static void init() {

    }

    /**
     * Solves a Test Case
     *
     * @param caseNum
     * @throws IOException
     */
    private static void solveCase(int caseNum) throws IOException {
        // Read input
        String[] tokens = io.readNextLine();
        int n = Integer.parseInt(tokens[0]);
        int k = Integer.parseInt(tokens[1]);
        if (k > n) {
            k = n;
        }

        // Interact
        double[] p = new double[n];
        double e = 0;
        Set<Integer> rooms = new HashSet<>();

        tokens = io.readNextLine();
        rooms.add(Integer.parseInt(tokens[0]));
        int passages = Integer.parseInt(tokens[1]);
        p[0] = passages;
        e += p[0];
        double sum = 0;

        for (int i=0; i<k-1; i++) {
            if (p[i] > i) {
                io.println(""W"");
            } else {
                io.println(""T "" + String.valueOf(pickRoom(n, rooms)));
            }
            tokens = io.readNextLine();
            rooms.add(Integer.parseInt(tokens[0]));
            passages = Integer.parseInt(tokens[1]);
            if (p[i] > i) {
                p[i+1] = passages - 1;
            } else {
                p[i+1] = passages - p[i] / (n-1);
            }
            p[i+1] -= sum / (n-1);
            e += p[i+1];
            sum += p[i];
        }
        double mean = e / n;
        for (int i=k; i<n-1; i++) {
            sum += p[i];
            p[i+1] = mean - sum / (n-1);
            e += p[i+1];
        }

        // Print results
        io.println(""E "" + String.valueOf(Math.round(e)));
    }

    private static int pickRoom(int n, Set<Integer> rooms) {
        for (int i=0; i<n; i++) {
            if (!rooms.contains(i+1)) {
                return i+1;
            }
        }
        throw new RuntimeException();
    }

    /**
     * Input and Output CodeJam style
     *
     */
    private static class CodeJamIO {
        private static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        private static PrintWriter out = new PrintWriter(System.out, true);
        private static PrintWriter err = new PrintWriter(System.err, true);

        public String[] readNextLine() throws IOException {
            String line = in.readLine();
            String[] tokens = line.split(""\\\s+"");
            return tokens;
        }

        public CodeJamIO printCase(int caseNum) { return print(""Case #"" + caseNum + "": "" ); }

        public CodeJamIO print(Object o) { out.print(o); return this; }

        public CodeJamIO print(Object o[]) { return print(concat(o)); }

        public CodeJamIO print(Object o[][]) { return print(concat(o)); }

        public CodeJamIO println() { out.println(); return this; }

        public CodeJamIO printlnCase(int caseNum) { return printCase(caseNum).println(); }

        public CodeJamIO println(Object o) { return print(o).println(); }

        public CodeJamIO println(Object o[]) { return print(o).println(); }

        public CodeJamIO println(Object o[][]) { return print(concat(o)).println(); }

        public CodeJamIO println(List<Integer[]> l) { return print(concat(l)).println(); }


        private String concat(Object[] o) {
            StringBuffer buf = new StringBuffer(10*o.length);

            String delim = """";
            for (int i=0; i < o.length; i++) {
                buf.append(delim).append(o[i]);
                delim = "" "";
            }
            return buf.toString();
        }

        private String concat(Object[][] o) {
            StringBuffer buf = new StringBuffer(100*o.length);
            for (int i=0; i < o.length; i++) {
                buf.append(concat(o[i])).append(""
"");
            }
            return buf.toString();
        }

        private String concat(List<Integer[]> list) {
            StringBuffer buf = new StringBuffer();
            String delim = """";
            for (Object[] elm : list) {
                buf.append(delim).append(concat(elm)).append(""
"");
            }
            return buf.toString();
        }

        public void debug(String message) {
            err.println(Calendar.getInstance().getTime() + "": "" + message);
        }

        public void debug(String message, Object[] o) {
            err.println(Calendar.getInstance().getTime() + "": "" + message);
            err.println(""	"" + concat(o));
        }

        public void debug(String message, Object[][] o) {
            err.println(Calendar.getInstance().getTime() + "": "" + message);
            String values = concat(o);
            err.println(""	"" + values.replaceAll(""
"", ""
	""));
        }

        public void debug(String message, List<Integer[]> list) {
            err.println(Calendar.getInstance().getTime() + "": "" + message);
            String values = concat(list);
            err.println(""	"" + values.replaceAll(""
"", ""
	""));
        }

        public void flush() {
            out.flush();
            err.flush();
        }

    }
",ddimi
185,"public class Solution {
	
	public static void main(String[] args) throws IOException {

		
		Scanner s = new Scanner(System.in);
		int cases = s.nextInt();
		for(int caseIndex=0;caseIndex<cases;caseIndex++) {
			int roomCount = s.nextInt();
			int maximumTries = s.nextInt();
			
			long estimation = 0;
			int currentRoom = 1;
			int passageCount = 0;
			
			long totalPassages=0;
			int skip = (int)(roomCount*1f/maximumTries);
			for(int step=0;step<maximumTries;step++) {
				if(step==0) {
					currentRoom = s.nextInt();
					passageCount = s.nextInt();
				}

				totalPassages+=passageCount;
				if(Math.random()>0.5) {
					System.out.println(""T ""+((currentRoom+skip*2)%roomCount+1));
				}else {
					System.out.println(""W"");
				}
				currentRoom = s.nextInt();
				passageCount = s.nextInt();
				
				
			}
			
			estimation = (long)(totalPassages*1f*roomCount/maximumTries/2);
			
			System.out.println(""E ""+estimation);
		}
		
		s.",KovacsA22
1332,"public class Solution {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
		int n = scanner.nextInt();
        for (int i = 0; i < n; i++) {
            int N = scanner.nextInt();
            List<Node> rootList = new ArrayList<>();
            Node[] arr = new Node[N];
            for(int j=0; j<N; j++) {
                arr[j] = new Node(j+1, scanner.nextLong());
		    }
            for(int j=0; j<N; j++) {
                int p = scanner.nextInt();
                if(p==0) {
                    rootList.add(arr[j]);
                } else {
                    Node node = arr[p-1];
                    node.son.add(arr[j]);
                    arr[p-1] = node;
                }
            }
            long total = 0;
            for (int k=0; k<rootList.size(); k++) {
                total += dfs(rootList.get(k)).sum;
            }
            System.out.print(""Case #""+(i+1)+"": "");
            System.out.println(total);
       }
    }

    public static Data dfs(Node node) {
        if(node.son.size()==0) {
            return new Data(node.value, node.value);
        }
        int n = node.son.size();
        long minSon = Long.MAX_VALUE;
        int sum = 0;
        for (int i = 0; i < n; i++) {
            Data sonData = dfs(node.son.get(i));
            minSon = Math.min(sonData.minV, minSon);
            sum += sonData.sum;
        }

        Data result;
        if(node.value > minSon) {
            result = new Data(sum+(node.value-minSon), node.value);
            System.out.println(JSON.toJSONString(result));
            return result;
        } else {
            result = new Data(sum, minSon);
            System.out.println(result);
            return result;
        }
    }

    public static class Data {
        public long sum;
        public long minV;
        public Data(long sum, long minV) {
            this.sum = sum;
            this.minV = minV;
        }
    }

    static class Node {
        public long value;
        public int i;
        public List<Node> son;
        public Node(int i, long value) {
            this.i = i;
            this.value = value;
            son = ",xinyou
952,"public class Solution {

	public static void main(String[] args) {
		Scanner s = new Scanner(System.in);
		int i, j, k, l, t;
		int p1[] = new int[4];
		int p2[] = new int[4];
		int p3[] = new int[4];
		int saida[] = new int[4];

		
		do {
			t = s.nextInt();
		} while(t < 1 || t > 100);
		
		for(i = 1; i <= t; i++) { //casos
			l = 0;
			
				for(k = 0; k < 4; k++) { // 1 impressora
					do {
						p1[k] = s.nextInt();
						
					} while(p1[k] < 0 || p1[k] > (int) Math.pow(10, 6));
				}
				
				for(k = 0; k < 4; k++) { // 2 impressora
					do {
						p2[k] = s.nextInt();
						
					} while(p2[k] < 0 || p2[k] > (int) Math.pow(10, 6));
				}
				
				for(k = 0; k < 4; k++) { // 3 impressora
 					do {
						p3[k] = s.nextInt();
						
					} while(p3[k] < 0 || p3[k] > (int) Math.pow(10, 6));
				}
			
			for(j = 0; j < 4; j++) { // cada impressora
				
				if(p1[j] >= p2[j] & p1[j] >= p3[j]) { // o maior
					saida[l] = p1[j];
				} else if(p2[j] >= p3[j]) {
					saida[l] = p2[j];
				} else {
					saida[l] = p3[j];
				}
				
				//if(p1[j] == 0 && p2[j] == 0 && p3[j] == 0) { // todos 0
				//	imp = true;
				//	break;
				//}
				
				if(p1[j] == 0) // o 1 eh zero
					if(p2[j] >= p3[j])
						saida[l] = p2[j];
					else
						saida[l] = p3[j];
				
				if(p2[j] == 0) // o 2 eh zero
					if(p1[j] >= p3[j])
						saida[l] = p1[j];
					else
						saida[l] = p3[j];
				
				if(p3[j] == 0) // o 3 eh zero
					if(p1[j] >= p2[j])
						saida[l] = p1[j];
					else
						saida[l] = p2[j];
				
				if(p1[j] == 0 && p2[j] == 0) // 1 e 2 são zero
					saida[l] = p3[j];
				
				if(p2[j] == 0 && p3[j] == 0) // 2 e 3 são zero
					saida[l] = p1[j];
				
				if(p1[j] == 0 && p3[j] == 0) // 1 e 3 são zero
					saida[l] = p2[j];
				
				l++;
			}
			
			l = 0;
			System.out.print(""Case #"" + i + "": "");
			
			if((saida[0] + saida[1] + saida[2] + saida[3]) > (int) Math.pow(10, 6)) {
				System.out.print(saida[0] + "" "" + saida[1] + "" "" + saida[2] + "" "" + saida[3]);
			} else {
				System.out.print(""IMPOSSIBLE"");
			}
			
			if(i != t)
				System.",marcosph
451,"public class Solution {


    public static void main(String[] args) throws Exception {

        int t=sc.nextInt();
       out: while(t-->0){
            int cnt=8;
//            int cnt2=0;
//            int ii=0;
            while(true){
//                ii++;
//                if(ii%20==0)cnt=8;
                if(cnt==1)cnt=7;
                if(cnt==2)cnt=5;
                if(cnt==3)cnt=6;
                if(cnt==4)cnt=2;
                if(cnt==5)cnt=2;
                if(cnt==6)cnt=3;

                int S=(int)(Math.random()*255)+1;
                while(Integer.bitCount(S)!=cnt){
                    S=(int)(Math.random()*255)+1;
                }
                String s=Integer.toBinaryString(S);
                while(s.length()<8){
                    s=s+""0"";
                }
                pw.println(s);
                pw.flush();
                int x=sc.nextInt();
                cnt=x;
                if(x==-1){
                    break out;
                }
                if(x==0){
                    break;
                }

            }
        }

//        int[][]lol=new int[9][256];
//        for(int i=0;i<256;i++){
//            int x=Integer.bitCount(i);
//            for(int j=0;j<8;j++){
//                int y=((i<<j)&255)|(i>>(8-j));
//                if(y==i)
//                lol[x][y]++;
//            }
//        }
//        for(int i=0;i<9;i++)pw.println(Arrays.toString(lol[i]));
        pw.close();
    }

    static class Scanner {
        StringTokenizer st;
        BufferedReader br;

        public Scanner(InputStream s) {
            br = new BufferedReader(new InputStreamReader(s));
        }

        public Scanner(FileReader r) {
            br = new BufferedReader(r);
        }

        public String next() throws IOException {
            while (st == null || !st.hasMoreTokens())
                st = new StringTokenizer(br.readLine());
            return st.nextToken();
        }

        public int nextInt() throws IOException {
            return Integer.parseInt(next());
        }

        public long nextLong() throws IOException {
            return Long.parseLong(next());
        }

        public String nextLine() throws IOException {
            return br.readLine();
        }

        public double nextDouble() throws IOException {
            String x = next();
            StringBuilder sb = new StringBuilder(""0"");
            double res = 0, f = 1;
            boolean dec = false, neg = false;
            int start = 0;
            if (x.charAt(0) == '-') {
                neg = true;
                start++;
            }
            for (int i = start; i < x.length(); i++)
                if (x.charAt(i) == '.') {
                    res = Long.parseLong(sb.toString());
                    sb = new StringBuilder(""0"");
                    dec = true;
                } else {
                    sb.append(x.charAt(i));
                    if (dec)
                        f *= 10;
                }
            res += Long.parseLong(sb.toString()) / f;
            return res * (neg ? -1 : 1);
        }

        public long[] nextlongArray(int n) throws IOException {
            long[] a = new long[n];
            for (int i = 0; i < n; i++)
                a[i] = nextLong();
            return a;
        }

        public Long[] nextLongArray(int n) throws IOException {
            Long[] a = new Long[n];
            for (int i = 0; i < n; i++)
                a[i] = nextLong();
            return a;
        }

        public int[] nextIntArray(int n) throws IOException {
            int[] a = new int[n];
            for (int i = 0; i < n; i++)
                a[i] = nextInt();
            return a;
        }

        public Integer[] nextIntegerArray(int n) throws IOException {
            Integer[] a = new Integer[n];
            for (int i = 0; i < n; i++)
                a[i] = nextInt();
            return a;
        }

        public boolean ready() throws IOException {
            return br.ready();
        }

    }

    static class pair implements Comparable<pair> {
        long x;
        long y;

        public pair(long x, long y) {
            this.x = x;
            this.y = y;
        }

        public String toString() {
            return x + "" "" + y;
        }

        public boolean equals(Object o) {
            if (o instanceof pair) {
                pair p = (pair) o;
                return p.x == x && p.y == y;
            }
            return false;
        }

        public int hashCode() {
            return new Long(x).hashCode() * 31 + new Long(y).hashCode();
        }

        public int compareTo(pair other) {
            if (this.x == other.x) {
                return Long.compare(this.y, other.y);
            }
            return Long.compare(this.x, other.x);
        }
    }

    static class tuble implements Comparable<tuble> {
        int x;
        int y;
        int z;

        public tuble(int x, int y, int z) {
            this.x = x;
            this.y = y;
            this.z = z;
        }

        public String toString() {
            return x + "" "" + y + "" "" + z;
        }

        public int compareTo(tuble other) {
            if (this.x == other.x) {
                if (this.y == other.y) {
                    return this.z - other.z;
                }
                return this.y - other.y;
            } else {
                return this.x - other.x;
            }
        }
    }

    static long mod = 1000000007;
    static Random rn = new Random();
    static Scanner sc = ",ZerooCool
1338,"public class Solution {
    private static BufferedReader br;
    private static StringTokenizer st;
    private static PrintWriter pw;

    public static void main(String[] args) throws Exception {
        br = new BufferedReader(new InputStreamReader(System.in));
        pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
        int tt = readInt();
        for (int zz = 1; zz <= tt; zz++) {
            int n = readInt();
            Integer[] arr = new Integer[n * 2];
            int z = 1;
            StringBuilder sb = new StringBuilder();
            long sum = 0;
            for (int i = 0; i < n; i++) {
                arr[i] = z;
                sum += z;
                sb.append(z);
                if (i < n - 1) sb.append("" "");

                if (z == 1) z = 0;
                z += 10;
            }
            System.out.println(sb);
            System.out.flush();
            //            String ret = nextLine();
//            String[] arrS = ret.split("" "");
            for (int i = 0; i < n; i++) {
                int next = readInt();
                sum += next;
                arr[n + i] = next;
            }

            ab(arr, 0, 0, new HashSet<>(), sum / 2);
            sb = new StringBuilder();

            Set<Integer> set = new HashSet<>(Arrays.asList(arr));
            set.removeAll(nextHalf);
            for (Integer integer : nextHalf) {
                sb.append(integer).append("" "");
            }

            for (Integer integer : set) {
                sb.append(integer).append("" "");
            }
            System.out.println(sb);
            System.out.flush();
        }
        pw.close();

    }

    static boolean found = false;
    static Set<Integer> nextHalf;
    static Set<Long> memo = new HashSet<>();

    public static void ab(Integer[] arr, int idx, long sum, Set<Integer> curr, long target) {
        if (found || idx > arr.length - 1 || memo.contains(sum) || sum > target) return;
        if (sum == target) {
            found = true;
            nextHalf = curr;
            return;
        }

        curr.add(arr[idx]);
        ab(arr, idx + 1, sum + arr[idx], curr, target);
        if (found) return;
        curr.remove(arr[idx]);
        ab(arr, idx + 1, sum, curr, target);
        if (found) return;

        memo.add(sum);

    }

    private static void exitImmediately() {
        pw.close();
        System.exit(0);
    }

    private static long readLong() throws IOException {
        return Long.parseLong(nextToken());
    }

    private static double readDouble() throws IOException {
        return Double.parseDouble(nextToken());
    }

    private static int readInt() throws IOException {
        return Integer.parseInt(nextToken());
    }

    private static String nextLine() throws IOException {
        String s = br.readLine();
        if (s == null) {
            exitImmediately();
        }
        st = null;
        return s;
    }

    private static String nextToken() throws IOException {
        while (st == null || !st.hasMoreTokens()) {
            st = ",zubaidullo
775,"public class Solution {
    public static void main(String[] argu) throws Exception {
        Reader br = new Reader();
        PrintWriter pw = new PrintWriter(System.out);
        int T = br.nextInt();
        char[] cs = new char[8];
        for (int t = 1; t <= T; ++t) {
            pw.println(""11111111"");
            pw.flush();
            int init = br.nextInt(), j = init - 1;
            for (int i = 0; i < init; ++i) cs[i] = '1';
            for (int i = init; i < 8; ++i) cs[i] = '0';
            while (0 != init) {
                pw.println(new String(cs));
                pw.flush();
                int num = br.nextInt();
                //System.err.format(""t = %d, cmd = %s, num = %d, st = %d
"", t, new String(cs), num, st);
                if (0 == num) break;
                if (-1 == num) return;
                if (num == init) j = (j + 1) % 8;
                else if (num < init) j = (j + num) % 8;
                init = num;
                for (int i = 0; i < 8; ++i) cs[i] = '0';
                for (int i = 0; i < init; ++i) cs[(i + j) % 8] = '1';
            }
        }
        pw.close();
        br.close();
    }
    static class Reader
    {
        final private int BUFFER_SIZE = 1 << 16;
        private DataInputStream din;
        private byte[] buffer;
        private int bufferPointer, bytesRead;

        public Reader()
        {
            din = new DataInputStream(System.in);
            buffer = new byte[BUFFER_SIZE];
            bufferPointer = bytesRead = 0;
        }
        private void fillBuffer() throws IOException
        {
            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);
            if (bytesRead == -1)
                buffer[0] = -1;
        }

        private byte read() throws IOException
        {
            if (bufferPointer == bytesRead)
                fillBuffer();
            return buffer[bufferPointer++];
        }

        public void close() throws IOException
        {
            if (din == null)
                return;
            din.close();
        }
        public int nextInt() throws IOException
        {
            int ret = 0;
            byte c = read();
            while (c <= ' ')
                c = read();
            boolean neg = (c == '-');
            if (neg)
                c = read();
            do
            {
                ret = ret * 10 + c - '0';
            }  while ((c = read()) >= '0' && c <= '9');

            if (neg)
                return -ret;
            return ret;
        }
        public long nextLong() throws IOException
        {
            long ret = 0;
            byte c = read();
            while (c <= ' ')
                c = read();
            boolean neg = (c == '-');
            if (neg)
                c = read();
            do
            {
                ret = ret * 10 + c - '0';
            }  while ((c = read()) >= '0' && c <= '9');

            if (neg)
                return -ret;
            return ret;
        }

        public String readLine() throws IOException {
            byte[] buf = new byte[500001]; // line length
            int cnt = 0, c = read();
            if (-1 != c && '
' != c) buf[cnt++] = (byte) c;
            while ((c = read()) != -1)
            {
                if (c == '
')
                    break;
                buf[cnt++] = (byte) c;
            }
            return new String(buf, 0, cnt);
        }

    }
}",hdchen
63,"public class Solution {
	static Scanner sc;
	static StringBuffer s;

  public static void main(String[] args)throws Exception{
	  sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
	  //sc = new Scanner(new BufferedReader(new InputStreamReader(new FileInputStream(new File(""src/input.txt""))))); 
    
     int nbTest = sc.nextInt();
     
	 for(int test = 1;test<=nbTest;test++){ 	   	 	
	 	solve(test);
	 }   
	 
  }
  
  static void solve (int test) {
	  int N = sc.nextInt();
	  List<Integer> list = new ArrayList<Integer>();
	  List<Integer> buf = new ArrayList<Integer>();
	  int[] tab = new int[1000000];
	  int res = 1;
	  int a;
	  int max = 0;
	  for (int i = 0; i<N;i++) {
		  a = sc.nextInt();
		  if (a>max) max = a;
		  
		  tab[a]++;
	  }
	  
	 // int max = Collections.max(list);
	  //for(int i = 0; i<=max+1; i++) System.out.print(tab[i]+""-"");
	  boolean flag = false;
	  int h=1;
	  for (int i = 1; i<=N;i++) {
		  for (int j = i; j<=max ; j++) {
			  if (tab[j] > 0) {
				  tab[j]--;
				  flag = true;
				  //h=j+1;
				  break;
			  } 			  
		  }
		  
		  if (flag==false) {
			  System.out.println(""Case #""+test+"": ""+res);
			  return;
		  }
			  
		  flag = false;
		  
		  res = i;
		  
	  }
	  
	  System.out.println(""Case #""+test+"": ""+(res));
  
  }
  

  public static int  minimum (int a, int b, int c) {	 
		return Math.min(Math.min(a, b), c);
	}
  public static int somme(List<Integer> list) {
	  int res = 0;
	  for (int i = ",Bil1983
142,"public class Solution { //Solution
	static int INF = (int)(1e9);
	static long mod = (long)(1e9)+7;
	static long mod2 = 998244353;
	static long[] segtree;
	static char[] curans;
	static long ans;	
	static String S;
	static ArrayList<Integer>[] graph;
	static boolean[] vis;
	static int[] a;
	static int N;
	static long K;
	static long[] fact;
	static ArrayList<Long> pos;
	static ArrayList<Long> neg;
	static long[] max;
	static int[] dp;
	static long mx;
	static long[] fun;
	public static void main(String[] args) {  //Cash out
		/*(Notes)
		 * 
		 * 
		 * */
		FastScanner I = new FastScanner(); //Input
		OutPut O = new OutPut(); //Output
		
		int T = I.nextInt();
		for (int t = 1; t <= T; t++) {
			
			int N = I.nextInt();
			int[] a = new int[N];
			
			int L = 0;
			int R = N - 1;
			
			for (int i = 0; i < N; i++) {
				a[i] = I.nextInt();
			}
			
			int max_so_far = 0;
			int ans = 0;
			
			while (L <= R) {
				if (a[L] <= a[R]) {
					if (a[L] >= max_so_far) {
						ans++;
						max_so_far = a[L];
					}
					L++;
					
				}else {
					if (a[R] >= max_so_far) {
						ans++;
						max_so_far = a[R];
					}
					R--;
				}
			}
			
			O.pln(""Case #"" + t + "": "" + ans);
		}
		
	}
	
	public static boolean pal(String x) {
		int N = x.length();
		
		for (int i = 0; i < N / 2; i++) {
			if (x.charAt(i) != x.charAt(N - i - 1)) {
				return false;
			}
		}
		
		return true;
	}
	
	public static ArrayList<String> perms(int N, int upper){
		if (N==1) {
			ArrayList<String> ret = new ArrayList<String>();
			for (int i = 1; i<=upper; i++) ret.add(Integer.toString(i)+"" "");
			return ret;
		}
		ArrayList<String> prev = perms(N-1,upper);
		ArrayList<String> ret = new ArrayList<String>();
		for (int i = 0; i < prev.size(); i++) {
			boolean[] vis = new boolean[upper+1];
			String cur = prev.get(i);
			String[] parts = cur.split("" "");
			for (int j = 0; j < parts.length; j++) {
				vis[Integer.parseInt(parts[j])]=true;
			}
			for (int j = 1; j <= upper; j++) {
				if (!vis[j]) {
					String curans = cur;
					curans+=Integer.toString(j)+"" "";
					ret.add(curans);
				}
			}
		}
		return ret;
	}
	
	public static void DFS(int start) {
		if (start == 0) {
			return;
		}
		
		vis[start] = true;
		mx = Math.max(mx, fun[start]);
		int next = graph[start].get(0); // We only ever point to one node at a time
		if (vis[next]) {
			return;
		}
		
		DFS(next);
	}
	
	public static long C(int N, int K) {
		long ans = fact[N];
		ans *= FastExp(fact[K], mod - 2);
		ans %= mod;
		
		ans *= FastExp(fact[N - K], mod - 2);
		ans %= mod;
		
		return ans;
	}
	
	
	public static double[][] matrix_exp(double[][] a, long exp, long mod) {
		int R = a.length;
		int C = a[0].length;
		double[][] ans = new double[R][C];
		
		boolean mult_yet = false;
		
		while (exp > 0) {
			if (exp % 2 == 1) {
				if (!mult_yet) {
					mult_yet = true;
					for (int i = 0; i < R; i++) {
						for (int j = 0; j < C; j++) {
							ans[i][j] = a[i][j]; 
						}
					}
				}else {
					double[][] new_ans = mult(ans, a, mod);
					for (int i = 0; i < R; i++) {
						for (int j = 0; j < C; j++) {
							ans[i][j] = new_ans[i][j]; 
						}
					}
				}
			}
			
			double[][] new_a = mult(a, a, mod); // a = a^2 (binary exponentiation on matrices)
			for (int i = 0; i < R; i++) {
				for (int j = 0; j < C; j++) {
					a[i][j] = new_a[i][j]; 
				}
			}
			exp /= 2;
		}
		
		return ans;
	}
	public static double[][] mult(double[][] a, double[][] b, long mod) {
		int r1 = a.length;
		int c1 = a[0].length;
		int r2 = b.length;
		int c2 = b[0].length;
		//Requires: c1 = r2
		
		double[][] ans = new double[r1][c2];
		for (int r = 0; r < r1; r++) {
			for (int c = 0; c < c2; c++) {
				//Dot product of (a[r])^T and b[c] (as vectors in R^n (n = c1 = r2))
				double[] col_vector = new double[r2];
				double[] row_vector = new double[c1];
				
				for (int i = 0; i < r2; i++) {
					col_vector[i] = b[i][c];
				}
				for (int i = 0; i < c1; i++) {
					row_vector[i] = a[r][i]; 
				}
				
				ans[r][c] = dot_product(row_vector, col_vector, mod);
			}
		}
		return ans;
	}
	
	public static double dot_product(double[] a, double[] b, long mod) {
		double ans = 0;
		int N = a.length; //Requires: a and b are both vectors in R^n
		for (int i = 0; i < N; i++) {
			ans += a[i] * b[i];
		}
		return ans;
	}
	public static double max(double a, double b) {return Math.max(a, b);}
	public static double min(double a, double b) {return Math.min(a, b);}
	public static long min(long a, long b) {return Math.min(a,b);}
	public static long max(long a, long b) {return Math.max(a,b);}
	public static int min(int a, int b) {return Math.min(a,b);}
	public static int max(int a, int b) {return Math.max(a,b);}
	public static long abs(long x) {return Math.abs(x);}
	public static long abs(int x) {return Math.abs(x);}
	public static long ceil(long num, long den) {long ans = num/den; if (num%den!=0) 
	ans++; return ans;}
	public static long GCD(long a, long b) {
		if (a==0||b==0) return max(a,b);
		return GCD(min(a,b),max(a,b)%min(a,b));
	}
	public static long FastExp(long base, long exp) {
		long ans=1;
		while (exp>0) {
			if (exp%2==1) ans*=base;
			exp/=2;
			base*=base;
			base%=mod;
			ans%=mod;
		}
		return ans;
	}
	public static long ModInv(long num,long mod) {return FastExp(num,mod-2);}
	public static int pop(long x) { //Returns number of bits within a number
		int cnt = 0;
		while (x>0) {
			if (x%2==1) cnt++;
			x/=2;
		}
		return cnt;
	}
	static class FastScanner {
		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st=",IQEmperor
432,"public class Solution {
    public static void main(String[] args) {
        try {
            Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
            int tests = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
            StringBuilder sb = new StringBuilder();
            for (int currentTest = 1; currentTest <= tests; ++currentTest) {
                if(currentTest == 100){
                    throw new RuntimeException(sb.toString());
                }
                int N = in.nextInt();
                if(N == -1) System.exit(3);
                int K = in.nextInt();
                if(K == -1) System.exit(3);
                int r = in.nextInt();
                if(r == -1) System.exit(3);
                int p = in.nextInt();
                if(p == -1) System.exit(3);
                long pSum = p;
                long queries = K;
                Set<Integer> visited = new HashSet<>();
                visited.add(r);
                if(N <=1){
                    System.out.println(""E 0"");
                    System.out.flush();
                }else if(N == 2){
                    System.out.println(""E 1"");
                    System.out.flush();
                }
                else if(N <= K){
                    long count = 0;
                    for(int i = 1; i <= N; i++){
                        System.out.println(""T "" + i);
                        System.out.flush();
                        r = in.nextInt();
                        if(r == -1) System.exit(3);
                        p = in.nextInt();
                        if(p == -1) System.exit(3);
                        count += p;
                        queries --;
                    }
                    String ans = ""E "" + (count/2);
                    sb.append(ans).append(""
"");
                    System.out.println(ans);
                    System.out.flush();
                }else {
                    boolean needToJump = false;
                    while (queries > 0) {



                        if(needToJump) {
                            int nxt = (int) (Math.random() * N + 1);
                            while(visited.contains(nxt)){
                                nxt = (int) (Math.random() * N + 1);
                            }
                            System.out.println(""T "" + nxt);
                            System.out.flush();
                            r = in.nextInt();
                            if (r == -1) System.exit(3);
                            p = in.nextInt();
                            if (p == -1) System.exit(3);
                            needToJump = false;
                            pSum += p;
                            visited.add(r);
                        }else{
                            System.out.println(""W"");
                            System.out.flush();
                            r = in.nextInt();  if (r == -1) System.exit(3);
                            p = in.nextInt();  if (p == -1) System.exit(3);
                            if(visited.contains(r)){
                                needToJump = true;
                            }else{
                                pSum += p;
                                visited.add(r);
                            }

                        }

                        queries--;
                    }
                    double avg = (double) pSum / visited.size();
                    long mid = (long) ((N * avg) / 2.0);
                    long minT = N/2 + N%2;
                    long maxT = ((long)N*(N-1))/2;
                    maxT = maxT - (long)( maxT/3.5);
                    minT = minT + (long) (minT/3.5);
                    if(mid < minT) mid = minT;
                    if(mid > maxT) mid = maxT;
                    String ans = ""E "" + mid;
                    sb.append(ans);
                    System.out.println(ans);
                    System.out.flush();
                }
            }
        }catch (Exception e){
            System.err.println(e.getMessage());
            e.print",Vlad
1110,"public class Solution {

  static Scanner in;

  public static void main(String[] args) {
    in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
    int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
    for (int i = 1; i <= t; i++) {
      int n = in.nextInt();
      int k = in.nextInt();
      solve(n, k);
    }
  }

  static void solve(int n, int k) {
    var rng = new Random();
    long sum = 0;
    var set = new HashSet<Integer>();
    set.add(in.nextInt());
    sum += in.nextInt();
    boolean flag = sum != 1;
    for (int i = 0; i < k; i++) {
      if (flag && i % 5 == 0) {
        System.out.println(""W"");
      } else {
        int t = rng.nextInt(n) + 1;
        int tries = 100;
        while (set.contains(t) && tries > 0) {
          t = rng.nextInt(n) + 1;
          tries--;
        }
        System.out.println(""T "" + t);
      }
      set.add(in.nextInt());
      var z = in.nextInt();
      flag = z != 1;
      sum += z;
    }
    long r = ",rk13
1051,"public class Solution {
	
	static Scanner sc = new Scanner(System.in);
	
	static List<List<Integer>> list;
	static Stack<Integer> stack;
	static boolean [] visited;
	static long [][] arrPos;
	static long [][] arrSweet;

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int testCases = sc.nextInt();
		
		for (int i = 1; i <= testCases; ++i) {
			solve(i);
		}
	}
	
	private static void solve(int t) {
		int n = sc.nextInt();
		
		arrPos = new long [n + 1][2];
		arrSweet = new long [n + 2][2];
		
		int a, b;
		
		for (int i = 1; i <= n; ++i) {
			arrPos[i][0] = sc.nextLong();
			arrPos[i][1] = sc.nextLong();
		}
		
		for (int i = 1; i <= n+1; ++i) {
			arrSweet[i][0] = sc.nextLong();
			arrSweet[i][1] = sc.nextLong();
		}
		
		list = new ArrayList<>();
		stack = new Stack<>();
		
		visited = new boolean [n + 1];
		
		generatePermutations(n);
		
		List<Integer> res = null;
		
		for (List<Integer> l : list) {
			res = solve2(l); 
			
			if (res != null) {
				print(t, ""POSSIBLE"");
				
				for (int i = 0; i < l.size(); ++i) {
					System.out.println(l.get(i) + "" "" + res.get(i));
				}
				return;
			}
		}
		
		if (res == null) {
			print(t, ""IMPOSSIBLE"");
			return;
		}
	}
	
	private static List<Integer> solve2(List<Integer> order){
		boolean [] visited = new boolean [arrSweet.length];
		long dist;
		long min = Long.MAX_VALUE;
		long x,y;
		int pos;
		
		List<Integer> result = new ArrayList<>();
		
		for (int num : order) {
			min = Long.MAX_VALUE;
			pos = 0;
			
			for (int i = 1; i < arrSweet.length; ++i) {
				if (visited[i]) continue;
				
				x = arrPos[num][0] - arrSweet[i][0];
				y = arrPos[num][1] - arrSweet[i][1];
				
				dist = x*x + y*y;
				
				if (dist <= min) {
					min = dist;
					pos = i;
				}
			}
			
			visited[pos] = true;
			result.add(pos);
			
			if (pos <= 1)
				return null;
		}
		
		return result;
	}
	
	private static void generatePermutations(int n) {
		if (stack.size() == n) {
			list.add(new ArrayList<>(stack));
			return;
		}
		
		for (int i = 1; i <= n; ++i) {
			if (visited[i]) continue;
			
			visited[i] = true;
			stack.push(i);
			
			generatePermutations(n);
			
			stack.pop();
			visited[i] = false;
		}
	}
	
	public static void print(int test, String result) {
		System.",profchi
1199,"class Solution{
    public static void main(String args[]){
        Scanner sin = new Scanner(System.in);
        int a = Integer.parseInt(sin.nextLine());
        for(int j =0;j<a;j++) {
            String h = sin.nextLine();
            String s;
            char d;
            int g=0;
            int c = 0;
            char b [] = h.toCharArray();
            char k [] = new char[b.length];
            Arrays.sort(b);
            k[0]=b[0];
            for(int i=1;i<h.length();i++){
                int f = Character.getNumericValue(b[i])-Character.getNumericValue(b[i-1]);
                        if(f==1) {
                            k[i] = b[i];
                            k[i-1]=b[i-1];
                        }

            }
          System.out.print(""Case #""+(j+1)+"": "");
            int x=0;
            int n =0;
           while(x<b.length){
               for(int i=n;i<k.length;i++) {
                   if (h.charAt(x) == k[i]) {
                       System.out.print(h.charAt(x));
                       n++;
                       break;
                   }
               }
                   System.out.print(h.charAt(x));
                   x++;

           }
           System.",spsaivaraprasad
596,"public class Solution{
    public static void main(String[] args){
        Scanner s = new Scanner(System.in);
        int T = s.nextInt();
        for(int ii=1; ii <= T; ii++){
            int R = s.nextInt();
            int C = s.nextInt();
            char[][] M = new char[2*R+1][2*C+1];
        
        
            for(int i=0; i < 2*R+1; i++){
                for(int j = 0; j < 2*C+1; j++){
                    if (i%2 == 0 && j % 2 == 0)
                      M[i][j] = '+' ;
                    if (i%2 == 0 && j%2 == 1)
                      M[i][j] = '-';
                    if (i%2 == 1 && j%2 == 1)
                      M[i][j] = '.';
                    if (i%2 == 1 && j%2 == 0)
                      M[i][j] = '|';
  
  
                }
            }
            
            M[0][0] = '.';
            M[0][1] = '.';
            M[1][0] = '.';
            M[1][1] = '.';
            
            
            System.out.println(""Case #"" + ii  + "":"" );
            for(int i=0; i < 2*R+1; i++){
                for(int j = 0; j < 2*C+1; j++){
                    
                    System.out.print(M[i][j]);
                }
                System.",dattap
426,"public class Solution {
    public static void main(String[] args) {
        try {
            Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
            int tests = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
            for (int currentTest = 1; currentTest <= tests; ++currentTest) {
                int R = in.nextInt();
                int C = in.nextInt();

                char[][] arr = new char[R*2+1][C*2+1];
                StringBuilder sb = new StringBuilder();
                for(int r = 0; r < arr.length; r ++){
                    for(int c = 0; c < arr[0].length; c ++){
                        if(r%2==0){
                            if(c%2 ==0){
                                arr[r][c] = '+';
                            }else{
                                arr[r][c] = '-';
                            }

                        }else{
                            if(c%2 ==0){
                                arr[r][c] = '|';
                            }else{
                                arr[r][c] = '.';
                            }
                        }
                    }
                    if(r == 0){
                        arr[0][0] = '.';
                        arr[0][1] = '.';
                    }else  if(r == 1){
                        arr[1][0] = '.';
                    }

                    sb.append(""
"");

                    sb.append(arr[r]);
                }


                System.out.println(""Case #"" + currentTest + "":"" + sb.toString());
            }
        }catch (Exception e){
            System.err.println(e.getMessage());
            e.printStackTrace();
        }
    }

    public static String arrToStr(int[][] arr) {
        StringBuilder str = new StringBuilder();
        for (int[] ints : arr) {
            String s = Arrays.toString(ints).replace("","", """");
            str.append(""
"").append(s.substri",Vlad
301,"public class Solution {

    public static void main(String[] args) throws InterruptedException {
        Scanner in = new Scanner(System.in);
        // Thread.sleep(3000);
        int T = in.nextInt();

        for (int t = 1; t <= T; t++) {
            long sum=0;
            long C= Long.MAX_VALUE;
            long M= Long.MAX_VALUE;
            long Y= Long.MAX_VALUE;
            long K= Long.MAX_VALUE;
            int[] colors= new int[4];
            Arrays.fill(colors, (int) 1e6);
            for(int i=0; i<3; i++){
                for(int j=0; j<4; j++)
                    colors[j]=Math.min( colors[j], in.nextInt());
            }

            for(int i=0; i<4; i++)
                sum+=colors[i];

            int curr=0;
            while(curr<4 && sum>1e6){
                if(colors[curr]>0) {
                    int remove =(int) Math.min(colors[curr], sum - 1e6);
                    colors[curr] -= remove;
                    sum-=remove;
                }
                else{
                    curr++;
                }
            }
            if(sum<1e6){
                System.out.println(""Case #""+t+"": IMPOSSIBLE"");
            }
            if(sum==1e6){
                System.",Rawan321
456,"public class Solution {
    private static int n;

    public static void main(String[] args) throws Exception {

        int t=sc.nextInt();
        int ii=1;
        while(t-->0){
            int n=sc.nextInt();
            LinkedList<Integer>ll=new LinkedList<>();
            for(int i=0;i<n;i++){
                ll.add(sc.nextInt());
            }
            int max=0;
            int ans=0;
            while(!ll.isEmpty()){
                if(ll.peekFirst()<ll.peekLast()){
                    int x=ll.pollFirst();
                    if(x>=max){
                        ans++;
                        max=x;
                    }
                }else{
                    int x=ll.pollLast();
                    if(x>=max){
                        ans++;
                        max=x;
                    }
                }
            }
            pw.println(""Case #""+ii+++"": ""+ans);
        }

        pw.close();
    }

    static class Scanner {
        StringTokenizer st;
        BufferedReader br;

        public Scanner(InputStream s) {
            br = new BufferedReader(new InputStreamReader(s));
        }

        public Scanner(FileReader r) {
            br = new BufferedReader(r);
        }

        public String next() throws IOException {
            while (st == null || !st.hasMoreTokens())
                st = new StringTokenizer(br.readLine());
            return st.nextToken();
        }

        public int nextInt() throws IOException {
            return Integer.parseInt(next());
        }

        public long nextLong() throws IOException {
            return Long.parseLong(next());
        }

        public String nextLine() throws IOException {
            return br.readLine();
        }

        public double nextDouble() throws IOException {
            String x = next();
            StringBuilder sb = new StringBuilder(""0"");
            double res = 0, f = 1;
            boolean dec = false, neg = false;
            int start = 0;
            if (x.charAt(0) == '-') {
                neg = true;
                start++;
            }
            for (int i = start; i < x.length(); i++)
                if (x.charAt(i) == '.') {
                    res = Long.parseLong(sb.toString());
                    sb = new StringBuilder(""0"");
                    dec = true;
                } else {
                    sb.append(x.charAt(i));
                    if (dec)
                        f *= 10;
                }
            res += Long.parseLong(sb.toString()) / f;
            return res * (neg ? -1 : 1);
        }

        public long[] nextlongArray(int n) throws IOException {
            long[] a = new long[n];
            for (int i = 0; i < n; i++)
                a[i] = nextLong();
            return a;
        }

        public Long[] nextLongArray(int n) throws IOException {
            Long[] a = new Long[n];
            for (int i = 0; i < n; i++)
                a[i] = nextLong();
            return a;
        }

        public int[] nextIntArray(int n) throws IOException {
            int[] a = new int[n];
            for (int i = 0; i < n; i++)
                a[i] = nextInt();
            return a;
        }

        public Integer[] nextIntegerArray(int n) throws IOException {
            Integer[] a = new Integer[n];
            for (int i = 0; i < n; i++)
                a[i] = nextInt();
            return a;
        }

        public boolean ready() throws IOException {
            return br.ready();
        }

    }

    static class pair implements Comparable<pair> {
        long x;
        long y;

        public pair(long x, long y) {
            this.x = x;
            this.y = y;
        }

        public String toString() {
            return x + "" "" + y;
        }

        public boolean equals(Object o) {
            if (o instanceof pair) {
                pair p = (pair) o;
                return p.x == x && p.y == y;
            }
            return false;
        }

        public int hashCode() {
            return new Long(x).hashCode() * 31 + new Long(y).hashCode();
        }

        public int compareTo(pair other) {
            if (this.x == other.x) {
                return Long.compare(this.y, other.y);
            }
            return Long.compare(this.x, other.x);
        }
    }

    static class tuble implements Comparable<tuble> {
        int x;
        int y;
        int z;

        public tuble(int x, int y, int z) {
            this.x = x;
            this.y = y;
            this.z = z;
        }

        public String toString() {
            return x + "" "" + y + "" "" + z;
        }

        public int compareTo(tuble other) {
            if (this.x == other.x) {
                if (this.y == other.y) {
                    return this.z - other.z;
                }
                return this.y - other.y;
            } else {
                return this.x - other.x;
            }
        }
    }

    static long mod = 1000000007;
    static Random rn = new Random();
    static Scanner sc = ",ZerooCool
1249,"public class Solution {
	public static void input() {
		Scanner sc = new Scanner(System.in);
		int testCase = sc.nextInt();
		int countTest = 1;
		int[] dices;
		while (testCase > 0) {
			int numDices = sc.nextInt();
			dices = new int[numDices];
			for (int i = 0; i < numDices; i++) {
				dices[i] = sc.nextInt();
			}
			System.out.println(""Case #"" + countTest + "": "" + output(dices));
			countTest++;
			testCase--;
		}
	}

	public static int output(int[] arr) {
		int len = arr.length;
		if (len == 1) {
			return 1;
		}
		
		int [] arrCheck = new int[len-1];
		for(int i = 0; i < arrCheck.length; i++) {
			arrCheck[i] = arr[i];
		}
		
		//Check for element is equal len or not
		boolean isEqual = false;
		for(int i = 0; i < len; i++) {
			if(arr[i] == len) {
				isEqual = true;
			}
			break;
		}
		
		Arrays.sort(arr);
		Arrays.sort(arrCheck);
		
		int countForward = 1;
		if(Boolean.TRUE.equals(isEqual)) {
			int mockCheck = arr[0];
			for(int i = 1; i < arrCheck.length; i++) {
				if(arrCheck[i] == countForward) {
					return countForward;
				}else if(arrCheck[i] >= mockCheck) {
					countForward++;
					mockCheck = arrCheck[i];
				}
			}
			return countForward;
		}else {
			int mockCheck = arr[0];
			for(int i = 1; i < len; i++) {
				if(arr[i] <= countForward) {
					return countForward++;
				}else if(arr[i] >= mockCheck) {
					countForward++;
					mockCheck = arr[i];
				}
			}
			return countForward;
		}
	}

	public static void main(String[] args) ",tonybuidn
1272,"public class Solution {
    {
        MULTI_TEST = false;
        FILE_NAME = """";
        NEED_FILE_IO = false;
        INF = (long) 1e18;
    } // fields

    int ask(String s) {
        out.println(s);
        out.flush();
        return ri();
    }

    String getForm(int x) {
        char[] form = new char[8];
        Arrays.fill(form, '0');
        int cnt = 0;
        while(x > 0) {
            int bit = x % 2;
            x/=2;
            form[8 - cnt - 1] = (char) ('0' + bit);
            cnt++;
        }

        return new String(form);
    }
    String solve_test() {
        TreeSet<String>[] ts = new TreeSet[9];
        for(int i = 0; i < 9; i++) ts[i] = new TreeSet<>();
        for(int i = 0; i <= 255; i++) {
            String b = getForm(i);
            int cnt = 0;
            for(var c : b.toCharArray()) {
                cnt += c == '1' ? 1 : 0;
            }

            ts[cnt].add(b);
        }
        int x = 0;
        while(true) {
            x = ask(ts[x].pollFirst());
            if(x == 0) return """";
            if(x == -1) break;
        }
        return """";
    }


    void solve() {
        int t = ri();
        for(int it = 0; it < t; it++) {
            solve_test();
        }
    }

    public static void main(String[] args) {
        new Solution().run();
    } //main

    @SuppressWarnings(""unused"")
    long gcd(long a, long b) {
        return b == 0 ? a : gcd(b, a % b);
    }

    @SuppressWarnings(""unused"")
    long lcm(long a, long b) {
        return a / gcd(a, b) * b;
    }

    @SuppressWarnings(""unused"")
    int gcd(int a, int b) {
        return (int) gcd((long) a, b);
    }

    @SuppressWarnings(""unused"")
    int lcm(int a, int b) {
        return (int) lcm(a, (long) b);
    }

    @SuppressWarnings(""unused"")
    int sqrtInt(int x) {
        return (int) sqrtLong(x);
    }

    @SuppressWarnings(""unused"")
    long sqrtLong(long x) {
        long root = (long) Math.sqrt(x);
        while (root * root > x) --root;
        while ((root + 1) * (root + 1) <= x) ++root;
        return root;
    }

    @SuppressWarnings(""unused"")
    int cbrtLong(long x) {
        int cbrt = (int) Math.cbrt(x);
        while ((long) cbrt * cbrt >= x) {
            cbrt--;
        }
        while ((long) (cbrt + 1) * (cbrt + 1) <= x) cbrt++;
        return cbrt;
    }

    @SuppressWarnings(""unused"")
    long binpow(long a, long power) {
        return binpow(a, power, Long.MAX_VALUE);
    }

    @SuppressWarnings(""unused"")
    long binpow(long a, long power, long modulo) {
        if (power == 0) return 1 % modulo;
        if (power % 2 == 1) {
            long b = binpow(a, power - 1, modulo) % modulo;
            return ((a % modulo) * b) % modulo;
        } else {
            long b = binpow(a, power / 2, modulo) % modulo;
            return (b * b) % modulo;
        }
    }

    @SuppressWarnings(""unused"")
    long fastMod(String s1, long n2) {
        long num = 0;
        for (int i = 0; i < s1.length() - 1; i++) {
            num += Integer.parseInt(String.valueOf(s1.charAt(i)));
            num *= 10;
            if (num >= n2) {
                num = num % n2;
            }
        }
        return (num + Integer.parseInt(String.valueOf(s1.charAt(s1.length() - 1)))) % n2;
    }

    @SuppressWarnings(""unused"")
    long factorialMod(long n, long p) {
        long res = 1;
        while (n > 1) {
            res = (res * ((n / p) % 2 == 1 ? p - 1 : 1)) % p;
            for (int i = 2; i <= n % p; ++i)
                res = (res * i) % p;
            n /= p;
        }
        return res % p;
    }

    @SuppressWarnings(""unused"")
    boolean isPrime(int number) {
        for (int i = 2; i * i <= number; i++) {
            if (number % i == 0) {
                return false;
            }
        }
        return number > 1;
    }

    @SuppressWarnings(""unused"")
    boolean[] primes(int border) {
        boolean[] isPrimes = new boolean[border + 1];
        Arrays.fill(isPrimes, true);
        isPrimes[0] = false;
        isPrimes[1] = false;
        for (int i = 2; i < border + 1; i++) {
            if (!isPrimes[i]) continue;
            for (int k = i * 2; k < border; k += i) {
                isPrimes[k] = false;
            }
        }
        return isPrimes;
    } //Number theory

    @SuppressWarnings(""unused"")
    void sort(int[] a) {
        int n = a.length;
        Integer[] arr = new Integer[n];
        for (int i = 0; i < n; i++) {
            arr[i] = a[i];
        }
        Arrays.sort(arr);
        for (int i = 0; i < n; i++) {
            a[i] = arr[i];
        }
    }

    @SuppressWarnings(""unused"")
    void sort(long[] a) {
        int n = a.length;
        Long[] arr = new Long[n];
        for (int i = 0; i < n; i++) {
            arr[i] = a[i];
        }
        Arrays.sort(arr);
        for (int i = 0; i < n; i++) {
            a[i] = arr[i];
        }
    }

    @SuppressWarnings(""unused"")
    int max(int[] a) {
        int n = a.length;
        int max = Integer.MIN_VALUE;
        for (int j : a) {
            if (j > max) max = j;
        }
        return max;
    }

    @SuppressWarnings(""unused"")
    long max(long[] a) {
        int n = a.length;
        long max = Long.MIN_VALUE;
        for (long l : a) {
            if (l > max) max = l;
        }
        return max;
    }

    @SuppressWarnings(""unused"")
    int maxIndex(int[] a) {
        int n = a.length;
        int max = Integer.MIN_VALUE;
        int index = 0;
        for (int i = 0; i < n; i++) {
            if (a[i] > max) {
                max = a[i];
                index = ",v0s7er
313,"public class Solution {

    public static void main(String[] args) throws InterruptedException {
        Scanner in = new Scanner(System.in);
        // Thread.sleep(3000);
        int T = in.nextInt();

        for (int t = 1; t <= T; t++) {
            String s= in.next();
            StringBuilder sb= new StringBuilder();
            HashSet<Character> diff= new HashSet<>();
        for(int i=0; i<s.length()-1; i++){
            diff.add(s.charAt(i));
            sb.append(s.charAt(i));
            if(s.charAt(i)<=s.charAt(i+1))
            sb.append(s.charAt(i));
        }
        sb.append(s.charAt(s.length()-1));
diff.add(s.charAt(s.length()-1));
        if(diff.size()==1)
            System.out.println(""Case #""+t+"": ""+s);
        else
            System.out.println(""Case #""+t+"": ""+sb.toString());
        }
    }
}
tInt();

        for (int t = 1; t <= T; t++) {
            String s= in.next();
        StringBuilder sb= new StringBuilder();
            HashSet<Character> diff= new HashSet<>();
        for(int i=0; i<s.length()-1; i++){
            diff.add(s.charAt(i));
            sb.append(s.charAt(i));
            if(s.charAt(i)<=s.charAt(i+1))
            sb.append(s.charAt(i));
        }
        sb.append(s.charAt(s.length()-1));

if(diff.size()==1) System.out.println(""Case #""+t+"": ""+s);
           else  System.",Rawan321
438,"public class Solution {
    static Scanner sc = new Scanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);

    static final int mod = (int) 1e9 + 7;

    public static long modInv(long x) {
        return modPow(x, mod - 2);
    }

    public static long modPow(long a, long e) {
        a %= mod;
        long res = 1;
        while (e > 0) {
            if ((e & 1) != 0)
                res = res * a % mod;
            e >>= 1;
            a = a * a % mod;
        }
        return res;
    }

    public static void main(String[] args) throws IOException {
        int t = sc.nextInt();
        for (int tc = 1; tc <= t; tc++) {
            pw.println(""Case #"" + tc + "":"");
            int r = sc.nextInt();
            int c = sc.nextInt();
            char[][] grid = new char[2 * r + 1][2 * c + 1];
            for (int i = 0; i < grid.length; i++) {
                for (int j = 0; j < grid[0].length; j++) {
                    if (i % 2 == 0) {
                        if (j % 2 == 0) {
                            grid[i][j] = '+';
                        } else {
                            grid[i][j] = '-';
                        }
                    } else {
                        if (j % 2 == 0) {
                            grid[i][j] = '|';
                        } else {
                            grid[i][j] = '.';
                        }
                    }
                }
            }
            grid[0][0] = grid[0][1] = grid[1][0] = grid[1][1] = '.';
            for (char[] x : grid) {
                pw.println(new String(x));
            }
        }
        pw.close();
    }

    static class Scanner {
        BufferedReader br;
        StringTokenizer st;

        public Scanner(InputStream in) {
            br = new BufferedReader(new InputStreamReader(in));
        }

        public String next() throws IOException {
            while (st == null || !st.hasMoreTokens())
                st = new StringTokenizer(br.readLine());
            return st.nextToken();
        }

        public int nextInt() throws IOException {
            return Integer.",YahiaSherif
377,"class Solution {
    public static Scanner scan;
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int runtime = scan.nextInt();
        int a=1000000000;
        for(int i=0;i<runtime;i++){
            int num=scan.nextInt();
            int [] array=new int[num];
            int [] array2=new int[num];
            Arrays.sort(array);
            System.out.print(""Case #""+"" ""+(i+1)+"":"");
            int t=0;
            for(int d=0;d<array.length;d++) {
                t++;
                if (array[d]<t) {
                    t--;
                }
            }
            System.",ShuoXu
268,"public class Solution {
    public static int solve(int[] f, int[] p) {
        int[] f2 = Arrays.copyOf(f, f.length);
        Map<Integer, List<Integer>> tree = new HashMap<>();
        List<Integer> initiators = new ArrayList<>();
        for (int i=0; i<p.length; i++){
            List<Integer> children = tree.get(p[i]);
            if (children == null) {
                children = new ArrayList<Integer>();
                tree.put(p[i], children);
            }
            children.add(i+1);
        }
        for (int i=1; i<=f.length; i++) {
            if (!tree.containsKey(i)){
                initiators.add(i);
            }
        }
        for (int initiator: initiators) {
            int nodeId = initiator;
            f2[nodeId-1] = f[nodeId-1];
            while(p[nodeId-1] != 0) {
                if (f2[nodeId - 1] > f2[p[nodeId-1]-1]) {
                    f2[p[nodeId-1]-1] =  f2[nodeId - 1];
                }
                nodeId = p[nodeId-1];
            }
        }
        Deque<Integer> queue = new ArrayDeque<>();
        queue.addFirst(0);
        while(!queue.isEmpty()) {
            int nodeId = queue.pollFirst();
            int min = Integer.MAX_VALUE;
            int minChild = 0;
            if (!tree.containsKey(nodeId)) continue;
            for(int child: tree.get(nodeId)) {
                if (f2[child-1] < min) {
                    min = f2[child-1];
                    minChild = child;
                }
            }
            for(int child: tree.get(nodeId)) {
                queue.addFirst(child);
                if (nodeId!=0 && child == minChild) {
                    if (f[nodeId-1] > f[child-1]) {
                        f[child-1] = f[nodeId-1];
                    }
                }
            }
        }

        int result = 0;
        for (int initiator: initiators) {
            result += f[initiator-1];
        }

        return result;
    }
    public static void main(String[] args) {
        // Read input from stdin, write output to stdout
        Scanner in;
        try {
            in = new Scanner(new BufferedReader(new FileReader(""input.txt"")));
        } catch (IOException e) {
            // e.printStackTrace();
            in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        }

        int t = in.nextInt();
        for (int i=1; i<=t; i++) {
            int n = in.nextInt();
            int[] f = new int[n];
            int[] p = new int[n];
            for (int j=0; j<n; j++) {
                f[j] = in.nextInt();
            }
            for (int j=0; j<n; j++) {
                p[j] = in.nextInt();
            }
            int c = ",MehdiKalhori
184,"public class Solution {

	
	public static void main(String[] args) {
		Scanner s = new Scanner(System.in);
		int cases = s.nextInt();
		
		for(int caseIndex=0;caseIndex<cases;caseIndex++) {
			Node.ABYSS=new Node(0);
			int nodeCount = s.nextInt();
			Node[] nodes = new Node[nodeCount];
			for(int i=0;i<nodeCount;i++) {
				nodes[i]=new Node(s.nextInt());
			}
			
			ArrayList<Node> initiators = new ArrayList<>(Arrays.asList(nodes));
			
			for(int i=0;i<nodeCount;i++) {
				int parent = s.nextInt();

				if(parent>0) {
					initiators.remove(nodes[parent-1]);
					nodes[i].parent=nodes[parent-1];
					nodes[parent-1].children.add(nodes[i]);
				}else {
					nodes[i].parent=Node.ABYSS;
					Node.ABYSS.children.add(nodes[i]);
				}
			}
			ArrayList<Node> results = new ArrayList<>();
			Node.ABYSS.traverse(results);
			
			
			int maxValue = 0;
			for(Node initiator : results) {
				maxValue += initiator.validate(0);
				
			}
			System.out.println(""Case #""+(caseIndex+1)+"": ""+maxValue);
			
			
			
			
		}
		
		s.close();

	}
	
	public static class Node{
		int fun;
		Node parent;
		ArrayList<Node> children = new ArrayList<>();
		public static Node ABYSS = new Node(0);
		
		public Node(int fun) {
			this.fun=fun;
		}
		
		
		public void traverse(ArrayList<Node> initiators) {
			
			if(children.isEmpty()) {
				initiators.add(this);
			}
			
			Collections.sort(children, (c1,c2)->Integer.compare(c1.fun, c2.fun));
			
			for(Node n : children) {
				n.traverse(initiators);
			}
			
		}
		
		public int validate(int maxBefore) {
			if(parent != null) {
				maxBefore = Math.max(fun, maxBefore);
				int newMax = parent.validate(maxBefore);
				for(Node child: children) {
					child.parent=null;
				}
				return newMax;
			}else {
				return Math.max(fun, maxBefore);
			}
			
		}
		
		@Override
		public String toString() ",KovacsA22
327,"public class Solution {
	static int n;
	static int[] p;
	static long[] f;
	static ArrayList<Integer> adj[];
	static ArrayList<Integer> adj1[];
	
	static long[][] dp;
	public static void dfs(int i) {
		if(adj[i].isEmpty()) {
			dp[i][0] = 0;
			dp[i][1] = f[i];
			return;
		}
		for(int j : adj[i]) dfs(j);
		
		long allTake = 0;
		for(int j : adj[i]) allTake += dp[j][1];
		
		long maxTake = Long.MIN_VALUE;
		long maxTake2 = Long.MIN_VALUE;
		for(int j : adj[i]) {
			maxTake = Math.max(maxTake, f[i] + allTake - dp[j][1] + dp[j][0]);
			maxTake = Math.max(maxTake, dp[j][1]);
			maxTake2 = Math.max(maxTake2, allTake - dp[j][1] + dp[j][0]);
		}
		dp[i][1] = maxTake;
		dp[i][0] = maxTake2;
		dp[i][1] = Math.max(dp[i][1], dp[i][0]);
	}
	
	public static void solveCase() {
		int n = in.nextInt();
		f = in.nl(n);
		p = in.na(n);
		adj = new ArrayList[n];
		adj1 = new ArrayList[n];
		dp = new long[n][2];
		for(int i = 0; i<n; i++) Arrays.fill(dp[i], Integer.MIN_VALUE);
		ArrayList<Integer> first = new ArrayList<>();
		for(int i = 0; i<n; i++) {
			adj[i] = new ArrayList<>();
			adj1[i] = new ArrayList<>();
		}
		for(int i = 0; i<n; i++) {
			if(p[i]==0) {
				first.add(i);
				continue;
			}
			adj[p[i]-1].add(i);
			adj1[i].add(p[i]-1);
		}
		long ans = 0;
		for(int f : first) {
			dfs(f);
			ans += Math.max(dp[f][0], dp[f][1]);
		}
		out.println(ans);
	}
	
	public static void solve() {
		int t = in.nextInt();
		for (int i = 1; i <= t; i++) {
			out.print(""Case #"" + i + "": "");
			solveCase();
		}
	}

	public static void main(String[] args) {
		in = new Reader();
		out = new Writer();
		solve();
		out.exit();
	}

	static Reader in;
	static Writer out;

static class Reader {
	static BufferedReader br;
	static StringTokenizer st;
	
	public Reader() {
		br = new BufferedReader(new InputStreamReader(System.in));
	}
	
	public Reader(String f){
		try {
			br = new BufferedReader(new FileReader(f));
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	public int[] na(int n) {
		int[] a = new int[n];
		for (int i = 0; i < n; i++) a[i] = nextInt();
		return a;
	}

	public double[] nd(int n) {
		double[] a = new double[n];
		for (int i = 0; i < n; i++) a[i] = nextDouble();
		return a;
	}
	
	public long[] nl(int n) {
		long[] a = new long[n];
		for (int i = 0; i < n; i++) a[i] = nextLong();
		return a;
	}

	public char[] nca() {
		return next().toCharArray();
	}

	public String[] ns(int n) {
		String[] a = new String[n];
		for (int i = 0; i < n; i++) a[i] = next();
		return a;
	}

	public int nextInt() {
		ensureNext();
		return Integer.parseInt(st.nextToken());
	}

	public double nextDouble() {
		ensureNext();
		return Double.parseDouble(st.nextToken());
	}

	public Long nextLong() {
		ensureNext();
		return Long.parseLong(st.nextToken());
	}

	public String next() {
		ensureNext();
		return st.nextToken();
	}
	
	public String nextLine() {
		try {
			return br.readLine();
		} catch (Exception e) {
			e.printStackTrace();
			return null;
		}
	}
	
	private void ensureNext() {
		if (st == null || !st.hasMoreTokens()) {
			try {
				st = new StringTokenizer(br.readLine());
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	}
}

static class Util{
		private static Random random = new Random();
		static long[] fact;
		
		public static void initFactorial(int n, long mod) {
			fact = new long[n+1];
			fact[0] = 1;
			for (int i = 1; i < n+1; i++) fact[i] = (fact[i - 1] * i) % mod;
		}
		
		public static long modInverse(long a, long MOD) {
			long[] gcdE = gcdExtended(a, MOD);
			if (gcdE[0] != 1) return -1; // Inverted doesn't exist
			long x = gcdE[1];
			return (x % MOD + MOD) % MOD;
		}
		
		public static long[] gcdExtended(long p, long q) {
			if (q == 0) return new long[] { p, 1, 0 };
			long[] vals = gcdExtended(q, p % q);
			long tmp = vals[2];
			vals[2] = vals[1] - (p / q) * vals[2];
			vals[1] = tmp;
			return vals;
		}
		
		public static long nCr(int n, int r, long MOD) {
			if (r == 0) return 1;
			return (fact[n] * modInverse(fact[r], MOD) % MOD * modInverse(fact[n - r], MOD) % MOD) % MOD;
		}
		
		public static long nCr(int n, int r) {
			return (fact[n]/fact[r])/fact[n-r];
		}
		
		public static long nPr(int n, int r, long MOD) {
			if (r == 0) return 1;
			return (fact[n] * modInverse(fact[n - r], MOD) % MOD) % MOD;
		}
		public static long nPr(int n, int r) {
			return fact[n]/fact[n-r];
		}
		
		public static boolean isPrime(int n) { 
	        if (n <= 1) return false; 
	        if (n <= 3) return true; 
	        if (n % 2 == 0 || n % 3 == 0) return false; 
	        for (int i = 5; i * i <= n; i = i + 6) 
	            if (n % i == 0 || n % (i + 2) == 0) 
	            return false; 
	        return true; 
	    }
		
	    public static boolean[] getSieve(int n) {
	        boolean[] isPrime = new boolean[n+1];
	        for (int i = 2; i <= n; i++) isPrime[i] = true;
	        for (int i = 2; i*i <= n; i++) if (isPrime[i]) 
	                for (int j = i; i*j <= n; j++) isPrime[i*j] = false;
	        return isPrime;
	    }
	    
	    static long pow(long x, long pow, long mod){
	    	long res = 1;
	    	x = x % mod;
	    	if (x == 0) return 0;
	    	while (pow > 0){
	    		if ((pow & 1) != 0) res = ",Restricted
379,"public class Solution {
    public static Scanner scan;
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int runtime = scan.nextInt();
        int a=1000000000;
        for(int i=0;i<runtime;i++){
            int num=scan.nextInt();
            int [] array=new int[num];
            int [] array2=new int[num];
            for(int j=0;j<num;j++){
                int numside=scan.nextInt();
                array[j]=numside;
            }
            for(int d=0;d<array.length;d++) {
                for (int c = d+1; c < array.length; c++) {
                    if (array[d] > array[c]) {
                        a = array[d];
                        array[d] = array[c];
                        array[c] = a;
                    }
                }
            }
            for(int d=0;d<array.length;d++) {
                System.out.println(array[d]);
            }
            System.out.print(""Case #""+(i+1)+"":"");
            int t=0;
            for(int d=0;d<array.length;d++) {
                t++;
                if (array[d]<t) {
                    t--;
                }
            }
            System.",ShuoXu
449,"public class Solution {
    public static void main(String[] args) throws IOException {
        Scanner sc = new Scanner(System.in);
        PrintWriter pw = new PrintWriter(System.out);
        int t = sc.nextInt();
        int n = sc.nextInt();
        int k = sc.nextInt();
        for (int tc = 1; tc <= t; tc++) {
            int[] a = new int[n];
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt() - 1;
            }
            while (true) {
                int color = 1;
                int[] c = new int[n];
                for (int i = 0; i < n; i++) {
                    if (c[i] != 0) {
                        continue;
                    }
                    ArrayList<Integer> curAl = new ArrayList<>();
                    int cur = i;
                    while (c[cur] == 0) {
                        c[cur] = color;
                        curAl.add(cur);
                        cur = a[cur];
                    }
                    for (int j = 0; j < curAl.size(); j++) {
                        if (j != 0 && j % 100 == 0)
                            color++;
                        c[curAl.get(j)] = color;
                    }
                    color++;
                }
                for (int i = 0; i < n; i++) {
                    pw.print(c[i] + "" "");
                }
                pw.println();
                pw.flush();
                int res = sc.nextInt();
                if (res == -1) {
                    System.exit(0);
                }
                if (res != 0) {
                    break;
                }
                for (int i = 0; i < n; i++) {
                    a[i] = sc.nextInt() - 1;
                }
            }
        }
        pw.close();
    }

    static class Scanner {
        BufferedReader br;
        StringTokenizer st;

        public Scanner(InputStream s) {
            br = new BufferedReader(new InputStreamReader(s));
        }

        public Scanner(FileReader f) {
            br = new BufferedReader(f);
        }

        public String next() throws IOException {
            while (st == null || !st.hasMoreTokens())
                st = new StringTokenizer(br.readLine());
            return st.nextToken();
        }

        public int nextInt() throws IOException {
            return Integer.parseInt(next());
        }

        public long nextLong() throws IOException {
            return Long.parseLong(next());
        }

        public double nextDouble() throws IOException {
            return Double.parseDouble(next());
        }

        public int[] nextIntArr(int n) throws IOException {
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = ",YahiaSherif
571,"public class Solution {
    private final InputStream in;
    private final PrintWriter out;
    private final Scanner scanner;

    public Solution(InputStream in, OutputStream outs) {
        this.in = in;
        this.scanner = new Scanner(in);
        this.out = new PrintWriter(new BufferedOutputStream(outs));
    }

    public static void main(String[] args) throws IOException {
        new Solution(System.in, System.out).solve();
    }

    void solve() throws IOException {
        int t = scanner.nextInt();
        for (int i = 1; i <= t; i++) {
            int r = scanner.nextInt();
            int c = scanner.nextInt();
            out.printf(""Case #%d
"", i);
            for (int j = 0; j < r*2+1; j++) {
                for (int k = 0; k < c*2+1; k++) {
                    if(j<=1 && k<=1) {
                        out.print('.');
                        continue;
                    }
                    if(j%2==0) {
                        out.print((k%2==0)?'+':'-');
                    } else {
                        out.print((k%2==0)?'|':'.');
                    }
                }
                out.println();
            }
        }
        out.flush();
        out",bdomokos74
42,"public class Solution {

  
    public static void main(String[] args) {
          Scanner keyboard = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
    int a;
    int b;
    a = keyboard.nextInt();
    int[]arrcount = new int [a];
    int array1[] = new int [1];
    int array2[] = new int [1];
    int array3[] = new int [1];
    int array4[] = new int [1];
    int array5[] = new int [1];
    int array6[] = new int [1];
    int array7[] = new int [1];
    int array8[] = new int [1];
    int array9[] = new int [1];
    int array10[] = new int [1];
            
    
    
    if (a > 0)
    {
        b = keyboard.nextInt();
               arrcount[0] = b; 
               array1 = new int [b];
        for (int c = 0; c<b; c++)
        {
            
    array1[c]=keyboard.nextInt();
    
    }
    }
    
        if (a > 1)
    {
        b = keyboard.nextInt();
              arrcount[1] = b;  
              array2 = new int [b];
        for (int c = 0; c<b; c++)
        {
            
    array2[c]=keyboard.nextInt();
    
    }
    }
        
         if (a > 2)
    {
        b = keyboard.nextInt();
            arrcount[2] = b;    array3 = new int[b];
        for (int c = 0; c<b; c++)
        {
            
    array3[c]=keyboard.nextInt();
    
    }
    }
         
          if (a > 3)
    {
        b = keyboard.nextInt();
                array4 = new int [b];
                arrcount[3] = b;
        for (int c = 0; c<b; c++)
        {
            
    array4[c]=keyboard.nextInt();
    }
    }
          
           if (a > 4)
    {
        b = keyboard.nextInt();
                array5 = new int [b];
                arrcount[4] = b;
        for (int c = 0; c<b; c++)
        {
            
    array5[c]=keyboard.nextInt();
    }
    }
           
            if (a > 5)
    {
        b = keyboard.nextInt();
                array6 = new int[b];
                arrcount[5] = b;
        for (int c = 0; c<b; c++)
        {
            
    array6[c]=keyboard.nextInt();
    }
    }
            
             if (a > 6)
    {
        b = keyboard.nextInt();
                array7 = new int [b];
                arrcount[6] = b;
        for (int c = 0; c<b; c++)
        {
            
    array7[c]=keyboard.nextInt();
    }
    }
             
              if (a > 7)
    {
        b = keyboard.nextInt();
                array8 = new int[b];
                arrcount[7] = b;
        for (int c = 0; c<b; c++)
        {
            
    array8[c]=keyboard.nextInt();
    }
    }
              
               if (a > 8)
    {
        b = keyboard.nextInt();
                array9 = new int[b];
                arrcount[8] = b;
        for (int c = 0; c<b; c++)
        {
            
    array9[c]=keyboard.nextInt();
    }
    }
               
                if (a > 9)
    {
        b = keyboard.nextInt();
                array10 = new int[b];
                arrcount[9] = b;
        for (int c = 0; c<b; c++)
        {
            
    array10[c]=keyboard.nextInt();
    }
    }
             
    if (a>0)
    {
        int count = 0;
        int e = arrcount[count];
       
        if (arrcount[count]<=4)
        {
        System.out.println(""Case #""+(count+1)+"":""+"" ""+arrcount[count]);
        }

        else
        {
            Arrays.sort(array1);
            int n_count=4;
            for (int z = 4; z < arrcount[count];z++)
            {
                if ((array1[z]>array1[z-1])||(((array1[z])-1)>=array1[z-2]))
                {
                    n_count++;
                }
            }
            if (array1[arrcount[count]-1]>n_count)
            System.out.println(""Case #""+(count+1)+"":""+"" ""+n_count);
            else
                System.out.println(""Case #""+(count+1)+"":""+"" ""+array1[arrcount[count]-1]);
        }
        
    }
    if (a>1)
    {
        int count = 1;
        int e = arrcount[count];
       
        if (arrcount[count]<=4)
        {
        System.out.println(""Case #""+(count+1)+"":""+"" ""+arrcount[count]);
        }

        else
        {
            Arrays.sort(array2);
            int n_count=4;
            for (int z = 4; z < arrcount[count];z++)
            {
                if ((array2[z]>array2[z-1])||(((array2[z])-1)>=array2[z-2]))
                {
                    n_count++;
                }
            }
                        if (array2[arrcount[count]-1]>n_count)
            System.out.println(""Case #""+(count+1)+"":""+"" ""+n_count);
            else
                System.out.println(""Case #""+(count+1)+"":""+"" ""+array2[arrcount[count]-1]);
        }
        
    }
        if (a>2)
    {
        int count = 2;
        int e = arrcount[count];
       
        if (arrcount[count]<=4)
        {
        System.out.println(""Case #""+(count+1)+"":""+"" ""+arrcount[count]);
        }

        else
        {
            Arrays.sort(array3);
            int n_count=4;
            for (int z = 4; z < arrcount[count];z++)
            {
                if ((array3[z]>array3[z-1])||(((array3[z])-1)>=array3[z-2]))
                {
                    n_count++;
                }
            }
                        if (array3[arrcount[count]-1]>n_count)
            System.out.println(""Case #""+(count+1)+"":""+"" ""+n_count);
            else
                System.out.println(""Case #""+(count+1)+"":""+"" ""+array3[arrcount[count]-1]);
        }
        
    }

            if (a>3)
    {
        int count = 3;
        int e = ",Ak9
786,"public class Solution {

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        PrintStream out = System.out;

        try {
//            in = new Scanner(new BufferedReader(new FileReader(""/Users/Shared/Sources/CodingStudy/src/codejam/year2022/round_QA/ChainReactions/sample/sample_ts1-in.txt"")));
//            out = new PrintStream(new FileOutputStream(""/Users/Shared/Sources/CodingStudy/src/codejam/year2022/round_QA/ChainReactions/sample/sample_ts1-out.txt""));

//            in = new Scanner(new BufferedReader(new FileReader(""/Users/Shared/Sources/CodingStudy/src/codejam/year2022/round_QA/ChainReactions/sample/sample_ts2-in.txt"")));
//            out = new PrintStream(new FileOutputStream(""/Users/Shared/Sources/CodingStudy/src/codejam/year2022/round_QA/ChainReactions/sample/sample_ts2-out.txt""));

        } catch (Exception e) {
            e.printStackTrace();
            return;
        }

        int T = in.nextInt();
        for (int t = 1; t <= T; t++) {
            int N = in.nextInt();

            int[] F = new int[N];
            for( int i=0;i<N;i++){
                F[i] = in.nextInt();
            }
            int[] parent = new int[N];
            for( int i=0;i<N;i++){
                parent[i] = in.nextInt();
            }

            long ans = getAnswer(N, F, parent);

            out.printf(""Case #%d: %d
"", t, ans);
        }
        in.close();
    }


    private static long getAnswer(int N, int[] F, int[] parent) {

        Map<Integer, List<Integer>> graph = new HashMap<>();

        Map<Integer,Integer> inDegree = new HashMap<>();
        Map<Integer,Integer> outDegree = new HashMap<>();

        Map<Integer,Boolean> visited = new HashMap<>();

        /* 1. Build graph. */
        for(int i=1;i<=N;i++) {
            graph.put(i, new ArrayList<>());
            inDegree.put(i, 0);
            outDegree.put(i, 0);
            visited.put(i, false);
        }

        for(int i=0;i<N;i++){
            int childNo = i + 1;
            int parentNo = parent[i];

            if( parentNo != 0) {
                graph.get(parentNo).add(childNo);
                inDegree.put(parentNo, inDegree.get(parentNo) + 1);
                outDegree.put(childNo, 1);
            }else{
                outDegree.put(childNo, 0);
            }

        }

        /* 3. Do DFS by maxEst */
        long ans = doDFSByMaxEst(N, F, graph, outDegree, visited);
        return ans;
    }

    private static long doDFSByMaxEst(int N, int[] F, Map<Integer, List<Integer>> graph, Map<Integer, Integer> outDegree, Map<Integer,Boolean> visited) {
        long sum = 0;
        for(Map.Entry<Integer,Integer> entry : outDegree.entrySet()){
            int rootNo = entry.getKey();
            if(entry.getValue() == 0 && visited.get(rootNo) == false){
                long val = doDFSByMaxEst(N, F, graph, rootNo, visited);
                sum += val;
            }
        }

        return sum;
    }

    private static long doDFSByMaxEst(int N, int[] F, Map<Integer, List<Integer>> graph, int rootNo, Map<Integer,Boolean> visited) {
        visited.put(rootNo, true);

        // Leaf node
        if( graph.get(rootNo).size() == 0){
            return F[rootNo-1];
        }

        // Non-leaf node
        long sum = F[rootNo-1];
        long minVal = sum;
        List<Long> cands = new ArrayList<>();
        cands.add(sum);

        for(int childNo: graph.get(rootNo)){
            if( visited.get(childNo) == false) {
                long val = doDFSByMaxEst(N, F, graph, childNo, visited);
                sum += val;
                minVal = Math.min(minVal, val);

                cands.add(val);
            };
        }
        sum = sum - minVal;

//        System.err.printf(""RootNo: %d Ret: %d Values: %s
"", rootNo, sum, cands);

        return sum;
    }
}",id
47,"public class Solution
{
	public static void main(String[] args) {
		Scanner input=new Scanner(System.in);
		int t=input.nextInt();
		for(int k=0;k<t;k++)
		{
		    String a=input.next();
		    int arr[]=new int[a.length()];
		    for(int i=0;i<a.length();i++)
		    {
		        arr[i]=(int)a.charAt(i);
		    }
		    HashSet<Integer> hs=new HashSet<>();
		    for(int i=0;i<arr.length;i++)
		    {
		        hs.add(arr[i]);
		    }
		    System.out.print(""Case #""+(k+1)+"": "");
		    if(hs.size()<=1)
		    {
		        System.out.print(a);
		    }
		    else
		    {
		      //  for(int i=0;i<arr.length;i++)
    		  //  {
    		  //      System.out.print(arr[i]+"" "");
    		  //  }
    		    String res="""";
    		    for(int i=0;i<arr.length-1;i++)
    		    {
    		        if((arr[i+1])>=arr[i])
    		        {
    		            res+=(char)arr[i];//+(char)arr[i];
    		            res+=(char)arr[i];
    		        }
    		        else
    		        {
    		            res+=(char)arr[i];
    		        }
    		        
    		    }
    		    res+=(char)arr[arr.length-1];
    		    System.out.print(res);
		    }
		    if(k!=t-1)
    		{
                System.",AniketTewari
111,"class Solution{
    public static Scanner s= new Scanner(System.in);
    public static void main(String[] args){
        int t= s.nextInt();
        for(int i=1;i<=t;i++){
            int n= s.nextInt();
            System.out.println(""Case #""+i+"":  ""+ ans(n));
        }
    }
    public static int ans(int n){
        PriorityQueue<Integer> pq= new PriorityQueue<>();
        for(int i =0 ; i< n;i++){
            int x= s.nextInt();
            pq.add(x); 
        }
        int l=0;
        while(!pq.isEmpty()){
            int temp = pq.poll();
            if(l<=temp){
                l++;
            }
            else",Dyeahhh
215,"public class Solution {
    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        int c=s.nextInt();
        int wj = s.nextInt();
        ArrayList<Integer> wjj=new ArrayList<>();
        for (int t = 0; t < c; t++) 
        {
            for(int z=0;z<wj;z++)
            { wjj.add(s.nextInt());}
    
            System.out.print(""Case #"" + (t + 1)+"":"");
            int min=wjj.get(0);
            int o=0;
            int f=0;
         int[] l=new int[wjj.size()];
            for(int w=0;w<wjj.size();w++)
            {
              for(int k=0;k<wjj.size();k++) 
              {
                  if((int)wjj.get(k)<=min)
                  {min=(int)wjj.get(k);
                  o=k;}
              }
              if(f>wjj.get(o))
              break;
              l[w]=f;
              f++;
              wjj.remove(o);
              w--;
            }
            System.",LeonardWang
34,"public class Solution {


    public static void main(String[] args) {
    Scanner keyboard = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
    int a;
    int[]array1;
    int[]array2;
    
    a = keyboard.nextInt();
    array1 = new int[a];
    array2 = new int[a];
    
for (int b = 0; b<a; b++)
{
  array1[b]=keyboard.nextInt();
  array2[b]=keyboard.nextInt();
 
}    
      for (int e = 0; e<a; e++)
      {
          
          System.out.println(""Case #""+(e+1));
          for (int d = 0; d< array1[e]; d++)
          {
              for (int row = 0; row < 2; row++)
              {
                  for (int c = 0; c < array2[e]; c++)
                  {
                      if (c==0&&d==0)
                      {
                          System.out.print("".."");
                      }
                      else if (row==0)
                      {
                          System.out.print(""+-"");
                      }
                      else if (row==1)
                      {
                          System.out.print(""|."");
                      }
                  }
                  if (row==0)
                  {
                      System.out.print(""+"");
                  }
                  else
                  {
                      System.out.print(""|"");
                  }
                     System.out.println(); 
              }
          }
          for (int f = 0; f <array2[e]; f++)
          {
              System.out.print(""+-"");
          }
          System.",Ak9
668,"public class Solution {
    public static int[] F;
    public static int[][] graph;
    public static void main(String[] args) throws IOException {
        FastScanner input = new FastScanner(false);
        int T = input.nextInt();
        for (int iter = 1; iter<=T; iter++) {
            int N = input.nextInt();
            F = new int[N+1];
            for (int i = 1; i<=N; i++) {
                F[i]=input.nextInt();
            }
            graph = new int[N+1][];
            int[] sizes = new int[N+1];
            int[][] edges = new int[N][2];
            for (int i = 0; i<N; i++) {
                edges[i]=new int[]{input.nextInt(),i+1};
                sizes[edges[i][0]]++;
            }
            for (int i = 0; i<=N; i++) {
                graph[i]=new int[sizes[i]];
            }
            for (int i = 0; i<N; i++) {
                graph[edges[i][0]][--sizes[edges[i][0]]]=edges[i][1];
            }
            System.out.println(""Case #""+iter+"": ""+dfs(0,0));
        }
    }
    public static long dfs(int node, long maxAncestor) {
        long newMaxAncestor = Math.max(F[node],maxAncestor);
        long[] noCurrent = new long[graph[node].length];
        long totalNoCurrent = 0;
        for (int i = 0; i<graph[node].length; i++) {
            noCurrent[i]=dfs(graph[node][i],0);
            totalNoCurrent+=noCurrent[i];
        }
        long res = newMaxAncestor;
        for (int i = 0; i<graph[node].length; i++) {
            int neighbor = graph[node][i];
            res = Math.max(res,totalNoCurrent-noCurrent[i]+dfs(neighbor,newMaxAncestor));
        }
        return res;
    }
    private static class FastScanner {
        final private int BUFFER_SIZE = 1 << 16;
        private DataInputStream din;
        private byte[] buffer;
        private int bufferPointer, bytesRead;
        private FastScanner(boolean usingFile) throws IOException {
            if (usingFile) din=new DataInputStream(new FileInputStream(""C:\\\Users\\\skwek\\\IdeaProjects\\\HelloWorld\\\src\\	esting.in""));
            else din = new DataInputStream(System.in);
            buffer = new byte[BUFFER_SIZE];
            bufferPointer = bytesRead = 0;
        }
        private short nextShort() throws IOException {
            short ret = 0;
            byte c = read();
            while (c <= ' ') c = read();
            boolean neg = (c == '-');
            if (neg) c = read();
            do ret = (short)(ret * 10 + c - '0');
            while ((c = read()) >= '0' && c <= '9');
            if (neg) return (short)-ret;
            return ret;
        }
        private int nextInt() throws IOException {
            int ret = 0;
            byte c = read();
            while (c <= ' ') c = read();
            boolean neg = (c == '-');
            if (neg) c = read();
            do ret = ret * 10 + c - '0';
            while ((c = read()) >= '0' && c <= '9');
            if (neg) return -ret;
            return ret;
        }
        public long nextLong() throws IOException {
            long ret = 0;
            byte c = read();
            while (c <= ' ') c = read();
            boolean neg = (c == '-');
            if (neg) c = read();
            do ret = ret * 10 + c - '0';
            while ((c = read()) >= '0' && c <= '9');
            if (neg) return -ret;
            return ret;
        }
        private char nextChar() throws IOException {
            byte c = read();
            while (c <= ' ') c = read();
            return (char)c;
        }
        private String nextString() throws IOException {
            StringBuilder ret = new StringBuilder();
            byte c = read();
            while (c <=' ') c = read();
            do {
                ret.append((char)c);
            } while ((c = read())>' ');
            return ret.toString();
        }
        private void fillBuffer() throws IOException {
            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);
            if (bytesRead == -1)  buffer[0] = -1;
        }
        private byte read() throws IOException ",ekwek
1261,"public class Solution {
    {
        MULTI_TEST = false;
        FILE_NAME = """";
        NEED_FILE_IO = false;
        INF = (long) 1e18;
    } // fields


    int n;
    int[] a;
    BigInteger sum;
    BigInteger sumSquare;
    BigInteger binsearch() {
        BigInteger l = new BigInteger(""-1000000000000000001""), r = new BigInteger(""1000000000000000001"");

        while(r.subtract(l).compareTo(BigInteger.ONE) > 0) {
            BigInteger m = r.add(l).divide(BigInteger.TWO);

            if((sum.add(m)).multiply(sum.add(m)).compareTo(sumSquare.add(m.multiply(m))) == 0) {
                return m;
            }
            //(sum + m) ^ 2 > sumSquare + m^2; -> we need to increment (r = m, else l = m);
            if((sum.add(m)).multiply(sum.add(m)).compareTo(sumSquare.add(m.multiply(m))) > 0) {
                r = m;
            } else {
                l = m;
            }
        }
        return l;
    }
    String solve_test() {
        n = ri();
        int k = ri();
        int[] a = ria(n);
        sum = BigInteger.ZERO;
        for(int i = 0; i < n; i++) {
            sum = sum.add(BigInteger.valueOf(a[i]));
        }
        sumSquare = BigInteger.ZERO;
        for(int i = 0; i < n; i++) {
            BigInteger x = BigInteger.valueOf(a[i]);
            sumSquare = sumSquare.add(x.multiply(x));
        }
        BigInteger answer = binsearch();
        if(answer.compareTo(new BigInteger(""-1000000000000000000"")) < 0 || answer.compareTo(new BigInteger(""100000000000000000"")) > 0) {
            return ""IMPOSSIBLE"";
        } else {
            return answer.toString();
        }
        //return """";
    }
    void solve() {
        int t = ri();
        for(int it = 1; it <= t; it++) {
            out.printf(""Case #%d: %s
"", it, solve_test());
        }
    }

    public static void main(String[] args) {
        new Solution().run();
    } //main

    @SuppressWarnings(""unused"")
    long gcd(long a, long b) {
        return b == 0 ? a : gcd(b, a % b);
    }

    @SuppressWarnings(""unused"")
    long lcm(long a, long b) {
        return a / gcd(a, b) * b;
    }

    @SuppressWarnings(""unused"")
    int gcd(int a, int b) {
        return (int) gcd((long) a, b);
    }

    @SuppressWarnings(""unused"")
    int lcm(int a, int b) {
        return (int) lcm(a, (long) b);
    }

    @SuppressWarnings(""unused"")
    int sqrtInt(int x) {
        return (int) sqrtLong(x);
    }

    @SuppressWarnings(""unused"")
    long sqrtLong(long x) {
        long root = (long) Math.sqrt(x);
        while (root * root > x) --root;
        while ((root + 1) * (root + 1) <= x) ++root;
        return root;
    }

    @SuppressWarnings(""unused"")
    int cbrtLong(long x) {
        int cbrt = (int) Math.cbrt(x);
        while ((long) cbrt * cbrt >= x) {
            cbrt--;
        }
        while ((long) (cbrt + 1) * (cbrt + 1) <= x) cbrt++;
        return cbrt;
    }

    @SuppressWarnings(""unused"")
    long binpow(long a, long power) {
        return binpow(a, power, Long.MAX_VALUE);
    }

    @SuppressWarnings(""unused"")
    long binpow(long a, long power, long modulo) {
        if (power == 0) return 1 % modulo;
        if (power % 2 == 1) {
            long b = binpow(a, power - 1, modulo) % modulo;
            return ((a % modulo) * b) % modulo;
        } else {
            long b = binpow(a, power / 2, modulo) % modulo;
            return (b * b) % modulo;
        }
    }

    @SuppressWarnings(""unused"")
    long fastMod(String s1, long n2) {
        long num = 0;
        for (int i = 0; i < s1.length() - 1; i++) {
            num += Integer.parseInt(String.valueOf(s1.charAt(i)));
            num *= 10;
            if (num >= n2) {
                num = num % n2;
            }
        }
        return (num + Integer.parseInt(String.valueOf(s1.charAt(s1.length() - 1)))) % n2;
    }

    @SuppressWarnings(""unused"")
    long factorialMod(long n, long p) {
        long res = 1;
        while (n > 1) {
            res = (res * ((n / p) % 2 == 1 ? p - 1 : 1)) % p;
            for (int i = 2; i <= n % p; ++i)
                res = (res * i) % p;
            n /= p;
        }
        return res % p;
    }

    @SuppressWarnings(""unused"")
    boolean isPrime(int number) {
        for (int i = 2; i * i <= number; i++) {
            if (number % i == 0) {
                return false;
            }
        }
        return number > 1;
    }

    @SuppressWarnings(""unused"")
    boolean[] primes(int border) {
        boolean[] isPrimes = new boolean[border + 1];
        Arrays.fill(isPrimes, true);
        isPrimes[0] = false;
        isPrimes[1] = false;
        for (int i = 2; i < border + 1; i++) {
            if (!isPrimes[i]) continue;
            for (int k = i * 2; k < border; k += i) {
                isPrimes[k] = false;
            }
        }
        return isPrimes;
    } //Number theory

    @SuppressWarnings(""unused"")
    void sort(int[] a) {
        int n = a.length;
        Integer[] arr = new Integer[n];
        for (int i = 0; i < n; i++) {
            arr[i] = a[i];
        }
        Arrays.sort(arr);
        for (int i = 0; i < n; i++) {
            a[i] = arr[i];
        }
    }

    @SuppressWarnings(""unused"")
    void sort(long[] a) {
        int n = a.length;
        Long[] arr = new Long[n];
        for (int i = 0; i < n; i++) {
            arr[i] = a[i];
        }
        Arrays.sort(arr);
        for (int i = 0; i < n; i++) {
            a[i] = arr[i];
        }
    }

    @SuppressWarnings(""unused"")
    int max(int[] a) {
        int n = a.length;
        int max = Integer.MIN_VALUE;
        for (int j : a) {
            if (j > max) max = j;
        }
        return max;
    }

    @SuppressWarnings(""unused"")
    long max(long[] a) {
        int n = a.length;
        long max = Long.MIN_VALUE;
        for (long l : a) {
            if (l > max) max = l;
        }
        return max;
    }

    @SuppressWarnings(""unused"")
    int maxIndex(int[] a) {
        int n = a.length;
        int max = Integer.MIN_VALUE;
        int index = 0",v0s7er
744,"public class Solution {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);

    int T = sc.nextInt();
    for (int tc = 1; tc <= T; ++tc) {
      int N = sc.nextInt();
      char[][] matrix = new char[2 * N][2 * N];
      for (int r = 0; r < 2 * N; ++r) {
        String line = sc.next();
        for (int c = 0; c < 2 * N; ++c) {
          matrix[r][c] = line.charAt(c);
        }
      }

      System.out.println(String.format(""Case #%d: %d"", tc, solve(matrix)));
    }

    sc.close();
  }

  static int solve(char[][] matrix) {
    int N = matrix.length / 2;

    return Math.abs(
            computeINum(matrix, 0, 0, N - 1, N - 1)
                - computeINum(matrix, N, N, 2 * N - 1, 2 * N - 1))
        + Math.abs(
            computeINum(matrix, 0, N, N - 1, 2 * N - 1)
                - computeINum(matrix, N, 0, 2 * N - 1, N - 1));
  }

  static int computeINum(char[][] matrix, int minR, int minC, int maxR, int maxC) {
    int result = 0;
    for (int r = minR; r <= maxR; ++r) {
      for (int c = minC; c <= maxC; ++c) {
        if (matrix[r][c] == 'I') {
          ++result;
        }
      }
    }

    return result;
  }
}",goalboy1015
346,"public class Solution {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        PrintWriter pw = new PrintWriter(System.out);

        int testCases = sc.nextInt();
        for (int testCase = 1; testCase <= testCases; testCase++) {
            Map<Integer, List<Integer>> map = new HashMap<>();
            List<Integer> resList = new ArrayList<>();

            int N = sc.nextInt();

            int[] F = new int[N + 1];
            int[] P = new int[N + 1];

            for (int i = 1; i <= N; i++) F[i] = sc.nextInt();
            for (int i = 1; i <= N; i++) P[i] = sc.nextInt();


            for (int i = 1; i <= N; i++) {
                map.putIfAbsent(P[i], new ArrayList<>());
                map.get(P[i]).add(i);
            }
            int res = helper(map, F, 0, resList);
            res += resList.stream().reduce(0, Integer::sum);

            pw.println(""Case #"" + testCase + "": "" + res);
        }

        pw.close();
        sc.close();
    }

    private static int helper(Map<Integer, List<Integer>> map, int[] F, int idx, List<Integer> resList) {
        if (!map.containsKey(idx)) {
            return F[idx];
        }

        int sum = 0, min = Integer.MAX_VALUE;
        for (int childIdx : map.get(idx)) {
            if (childIdx > idx) {
                int cur = helper(map, F, childIdx, resList);
                min = Math.min(min, cur);
                sum += cur;
            } else {
                resList.add(helper(map, F, childIdx, resList));
            }
        }
        sum -= min;
        if (sum != 0)
            resList.add(sum);
        return Math.",S
419,"public class Solution {


    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);

        int testCases = sc.nextInt();

        for (int caseNum = 0; caseNum < testCases; caseNum++) {

            int[][] printers = new int[3][4];

            for (int i = 0; i < 12; i++) {
                printers[i/4][i%4] = sc.nextInt();
            }


            Integer     a = Math.min(Math.min(printers[0][0],printers[1][0]),printers[2][0]),
                    b = Math.min(Math.min(printers[0][1],printers[1][1]),printers[2][1]),
                    c = Math.min(Math.min(printers[0][2],printers[1][2]),printers[2][2]),
                    d = Math.min(Math.min(printers[0][3],printers[1][3]),printers[2][3]);



            int sum = a + b + c + d;

            if(sum == 1e6){
                System.out.print(""Case #"" + (caseNum + 1) + "":"");
                System.out.println(a + "" "" + b + "" "" + c + "" "" +d);
            }else if(sum > 1e6){
                int diff = sum - (int) 1e6;

                if (a - diff > 0) {
                    a -= diff;
                } else if (b - diff > 0) {
                    b -= diff;
                } else if (c - diff > 0) {
                    c -= diff;
                } else if(d - diff > 0){
                    d -= diff;
                }

                while(sum != 1e6) {
                    diff = sum - (int) 1e6;

                    if(diff > 10000){

                        if(a > b && a > c && a > d){
                            a -= 10000;
                        }else if(b > a && b > c && b > d){
                            b -= 10000;
                        }else if(c > b && c > a && c > d){
                            c -= 10000;
                        }else{
                            d -= 10000;
                        }
                    }else{
                        if(a > b && a > c && a > d){
                            a -= diff;
                        }else if(b > a && b > c && b > d){
                            b -= diff;
                        }else if(c > b && c > a && c > d){
                            c -= diff;
                        }else{
                            d -= diff;
                        }
                    }
                    sum = a + b + c + d;
                }

                System.out.print(""Case #"" + (caseNum + 1) + "":"");
                System.out.println(a + "" "" + b + "" "" + c + "" "" +d);
            }else{
                System.",SurgeM
647,"public class Solution {

    public static void main(String[] args) {
        
        Scanner scan = new Scanner(System.in); 
        int numOfCases = scan.nextInt();
        
        int x = 1; // Test Case Number (starting from 1)
        
        int r = 0;
        int c = 0;
        
        for (int i = 0; i < numOfCases; i++) {
            r = scan.nextInt();
            c = scan.nextInt();
            
            System.out.println(""Case #"" + x + "": "");
            
            // First Two Lines
            if (r <= 2) {
                System.out.print("".."");
                for (int j = 1; j < c; j++) {
                    System.out.print(""+-"");
                }
                System.out.println(""+"");
                
                System.out.print("".."");
                for (int k = 1; k < c; k++) {
                    System.out.print(""|."");
                }
                System.out.println(""|"");
            }
            
            if (r > 2 && r < 8) {
                System.out.print("".."");
                for (int j = 0; j < r; j++) {
                    System.out.print(""+-"");
                }
                System.out.println(""+"");
                
                System.out.print("".."");
                for (int k = 0; k < r; k++) {
                    System.out.print(""|."");
                }
                System.out.println(""|"");
            }
            
            if (r >= 8) {
                System.out.print("".."");
                for (int j = 0; j < r - 1; j++) {
                    System.out.print(""+-"");
                }
                System.out.println(""+"");
                
                System.out.print("".."");
                for (int k = 0; k < r - 1; k++) {
                    System.out.print(""|."");
                }
                System.out.println(""|"");                
            }
            
            // Remaining Lines 
            for (int j = 0; j < r - 1; j++) {
                for (int k = 0; k < c; k++) {
                    System.out.print(""+-"");
                }
                System.out.println(""+"");
                
                for (int l = 0; l < c - 1; l++) {
                    System.out.print(""|."");
                }
                System.out.println(""|.|"");
            }
            
            // Last Lines
            for (int l = 0; l < c; l++) {
                System.out.print(""+-"");
            }
            System.",dtarde
932,"public class Solution {
    // TODO: changes this to  >>>  false
    static final boolean debug = false; // false | true
    ///////////////////////////////////////////
    static final String FILENAME = ""src/main/java/google/codejam/y2022/quali3/"";
    static final String IN = FILENAME + ""sample.in"";
    static final String OUT = FILENAME + ""out.out"";
    static final String IMPOSSIBLE = ""IMPOSSIBLE"";
    ///////////////////////////////////////////
    static int P;

    private static void solve() {
        int N = in.nextInt();
        Queue<Integer> queue = new PriorityQueue<>(N);
        for (int i = 0; i < N; i++) {
            queue.add(in.nextInt());
        }

        int next = 1;
        while (!queue.isEmpty()) {
            int head = queue.remove();
            if (head >= next) {
                next += 1;
            }
        }

        print(next-1);
    }

    private static void print(Object s) {
        out.println(s);
        out.flush();
        if (debug)
            System.out.println(s);
    }

    private static void print(int[] i) {
        String s = Arrays.stream(i).mapToObj(String::valueOf).collect(Collectors.joining("" ""));
        out.println(s); out.flush();
        if (debug) System.out.println(s);
    }

    private static Scanner in;
    private static PrintStream out;

    private static void run() throws Exception {
        if (debug) {
            in = new Scanner(new File(IN));
            // in = new Scanner(Quali4.class.getResourceAsStream(IN));
            out = new PrintStream(new FileOutputStream(OUT));
        } else {
            in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
            out = System.out;
        }
        int t = in.nextInt();
        for (int i = 1; i <= t; i++) {
            out.print(""Case #"" + i + "": "");
            solve();
        }
        in.close();
        out.",levios
1177,"public class Solution {
    public static void main(String[] args) throws IOException {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt();
        for(int i = 1; i <= t; ++i){
            int n = scanner.nextInt();
            int values[] = new int[n];
            int links[] = new int[n];
            for(int j = 0; j < n; ++ j){
                values[j] = scanner.nextInt();
            }
            for(int j = 0; j < n; ++ j){
                links[j] = scanner.nextInt() - 1;
            }
            System.out.println(String.format(""Case #%d: %d"",i,solve(values,links,n)));
        }
    }

    public static int solve(int[] values, int[] links, int n){
        Node[] nodes = new Node[n];
        Node root = new Node(0);
        for(int i = 0; i < n; ++i){
            nodes[i] = new Node(values[i]);
        }
        for(int i = 0; i < n; ++i){
            if(links[i] == -1){
                root.initiators.add(nodes[i]);
            }else{
                nodes[links[i]].initiators.add(nodes[i]);
            }
        }
        return root.maxFactor();
    }

    public static class Node{
        public int val;
        public Set<Node> initiators;

        public Node(int v){
            val = v;
            initiators = new HashSet<>();
        }

        int maxFactor(){
            if(initiators.isEmpty()){
                return val;
            }
            if(initiators.size() == 1){
                return Math.max(initiators.iterator().next().maxFactor(),val);
            }
            List<Integer> si =  initiators.stream().map(i -> i.maxFactor()).sorted().collect(Collectors.toList());
            Iterator<Integer> itr = si.iterator();
            int fun = Math.max(itr.next(),val);
            while(itr.hasNext()){
                fun += itr.",smartelf
401,"class Solution{
    static double maxans;
    public Solution(){
        maxans=0;
    }
    
    public static LinkedList<Integer> adj[];
    public static void Com(int end,int[] initiator,int N,List<Integer> temp,boolean[] tracker,double [] fun){
        if(temp.size()==end){
            double ans=0;
            boolean[] tracke = new boolean[N+1];
            tracke[0]=true;
            for(Integer v: temp){
                ans+=DFS(v,fun,tracke);
            }
            for(int i=0;i<N+1;i++){
                if(!tracke[i]){
                    ans+=fun[i-1];
                }
            }
            maxans=Math.max(maxans,ans);
            return;
        }
        for(int i=0 ;i<end;i++){
            if(!tracker[i]){
                temp.add(initiator[i]);
                tracker[i]=true;
                Com(end,initiator,N,temp,tracker,fun);
                temp.remove(temp.size()-1);
                tracker[i]=false;
            }
        }
        
    }
    
    public static double DFS(int s,double[] fun,boolean[] tracker){
        if(tracker[s]){
            return 0;
        }
        double max=fun[s-1];
        tracker[s]=true;
        Iterator<Integer> i = adj[s].listIterator();
        while(i.hasNext()){
            int n= i.next();
            if(!tracker[n]){
                double score = DFS(n,fun,tracker);
                max=Math.max(score,max);
                
            }
        }
        
        return max;
    }
    
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        int index=T;
        while(T-- > 0){
            new Solution();
            int N = sc.nextInt();
            double[] fun = new double[N];
            int[] edge = new int[N];
            for(int i=0;i<N;i++){
                fun[i]=sc.nextDouble();
            }
            for(int i=0;i<N;i++){
                edge[i]=sc.nextInt();
            }
            for(int i=0;i<N;i++){
                if(edge[i]>=i){
                    edge[i]=0;
                }
            }
            int[] degree = new int[N+1];
            for(int i=0;i<N;i++){
                degree[edge[i]]+=1;
            }
            adj=new LinkedList[N+1];
            for(int i=0;i<N+1;i++){
                adj[i]=new LinkedList();
            }
            for(int i=0;i<N;i++){
                adj[i+1].add(edge[i]);
            }
            
            
            int[] initiator = new int[N];
            int k=0;
            for(int i=1;i<N+1;i++){
                if(degree[i]==0){
                    initiator[k++]=i;
                }
            }
           
            List<Integer> temp = new ArrayList<>();
            boolean[] t = new boolean[k];
            Com(k,initiator,N,temp,t,fun);
            
                System.",Sujit_Das
529,"public class Solution {

    private static final Boolean FROM_FILE = Boolean.FALSE;

    public static void main(String[] args) throws IOException{
        BufferedReader br;
        BufferedWriter bw;

        if(FROM_FILE){
            br = new BufferedReader(new FileReader(""C2022QR1E.in""));
        } else {
            br = new BufferedReader(new InputStreamReader(System.in));
        }

        try {
            if(FROM_FILE) {
                File file = new File(""C2022QR1E.out"");
                if (!file.exists()) {
                    file.createNewFile();
                }
                bw = new BufferedWriter(new FileWriter(file.getAbsoluteFile()));
            } else {
                bw = new BufferedWriter(new OutputStreamWriter(System.out));
            }

            String line = br.readLine();
            String[] q,r;

            int tests = Integer.parseInt(line);//100
            int n,k;
            int maxk = 8000;
            long max;
            int actualCase;
            int bestCase;
            int worstCase;
            long max2;
            long max3;

            // max n is 10000
            // min is n/2 - islands of 2 -> 5 000
            // max is n*(n-1)/2 -> 5000*9999 = 49 995 000

            for(int i = 0; i < tests; i++){
                line = br.readLine();
                q = line.split(""\\\s+"");
                n = Integer.parseInt(q[0]);
                // same k for all tests?
                k = Integer.parseInt(q[1]);

                max = 0L;

                // read first room
                line = br.readLine();
                bestCase = n-1;
                worstCase = 0;

                if(k >= n){
                    // enough tries
                    for(int j = 0; j < n; j++){
                        bw.write(""T ""+(j+1)+""
"");
                        bw.flush();

                        line = br.readLine();
                        q = line.split(""\\\s+"");
                        max+= Integer.parseInt(q[1]);
                    }
                    // each was counted twice
                    max /= 2;
                    bw.write(""E ""+(max)+""
"");
                    bw.flush();
                    continue;
                }

                // not enough tries, try all k
                // 8000 from 10000 means a 8% random sample
                for(int j = 0; j < k; j++){
                    bw.write(""T ""+(ThreadLocalRandom.current().nextInt(1, n + 1))+""
"");
                    bw.flush();

                    line = br.readLine();
                    q = line.split(""\\\s+"");
                    actualCase = Integer.parseInt(q[1]);
                    max+= actualCase;
                    worstCase = Math.min(actualCase,worstCase);
                    bestCase = Math.max(actualCase,bestCase);
                }

                // assuming all are like worstCase
                max2 = (max + Math.round(worstCase*(n-k)))/2;
                // assuming all are like bestCase
                max3 = (max + Math.round(bestCase*(n-k)))/2;

                // average
                double average = (double) max / k;
                double uniform = average * n;
                max = Math.round(uniform/2);

                // max2 <= max <= max3
                // how to jump between 2/3 P and 4/3 P??
                max = (max2+max3)/2;
                        
                bw.write(""E ""+(max)+""
"");
                bw.flush();
            }

            if(FROM_FILE) {
                bw.close();
            }
        } finally {
            if(FROM_FILE) {
                br.close();
            }
        }
    }
}",araver
962,"public class Solution{
    public static void main(String [] args)
    {
        Scanner sc=new Scanner(System.in);
        int t=sc.nextInt();
        int m=t;
        sc.nextLine();
        int ans[]=new int[t];
        int h=0;
        while(t-->0)
        {

            int n=sc.nextInt();
            sc.nextLine();
            int a[]=new int[n];
            int count=0;

            PriorityQueue<Integer> p=new PriorityQueue<>();
            for(int i=0;i<n;i++)
            {
                a[i]=sc.nextInt();
                p.add(a[i]);



            }
            count=0;
            while (p.size()>0&&count<p.poll())
            {
                count++;
            }


            ans[h]=count;
            h++;
            sc.nextLine();
           
        }
        for(int i=",mukhtarsetas_gmail
649,"public class Solution {

    public static void main(String[] args) {
        
        Scanner scan = new Scanner(System.in); 
        int numOfCases = scan.nextInt();
        
        int x = 1; // Test Case Number (starting from 1)
        
        int r = 0;
        int c = 0;
        
        for (int i = 0; i < numOfCases; i++) {
            r = scan.nextInt();
            c = scan.nextInt();
            
            System.out.print(""Case #"" + x + "": "");
            
            for (int j = 0; j < 2 * r + 1; j++) { 
                System.out.println();
                for (int k = 0; k < 2 * c + 1; k++) {
                    if (j % 2 == 0) {
                        if ((k < 2) && (j < 2)) {
                            System.out.print(""."");
                        }
                        else if (k == 2 * c) {
                            System.out.print(""+"");
                        }
                        else {
                            if (k % 2 == 0) {
                                System.out.print(""+"");
                            }
                            else {
                                System.out.print(""-"");
                            }
                        }
                    }
                    else {
                        if ((k < 2) && (j > 2)) {
                            System.out.print(""."");
                        }
                        else if (k == 2 * c) { 
                            System.out.print(""|"");
                        }
                        else {
                            if (k % 2 == 0) {
                                System.out.print(""|"");
                            }
                            else {
                                System.out.print(""."");
                            }
                        }
                    }
                }
            }
        x++;  
        System.",dtarde
1348,"public class Solution {
    private static BufferedReader br;
    private static StringTokenizer st;
    private static PrintWriter pw;

    public static void main(String[] args) throws Exception {
        br = new BufferedReader(new InputStreamReader(System.in));
        pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
        int tt = readInt();
        for (int zz = 1; zz <= tt; zz++) {
            int n = readInt();
            Integer[] arr = new Integer[n * 2];
            int z = 1;
            StringBuilder sb = new StringBuilder();
            long sum = 0;
            for (int i = 0; i < n; i++) {
                arr[i] = z;
                sum += z;
                sb.append(z);
                if (i < n - 1) sb.append("" "");

                if (z == 1) z = 0;
                z += 10;
            }
            System.out.println(sb);
            System.out.flush();
            break;
            //            String ret = nextLine();
//            String[] arrS = ret.split("" "");
            for (int i = 0; i < n; i++) {
                int next = readInt();
                sum += next;
                arr[n + i] = next;
            }

            ab(arr, 0, 0, new HashSet<>(), sum / 2);
            sb = new StringBuilder();

            Set<Integer> set = new HashSet<>(Arrays.asList(arr));
            set.removeAll(nextHalf);
            for (Integer integer : nextHalf) {
                sb.append(integer).append("" "");
            }

            for (Integer integer : set) {
                sb.append(integer).append("" "");
            }
            System.out.println(sb);
            System.out.flush();
        }
        pw.close();

    }

    static boolean found = false;
    static Set<Integer> nextHalf;
    static Set<Long> memo = new HashSet<>();

    public static void ab(Integer[] arr, int idx, long sum, Set<Integer> curr, long target) {
        if (found || idx > arr.length - 1 || memo.contains(sum) || sum > target) return;
        if (sum == target) {
            found = true;
            nextHalf = curr;
            return;
        }

        curr.add(arr[idx]);
        ab(arr, idx + 1, sum + arr[idx], curr, target);
        if (found) return;
        curr.remove(arr[idx]);
        ab(arr, idx + 1, sum, curr, target);
        if (found) return;

        memo.add(sum);

    }

    private static void exitImmediately() {
        pw.close();
        System.exit(0);
    }

    private static long readLong() throws IOException {
        return Long.parseLong(nextToken());
    }

    private static double readDouble() throws IOException {
        return Double.parseDouble(nextToken());
    }

    private static int readInt() throws IOException {
        return Integer.parseInt(nextToken());
    }

    private static String nextLine() throws IOException {
        String s = br.readLine();
        if (s == null) {
            exitImmediately();
        }
        st = null;
        return s;
    }

    private static String nextToken() throws IOException {
        while (st == null || !st.hasMoreTokens()) {
            st = ",zubaidullo
807,"class Room {
    public boolean visited = false;
    public int index;
    public List<Integer> neighbors;
}

public class Solution {

    public static void main(String[] args) {

        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        int T = in.nextInt();

        for (int i = 0; i < T; i++) {

            int N = in.nextInt();
            int K = in.nextInt();

            Room[] rooms = new Room[N];

            int lastRoomIdx = -1;

            for (int j = 0; j <= K; j++) {

                int R = in.nextInt() - 1;
                int P = in.nextInt();

                if (rooms[R] == null) {

                    rooms[R] = new Room();
                    rooms[R].index = R;
                    rooms[R].neighbors = new ArrayList<>(P);

                    for (int k = 0; k < P; k++) {
                        rooms[R].neighbors.add(-1);
                    }
                }

                var room = rooms[R];
                room.visited = true;

                if (lastRoomIdx != -1) {

                    for (int k = 0; k < room.neighbors.size(); k++) {
                        if (room.neighbors.get(k) == -1) {
                            room.neighbors.set(k, lastRoomIdx);
                            break;
                        }
                    }

                    for (int k = 0; k < rooms[lastRoomIdx].neighbors.size(); k++) {
                        if (rooms[lastRoomIdx].neighbors.get(k) == -1) {
                            rooms[lastRoomIdx].neighbors.set(k, R);
                            break;
                        }
                    }
                }

                if (j == K) {
                    break;
                }

                var unknownNeighbors = room.neighbors.stream().filter(n -> n == -1).count();

                var chance = (float) unknownNeighbors / room.neighbors.size();

                if (chance > 0.75f) {
                    lastRoomIdx = R;
                    System.out.println(""W"");
                } else {
                    boolean teleported = false;

                    for (int k = 0; k < rooms.length; k++) {
                        if (rooms[k] == null) {
                            teleported = true;
                            System.out.printf(""T %d%n"", k + 1);
                            break;
                        }
                    }

                    if (teleported) {
                        lastRoomIdx = -1;
                    } else {
                        // all rooms are visited, go somewhere randomly
                        lastRoomIdx = R;
                        System.out.println(""W"");
                    }
                }

                System.out.flush();
            }

            var knownPendingRooms = new ArrayList<Integer>();
            var unknownPendingRooms = new ArrayList<Integer>();

            int nPassages = 0;

            for (int j = 0; j < N; j++) {

                var room = rooms[j];

                if (room == null) {
                    unknownPendingRooms.add(j);
                    continue;
                }

                boolean hasUnknownPassages = false;

                for (int k = 0; k < room.neighbors.size(); k++) {

                    if (room.neighbors.get(k) == -1) {

                        if (!hasUnknownPassages) {
                            knownPendingRooms.add(j);
                            hasUnknownPassages = true;
                        }

                    } else {

                        if (room.neighbors.get(k) > j) {
                            nPassages++;
                        }
                    }
                }
            }

            boolean[][] connections = new boolean[N][];

            for (int j = 0; j < N; j++) {

                connections[j] = new boolean[N];

                if (rooms[j] != null) {

                    for (int k = 0; k < rooms[j].neighbors.size(); k++) {

                        var neig = rooms[j].neighbors.get(k);

                        if (neig != -1) {
                            connections[j][rooms[j].neighbors.get(k)] = true;
                        }
                    }
                }
            }

            while (knownPendingRooms.size() > 0) {

                var pendingRoom = knownPendingRooms.get(0);

                var room = rooms[pendingRoom];

                if (!room.visited && room.neighbors.size() > 0) {
                    knownPendingRooms.remove(pendingRoom);
                    continue;
                }

                for (int j = 0; j < room.neighbors.size(); j++) {

                    if (room.neighbors.get(j) == -1) {

                        if (unknownPendingRooms.size() > 0) {

                            var unknownIndex = unknownPendingRooms.remove(0);

                            var unknownRoom = new Room();
                            unknownRoom.index = unknownIndex;
                            unknownRoom.neighbors = new ArrayList<>();
                            unknownRoom.neighbors.add(pendingRoom);

                            rooms[unknownIndex] = unknownRoom;

                            knownPendingRooms.add(unknownIndex);
                            room.neighbors.set(j, unknownIndex);

                            connections[pendingRoom][unknownIndex] = true;
                            connections[unknownIndex][pendingRoom] = true;

                            nPassages++;

                        } else {

                            for (var r : knownPendingRooms) {

                                if (r.equals(pendingRoom)) {
                                    continue;
                                }

                                if (connections[pendingRoom][r]) {
                                    continue;
                                }

                                var otherRoom = rooms[r];

                                if (!otherRoom.visited) {

                                    room.neighbors.set(j, r);
                                    otherRoom.neighbors.add(pendingRoom);

                                } else {

                                    int c = 0;
                                    int firstNeigh = -1;

                                    for (int h = 0; h < otherRoom.neighbors.size(); h++) {

                                        var neigh = otherRoom.neighbors.get(h);

                                        if (neigh == -1) {
                                            if (firstNeigh == -1) {
                                                firstNeigh = h;
                                            }
                                            c += 1;
                                        }
                                    }

                                    room.neighbors.set(j, r);
                                    otherRoom.neighbors.set(firstNeigh, pendingRoom);

                                    if (c == 1) {
                                        knownPendingRooms.remove(Integer.valueOf(otherRoom.index));
                                    }
                                }

                                nPassages++;

                                connections[pendingRoom][r] = true;
                                connections[r][pendingRoom] = true;

                                break;
                            }
                        }
                    }
                }

                if (room.visited) {
                    knownPendingRooms.remove(pendingRoom);
                }
            }

            System.out.printf(""E %d%n"", nPassages);
            System.",jaimuepe
276,"public class Solution {

    private static Scanner s = new Scanner(System.in);

    public static void main(String[] args) {
        int t = readInt();
        int c = 0;
        while(c++<t) {
            System.out.print(""Case #"" + c + "": "");
            int n = readInt();
            int[] input = readIntArray();
            System.out.println(getStraightSize(input));
        }
    }

    private static int getStraightSize(int[] input) {
        Arrays.sort(input);
        int cur = 0;

        for (int val : input) {
            if (cur < val) {
                cur++;
            }
        }
        return cur;
    }

    private static int[] readIntArray() {
        return Arrays.stream(s.nextLine().split("" "")).mapToInt(i -> Integer.parseInt(i)).toArray();
    }

    private static long[] readLongArray() {
        return Arrays.stream(s.nextLine().split("" "")).mapToLong(i -> Long.parseLong(i)).toArray();
    }

    private static long readLong() {
        return Long.parseLong(s.nextLine());
    }

    private static int readInt() {
        return Integer.",Mr
1066,"public class Solution {
    public static void main(String[] args) {
        System.",ql309
299,"public class Solution {

  public static void main(String[] args) {
   /* String aaa = ""3
"" +
        ""PEEL
"" +
        ""AAAAAAAAAA
"" +
        ""CODEJAMDAY"";
    final Stream<String> lines = Arrays.stream(aaa.split(""
""));*/
    
    final BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
    final Stream<String> lines = reader.lines();

    int T = 0;
    int cs = 1;
    int start = 1;
    int end = 1;
/*

    final String UPPER = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ"";
    final String LOWER = ""abcdefghijklmnopqrstuvwxyz"";
    final char [] upper = UPPER.toCharArray();
    final char [] lower = LOWER.toCharArray();
    String line="""";
    List<Long> l = Arrays.stream(line.split("" "")).map(Long::valueOf).collect(Collectors.toList());

*/

    final Iterator<String> iterator = lines.iterator();
    int i = 0;
    String[] temp;
String text = """";
    while (iterator.hasNext()) {
      final String line = iterator.next();
      if (i == 0) {
        T = Integer.valueOf(line);
      } else {
        if (i == start) {
          end = start;
          start += 1;
        }
        if (i == end) {
          text = line;

          if (cs <= T) {
            System.out.println(""Case #"" + cs + "": "" + print(line));
            cs++;
            if (cs > T) {
              break;
            }
          }
        }
      }
      i++;
    }

  }
  private static String print(String text) {
    if(text.length() == 1)
      return text;
    String newText = """";
    for (int i = 0; i < text.length()-1; i++) {
      if(text.charAt(i) >= text.charAt(i+1)) {
        newText += text.charAt(i);
      } else {
        newText +=text.charAt(i);
        newText +=text.charAt(i);
      }

    }
newText += text.",Obchelli
86,"public class Solution 
{
    public static void main(String[] args) 
	{
		Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));//make scanner
		int t = in.nextInt();//number of test cases
		for (int i = 1; i <= t; i++) //iterate through test cases
		{
			int n = in.nextInt();
			int k = in.nextInt();

			int loop = Math.min(n, k);
			
			int room = in.nextInt();
			int total = in.nextInt();
			
			for(int rep = 1; rep <= loop; rep++)
			{
				System.out.println(""T "" + rep);
				in.nextInt();
				total += in.nextInt();
			}
			
			int ans = ",CoCoCoder
549,"public class Solution {
public class C {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int ttt = Integer.parseInt(br.readLine());
        for (int tt = 1; tt <= ttt; ++tt) {
            int prev = -1;

            while (true) {
                final int curr = Integer.parseInt(br.readLine());
                if (curr == -1) {
                    break;
                } else if (curr == 0) {
                    break;
                } else if (curr == 1) {
                    send(3);
                } else if (curr == 2) {
                    send(2);
                } else if (curr == 3) {
                    send(4);
                } else if (curr == 4) {
                    if (prev == 4) {
                        System.out.println(""11110000"");
                    } else {
                        send(4);
                    }
                } else if (curr == 5) {
                    send(4);
                } else if (curr == 6) {
                    send(2);
                } else if (curr == 7) {
                    send(3);
                } else if (curr == 8) {
                    send(8);
                }
            }
        }
    }

    private static void send(int i) {
        System.out.println(get(i));
    }

    private static String get(int i) {
        if (i == 8) return ""11111111"";
        if (i == 3) return ""10101000"";
        if (i == 4) return ""10101010"";
        if (i == 1) return ""10000000"";
        throw new IllegalStateException();
    }

",attila
604,"public class Solution {
    public static void main(String[] args) {
        (new Solution()).readInput();
    }

    public void readInput() {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int caseCount = in.nextInt();
        for (int caseId = 1; caseId <= caseCount; ++caseId) {
            boolean result = play(in);
            if (!result){
                break;
            }
        }
    }

    private boolean play(Scanner in){
        //Random r = new Random();
        int i=0;
        while(true) {
            //int i = r.nextInt(256);
            i++;
            String binaryString = Integer.toBinaryString(i);
            while (binaryString.length() < 8) {
                binaryString = ""0"" + binaryString;
            }
            binaryString = binaryString.substring(0,8);
            System.out.print(binaryString);
            int result = in.nextInt();
            if (result == 0) {
                return true;
            }
            if (result<0)",dboteanu
371,"class Solution
{
    public static void main(String[] args) {
        Scanner in=new Scanner(System.in);
        int t=in.nextInt();
    
       for(int ca=1;ca<=t;ca++)
        {
            long arr[][]=new long[3][4];
       for(int i=0;i<3;i++)
       {
            for(int j=0;j<4;j++)
            {
                arr[i][j]=in.nextLong();
            }
       }



            solve(arr,ca);
        }
    }

      static void solve( long mat[][],int ca) {
            long c,m,k,y;
            c=mat[0][0];
            m=mat[0][1];
            y=mat[0][2];
            k=mat[0][3];

            for(int i=1;i<3;i++)
           {
           
            c=Math.min(c,mat[i][0]);
            m=Math.min(m,mat[i][1]);
            y=Math.min(y,mat[i][2]);
            k=Math.min(k,mat[i][3]);
           
         }
         long sum=c+y+m+k;
         long arr[]=new long[4];
         arr[0]=c;
         arr[1]=m;
         arr[2]=y;
         arr[3]=k;
         long t6=1000000L;
         boolean check=true;

         if(sum>t6)
         {
             long diff=t6/4;
            int i=0;
            while(i<4)
            {
             
                arr[i]=diff;
                i++;
            }
             
            
         }
         sum=0;
             for(int i=0;i<4;i++)
             {
                    sum+=arr[i];
             }
      if(sum!=t6)
              {
                  check=false;
              }
         if(check)
         {
         System.out.println(""Case #""+ca+"": ""+arr[0]+"" ""+arr[1]+"" ""+arr[2]+"" ""+arr[3]);
         }
         else{
            System.",SampathRajaRaghupathi
1055,"public class Solution {

	static Scanner sc = new Scanner(System.in);
	static int [] BIT;
	static int [] count;

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int testCases = sc.nextInt();
		
		for (int i = 1; i <= testCases; ++i) {
			solve(i);
		}
	}
	
	private static void solve(int t) {
		int n = sc.nextInt();
		
		int k = sc.nextInt();
		
		count = new int [n + 1];
		BIT = new int [n + 1];
		int currentNode, pas;
		int size = n;
		Random rand = new Random();
		int next;
		
		while (k-- >= 0 && size > 0) {
			currentNode = sc.nextInt();
			pas = sc.nextInt();
			
			count[currentNode] = pas;
			addToBIT(currentNode);
			--size;
			next = 1 + rand.nextInt(size);
			next = getPos(next, 0);
			
			if (k >= 0 && size > 0)
				System.out.println(""T "" + next);
		}
		
		double sum = 0;
		int cnt = 0;
		
		for (int num : count) {
			if (num == 0) continue;
			
			++cnt;
			sum += num;
		}
		
		sum /= cnt;
		sum /= 2;
		
		long result = (long)Math.round(sum * n);
		
		print(result);
	}
	
	private static int getPos(int num, int added) {
		
		int next = added;
		
		do {
			added = next;
			next = getBIT(num + added);
		}while(next > added);
		
		return num + added;
	}
	
	private static void addToBIT(int node) {
		
		for (int i = node; i < BIT.length; i += (i & -i) )
			++BIT[i];
	}
	
	private static int getBIT(int node) {
		
		int result = 0;
		
		for (int i = node; i > 0; i -= (i & -i))
			result += BIT[i];
		
		return result;
	}
	
	public static void print(long result) {
		System.",profchi
329,"public class Solution {
	public static void doIt(char[][] ans, int s, int n) {
		for(int x = -n; x<=n; x++) {
			int y = (int) Math.round(Math.sqrt(n*n -x*x));
			ans[s+x][s+y] = '*';
			ans[s+x][s-y] = '*';
			ans[s+y][s+x] = '*';
			ans[s-y][s+x] = '*';
		}
	}
	
	public static char[][] get(int n){
		char[][] ans = new char[n*2+1][n*2+1];
		for(int i = 0; i<n*2+1; i++)  Arrays.fill(ans[i], '.');
		for(int i = 0; i<=n; i++) doIt(ans,n, i);
//		doIt(ans,n, n);
//		doIt(ans,n, n-1);
		return ans;
	}
	public static char[][] getCorrect(int n){
		char[][] ans = new char[n*2+1][n*2+1];
		for(int i = 0; i<n*2+1; i++)  Arrays.fill(ans[i], '.');
		for(int x = -n; x<=n; x++) {
			for(int y = -n; y<=n; y++) {
				int v = (int) Math.round(Math.sqrt(x*x + y*y));
				if(v<=n) {
					ans[x+n][y+n] = '*';
				}
			}
		}
		
		return ans;
	}
	public static void solveCase() {
//		for(int n = 1; n<50; n++) {
		int n = in.nextInt();
			char[][] a = get(n);
			char[][] b = getCorrect(n);
			int diff = 0;
			for(int i = 0; i<a.length; i++) {
				for(int j = 0; j<a[0].length;j++) {
					if(a[i][j]!=b[i][j]) diff++;
				}
			}
			out.println(diff);
//		}
	}
	
	public static void solve() {
		int t = in.nextInt();
		for (int i = 1; i <= t; i++) {
			out.print(""Case #"" + i + "": "");
			solveCase();
		}
	}

	public static void main(String[] args) {
		in = new Reader();
		out = new Writer();
		solve();
		out.exit();
	}

	static Reader in;
	static Writer out;

static class Reader {
	
	private BufferedReader br;
	private StringTokenizer st;
	
	public Reader() {
		br = new BufferedReader(new InputStreamReader(System.in));
	}
	
	public Reader(String f){
		try {
			br = new BufferedReader(new FileReader(f));
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	public int[] na(int n) {
		int[] a = new int[n];
		for (int i = 0; i < n; i++) a[i] = nextInt();
		return a;
	}

	public double[] nd(int n) {
		double[] a = new double[n];
		for (int i = 0; i < n; i++) a[i] = nextDouble();
		return a;
	}
	
	public long[] nl(int n) {
		long[] a = new long[n];
		for (int i = 0; i < n; i++) a[i] = nextLong();
		return a;
	}

	public char[] nca() {
		return next().toCharArray();
	}

	public String[] ns(int n) {
		String[] a = new String[n];
		for (int i = 0; i < n; i++) a[i] = next();
		return a;
	}

	public int nextInt() {
		ensureNext();
		return Integer.parseInt(st.nextToken());
	}

	public double nextDouble() {
		ensureNext();
		return Double.parseDouble(st.nextToken());
	}

	public Long nextLong() {
		ensureNext();
		return Long.parseLong(st.nextToken());
	}

	public String next() {
		ensureNext();
		return st.nextToken();
	}
	
	public String nextLine() {
		try {
			return br.readLine();
		} catch (Exception e) {
			e.printStackTrace();
			return null;
		}
	}
	
	private void ensureNext() {
		if (st == null || !st.hasMoreTokens()) {
			try {
				st = new StringTokenizer(br.readLine());
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	}
}

static class Util {

	private static Random random = new Random();
	private static long MOD;
	static long[] fact, inv, invFact;

	public static void initCombinatorics(int n, long mod, boolean inversesToo, boolean inverseFactorialsToo) {
		MOD = mod;
		fact = new long[n + 1];
		fact[0] = 1;
		for (int i = 1; i < n + 1; i++) fact[i] = (fact[i - 1] * i) % mod;

		if (inversesToo) {
			inv = new long[n + 1];
			inv[1] = 1;
			for (int i = 2; i <= n; ++i) inv[i] = (mod - (mod / i) * inv[(int) (mod % i)] % mod) % mod;
		}

		if (inverseFactorialsToo) {
			invFact = new long[n + 1];
			invFact[n] = Util.modInverse(fact[n], mod);
			for (int i = n - 1; i >= 0; i--) {
				if (invFact[i + 1] == -1) {
					invFact[i] = Util.modInverse(fact[i], mod);
					continue;
				}
				invFact[i] = (invFact[i + 1] * (i + 1)) % mod;
			}
		}
	}

	public static long modInverse(long a, long mod) {
		long[] gcdE = gcdExtended(a, mod);
		if (gcdE[0] != 1) return -1; // Inverse doesn't exist
		long x = gcdE[1];
		return (x % mod + mod) % mod;
	}

	public static long[] gcdExtended(long p, long q) {
		if (q == 0) return new long[] { p, 1, 0 };
		long[] vals = gcdExtended(q, p % q);
		long tmp = vals[2];
		vals[2] = vals[1] - (p / q) * vals[2];
		vals[1] = tmp;
		return vals;
	}

	public static long nCr(int n, int r) {
		if (r > n) return 0;
		return (((fact[n] * invFact[r]) % MOD) * invFact[n - r]) % MOD;
	}

	public static long nPr(int n, int r) {
		if (r > n) return 0;
		return (fact[n] * invFact[n - r]) % MOD;
	}

	public static boolean isPrime(int n) {
		if (n <= 1) return false;
		if (n <= 3) return true;
		if (n % 2 == 0 || n % 3 == 0) return false;
		for (int i = 5; i * i <= n; i = i + 6)
			if (n % i == 0 || n % (i + 2) == 0)
				return false;
		return true;
	}

	public static boolean[] getSieve(int n) {
		boolean[] isPrime = new boolean[n + 1];
		for (int i = 2; i <= n; i++) isPrime[i] = true;
		for (int i = 2; i * i <= n; i++)
			if (isPrime[i])
				for (int j = i; i * j <= n; j++)
					isPrime[i * j] = false;
		return isPrime;
	}

	static long pow(long x, long pow, long mod) {
		long res = 1;
		x = x % mod;
		if (x == 0) return 0;
		while (pow > 0) {
			if ((pow & 1) != 0) res = ",Restricted
232,"class Solution {
    public static void main(String[] args)
    {
        Scanner s = new Scanner(System.in);
        int t = s.nextInt();
        for(int i = 1; i <= t; i++)
        {
            int n = s.nextInt();
            int p = s.nextInt();
            int[][] pressure = new int[n][p];
            for(int j = 0; j < n; j++)
            {
                for(int k = 0; k < p; k++)
                {
                    pressure[j][k] = s.nextInt();
                }
            }
            long[] min = new long[n];
            long[] max = new long[n];
            long out = 0;
            for(int j = 0; j < n; j++)
            {
                long tempMin = 10000000000L;
                long tempMax = 0;
                for(int k = 0; k < p; k++)
                {
                    if(pressure[j][k] < tempMin)
                    {
                        tempMin = pressure[j][k];
                    }
                    if(pressure[j][k] > tempMax)
                    {
                        tempMax = pressure[j][k];
                    }
                }
                out += tempMax-tempMin;
                min[j] = tempMin;
                max[j] = tempMax;
            }
            boolean up = true;
            out += min[0];
            for(int j = 1; j < n-1; j++)
            {
                if(min[j-1] > max[j+1])
                {
                    out += (int)Math.abs(min[j-1]-max[j]);
                    up = false;
                } else if(max[j-1] < min[j+1])
                {
                    out += (int)Math.abs(max[j-1]-min[j]);
                    up = true;
                } else if(up)
                {
                    out += (int)Math.abs(max[j-1]-max[j]);
                    up = false;
                } else if(!up)
                {
                    out += (int)Math.abs(min[j-1]-min[j]);
                    up = true;
                }
            }
            if(up)
            {
                out += (int)Math.min(Math.abs(max[n-2]-max[n-1]), Math.abs(max[n-2]-min[n-1]));
            } else
            {
                out += (int)Math.min(Math.abs(min[n-2]-max[n-1]), Math.abs(min[n-2]-min[n-1]));
            }
            System.",Maarten17581
273,"public class Solution {

	private static final String EOL = ""
"";

	public static void main(String[] args) throws IOException {

		Scanner sc;

		if (args.length > 0) {
			sc = new Scanner(new File(args[0]));
		} else {
			sc = new Scanner(System.in);
		}

		int t = sc.nextInt();
		for (int tt = 1; tt <= t; ++tt) {
			System.out.println(""Case #"" + tt + "": "" + _s(sc));
		}
		sc.close();
	}

	private static String _s(Scanner sc) {
		StringBuilder sb = new StringBuilder(EOL);
		String s = sc.nextLine();
		while (s.equals("""")) {
			s = sc.nextLine();
		}
		String[] params = s.split("" "");
		int r = Integer.parseInt(params[0]);
		int c = Integer.parseInt(params[1]);
		drawFirstRow(sb, c);
		for (int i = 2; i <= r; ++i)
			drawNRow(sb, c);
		return sb.toString();
	}

	private static void drawFirstRow(StringBuilder sb, int columns) {
		sb.append(""..+"");
		for (int i = 2; i <= columns; ++i)
			sb.append(""-+"");
		sb.append(EOL);
		sb.append(""..|"");
		for (int i = 2; i <= columns; ++i)
			sb.append("".|"");
		sb.append(EOL);
		sb.append(""+"");
		for (int i = 1; i <= columns; ++i)
			sb.append(""-+"");
		sb.append(EOL);
	}

	private static void drawNRow(StringBuilder sb, int columns) {
		sb.append(""|"");
		for (int i = 1; i <= columns; ++i)
			sb.append("".|"");
		sb.append(EOL);
		sb.append(""+""",Mr
125,"public class Solution {
    static int k;
    static Set<Integer> set;
    static long sum;
    public static void walk() {
        System.out.println(""W"");
    }

    public static void teleport(){
        for(int i : set){
            System.out.println(""T "" + i);
            break;
        }
    }

    public static void estimate(long res){
        System.out.println(""E "" + res);
    }

    public static void main(String args[]) {
        Scanner input = new Scanner(System.in);
        int T = input.nextInt();
        for (int ks = 1; ks <= T; ks++) {
            int N = input.nextInt();
            int K = input.nextInt();
            set = new HashSet<>();
            for( int i = 1; i <= N; i ++){
                set.add(i);
            }
            K = Math.min(N, K);
            sum = 0;
            for (int i = 0; i < K; i ++){
                int id = input.nextInt();
                int roads = input.nextInt();
                set.remove(id);
                sum += roads;
                if (i % 2 == 0){
                    walk();
                } else {
                    teleport();
                }
            }
            double average = (double)sum / K;
            long res = ",Em11
430,"public class Solution {
    public static void main(String[] args) {
        try {
            Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
            int tests = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
            for (int currentTest = 1; currentTest <= tests; ++currentTest) {
                int N = in.nextInt();
                int K = in.nextInt();
                int r = in.nextInt();
                int p = in.nextInt();
                long pSum = p;
                long queries = K;
                while(queries>0){
                    int nxt = (int)(Math.random()*N+1);
                    System.out.println(""T ""+nxt);
                    System.out.flush();
                    r = in.nextInt();
                    p = in.nextInt();
                    pSum +=p;
                    queries--;
                }
                double avg = (double) pSum/(K+1);
                long mid = (long)( (N * avg)/2.0);
                System.out.println(""E "" + mid);
                System.out.flush();
            }
        }catch (Exception e){
            System.err.println(e.getMessage());
            e.printStackTrace();
            System.exit(1);
        }
    }

    public static String arrToStr(int[][] arr) {
        StringBuilder str = new StringBuilder();
        for (int[] ints : arr) {
            String s = ",Vlad
39,"public class Solution {

    /**
     * @param args the command line arguments
     */
    
 
    
    public static void main(String[] args) {
          Scanner keyboard = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
    int a;
    int[][]array1;
int c=0;
int m=0;
int y=0;
int k=0;
    
    a = keyboard.nextInt();
    array1 = new int[a][12];

    
for (int b = 0; b<a; b++)
{
    for (int z = 0; z < 12; z++)
    {
  array1[b][z]=keyboard.nextInt();
    }
}
for (int d = 0; d < a; d++)
{

   if ((array1[d][0]<=array1[d][4])&&(array1[d][0]<=array1[d][8]))
           {
               c = array1[d][0];
           }
   else if (array1[d][4]<=array1[d][8])
   {        
               c = array1[d][4];
   }
   else
               c = array1[d][8];

   if ((array1[d][1]<=array1[d][5])&&(array1[d][1]<=array1[d][9]))
           {
               m = array1[d][1];
           }
   else if (array1[d][5]<=array1[d][9])
   {        
               m = array1[d][5];
   }
   else
               m = array1[d][9];

   if ((array1[d][2]<=array1[d][6])&&(array1[d][2]<=array1[d][10]))
           {
               y = array1[d][2];
           }
   else if (array1[d][6]<=array1[d][10])
   {        
               y = array1[d][5];
   }
   else
               y = array1[d][10];
   
      if ((array1[d][3]<=array1[d][7])&&(array1[d][3]<=array1[d][11]))
           {
               k = array1[d][3];
           }
   else if (array1[d][7]<=array1[d][11])
   {        
               k = array1[d][7];
   }
   else
               k = array1[d][11];



        if ((c+m+y+k)<1000000)
{
    System.out.println(""Case #""+(d+1)+"" IMPOSSIBLE"");
}
         
        else if (c+m+y+k>=1000000)
        {
            if (c==1000000)
            {
                y = 0;
                m = 0; 
                k = 0;
            }
            
            else if (m==1000000)
            {
                y = 0;
                c = 0; 
                k = 0;
            }
            else if (y==1000000)
            {
                c = 0;
                m = 0; 
                k = 0;
            }
            else if (k==1000000)
            {
                y = 0;
                m = 0; 
                c = 0;
            }
        
            else if (c+m>1000000)
        {
               if (c+m>1000000)
               {
                   m = (1000000 - (c));
                   y=0;
                   k = 0;
               }
               else
               {
                   y = 0;
                   k = 0;
               }
        }
         else if (c+y>1000000)
        {
               if (c+y>1000000)
               {
                   y = (1000000 - (c));
                   m=0;
                   k = 0;
               }
               else
               {
                   m = 0;
                   k = 0;
               }
        }   
         else if (c+k>1000000)
        {
               if (c+k>1000000)
               {
                   k = (1000000 - (c));
                   m=0;
                   y = 0;
               }
               else
               {
                   m = 0;
                   y = 0;
               }
        }   
         else if (m+y>1000000)
        {
               if (m+y>1000000)
               {
                   m = (1000000 - (k));
                   c=0;
                   y = 0;
               }
               else
               {
                   c = 0;
                   y = 0;
               }
        }
         
         else if (m+k>1000000)
        {
               if (m+k>1000000)
               {
                   k = (1000000 - (m));
                   c=0;
                   y = 0;
               }
               else
               {
                   c = 0;
                   y = 0;
               }
        }
         
         else if (y+k>1000000)
        {
               if (y+k>1000000)
               {
                   k = (1000000 - (y));
                   m=0;
                   c = 0;
               }
               else
               {
                   m = 0;
                   c = 0;
               }
        }       
            
            
            
            
            else if (c+m+y>1000000)
        {
               if (c+m>1000000)
               {
                   y = (1000000 - (c+m));
                   k = 0;
               }
               else 
                   k=0;
        }
            
        else if (c+m+k>1000000)
        {
               if (c+m>1000000)
               {
                   k = (1000000 - (c+m));
                   y = 0;
               }
               else 
                   y = 0;
        }    
            
                else if (y+m+k>1000000)
        {
               if (y+k>1000000)
               {
                   m = ",Ak9
247,"public class Solution{

    public static void main(String[] args){
int r=0;
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int sum=1000000;
        int T = in.nextInt();
        for (int i=1; i<=T; i++){
           
            int [] C=new int[3];
            int [] M=new int[3];
            int [] Y=new int[3];
            int [] B=new int[3];
            int [] R=new int[4];
        int j=0;
            while (j<3)
          {
           C[j]=in.nextInt();
            M[j]=in.nextInt();
            Y[j]=in.nextInt();
            B[j]=in.nextInt();
          j++;
            }
            Arrays.sort(C);
            Arrays.sort(M);
            Arrays.sort(Y);
            Arrays.sort(B);
         if(C[0]+M[0]+Y[0]+B[0]==sum)
         {r=0;
             R[0]=C[0];
         R[1]=M[0];
         R[2]=Y[0];
         R[3]=B[0];
         }
         else  if(C[0]+M[0]+Y[0]+B[0]<sum)
         {                    System.out.println(""Case #"" + i + "": "" + ""IMPOSSIBLE"");
r=1;
         }
         else {r=0;
         if(C[0]<sum)
         {
         R[0]=C[0];
         sum=sum-R[0];}
         else if (C[0]>=sum)
         {R[0]=sum;
         sum=0;
         }
         if(M[0]<sum)
         {
         R[1]=M[0];
         sum=sum-R[1];
      
         
         }
         else if(M[0]>=sum)
         {R[1]=sum;
         R[2]=0;
       R[3]=0;
         sum=0;
         }
            if(Y[0]<sum)
         {  R[2]=Y[0];
         sum=sum-R[2];
         }
         else if(Y[0]>=sum)
         {R[2]=sum;
         R[3]=0;
   
         sum=0;
         }
               if(B[0]<sum)
         {  R[3]=B[0];
         sum=sum-R[3];
         }
         else if(B[0]>=sum)
         {R[3]=sum;
         
   
         sum=0;
         }
            
            
             
            }
            
         if(r==0)
         {
             if((R[0]==0 && R[1] ==0 && R[2] ==0 && R[3]==0) ||(R[0]+R[1]+R[2]+R[3])>1000000 ) 
             {            System.out.println(""Case #"" + i + "": "" + ""IMPOSSIBLE"");

             }
             else {
            System.out.println(""Case #"" + i + "": ""+R[0]+"" ""+R[1]+"" ""+R[2]+"" ""+R[3]+"" "");
                     }}
        }     
            
       
        
        in.",Marwan
1259,"public class Solution {
	public static void input() {
		Scanner sc = new Scanner(System.in);
		int testCase = sc.nextInt();
		int countTest = 1;
		int[] dices;
		while (testCase > 0) {
			int numDices = sc.nextInt();
			dices = new int[numDices];
			for (int i = 0; i < numDices; i++) {
				dices[i] = sc.nextInt();
			}
			System.out.println(""Case #"" + countTest + "": "" + output(dices));
			countTest++;
			testCase--;
		}
	}

	public static int output(int[] arr) {
		int len = arr.length;
		if (len == 1) {
			return 1;
		}

		int[] arrCheck = arr;

		Arrays.sort(arr);
		Arrays.sort(arrCheck);

		int countForward = 1;
		int mockCheck = arr[0];
		if (len < 10) {
			for (int i = 1; i < len; i++) {
				if (arr[i] == countForward) {
					return countForward;
				} else if (arr[i] >= mockCheck) {
					countForward++;
					mockCheck = arr[i];
				}
			}
			return countForward;
		} else if (len == 10) {
			
			if(arr[len-1] <= 10) {
				mockCheck = arr[1];
				for (int i = 2; i < arrCheck.length; i++) {
					if (arrCheck[i] == countForward) {
						return countForward;
					} else if (arrCheck[i] >= mockCheck) {
						countForward++;
						mockCheck = arrCheck[i];
					}
				}
				return countForward;
			}else {
				mockCheck = arr[0];
				for (int i = 1; i < len; i++) {
					if (arr[i] >= mockCheck) {
						countForward++;
						mockCheck = arr[i];
					}
				}
				return countForward;
			}
		}
		return 1;
	}
}",tonybuidn
987,"public class Solution {

	public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        
        int numberOfCases = in.nextInt();
        for (int i = 1; i <= numberOfCases; ++i) {
        	int N = in.nextInt();
        	
        	List<Integer> pancakes = new ArrayList<>();
        	for(int j=0; j<N; j++) {
        		pancakes.add(in.nextInt());
        	}
        	
        	int result = 0;
        	int max = 0;
        	while(pancakes.size() > 0) {
        		int d = 0;
        		if(pancakes.get(0) < pancakes.get(pancakes.size()-1)) {
        			d = pancakes.remove(0);
        		} else {
        			d = pancakes.remove(pancakes.size()-1);
        		}
        		if(d >= max) {
        			result ++;
        			max = d;
        		}
        	}
        	
        	
        	System.",nicolasD
254,"public class Solution{

    public static void main(String[] args){

        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        int T = in.nextInt();
        for (int i=1; i<=T; i++){
            int count=0;
            int seq=1;
            int z=in.nextInt();
            int [] array=new int[z];
            for (int j=0;j<z;j++)
            {array[j]=in.nextInt();
            }
            Arrays.sort(array);
           
               for (int o=1;o<=z;o++)
               { if(seq<=array[o-1])
               {count++;
               seq++;}
               }
            
            
            
           
                    System.out.println(""Case #"" + i + "": "" + count);
            }
        
        in.",Marwan
287,"public class Solution {

  public static void main(String[] args) {
   /* String aaa = ""3
"" +
        ""PEEL
"" +
        ""AAAAAAAAAA
"" +
        ""CODEJAMDAY"";
    final Stream<String> lines = Arrays.stream(aaa.split(""
""));*/
    
    final BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
    final Stream<String> lines = reader.lines();

    int T = 0;
    int cs = 1;
    int start = 1;
    int end = 1;
/*

    final String UPPER = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ"";
    final String LOWER = ""abcdefghijklmnopqrstuvwxyz"";
    final char [] upper = UPPER.toCharArray();
    final char [] lower = LOWER.toCharArray();
    String line="""";
    List<Long> l = Arrays.stream(line.split("" "")).map(Long::valueOf).collect(Collectors.toList());

*/

    final Iterator<String> iterator = lines.iterator();
    int i = 0;
    String[] temp;
String text = """";
    while (iterator.hasNext()) {
      final String line = iterator.next();
      if (i == 0) {
        T = Integer.valueOf(line);
      } else {
        if (i == start) {
          end = start;
          start += 1;
        }
        if (i == end) {
          text = line;

          if (cs <= T) {
            System.out.println(""Case #"" + cs + "": "" + print(line));
            cs++;
            if (cs > T) {
              break;
            }
          }
        }
      }
      i++;
    }

  }
  private static String print(String text) {
    if (text.length() == 1) {
      return text;
    }
    String newText = """";
    int p = 0;
    for (int i = 0; i < text.length() - 1; i++) {
      if (text.charAt(i) > text.charAt(i + 1)) {
        newText += text.charAt(i);
      } else if (text.charAt(i) == text.charAt(i + 1)) {
        boolean found = false;
        if (i < text.length() - 2) {
          for (int j = i + 1; j < text.length() - 1; j++) {
            if (text.charAt(j) < text.charAt(j + 1)) {
              found = true;
            }
          }
          if (found) {
            newText += text.charAt(i);
            newText += text.charAt(i);
          } else {
            newText += text.charAt(i);
          }

        }

      } else {

        newText += text.charAt(i);
        newText += text.charAt(i);
      }

    }
    newText += text.",Obchelli
1148,"public class Solution {

    public static void main(String[] args) {

        try {
            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
            int numTests = Integer.parseInt(br.readLine());
            int cnt = 1;
            while (cnt <= numTests) {
                String NandK = br.readLine();

                String[] split = NandK.split("" "");
                int n = Integer.parseInt(split[0]); // rooms
                int K = Integer.parseInt(split[1]); // operations

                int minPassages = n/2;
                int maxPassages = (n * (n-1))/2;

                int minPassagesPerRoom = 1;
                int maxPassagesPerRoom = n-1;

                Map<Integer, Integer> roomNumToPassage = new HashMap<>();
                String estimate = ""E"";

                Set<Integer> unvisited = new HashSet<>();
                for (int k = 1; k < n; k++) {
                    unvisited.add(k);
                }

                int tele = 0;
                int passage = 0;
                boolean seen = false;
                int seenTimes = 0;

                int prevRoom = -1;
                Set<Pair> visitedEdges = new HashSet<>();
                int totalSeen = 0;


                Map<Integer, Integer> roomNumToPassageIsland = new HashMap<>();
                Set<Integer> prevIsland = new HashSet<>();
                Set<Pair> visitedEdgesIsland = new HashSet<>();
                int totalSeenIsland = 0;
                List<Integer> medians = new ArrayList<>();
                int totalSeenForIslands = 0;
                int islands = 0;

                for (int i = 0; i < K; i++) {
                    // read room num and passages
                    String[] roomAndNumPassages = br.readLine().split("" "");
                    int roomNum = Integer.parseInt(roomAndNumPassages[0]); // rooms
                    int passages = Integer.parseInt(roomAndNumPassages[1]); // operations

                    if (prevIsland.contains(roomNum)) {
                        seenTimes=80;
                    }
                    else if (roomNumToPassage.get(roomNum) == null) {
                        roomNumToPassage.put(roomNum, passages);
                        roomNumToPassageIsland.put(roomNum, passages);
                        totalSeen += passages;
                        totalSeenIsland +=passages;
                        unvisited.remove(roomNum);
                        if (prevRoom != -1) {
                            visitedEdges.add(new Pair(prevRoom, roomNum));
                        }
                    } else {
                        seen = true;
                        seenTimes++;
                    }

                    if (i == K - 1) {
                        break;
                    }

                    String walkPassage = ""W"";
                    String teleport = ""T"";
                    if (roomNumToPassage.keySet().size() == n) {
                        break;
                    }


                    if (seenTimes < 80) {
                        prevRoom = roomNum;
                        System.out.println(walkPassage);
                        passage++;
                    } else {
                        totalSeenIsland -= visitedEdgesIsland.size();
                        prevIsland.addAll(roomNumToPassageIsland.keySet());
                        List<Integer> known = new ArrayList<>(roomNumToPassageIsland.values());
                        Collections.sort(known);
                        Integer median = known.get(known.size() / 2); // median number of edges
                        medians.add(median);
                        totalSeenForIslands += totalSeenIsland;
                        roomNumToPassageIsland = new HashMap<>();
                        visitedEdgesIsland = new HashSet<>();
                        totalSeenIsland = 0;
                        islands++;
                        seenTimes=0;
                        for (Integer room : unvisited) {
                            System.out.println(teleport + "" "" + room);
                            prevRoom = -1;
                            tele++;
                            break;
                        }
                    }
                }

//                // for 8000 edges
//                totalSeen -= visitedEdges.size();
//                int unvisitedrooms = n - roomNumToPassage.size();
//                List<Integer> known = new ArrayList<>(roomNumToPassage.values());
//                Collections.sort(known);
//                Integer median = known.get(known.size() / 2); // median number of edges
//                //System.out.println(estimate+ "" "" + passage);

                int unvisitedrooms = n - roomNumToPassage.size();
                Collections.sort(medians);
                Integer superMedian = medians.get(medians.size() / 2);
                // choose random
                double edgesUnvisited =  ((double) (superMedian) * (long) unvisitedrooms)/2; // edges of unvisited nodes


                edgesUnvisited -= (totalSeen - visitedEdges.size());
                System.out.println(estimate + "" "" + ((long) edgesUnvisited + totalSeenForIslands));
                //System.out.println(estimate + "" "" + islands);
                cnt++;
            }
        } catch (Exception ex) {

        }
    }

    static class Pair {
        private int l;
        private int r;

        public Pair(int l, int r) {
            this.l = l;
            this.r = r;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;

            Pair pair = (Pair) o;

            if (l != pair.l) return false;
            return r == pair.r;

        }

        @Override
        public int hashCode() {
            int result = l;
            result = ",skyfugl
688,"public class Solution {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        FastScanner in = new FastScanner(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        E_TwistyLittlePassages solver = new E_TwistyLittlePassages();
        solver.solve(1, in, out);
        out.close();
    }

    static class E_TwistyLittlePassages {
        public void solve(int testNumber, FastScanner in, PrintWriter out) {
            SplittableRandom random = new SplittableRandom(0);

            int numTests = in.nextInt();
            for (int test = 0; test < numTests; test++) {
                int n = in.nextInt();
                int k = in.nextInt();
                if (k != 8000) {
                    throw new AssertionError(""bad k: "" + k);
                }
                int[] deg = new int[n];
                Arrays.fill(deg, -1);

                long edgesSeen = 0;
                int roomsSeen = 0;

                long edgesFromBigSeen = 0;
                int bigRoomsSeen = 0;
                for (int iter = 0; iter < k; iter++) {
                    int v = in.nextInt() - 1;
                    int d = in.nextInt();
                    boolean newRoom = false;
                    final int B = 1000;
                    if (deg[v] < 0) {
                        roomsSeen += 1;
                        edgesSeen += d;
                        newRoom = true;
                        if (d > B) {
                            bigRoomsSeen += 1;
                            edgesFromBigSeen += d;
                        }
                    }
                    deg[v] = d;

                    if (d > 2 && iter % 50 != 0) {
                        out.println(""W"");
                        out.flush();
                    } else {
                        out.println(""T "" + (random.nextInt(n) + 1));
                        out.flush();
                    }
                }

                in.nextInt();
                in.nextInt();
                long ans = edgesSeen * n / roomsSeen / 2;
                if (bigRoomsSeen > 0 && (double) bigRoomsSeen / roomsSeen < 0.1) {
                    ans = edgesFromBigSeen / 2 + (n - bigRoomsSeen);
                }
                out.println(""E "" + ans);
                out.flush();
            }
            out.close();
        }

    }

    static class FastScanner {
        private BufferedReader in;
        private StringTokenizer st;

        public FastScanner(InputStream stream) {
            in = new BufferedReader(new InputStreamReader(stream));
        }

        public String next() {
            while (st == null || !st.hasMoreTokens()) {
                try {
                    st = new StringTokenizer(in.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return st.nextToken();
        }

        public int nextInt() {
            return Integer.",fetetriste
80,"public class Solution 
{
	/*
	Reminder
	1. Make sure you read EVERYTHING listed in the limits sections of each problem
	2. Walk through all examples.
	3. Use Paper!
	4. Don't dismiss brute force/simulation/save all possibilities type solutions(comes up in A).
	5. Try solving each problem by thinking backwards. Start at the endcase and work your way forward.
	*/
    public static void main(String[] args) 
	{
		Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));//make scanner
		int t = in.nextInt();//number of test cases
		for (int i = 1; i <= t; i++) //iterate through test cases
		{
			
			int ones = 9;

			while(ones != 0)
			{
				if(ones == 8)
				{
					System.out.println(""11111111"");
				}
				else
				{
					System.out.println(""10000000"");
				}
			}
			ones = ",CoCoCoder
895,"public final class Solution
{    
	static PrintWriter out = new PrintWriter(System.out); 
	static StringBuilder ans=new StringBuilder();
	static FastReader in=new FastReader();
	static ArrayList<Integer> g[];
	static long mod=(long)998244353,INF=Long.MAX_VALUE;
	static boolean set[],col[]; 
	static int par[],tot[],partial[];
	static int Days[],P[][];
	static int sum=0,size[];
	static int seg[],vis[][];
	static long dp[][];
	public static void main(String args[])throws IOException
	{		
		/*
		 * star,rope,TPST
		 * BS,LST,MS,MQ
		 */
		int T=i();
		outer:for(int tt=1; tt<=T; tt++)
		{
			int N=i(),P=i();
			long A[][]=new long[N+1][P];
			dp=new long[N+5][P+5];
			for(int i=1; i<=N; i++)A[i]=inputLong(P);
			for(long a[]:dp)Arrays.fill(a, -1);
			cost=Long.MAX_VALUE;
			ans.append(""Case #""+tt+"": ""+f(1,0,A,N,0,0)+""
"");
		}



		out.println(ans);
		out.close();
	}
	static long cost=Long.MAX_VALUE;
	static long f(int i,int j,long A[][],int N,long p,long s)
	{
//		System.out.println(i+"" ""+s);
		if(i==N+1)
		{
			//			cost=Math.min(cost,s);
			return s;
			//			return;
		}
		long min=A[i][0],max=A[i][0];
		int minIndex=0,maxIndex=0;
		int it=0;
		for(long a:A[i])
		{
			min=Math.min(min, a);
			max=Math.max(max, a);
			if(min==a)minIndex=it;
			if(max==a)maxIndex=it;
			it++;		
		}
		if(dp[i][j]==-1)
		{
			if(min<=p && max<=p)
			{
				s+=p-min;
				dp[i][j]=f(i+1,minIndex,A,N,min,s);
			}
			else if(min>=p && max>=p)
			{
				s+=max-p;
				dp[i][j]=f(i+1,maxIndex,A,N,max,s);
			}
			else
			{
				long a=p-min,b=max-p;
				s+=(a+b);
				long s1=s;
				s+=a;
				dp[i][j]=f(i+1,maxIndex,A,N,max,s);


				s1+=b;
				dp[i][j]=Math.min(dp[i][j], f(i+1,minIndex,A,N,min,s1));

//System.out.println(dp[i][j]+"" ""+i+"" ""+j);
			}
		}
		return dp[i][j];
	}
	static boolean palin(long n)
	{
		long s=0;
		long N=n;
		while(N!=0)
		{
			long r=N%10;
			s*=10L;
			s+=r;
			N/=10;
		}		
		return s==n;
	}
	static String fdp(char X[],int i,int N)
	{
		String Y="""";
		if(i+1==N)return X[N-1]+"""";




		return Y;
	}
	static long s=0;
	static long dfs(int n,int p,long F[])
	{
		long min=0,sum=0;
		for(int c:g[n])
		{
			if(c!=p)
			{
				long a=dfs(c,n,F);
				sum+=a;
				if(min==0)min=a;
				min=Math.min(a, min);
			}
		}
		//		System.out.println(n+"" ""+min+ "" ""+sum);
		s+=(sum-min);
		return Math.max(F[n-1], min);
	}
	static boolean fSmall(char X[],int i,int N)
	{
		if(i==N)
		{
			//if length of maximum palindrome is >=5
			int max=1;
			for(int l=0; l<N; l++)
			{
				for(int r=l+1; r<N; r++)
				{
					if(isPal(X,l,r))max=Math.max(max, r-l+1);
				}
			}
			return max<5;
		}
		if(X[i]=='?')
		{
			char Y[]=Arrays.copyOf(X,N);
			Y[i]='0';
			X[i]='1';
			return fSmall(X,i+1,N)|fSmall(Y,i+1,N);
		}
		return fSmall(X,i+1,N);
	}
	static boolean isPal(char X[],int l, int r)
	{
		while(l<r)
		{
			if(X[l]!=X[r])return false;
			l++;
			r--;
		}
		return true;
	}


	static boolean f(char X[],char Y[],int N,int M)
	{
		int j=0;
		for(char x:Y)
		{
			if(j<N && x==X[j])j++;
		}
		//	  System.out.println(j+"" ""+N);
		return j==N;
	}
	static int index(int a,ArrayList<Integer> A)
	{
		int l=-1,r=A.size();
		while(r-l>1)
		{
			int m=(l+r)/2;
			int x=A.get(m);
			if(x<=a)l=m;
			else r=m;
		}
		return r;
	}
	static long and(int i,int j)
	{
		System.out.println(""and ""+i+"" ""+j);
		return l();
	}
	static long or(int i,int j)
	{
		System.out.println(""or ""+i+"" ""+j);
		return l();
	}
	static boolean is_Sorted(int A[])
	{
		int N=A.length;
		for(int i=1; i<=N; i++)if(A[i-1]!=i)return false;
		return true;
	}
	static boolean f(StringBuilder sb,String Y,String order)
	{
		StringBuilder res=new StringBuilder(sb.toString());
		HashSet<Character> set=new HashSet<>();
		for(char ch:order.toCharArray())
		{
			set.add(ch);
			for(int i=0; i<sb.length(); i++)
			{
				char x=sb.charAt(i);
				if(set.contains(x))continue;
				res.append(x);
			}
		}

		String str=",kkkkush
441,"public class Solution {
    public static void main(String[] args) throws IOException {
        Scanner sc = new Scanner(System.in);
        PrintWriter pw = new PrintWriter(System.out);
        int t = sc.nextInt();
        int n = sc.nextInt();
        int k = sc.nextInt();
        for (int tc = 1; tc <= t; tc++) {
            int[] a = new int[n];
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt() - 1;
            }
            while (true) {
                int color = 1;
                int[] c = new int[n];
                for (int i = 0; i < n; i++) {
                    if (c[i] != 0)
                        continue;
                    int cur = i;
                    while (c[cur] == 0) {
                        c[cur] = color;
                        cur = a[cur];
                    }
                    color++;
                }
                for (int i = 0; i < n; i++) {
                    pw.print(c[i] + "" "");
                }
                pw.println();
                pw.flush();
                int res = sc.nextInt();
                if (res != 0) {
                    break;
                }
                for (int i = 0; i < n; i++) {
                    a[i] = sc.nextInt() - 1;
                }
            }
        }
        pw.close();
    }

    static class Scanner {
        BufferedReader br;
        StringTokenizer st;

        public Scanner(InputStream s) {
            br = new BufferedReader(new InputStreamReader(s));
        }

        public Scanner(FileReader f) {
            br = new BufferedReader(f);
        }

        public String next() throws IOException {
            while (st == null || !st.hasMoreTokens())
                st = new StringTokenizer(br.readLine());
            return st.nextToken();
        }

        public int nextInt() throws IOException {
            return Integer.parseInt(next());
        }

        public long nextLong() throws IOException {
            return Long.parseLong(next());
        }

        public double nextDouble() throws IOException {
            return Double.parseDouble(next());
        }

        public int[] nextIntArr(int n) throws IOException {
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = ",YahiaSherif
239,"class Solution {
    public static void main(String[] args)
    {
        Scanner s = new Scanner(System.in);
        int t = s.nextInt();
        for(int i = 1; i <= t; i++)
        {
            System.out.println(11111111);
            System.out.flush();
            int comp = s.nextInt();
            while(comp > 0)
            {
                if(comp == 8)
                {
                    System.out.println(11111111);
                    System.out.flush();
                } else if(comp == 7)
                {
                    System.out.println(11111110);
                    System.out.flush();
                } else if(comp == 6)
                {
                    System.out.println(11111100);
                    System.out.flush();
                } else if(comp == 5)
                {
                    System.out.println(11111000);
                    System.out.flush();
                } else if(comp == 4)
                {
                    System.out.println(11110000);
                    System.out.flush();
                } else if(comp == 3)
                {
                    System.out.println(11100000);
                    System.out.flush();
                } else if(comp == 2)
                {
                    System.out.println(11000000);
                    System.out.flush();
                } else if(comp == 1)
                {
                    System.out.println(10000000);
                    System.out.flush();
                }
                comp = s.nextInt();
            }
            if(comp == -1)
            ",Maarten17581
902,"class Solution
{
	public static void main (String[] args) throws java.lang.Exception
	{
		// your code goes here
	    	int i, j, k, modules, buf;
		Scanner reader = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		
		long cases, max, res, sol;
		int[] funfact, setup;
		String anotherLine = """";
		
		ArrayList<Integer> inits;
		//Iterator<Arraylist<Integer>> itr = null;
		
		Map<Integer, Integer> assoc;
	        Map<Integer, Boolean> route; //Map.Entry<Integer, Integer> buf;

		cases = Long.parseLong(reader.nextLine());
		
		for(i = 0; i < cases; i++) {
		    modules = Integer.parseInt(reader.nextLine());
		    
		    try {
		        funfact = getLine(reader, modules);
		    } catch (Exception e) {
		        return;
		    }
		    
		    try {
		        setup = getLine(reader, modules);
		    } catch (Exception e) {
		        return;
		    }

		    assoc = new HashMap<Integer, Integer>();
		    route = new HashMap<Integer, Boolean>();
		    for(j = 0; j < modules; assoc.put(j + 1, setup[j]), route.put(j + 1, false), j++);
		    
		    inits = new ArrayList<>();
		    for(j = 0; j < modules; j++) {
			    buf = getKey(assoc, j + 1);
			    if(buf == 0) inits.add(j + 1);
		    } 

		    for(k = 0, sol = 0; k < inits.size(); k++) {
		        for(j = k, max = 0; j < inits.size() + k; j++) {
			        buf = inits.get((j >= inits.size())? j - inits.size(): j);
			        res = funfact[buf -1];
			        while(buf != 0) {
				    //System.out.print(buf + "" -> "" );
				        if(!route.get(buf)) {
					        if(res < funfact[buf -1]) {
					            res = funfact[buf - 1];
					            route.put(buf, true);
					        }
				        }
				        buf = assoc.get(buf);
			        }
			        max += res; 
		        }
		        for(j = 0; j < modules; route.put(j + 1, false), j++);
		        if(sol < max) sol = max;
		    }

		    System.out.println(""Case #"" + (i + 1) + "": "" + sol);
		}
		return;
	}
	
	public static int[] getLine(Scanner pipe, int num) throws java.lang.Exception
	{
	    int i = 0;
	    int[] result = null;
	    String anotherLine = """";
	    try {
	        anotherLine = pipe.nextLine();
	    } catch (Exception e) {
	        System.out.println(""Out of format"");
	        return result;
	    }
	    
	    StringTokenizer st = new StringTokenizer(anotherLine, "" "");
		if (st.countTokens() != num) {
		    System.out.println(""Out of format."");
		    return result;
		}
		
		result = new int[num];
		while (st.hasMoreTokens()) {
		    result[i++] = Integer.parseInt(st.nextToken());
		    
		}
        return result;
	}
	
	public static int getInit(Map<Integer, Integer> map, int value) {
		if(getKey(map, value) != 0) return getInit(map, value);
		return 0;
	}

	public static int getKey(Map<Integer, Integer> map, int value) {
		for (Map.Entry<Integer, Integer> entry : map.entrySet()) {
			if (entry.getValue().equals(value)) {
				return entry.",krizor
1164,"class Solution {

	public static void main ( String [] args ) {
		Scanner s = new Scanner ( System.in);
			
		int T = s.nextInt(); 
		for ( int t=1; t<=T; t++) {  
			int N = s.nextInt(); 
			int k = s.nextInt();
			
			int total=0;
			int seen=0;
			int room = s.nextInt(); 
			int passages = s.nextInt(); 
			total += passages;
			seen+=1;
			
			Random rnd = new Random();
	
			List<Integer> shuffle = new ArrayList();
			for ( int i=1; i<=N; i++) {
				shuffle.add(i);
				
			}
			Collections.shuffle(shuffle);
			
			for ( int i=0; i<k; i++) {
				int next = shuffle.get(i);
				if (i%2==0) {
					System.out.println(""T "" + next);
				} else {
					System.out.println(""W"");	
				}
				room = s.nextInt(); 
				passages = s.nextInt(); 
				total += passages;
				seen+=1;
			}
			double avg = total/(double)seen; 
			
			double estimation = (N*avg)/2;
			System.out.println(""E ""+(int)estimation);
			
			//System.out.print(false)
//			for ( int i=N-1; i<N*N; i++) {
//				double aux = expected/(double)N;
//				expected+=2;
//				if (aux>avg) {
//					System.out.print(""E ""+i);
//					break;
//				}
//			}
			
		}
	}  
	
}",slycer
594,"public class Solution{
    public static void main(String[] args){
        Scanner s = new Scanner(System.in);
        int T = s.nextInt();
    forloop:    for(int ii=1; ii <= T; ii++){
            
            int[][] c = new int[3][4];
            
            for(int i=0; i < 3; i++){
                for(int j=0; j <=3; j++){
                    c[i][j] = s.nextInt();
                }
            }
            int rowSum = 0;
            int column = -1;
            int[] min = new int[4];
            Arrays.fill(min,Integer.MAX_VALUE);
            for(int j=0; j <= 3; j++){
               // min = 0;
                for(int i=0; i < 3; i++){
                     min[j] = Math.min(min[j],c[i][j]);
                }
                
                
            }
            
            int target = 1000000;
            int sum = 0;
            int[] ans = new int[4];
            for(int i=0; i < 4; i++){
                sum = sum + min[i];
                
                if (target >= 0){
                    ans[i] = min[i];
                    //continue;
                }
                else{
                    ans[i-1] = min[i-1] + target;
                }
                target = target - min[i];
            }
            
            if (sum < 1000000){
                System.out.println(""Case #"" + ii  + "": IMPOSSIBLE"" );
                continue forloop;
            }
            
            System.out.print(""Case #"" + ii  + "": "" );
            
            for(int i=0; i < 4; i++){
                System.out.print(ans[i] + "" "");
            }
            
            
            System.",dattap
982,"public class Solution {

	public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        
        int numberOfCases = in.nextInt();
        
        for (int i = 1; i <= numberOfCases; ++i) {
        	int[] result = new int[] {0,0,0,0,0,0,0,0};
        	int N = 10;
        	while(N>0) {
        		if(N == 10) {
        			System.out.println(""00000000"");
        			N = in.nextInt();
        			System.err.println(N);
        		}
        		if(N == 1) {
        			System.out.println(""00010000"");
        			N = in.nextInt();
        			System.err.println(N);
        		}
        		if(N == 2) {
        			System.out.println(""01000010"");
        			N = in.nextInt();
        			System.err.println(N);
        		}
        		if(N == 3) {
        			System.out.println(""10000110"");
        			N = in.nextInt();
        			System.err.println(N);
        		}
        		if(N == 4) {
        			System.out.println(""01011010"");
        			N = in.nextInt();
        			System.err.println(N);
        		}
        		if(N > 4) {
        			System.out.println(""11111111"");
        			N = in.nextInt();
        			System.err.println(N);
        		}
        	}
        	if(N == -1)break;
        	
        }
      }
}",nicolasD
630,"public class Solution {

    private int N;
    private ArrayList<int[][]> tables = new ArrayList<>();

    public static void main(String[] args) {

        Solution printing3D = new Solution();
        printing3D.readInput();

        for (int x = 0; x< printing3D.tables.size(); x++) {
            int[][] table = printing3D.tables.get(x);

            printing3D.solveTestCase(x, table);
        }

    }

    private void solveTestCase(int x, int[][] cartridges) {

        int[] CMYK = minimumCMYK(cartridges);
        boolean isPossible = isPossible(CMYK);
        calculateCMYK(CMYK);

        if(isPossible) {
            System.out.println(String.format(""Case #%d: %d %d %d %d"", x+1, CMYK[0], CMYK[1], CMYK[2], CMYK[3]));
        } else {
            System.out.println(String.format(""Case #%d: IMPOSSIBLE"", x+1));
        }
    }

    private void calculateCMYK(int[] CMYK) {
        int remainingInkUnits = (int) Math.pow(10, 6);

        for(int i=0; i<CMYK.length; i++) {
            if(remainingInkUnits < CMYK[i]) {
                CMYK[i] = remainingInkUnits;
            }
            remainingInkUnits -= CMYK[i];
        }
    }

        private int[] minimumCMYK(int[][] cartridges) {
        int[] CMYK = new int[4];
        CMYK[0] = cartridges[0][0];
        CMYK[1] = cartridges[0][1];
        CMYK[2] = cartridges[0][2];
        CMYK[3] = cartridges[0][3];

        for (int i = 0; i < cartridges.length; i++) {
            for (int j = 0; j < cartridges[i].length; j++){
                if(cartridges[i][j] < CMYK[j]) {
                    CMYK[j] = cartridges[i][j];
                }
            }
        }

        return CMYK;
    }

    private boolean isPossible(int[] CMYK) {
        int totalInkUnits = 0;
        for (int i = 0; i < CMYK.length; i++) {
            totalInkUnits += CMYK[i];
        }

        boolean isPossible = (totalInkUnits >= Math.pow(10, 6));
        return isPossible;
    }

    private void readInput() {

        Scanner reader = new Scanner(System.in);
        String data;

        if (reader.hasNextLine()) {
            data = reader.nextLine();
            N = Integer.parseInt(data);
        }

        for (int i = 0; i < N; i++) {
            int[][] table = new int[N][4];

            for (int j = 0; j < 3; j++) {
                data = reader.nextLine();

                String[] cells = data.split("" "", 0);
                table[j][0] = Integer.parseInt(cells[0]);
                table[j][1] = Integer.parseInt(cells[1]);
                table[j][2] = Integer.parseInt(cells[2]);
                table[j][3] = Integer.parseInt(cells[3]);
            }

            tables.add(table);
        }

        reader.",dionysis_dt
530,"public class Solution {

    private static final Boolean FROM_FILE = Boolean.FALSE;

    public static void main(String[] args) throws IOException{
        BufferedReader br;
        BufferedWriter bw;

        if(FROM_FILE){
            br = new BufferedReader(new FileReader(""C2022QR1E.in""));
        } else {
            br = new BufferedReader(new InputStreamReader(System.in));
        }

        try {
            if(FROM_FILE) {
                File file = new File(""C2022QR1E.out"");
                if (!file.exists()) {
                    file.createNewFile();
                }
                bw = new BufferedWriter(new FileWriter(file.getAbsoluteFile()));
            } else {
                bw = new BufferedWriter(new OutputStreamWriter(System.out));
            }

            String line = br.readLine();
            String[] q,r;

            int tests = Integer.parseInt(line);//100
            int n,k;
            int maxk = 8000;
            long max;

            // max n is 10000
            // min is n/2 - islands of 2 -> 5 000
            // max is n*(n-1)/2 -> 5000*9999 = 49 995 000

            for(int i = 0; i < tests; i++){
                line = br.readLine();
                q = line.split(""\\\s+"");
                n = Integer.parseInt(q[0]);
                // same k for all tests?
                k = Integer.parseInt(q[1]);

                max = 0L;
                if(k >= n){
                    // enough tries
                    for(int j = 0; j < n; j++){
                        bw.write(""T""+(j+1)+""
"");
                        bw.flush();

                        line = br.readLine();
                        q = line.split(""\\\s+"");
                        max+= Integer.parseInt(q[1]);
                    }
                    // each was counted twice
                    max /= 2;
                    bw.write(""E""+(max)+""
"");
                    bw.flush();
                    continue;
                }

                // not enough tries, try all k
                // 8000 from 10000 means a 8% random sample
                for(int j = 0; j < k; j++){
                    bw.write(""T""+(ThreadLocalRandom.current().nextInt(1, n + 1))+""
"");
                    bw.flush();

                    line = br.readLine();
                    q = line.split(""\\\s+"");
                    max+= Integer.parseInt(q[1]);
                }

                double average = (double) max / k;

                double uniform = average * n;

                max = Math.round(uniform/2);

                bw.write(""E""+(max)+""
"");
                bw.flush();
            }

            if(FROM_FILE) {
                bw.close();
            }
        } finally {
            if(FROM_FILE) {
                br.close();
            }
        }
    }
}",araver
629,"public class Solution {

    private static CodeJamIO io = new CodeJamIO();

    /**
     * @param args
     */
    public static void main(String[] args) {

        try {
            init();

            int numCases = Integer.parseInt(io.readNextLine()[0]);
            for (int i=1; i <= numCases; i++) {
                io.debug(""Solving Case #"" + i + ""..."");
                solveCase(i);
                io.debug(""Case #"" + i + "" solved!"");
            }

        } catch (Exception e) {
            e.printStackTrace();
        }

    }

    /**
     * Performs initial computations
     */
    private static void init() {

    }

    /**
     * Solves a Test Case
     *
     * @param caseNum
     * @throws IOException
     */
    private static void solveCase(int caseNum) throws IOException {
        // Read input
        String[] tokens = io.readNextLine();
        int n = Integer.parseInt(tokens[0]);
        int k = Integer.parseInt(tokens[1]);
        if (k > n) {
            k = n;
        }

        // Interact
        double[] p = new double[n];
        double e = 0;
        Set<Integer> rooms = new HashSet<>();

        tokens = io.readNextLine();
        rooms.add(Integer.parseInt(tokens[0]));
        int passages = Integer.parseInt(tokens[1]);
        p[0] = passages;
        e += p[0];
        double sum = 0;

        for (int i=0; i<k-1; i++) {
            if (p[i] > i) {
                io.println(""W"");
            } else {
                io.println(""T "" + String.valueOf(pickRoom(n, rooms)));
            }
            tokens = io.readNextLine();
            rooms.add(Integer.parseInt(tokens[0]));
            passages = Integer.parseInt(tokens[1]);
            if (p[i] > i) {
                p[i+1] = passages - 1;
            } else {
                p[i+1] = passages - p[i] / (n-1);
            }
            p[i+1] -= sum / (n-1);
            e += p[i+1];
            sum += p[i];
        }
        double mean = e / n;
        for (int i=k; i<n-1; i++) {
            sum += p[i];
            p[i+1] -= sum / (n-1);
            e += p[i+1];
        }

        // Print results
        io.println(""E "" + String.valueOf(Math.round(e)));
    }

    private static int pickRoom(int n, Set<Integer> rooms) {
        for (int i=0; i<n; i++) {
            if (!rooms.contains(i+1)) {
                return i+1;
            }
        }
        throw new RuntimeException();
    }

    /**
     * Input and Output CodeJam style
     *
     */
    private static class CodeJamIO {
        private static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        private static PrintWriter out = new PrintWriter(System.out, true);
        private static PrintWriter err = new PrintWriter(System.err, true);

        public String[] readNextLine() throws IOException {
            String line = in.readLine();
            String[] tokens = line.split(""\\\s+"");
            return tokens;
        }

        public CodeJamIO printCase(int caseNum) { return print(""Case #"" + caseNum + "": "" ); }

        public CodeJamIO print(Object o) { out.print(o); return this; }

        public CodeJamIO print(Object o[]) { return print(concat(o)); }

        public CodeJamIO print(Object o[][]) { return print(concat(o)); }

        public CodeJamIO println() { out.println(); return this; }

        public CodeJamIO printlnCase(int caseNum) { return printCase(caseNum).println(); }

        public CodeJamIO println(Object o) { return print(o).println(); }

        public CodeJamIO println(Object o[]) { return print(o).println(); }

        public CodeJamIO println(Object o[][]) { return print(concat(o)).println(); }

        public CodeJamIO println(List<Integer[]> l) { return print(concat(l)).println(); }


        private String concat(Object[] o) {
            StringBuffer buf = new StringBuffer(10*o.length);

            String delim = """";
            for (int i=0; i < o.length; i++) {
                buf.append(delim).append(o[i]);
                delim = "" "";
            }
            return buf.toString();
        }

        private String concat(Object[][] o) {
            StringBuffer buf = new StringBuffer(100*o.length);
            for (int i=0; i < o.length; i++) {
                buf.append(concat(o[i])).append(""
"");
            }
            return buf.toString();
        }

        private String concat(List<Integer[]> list) {
            StringBuffer buf = new StringBuffer();
            String delim = """";
            for (Object[] elm : list) {
                buf.append(delim).append(concat(elm)).append(""
"");
            }
            return buf.toString();
        }

        public void debug(String message) {
            err.println(Calendar.getInstance().getTime() + "": "" + message);
        }

        public void debug(String message, Object[] o) {
            err.println(Calendar.getInstance().getTime() + "": "" + message);
            err.println(""	"" + concat(o));
        }

        public void debug(String message, Object[][] o) {
            err.println(Calendar.getInstance().getTime() + "": "" + message);
            String values = concat(o);
            err.println(""	"" + values.replaceAll(""
"", ""
	""));
        }

        public void debug(String message, List<Integer[]> list) {
            err.println(Calendar.getInstance().getTime() + "": "" + message);
            String values = concat(list);
            err.println(""	"" + values.replaceAll(""
"", ""
	""));
        }

        public void flush() {
            out.flush();
            err.flush();
        }

    }
",ddimi
771,"public class Solution {
    public static void main(String[] argu) throws Exception {
        Reader br = new Reader();
        PrintWriter pw = new PrintWriter(System.out);
        int nt = br.nextInt();
        for (int t = 1; t <= nt; ++t) {
            int N = br.nextInt();
            long[] F = new long[N], maxF = new long[N];
            List<Integer>[] adj = new List[N];
            for (int i = 0; i < N; ++i) F[i] = br.nextLong();
            int[] P = new int[N], outDeg = new int[N], inDeg = new int[N];
            for (int i = 0; i < N; ++i) {
                adj[i] = new LinkedList();
                P[i] = br.nextInt() - 1;
                if (-1 == P[i]) continue;
                outDeg[i]++;
                inDeg[P[i]]++;
                adj[P[i]].add(i);
            }
            boolean[] seen = new boolean[N];
            PriorityQueue<Integer> pq = new PriorityQueue<Integer>(1, (a, b) -> Long.compare(F[b], F[a]));
            for (int i = 0; i < N; ++i) {
                if (0 != outDeg[i]) continue;
                pq.add(i);
                dfs(adj, i, F, maxF);
            }
            long res = 0;
            while (!pq.isEmpty()) {
                int cur = pq.poll();
                if (0 == inDeg[cur]) res += F[cur];
                int min = Integer.MAX_VALUE, next = -1;
                for (int dst : adj[cur]) {
                    pq.add(dst);
                    if (maxF[dst] < min) {
                        min = (int) maxF[dst];
                        next = dst;
                    }
                }
                if (-1 == next) continue;
                F[next] = Math.max(F[next], F[cur]);
            }
            pw.format(""Case #%d: %d"", t, res);
            pw.println();
        }
        pw.close();
        br.close();
    }
    private static void dfs(List<Integer>[] adj, int src, long[] F, long[] maxF) {
        if (0 != maxF[src]) return;
        maxF[src] = F[src];
        for (int dst : adj[src]) {
            dfs(adj, dst, F, maxF);
            maxF[src] = Math.max(maxF[src], maxF[dst]);
        }
    }
    static class Reader
    {
        final private int BUFFER_SIZE = 1 << 16;
        private DataInputStream din;
        private byte[] buffer;
        private int bufferPointer, bytesRead;

        public Reader()
        {
            din = new DataInputStream(System.in);
            buffer = new byte[BUFFER_SIZE];
            bufferPointer = bytesRead = 0;
        }
        private void fillBuffer() throws IOException
        {
            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);
            if (bytesRead == -1)
                buffer[0] = -1;
        }

        private byte read() throws IOException
        {
            if (bufferPointer == bytesRead)
                fillBuffer();
            return buffer[bufferPointer++];
        }

        public void close() throws IOException
        {
            if (din == null)
                return;
            din.close();
        }
        public int nextInt() throws IOException
        {
            int ret = 0;
            byte c = read();
            while (c <= ' ')
                c = read();
            boolean neg = (c == '-');
            if (neg)
                c = read();
            do
            {
                ret = ret * 10 + c - '0';
            }  while ((c = read()) >= '0' && c <= '9');

            if (neg)
                return -ret;
            return ret;
        }
        public long nextLong() throws IOException
        {
            long ret = 0;
            byte c = read();
            while (c <= ' ')
                c = read();
            boolean neg = (c == '-');
            if (neg)
                c = read();
            do
            {
                ret = ret * 10 + c - '0';
            }  while ((c = read()) >= '0' && c <= '9');

            if (neg)
                return -ret;
            return ret;
        }

        public String readLine() throws IOException {
            byte[] buf = new byte[200001]; // line length
            int cnt = 0, c = read();
            if (-1 != c && '
' != c) buf[cnt++] = (byte) c;
            while ((c = read()) != -1)
            {
                if (c == '
')
                    break;
                buf[cnt++] = (byte) c;
            }
            return new String(buf, 0, cnt);
        }

    }
}",hdchen
439,"public class Solution {

    static HashSet<Integer>[] adj;
    static int[] path = new int[3];
    static int[] l, r;

    static void getEdges(int u, int lvl) {
        path[lvl] = u;
        if (lvl == 2) {
            for (int i = 0; i < 3; i++) {
                for (int j = i + 1; j < 3; j++) {
                    adj[path[i]].add(path[j]);
                    adj[path[j]].add(path[i]);
                }
            }
            return;
        }
        getEdges(l[u], lvl + 1);
        getEdges(r[u], lvl + 1);
    }

    public static void main(String[] args) throws IOException {
        Scanner sc = new Scanner(System.in);
        PrintWriter pw = new PrintWriter(System.out);
        String s = ""ACDEHIJKMORST"";
        int t = sc.nextInt();
        for (int tc = 1; tc <= t; tc++) {
            int n = sc.nextInt();
            l = new int[n];
            r = new int[n];
            for (int i = 0; i < n; i++) {
                l[i] = sc.nextInt() - 1;
            }
            for (int i = 0; i < n; i++) {
                r[i] = sc.nextInt() - 1;
            }
            adj = new HashSet[n];
            for (int i = 0; i < n; i++) {
                adj[i] = new HashSet<>();
            }
            for (int i = 0; i < n; i++) {
                getEdges(i, 0);
            }
            boolean valid = true;
            for (int i = 0; i < n; i++) {
                valid &= !adj[i].contains(i);
            }
            if (!valid) {
                pw.println(""Case #"" + tc + "": IMPOSSIBLE"");
                continue;
            }
            boolean[] vis = new boolean[n];
            Queue<Integer> q = new LinkedList<>();
            int[] size = new int[n];
            for (int i = 0; i < n; i++) {
                size[i] = adj[i].size();
                if (adj[i].size() <= 12) {
                    q.add(i);
                    vis[i] = true;
                }
            }
            Stack<Integer> st = new Stack<>();
            while (!q.isEmpty()) {
                int cur = q.poll();
                st.add(cur);
                for (int x : adj[cur]) {
                    if (!vis[x] && --size[x] <= 12) {
                        vis[x] = true;
                        q.add(x);
                    }
                }
            }
            if (st.size() != n) {
                pw.println(""Case #"" + tc + "": IMPOSSIBLE"");
                continue;
            }
            int[] color = new int[n];
            Arrays.fill(color, -1);
            while (!st.isEmpty()) {
                int cur = st.pop();
                boolean[] taken = new boolean[13];
                for (int x : adj[cur]) {
                    if (color[x] != -1) {
                        taken[color[x]] = true;
                    }
                }
                for (int i = 0; i < 13; i++) {
                    if (!taken[i]) {
                        color[cur] = i;
                        break;
                    }
                }
            }
            pw.print(""Case #"" + tc + "": "");
            for (int x : color) {
                pw.print(s.charAt(x));
            }
            pw.println();
        }
        pw.close();
    }

    static class Scanner {
        BufferedReader br;
        StringTokenizer st;

        public Scanner(InputStream s) {
            br = new BufferedReader(new InputStreamReader(s));
        }

        public Scanner(FileReader f) {
            br = new BufferedReader(f);
        }

        public String next() throws IOException {
            while (st == null || !st.hasMoreTokens())
                st = new StringTokenizer(br.readLine());
            return st.nextToken();
        }

        public int nextInt() throws IOException {
            return Integer.parseInt(next());
        }

        public long nextLong() throws IOException {
            return Long.parseLong(next());
        }

        public double nextDouble() throws IOException {
            return Double.parseDouble(next());
        }

        public int[] nextIntArr(int n) throws IOException {
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = ",YahiaSherif
867,"public class Solution {
    
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        int t = Integer.parseInt(in.readLine());
        for (int e = 0; e < t; e++) {
            System.out.print(""Case #"" + (e + 1) + "": "");
            int n = Integer.parseInt(in.readLine());
            int[] f = new int[n + 1];
            int[] p = new int[n + 1];
            int[] incoming = new int[n + 1];
            StringTokenizer st = new StringTokenizer(in.readLine());
            StringTokenizer st2 = new StringTokenizer(in.readLine());
            for (int i = 1; i <= n; i++) {
                f[i] = Integer.parseInt(st.nextToken());
                p[i] = Integer.parseInt(st2.nextToken());
                incoming[p[i]]++;
            }
            int totalFun = 0;
            int[] min = new int[n + 1];
            Arrays.fill(min, -1);
            for (int i = n; i >= 1; i--) {
                if (min[i] == -1) {
                    min[i] = f[i];
                }
                int x = min[p[i]];
                if (x == -1) {
                    min[p[i]] = min[i];
                } else if (x > min[i]) {
                    totalFun += x;
                    min[p[i]] = min[i];
                } else {
                    totalFun += min[i];
                }
                incoming[p[i]]--;
                if (incoming[p[i]] == 0) {
                    min[p[i]] = Math.max(min[p[i]], f[p[i]]);
                }
            }
            totalFun += min[0];
            System.out.println(totalFun);
        }
        in.",kevinz1423
423,"public class Solution {
    public static void main(String[] args) {
        try {
            Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
            int tests = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
            for (int currentTest = 1; currentTest <= tests; ++currentTest) {
                int N = in.nextInt();
                int K = in.nextInt();
                int r = in.nextInt();
                int p = in.nextInt();
                long pSum = p;
                long queries = K;
                if(N <=1){
                    System.out.println(""E 0"");
                    System.out.flush();
                }else if(N == 2){
                    System.out.println(""E 1"");
                    System.out.flush();
                }
                else if(N <= 8000){
                    long count = 0;
                    for(int i = 1; i <= N; i++){
                        System.out.println(""T "" + i);
                        System.out.flush();
                        r = in.nextInt();
                        p = in.nextInt();
                        count += p;
                        queries --;
                    }

                    System.out.println(""E "" + (count/2));
                    System.out.flush();
                }else {
                    while (queries > 0) {
                        int nxt = (int) (Math.random() * N + 1);
                        System.out.println(""T "" + nxt);
                        System.out.flush();
                        r = in.nextInt();
                        p = in.nextInt();
                        pSum += p;
                        queries--;
                    }
                    double avg = (double) pSum / (K + 1);
                    long mid = (long) (((long)N * avg) / 2.0);
                    System.out.println(""E "" + mid);
                    System.out.flush();
                }
            }
        }catch (Exception e){
           // System.err.println(e.getMessage());
            e.",Vlad
396,"class Solution{
    static int maxans;
    public Solution(){
        maxans=0;
    }
    
    public static LinkedList<Integer> adj[];
    public static void Com(int end,int[] initiator,int N,List<Integer> temp,boolean[] tracker,int [] fun){
        if(temp.size()==end){
            int ans=0;
            boolean[] tracke = new boolean[N+1];
            tracke[0]=true;
            for(Integer v: temp){
                ans+=DFS(v,fun,tracke);
            }
            for(int i=0;i<N+1;i++){
                if(!tracke[i]){
                    ans+=fun[i-1];
                }
            }
            maxans=Math.max(maxans,ans);
            return;
        }
        for(int i=0 ;i<end;i++){
            if(!tracker[i]){
                temp.add(initiator[i]);
                tracker[i]=true;
                Com(end,initiator,N,temp,tracker,fun);
                temp.remove(temp.size()-1);
                tracker[i]=false;
            }
        }
        
    }
    
    public static int DFS(int s,int[] fun,boolean[] tracker){
        if(tracker[s]){
            return 0;
        }
        int max=fun[s-1];
        tracker[s]=true;
        Iterator<Integer> i = adj[s].listIterator();
        while(i.hasNext()){
            int n= i.next();
            if(!tracker[n]){
                int score = DFS(n,fun,tracker);
                max=Math.max(score,max);
                
            }
        }
        
        return max;
    }
    
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        int index=T;
        while(T-- > 0){
            new Solution();
            int N = sc.nextInt();
            int[] fun = new int[N];
            int[] edge = new int[N];
            for(int i=0;i<N;i++){
                fun[i]=sc.nextInt();
            }
            for(int i=0;i<N;i++){
                edge[i]=sc.nextInt();
            }
            for(int i=0;i<N;i++){
                if(edge[i]>=i){
                    edge[i]=0;
                }
            }
            int[] degree = new int[N+1];
            for(int i=0;i<N;i++){
                degree[edge[i]]+=1;
            }
            adj=new LinkedList[N+1];
            for(int i=0;i<N+1;i++){
                adj[i]=new LinkedList();
            }
            for(int i=0;i<N;i++){
                adj[i+1].add(edge[i]);
            }
            
            
            int[] initiator = new int[N];
            int k=0;
            for(int i=1;i<N+1;i++){
                if(degree[i]==0){
                    initiator[k++]=i;
                }
            }
           
            List<Integer> temp = new ArrayList<>();
            boolean[] t = new boolean[k];
            Com(k,initiator,N,temp,t,fun);
            
                System.",Sujit_Das
168,"public class Solution {

    public void solve(Scanner scanner) {
        int n = scanner.nextInt();
        int k = scanner.nextInt();
        int[] nums = new int[n];
        for (int i = 0; i < n; i++) {
            nums[i] = scanner.nextInt();
        }
        int sum = Arrays.stream(nums).sum();
        int squaredSum = Arrays.stream(nums)
                .map(i -> i * i)
                .sum();
        if (sum == squaredSum) {
            System.out.println(""0"");
            return;
        }
        if (sum == 0) {
            System.out.println(""IMPOSSIBLE"");
        } else {
            int x = (squaredSum - (sum * sum)) / (2 * sum);
            System.out.println(x);
        }
    }

    public static void main(String[] args) throws Exception {
        Scanner scan = new Scanner(System.in);
        int problems = scan.nextInt();
        for (int count = ",KatieSanderson
434,"public class Solution {
    public static void main(String[] args) {
        try {
            Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
            int tests = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
            in.nextLine();
            for (int currentTest = 1; currentTest <= tests; ++currentTest) {
                StringBuilder sb = new StringBuilder();
                char[] arr = in.nextLine().toCharArray();
                sb.append(arr[0]);

                    for(int i = 1; i < arr.length; i++){
                        if(arr[i] > arr[i-1]){
                            sb.append(arr[i-1]);
                            //sb.append(Arrays.copyOfRange(arr, i , arr.length));
                            //break;
                        }
                        sb.append(arr[i]);
                    }





                System.out.println(""Case #"" + currentTest + "": "" + sb.toString());
            }
        }catch (Exception e){
            System.",Vlad
1192,"class Solution{
    public static void main(String args[]){
        Scanner sin = new Scanner(System.in);
        int a = Integer.parseInt(sin.nextLine());
        for(int j =0;j<a;j++) {
            String h = sin.nextLine();
            String s;
            char d;
            int g=0;
            int c = 0;
            char b [] = h.toCharArray();
            char k [] = new char[b.length];
            Arrays.sort(b);
            k[0]=b[0];
            for(int i=1;i<h.length();i++){
                int f = Character.getNumericValue(b[i])-Character.getNumericValue(b[i-1]);
                        if(f==1) {
                            k[i] = b[i];
                            k[i-1]=b[i-1];
                        }

            }
          System.out.print(""Case #""+(j+1)+"": "");
            int x=0;
            int n =0;
           while(x<b.length){
               for(int i=0;i<k.length;i++) {
                   if (h.charAt(x) == k[i]) {
                       System.out.print(h.charAt(x));
                       k[i]=' ';
                       break;
                   }
               }
                   System.out.print(h.charAt(x));
                   x++;

           }
           System.",spsaivaraprasad
1254,"public class Solution {
	public static void input() {
		Scanner sc = new Scanner(System.in);
		int testCase = sc.nextInt();
		int countTest = 1;
		int[] pr1, pr2, pr3;
		while (testCase > 0) {
			pr1 = new int[4];
			pr2 = new int[4];
			pr3 = new int[4];
			for (int i = 0; i < 4; i++) {
				pr1[i] = sc.nextInt();
			}
			for (int i = 0; i < 4; i++) {
				pr2[i] = sc.nextInt();
			}
			for (int i = 0; i < 4; i++) {
				pr3[i] = sc.nextInt();
			}
			System.out.print(""Case #"" + countTest + "": "");
			output(pr1, pr2, pr3);
			System.out.println("""");
			countTest++;
			testCase--;
		}
	}

	public static void output(int[] pr1, int[] pr2, int[] pr3) {
		int len = 4;
		int maxColor = (int) Math.pow(10, 6);

		// Find the maximum the color for each printers in case 1
		for (int i = 0; i < len; i++) {
			int countMaxColor = 0, getIndexMax = 0;
			int getIsZeroFirst = 0, getIsZeroSecond = 0, getIsZeroThird = 0;
			if (pr1[i] == maxColor) {
				countMaxColor++;
				getIndexMax = i;

			} else if (pr1[i] == 0) {
				getIsZeroFirst++;
			}
			if (pr2[i] == maxColor) {
				countMaxColor++;

			} else if (getIsZeroSecond == 0) {
				getIsZeroSecond++;
			}
			if (pr3[i] == maxColor) {
				countMaxColor++;

			} else if (getIsZeroThird == 0) {
				getIsZeroThird++;
			}

			if (getIsZeroFirst >= 2 && (getIsZeroSecond == 1 || getIsZeroThird == 1)
					|| getIsZeroSecond >= 2 && (getIsZeroSecond == 1 || getIsZeroThird == 1)
					|| getIsZeroThird >= 2 && (getIsZeroFirst == 1 || getIsZeroSecond == 1)) {
				if (countMaxColor == len - 1) {
					for (int j = 0; j < len; j++) {
						if (j != getIndexMax) {
							System.out.print(0 + "" "");
						} else {
							System.out.println(Math.pow(10, 6));
						}
					}
					return;
				} else {
					System.out.println(""IMPOSSIBLE"");
					return;
				}
			}

		}

		Map<Integer, Integer> map = new TreeMap<>();
		List<Integer> getMin = new LinkedList<>();
		int countColor = 0;
		for (int i = 0; i < len; i++) {
			if (pr1[i] <= pr2[i] && pr1[i] <= pr3[i] && pr1[i] != 0) {
				countColor += pr1[i];
				map.put(i, countColor);
				getMin.add(pr1[i]);
			} else if (pr2[i] <= pr1[i] && pr2[i] <= pr3[i] && pr2[i] != 0) {
				countColor += pr2[i];
				map.put(i, countColor);
				getMin.add(pr2[i]);
			} else if (pr3[i] <= pr1[i] && pr3[i] <= pr2[i] && pr3[i] != 0) {
				map.put(i, countColor);
				countColor += pr3[i];
				getMin.add(pr3[i]);
			}
		}

		// int firstMin = getMin.get(0);
		int countColorCase2 = 0;
		for (int i = 0; i < len - 1; i++) {
			countColorCase2 += getMin.get(i);
			if(i == 0) {
				int remainColor = maxColor - countColorCase2;
				if(remainColor == 0) {
					int mockForAddColor = i;
					for(int j = 0; j < len; j++) {
						if(j == mockForAddColor) {
							System.out.print(countColorCase2 + "" "");
						}else {
							System.out.print(0 + "" "");
						}
					}
					return;
				}
			}
			if (i >= 1) {
				int remainColor = maxColor - countColorCase2;
				if (remainColor > 0) {
					int mockForAddColor = 0;
					if (remainColor <= getMin.get(i + 1)) {
						mockForAddColor = i + 1;
						for (int j = 0; j < len; j++) {
							if (getMin.get(j) != 0 && j != mockForAddColor && j < mockForAddColor) {
								System.out.print(getMin.get(j) + "" "");
							} else if (j == mockForAddColor) {
								System.out.print(remainColor + "" "");
							} else {
								System.out.print(0 + "" "");
							}
						}
						return;
					}
				} else if (remainColor < 0) {
					int addColor = 0;
					int mockForAddColor = 0;
					if (getMin.get(i) > getMin.get(i + 1)) {
						mockForAddColor = i + 1;
						addColor = maxColor - getMin.get(i) - 1;
						for (int j = 0; j < len; j++) {
							if (j < mockForAddColor) {
								System.out.print(getMin.get(j) + "" "");
							} else if (j == mockForAddColor) {
								System.out.print(addColor + "" "");
							} else {
								System.out.print(1 + "" "");
							}
						}
						return;
					} else if (getMin.get(i) < getMin.get(i + 1)) {
						mockForAddColor = i;
						addColor = maxColor - getMin.get(i + 1) - 1;
						for (int j = 0; j < len; j++) {
							if (j == i) {
								System.out.print(addColor + "" "");
							} else if (j <= mockForAddColor + 1) {
								System.out.print(getMin.get(j) + "" "");
							} else {
								System.out.println(0 + "" "");
							}
						}
						return;
					}
				}
			}
		}
		System.",tonybuidn
1328,"public class Solution {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
		int n = scanner.nextInt();
        for (int i = 0; i < n; i++) {
            int N = scanner.nextInt();
            List<Node> rootList = new ArrayList<>();
            Node[] arr = new Node[N];
            for(int j=0; j<N; j++) {
                arr[j] = new Node(j+1, scanner.nextInt());
		    }
            for(int j=0; j<N; j++) {
                int p = scanner.nextInt();
                if(p==0) {
                    rootList.add(arr[j]);
                } else {
                    Node node = arr[p-1];
                    node.son.add(arr[j]);
                    arr[p-1] = node;
                }
            }
            int total = 0;
            for (int k=0; k<rootList.size(); k++) {
                total += dfs(rootList.get(k));
            }
            System.out.print(""Case #""+(i+1)+"": "");
            System.out.println(total);
       }
    }

    public static long dfs(Node node) {
        if(node.son.size()==0) {
            return node.value;
        }
        if(node.son.size()==1) {
            long maxV = Math.max(node.value, node.son.get(0).value);
            node.value = maxV;
            node.son = new ArrayList<>();
            return maxV;
        }
        int n = node.son.size();
        long[] arr = new long[n];
        int mini = -1;
        long minTotal = Long.MAX_VALUE;
        for (int i = 0; i < n; i++) {
            arr[i] = dfs(node.son.get(i));
            if(arr[i]<minTotal) {
                mini = i;
                minTotal = arr[i];
            }
        }
        arr[mini] = Math.max(arr[mini], node.value);
        long sum = 0;
        for (int i = 0; i < n; i++) {
            sum += arr[i];
        }
        node.value = sum;
        node.son = new ArrayList<>();
        return  sum;
    }

    static class Node {
        public long value;
        public int i;
        public List<Node> son;
        public Node(int i, long value) {
            this.i = i;
            this.value = value;
            son = ",xinyou
341,"class Test {

    public static void printOutput(int[] input) {
        int numOfRows = input[0] + input[0] + 1;
        for (int i = 0; i < numOfRows; i++) {
            if (i == 0) {
                System.out.print("".."");
                for (int j = 0; j < input[1] - 1; j++) {
                    System.out.print(""+-"");
                }
                System.out.print(""+"");
                System.out.println();
            } else if (i == 1) {
                System.out.print("".."");
                for (int j = 0; j < input[1] - 1; j++) {
                    System.out.print(""|."");
                }
                System.out.print(""|"");
                System.out.println();
            } else if (i % 2 == 0) {
                for (int j = 0; j < input[1]; j++) {
                    System.out.print(""+-"");
                }
                System.out.print(""+"");
                System.out.println();
            } else {
                for (int j = 0; j < input[1]; j++) {
                    System.out.print(""|."");
                }
                System.out.print(""|"");
                System.out.println();
            }
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[][] input = new int[n][2];
        for (int i = 0; i < n; i++) {
            input[i][0] = sc.nextInt();
            input[i][1] = sc.nextInt();
            // printOutput(input[i]);
        }
        for (int i = ",Roshan
934,"public class Solution {
    ///////////////////////////////////////////
    static boolean[] visited = null;
    static int N = 0;
    static Random random = new Random();

    private static void solve() {
        N = in.nextInt();
        int K = in.nextInt();
        visited = new boolean[N];
        Map<Integer, Integer> numEdges = new HashMap<>();

        T2<Integer, Integer> R_P = request();
        Integer r = R_P._1;
        Integer p = R_P._2;
        numEdges.put(r, p);

        while (K > 0) {
            if (numEdges.size() <= N) {
                int next = randomUnknown();
                R_P = teleport(next+1);
                numEdges.put(R_P._1, R_P._2);
            } else {
                break;
            }
            K--;
        }


        if (numEdges.size() >= N) {
            long sum = 0L;
            for (Map.Entry<Integer, Integer> entry: numEdges.entrySet()) {
                sum += entry.getValue();
            }
            estimate(sum / 2);

        } else {
            // calculate average
            int count = numEdges.size();
            float sum = 0.0f;
            for (Map.Entry<Integer, Integer> entry : numEdges.entrySet()) {
                sum += entry.getValue();
            }

            float avg = sum / count;
            int diff = N - count;
            sum += diff * avg;

            long response = (long) (sum  / 2.0);

            estimate(response);
        }
    }

    static int randomUnknown() {
        int steps = 0;
        int pointer = random.nextInt(N);
        while (steps < N) {
            if (!visited[pointer % N]) {
                return pointer % N;
            }
            pointer++;
            steps++;
        }
        return -1;
    }

    static T2<Integer, Integer> request() {
        int R = in.nextInt();
        if (R == -1) {
            throw new IllegalStateException(""Received R -1"");
        }
        visited[R-1] = true;
        int P = in.nextInt();
        if (P == -1) {
            throw new IllegalStateException(""Received P -1"");
        }
        return new T2<>(R, P);
    }
    static T2<Integer, Integer> walk() {
        out.println(""W"");
        out.flush();
        return request();
    }
    static T2<Integer, Integer> teleport (int S) {
        out.println(""T "" + S);
        out.flush();
        return request();
    }
    static void estimate(long P) {
        out.println(""E "" + P);
        out.flush();
    }

    private static Scanner in;
    private static PrintStream out;

    private static void run() throws Exception {
        in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        out = System.out;
        int t = in.nextInt();
        for (int i = 1; i <= t; i++) {
            solve();
        }
        in.close();
        out.close();
        System.exit(0);
    }

    public static void main(String[] args) throws Exception {
        run();
//        if (debug)
//            System.in.read();
    }

    static class T2<X, Y> {
        public final X _1;
        public final Y _2;
        T2(X _1, Y _2) {
            this._1 = _1;
            this._2 = _2;
        }
        @Override
        public String toString() ",levios
557,"public class Solution {
    static final int REL = 1;
    static final int NOLOG = 2;
    static final int TEST = 3;
    static int mode = REL;
    static PrintWriter pw;

    private static int max(int a, int b) {
        if(a >= b) { return a;} else {return b;}
    }

    private static int minIndex(int a, int b, int c) {
        if(a <= b && a <= c) {
            return 0;
        } else if(b <= a && b <= c) {
            return 1;
        } else {
            return 2;
        }
    }

    private static int min(int a, int b, int c) {
        if(a <= b && a <= c) {
            return a;
        } else if(b <= a && b <= c) {
            return b;
        } else {
            return c;
        }
    }

    public static boolean nextPermutation(List<Node> arr) {
        int len = arr.size();
        int left = len - 2;
        while (left >= 0 && arr.get(left).index >= arr.get(left+1).index) left--;
        if (left < 0) return false;
        int right = len - 1;
        while (arr.get(left).index >= arr.get(right).index) right--;
        {Node t = arr.get(left); arr.set(left, arr.get(right)); arr.set(right, t); }
        left++;
        right = len - 1;
        while (left < right) {
            { Node t = arr.get(left); arr.set(left, arr.get(right)); arr.set(right, t); }
          left++;
          right--;
        }
        return true;
      }

    private static class Node {
        int val;
        Node next = null;
        List<Node> pref = new ArrayList<>();
        boolean triggered = false;
        int index = 0;
        Node(int val, int index) {
            this.val = val;
            this.index = index;
        }
    }

    static int factCalculator(int n){
        if( n == 0 || n ==1){
            return 1;
        }
        else{
            return n * factCalculator(n-1); 
        }
    }

    private static void initList(List<Node> list) {
        for(Node node : list) {
            node.triggered = false;
        }
    }

    public static void main(String[] args) {
        Scanner in = getScanner();
        if(in == null) {
            log(""get scanner fail"");
            return;
        }
        long start = System.currentTimeMillis();
        
        try {
            int t = in.nextInt();
            log(""t:"" + t);
            for (int i = 1; i <= t; ++i) {
                int N = in.nextInt();
                List<Integer> F = new ArrayList<>();
                List<Integer> P = new ArrayList<>();
                for(int j = 0; j < N; ++j) {
                    F.add(in.nextInt());
                }
                for(int j = 0; j < N; ++j) {
                    P.add(in.nextInt());
                }
                log(""F:"", F);
                log(""P:"", P);
                List<Node> list = new ArrayList<>();
                for(int j = 0; j < N; ++j) {
                    list.add(new Node(F.get(j), j));
                }
                for(int j = 0; j < N; ++j) {
                    int nextIndex = P.get(j);
                    if(nextIndex > 0 && nextIndex < N) {
                        list.get(j).next = list.get(nextIndex - 1);
                        list.get(nextIndex - 1).pref.add(list.get(j));
                    }
                }
                F.clear(); F = null; P.clear(); P = null;
                
                // initiators
                List<Node> initiators = new ArrayList<>();
                for(Node node : list) {
                    if(node.pref.size() == 0) {
                        initiators.add(node);
//                        log(""initiator:"" + node.val);
                    }
                }

                int score = 0;
                do{
                    log(""***"");
                    int curScore = 0;
                    for(Node node : initiators) {
                        Node cur = node;
                        int maxScore = 0;
                        while(cur != null) {
                            if(!cur.triggered && cur.val >= maxScore) {
                                maxScore = cur.val;
                            }
                            if(cur.triggered) {
                                break;
                            }
                            cur.triggered = true;
                            cur = cur.next;
                        }
                        curScore += maxScore;
                        log(""initiator:"" + node.val + "" score:"" + curScore);
                    }
                    log(""score:"" + curScore);
                    if(curScore > score) {
                        score = curScore;
                        log(""update"");
                    }
                    initList(list);
                }while(nextPermutation(initiators));

                System.out.println(""Case #"" + i + "": "" + score);
            }
            in.close();
        }catch(Exception e) {
            log(e + "" "" + e.getMessage());
        }

        if(mode != REL) {
            log(""time:"" + (System.currentTimeMillis() - start));
            pw.close();
            test();
        }
    }

    private static void test() {
    }

    private static void log(String msg) {
        if(mode == TEST) {
            System.out.print(""[log]"");
            System.out.println(msg);
            pw.println(msg);
        }
    }
    private static void log(List<Integer> list) {
        log("""", list);
    }
    private static void log(String msg, List<Integer> list) {
        if(mode == TEST) {
            System.out.print(""[log]"" + msg);
            for(Integer a : list) {
                System.out.print(a + "" "");
            }
            System.out.println("""");
        }
    }

    private static Scanner getScanner() {
        BufferedReader br;
        if(mode == REL) {
            br = new BufferedReader(new InputStreamReader(System.in));
        } else {
            try {
                br = new BufferedReader(
                    new InputStreamReader(new FileInputStream(""C:\\\\\Users\\	akafumi\\\Desktop\\\Java\\\codejam2022\\	est.txt""), ""UTF-8""));
                    FileWriter file = new FileWriter(""C:\\\\\Users\\	akafumi\\\Desktop\\\Java\\\codejam2022\\\out.txt"", false);
                    pw = new PrintWriter(new BufferedWriter(file));
           } catch(Exception e) ",azzurri992
917,"public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        int cases = Integer.parseInt(in.readLine());
        for (int i = 1; i <= cases; i++) {
            System.out.println(""11010100"");
            boolean done = false;
            while (!done) {
                switch(Integer.parseInt(in.readLine())) {
                    case 0:
                        done = true;
                        break;
                    case 1:
                        System.out.println(""10000000"");
                        break;
                    case 2:
                        System.out.println(""11000000"");
                        break;
                    case 3:
                        System.out.println(""11100000"");
                        break;
                    case 4:
                        System.out.println(""11110000"");
                        break;
                    case 5:
                        System.out.println(""11111000"");
                        break;
                    case 6:
                        System.out.println(""11111100"");
                        break;
                    case 7:
                        System.out.println(""11111110"");
                        break;
                    case 8:
                        System.",lavikj
955,"public class Solution {

	public static void main(String[] args) {
		Scanner s = new Scanner(System.in);
		int i, j, k, l, m, n, t, diferenca, temp;
		int p1[] = new int[4];
		int p2[] = new int[4];
		int p3[] = new int[4];
		int saida[] = new int[4];
		int saida2[] = new int[4];

		
		do {
			t = s.nextInt();
		} while(t < 1 || t > 100);
		
		for(i = 1; i <= t; i++) { //casos
			l = 0;
			
				for(k = 0; k < 4; k++) { // 1 impressora
					do {
						p1[k] = s.nextInt();
						
					} while(p1[k] < 0 || p1[k] > (int) Math.pow(10, 6));
				}
				
				for(k = 0; k < 4; k++) { // 2 impressora
					do {
						p2[k] = s.nextInt();
						
					} while(p2[k] < 0 || p2[k] > (int) Math.pow(10, 6));
				}
				
				for(k = 0; k < 4; k++) { // 3 impressora
 					do {
						p3[k] = s.nextInt();
						
					} while(p3[k] < 0 || p3[k] > (int) Math.pow(10, 6));
				}
			
			for(j = 0; j < 4; j++) { // cada impressora
				
				if(p1[j] >= p2[j] & p1[j] >= p3[j]) { // o maior
					saida[l] = p1[j];
				} else if(p2[j] >= p3[j]) {
					saida[l] = p2[j];
				} else {
					saida[l] = p3[j];
				}
				
				if(p1[j] == 0) // o 1 eh zero
					if(p2[j] >= p3[j])
						saida[l] = p2[j];
					else
						saida[l] = p3[j];
				
				if(p2[j] == 0) // o 2 eh zero
					if(p1[j] >= p3[j])
						saida[l] = p1[j];
					else
						saida[l] = p3[j];
				
				if(p3[j] == 0) // o 3 eh zero
					if(p1[j] >= p2[j])
						saida[l] = p1[j];
					else
						saida[l] = p2[j];
				
				if(p1[j] == 0 && p2[j] == 0) // 1 e 2 sao zero
					saida[l] = p3[j];
				
				if(p2[j] == 0 && p3[j] == 0) // 2 e 3 sao zero
					saida[l] = p1[j];
				
				if(p1[j] == 0 && p3[j] == 0) // 1 e 3 sao zero
					saida[l] = p2[j];
				
				l++;
			}
			
			n = 0;
			
			for(j = 0; j < 4; j++) { // soma de cada impressora
				saida2[j] += p1[j] + p2[j] + p3[j];
			}

			l = 0;
			System.out.print(""Case #"" + i + "": "");
			
			if((saida2[0] + saida2[1] + saida2[2] + saida2[3]) >=  3 * Math.pow(10, 6)) {
				diferenca = saida2[0] + saida2[1] + saida2[2] + saida2[3] - 3*10*10*10*10*10*10;
				
				for(j = 0; j < 4; j++) { // cada impressora
					while(saida2[j] > 0 && diferenca > 0) {
						saida2[j]--;
						diferenca--;
							
						if(saida2[j] == 0)
							break;
					}
				}
				
				for(j = 0; j < 4; j++) {
					if(j == 0) {
						temp = saida2[j];
						saida2[j] = (int) saida2[j] / 3;
						saida2[j] += temp % 3;
					} else {
						saida2[j] = (int) saida2[j] / 3;
					}
				}
				
				System.out.print(saida2[0] + "" "" + saida2[1] + "" "" + saida2[2] + "" "" + saida2[3]);
			} else {
				System.out.print(""IMPOSSIBLE"");
			}
			
			if(i != 1)
				System.",marcosph
847,"class Solution{
    public static void main(String[] args){
        Scanner s = new Scanner(System.in);
        int t = s.nextInt();
        int x = t;
        while(t>0){
            System.out.print(""Case #""+(x-(t-1))+"":"");
            int a1 = s.nextInt();
            int a2 = s.nextInt();
            int a3 = s.nextInt();
            int a4 = s.nextInt();
            int b1 = s.nextInt();
            int b2 = s.nextInt();
            int b3 = s.nextInt();
            int b4 = s.nextInt();
            int c1 = s.nextInt();
            int c2 = s.nextInt();
            int c3 = s.nextInt();
            int c4 = s.nextInt();
            int min1 = Math.min(a1, Math.min(b1, c1));
            int min2 = Math.min(a2, Math.min(b3, c2));
            int min3 = Math.min(a3, Math.min(b3, c3));
            int min4 = Math.min(a4, Math.min(b4, c4));
            if(min1+min2+min3+min4 <1000000){
                System.out.print("" IMPOSSIBLE"");
                System.out.println();
            }
            else{
                int twoSum = min1+min2;
                int rem = 1000000 - twoSum;
                int c  = 0;
                int d = 0;
                if(min3<rem && min4<rem){
                    c = min3;
                    d = min4;
                }
                else if(min3>rem){
                    c= min3-rem;
                    d = 1000000 -(c+twoSum);
                }
                else if(min4>rem){
                    d = min4-rem;
                    c = 1000000 -(d+twoSum);
                }
                System.out.print("" ""+min1);
                System.out.print("" ""+min2);
                System.out.print("" ""+c);
                System.out.print("" ""+d);
                System.",kaushik_0705
392,"class Solution{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while(T-- > 0){
            int[] in = new int[2];
            for(int i=0;i<2;i++){
                in[i]=sc.nextInt();
            }
            int row = 2*in[0]+1;
            int column= 2*in[1]+1;
            String s1="""";
            String s2="""";
            String s3="""";
            String s4="""";
            for(int j=0;j<column;j++){
                if(j<=1){
                    s1+=""."";
                    s2+=""."";
                }
                else{
                    if(j%2==0){
                        s1+=""+"";
                        s2+=""|"";
                    }
                    else{
                        s1+=""-"";
                        s2+=""."";
                    }
                }
            }
            for(int j=0;j<column;j++){
                if(j%2==0){
                    s3+=""+"";
                    s4+=""|"";
                }
                else{
                    s3+=""-"";
                    s4+=""."";
                }
                
            }
            for(int i=0;i<row;i++){
                if(i==0){
                    System.out.println(s1);
                }
                else if(i==1){
                    System.out.println(s2);
                }
                else{
                    if(i%2==0){
                        System.out.println(s3);
                    }
                    else{
                        System.",Sujit_Das
114,"class Solution{
    public static void main(String[] args){
        Scanner s = new Scanner(System.in);
        int t= s.nextInt();
        for(int i =1;i<=t;i++){
            int r = s.nextInt();
            int c= s.nextInt();
            System.out.println(""Case #""+i+"":"");
            printPattern(r,c);
        }
        //return;
    }
    public static void printPattern(int r , int c){
        for(int i =0 ;i< r;i++){
            for(int j =0; j<c ;j++){
                if(i==0 && j==0){
                    System.out.print("".."");
                    j++;
                }
                System.out.print(""+-"");
            }
            System.out.print(""+"");
            System.out.println();
            for(int j =0 ;j<c;j++){
               if(i==0&& j==0){
                  System.out.print("".."");
                  j++;
               }
               System.out.print(""|."");
            }
            System.out.print(""|"");
            System.out.println();
        }
        for(int el=",Dyeahhh
54,"public class Solution
{
	public static void main(String[] args) {
		Scanner input=new Scanner(System.in);
		int t=input.nextInt();
		for(int k=0;k<t;k++)
		{
		    String a=input.next();
		    int arr[]=new int[a.length()];
		    for(int i=0;i<a.length();i++)
		    {
		        arr[i]=(int)a.charAt(i);
		    }
		    HashSet<Integer> hs=new HashSet<>();
		    for(int i=0;i<arr.length;i++)
		    {
		        hs.add(arr[i]);
		    }
		    System.out.print(""Case #""+(k+1)+"": "");
		    if(hs.size()<=1)
		    {
		        System.out.print(a);
		    }
		    else
		    {
		      //  for(int i=0;i<arr.length;i++)
    		  //  {
    		  //      System.out.print(arr[i]+"" "");
    		  //  }
    		    String res="""";
    		    int c=0;
    		    for(int i=0;i<arr.length-1;i++)
    		    {
    		        if((arr[i+1])>=arr[i])
    		        {
    		            res+=(char)arr[i];//+(char)arr[i];
    		            res+=(char)arr[i];
    		        }
    		        else
    		        {
    		            res+=(char)arr[i];
    		        }
    		        
    		    }
    		    if(res.compareTo(a)<0)
    		        {
    		            System.out.print(res);
    		            c++;
    		        }
    		        else
    		        {
    		            System.out.print(a);
    		        }
    		    if(c>0)
    		    {
    		        System.out.print((char)arr[arr.length-1]);
    		    }
    		    //System.out.print(res+""
"");
		    }
		    if(k!=t-1)
    		{
                System.out.println();
    	    }
		}
	}
}
",AniketTewari
116,"class Solution{
    public static Scanner s= new Scanner(System.in);
    public static void main(String[] args){
        int t= s.nextInt();
        for(int i=1;i<=t;i++){
            int n= s.nextInt();
            System.out.println(""Case #""+i+"": ""+ ans(n));
        }
    }
    public static int ans(int n){
        PriorityQueue<Integer> pq= new PriorityQueue<>();
        for(int i =0 ; i< n;i++){
            int x= s.nextInt();
            pq.add(x); 
        }
        int l=0;
        while(!pq.isEmpty()){
            int temp = pq.poll();
            if(l<=temp){
                l++;
            }
            else",Dyeahhh
241,"public class Solution{

    public static void main(String[] args){
int r=0;
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int sum=1000000;
        int T = in.nextInt();
        for (int i=1; i<=T; i++){
           
            int [] C=new int[3];
            int [] M=new int[3];
            int [] Y=new int[3];
            int [] B=new int[3];
            int [] R=new int[4];
        int j=0;
            while (j<3)
          {
           C[j]=in.nextInt();
            M[j]=in.nextInt();
            Y[j]=in.nextInt();
            B[j]=in.nextInt();
          j++;
            }
            Arrays.sort(C);
            Arrays.sort(M);
            Arrays.sort(Y);
            Arrays.sort(B);
         if(C[0]+M[0]+Y[0]+B[0]==sum)
         {r=0;
             R[0]=C[0];
         R[1]=M[0];
         R[2]=Y[0];
         R[3]=B[0];
         }
         else  if(C[0]+M[0]+Y[0]+B[0]<sum)
         {                    System.out.println(""Case #"" + i + "": "" + ""IMPOSSIBLE"");
r=1;
         }
         else {r=0;
         if(C[0]<sum)
         {
         R[0]=C[0];
         sum=sum-R[0];}
         else if (C[0]>sum)
         {R[0]=sum;
         sum=0;
         }
         if(M[0]<sum)
         {
         R[1]=M[0];
         sum=sum-R[1];
      
         
         }
         else if(M[0]>=sum)
         {R[1]=sum;
         R[2]=0;
       R[3]=0;
         sum=0;
         }
            if(Y[0]<sum)
         {  R[2]=Y[0];
         sum=sum-R[2];
         }
         else if(Y[0]>=sum)
         {R[2]=sum;
         R[3]=0;
   
         sum=0;
         }
               if(B[0]<sum)
         {  R[3]=B[0];
         sum=sum-R[3];
         }
         else if(B[0]>=sum)
         {R[3]=sum;
         
   
         sum=0;
         }
            
            
             
            }
            
         if(r==0)
         {
            System.out.println(""Case #"" + i + "": ""+R[0]+"" ""+R[1]+"" ""+R[2]+"" ""+R[3]+"" "");}
        }     
            
       
        
        in.",Marwan
139,"public class Solution { //Solution
	static int INF = (int)(1e9);
	static long mod = (long)(1e9)+7;
	static long mod2 = 998244353;
	static long[] segtree;
	static char[] curans;
	static long ans;	
	static String S;
	static ArrayList<Integer>[] graph;
	static boolean[] vis;
	static int[] a;
	static int N;
	static long K;
	static long[] fact;
	static ArrayList<Long> pos;
	static ArrayList<Long> neg;
	static long[] max;
	static int[] dp;
	static long mx;
	static long[] fun;
	public static void main(String[] args) {  //Cash out
		/**/
		FastScanner I = new FastScanner(); //Input
		OutPut O = new OutPut(); //Output
		
		int T = I.nextInt();
		
		for (int i = 1; i <= T; i++) {
			int N = I.nextInt();
			long ans = 0;
			
			long[][] fun = new long[N + 1][2];
			long[] fun_factor = new long[N + 1];
			ArrayList<Integer>[] g = new ArrayList[N + 1];
			ArrayList<Integer>[] g_recieve = new ArrayList[N + 1];
			g_recieve[0] = new ArrayList<Integer>();
			
			for (int j = 1; j <= N; j++) {
				fun[j][0] = I.nextLong();
				fun[j][1] = j;
				fun_factor[j] = fun[j][0];
				
				g[j] = new ArrayList<Integer>();
				g_recieve[j] = new ArrayList<Integer>();
			}
			
			for (int j = 1; j <= N; j++) {
				int nbr = I.nextInt();
				g[j].add(nbr);
				g_recieve[nbr].add(j);
			}
			
			int num_roots = 0;
			boolean[] root = new boolean[N + 1];
			
			for (int j = 1; j <= N; j++) {
				num_roots += g_recieve[j].size() == 0? 1 : 0;
				root[j] = true;
			}
			
			Arrays.sort(fun, (a, b) -> Long.compare(a[0], b[0]));
			long lower_bound = Long.MAX_VALUE;
			
			for (int j = N; j > N - num_roots; j--) {
				ans += fun[j][0];
				lower_bound = Math.min(lower_bound, fun[j][0]);
			}
			
			int next_idx = N - num_roots;
			for (int j = 1; j <= N; j++) {
				boolean all_roots_nbrs = true;
				long cur_min = Long.MAX_VALUE;
				
				for (int k = 0; k < g_recieve[j].size(); k++) {
					int nbr = g_recieve[j].get(k);
					all_roots_nbrs &= root[nbr];
					cur_min = Math.min(cur_min, fun_factor[nbr]);
				}
				
				if (g_recieve[j].size() > 0) {
					if (all_roots_nbrs && cur_min >= lower_bound && 
						fun_factor[j] >= lower_bound) {
						
						ans -= cur_min;
						ans += fun[next_idx][0];
						lower_bound = fun[next_idx][0];
						next_idx--;
					}
				}
			}
			
			/*Subtraction fun here most likely with common root neighbors and indexing needed*/
			
			O.pln(""Case #"" + i + "": "" + ans);
		}
		
	}
	
	public static void DFS(int start) {
		if (start == 0) {
			return;
		}
		
		vis[start] = true;
		mx = Math.max(mx, fun[start]);
		int next = graph[start].get(0); // We only ever point to one node at a time
		if (vis[next]) {
			return;
		}
		
		DFS(next);
	}
	
	public static long C(int N, int K) {
		long ans = fact[N];
		ans *= FastExp(fact[K], mod - 2);
		ans %= mod;
		
		ans *= FastExp(fact[N - K], mod - 2);
		ans %= mod;
		
		return ans;
	}
	
	
	public static double[][] matrix_exp(double[][] a, long exp, long mod) {
		int R = a.length;
		int C = a[0].length;
		double[][] ans = new double[R][C];
		
		boolean mult_yet = false;
		
		while (exp > 0) {
			if (exp % 2 == 1) {
				if (!mult_yet) {
					mult_yet = true;
					for (int i = 0; i < R; i++) {
						for (int j = 0; j < C; j++) {
							ans[i][j] = a[i][j]; 
						}
					}
				}else {
					double[][] new_ans = mult(ans, a, mod);
					for (int i = 0; i < R; i++) {
						for (int j = 0; j < C; j++) {
							ans[i][j] = new_ans[i][j]; 
						}
					}
				}
			}
			
			double[][] new_a = mult(a, a, mod); // a = a^2 (binary exponentiation on matrices)
			for (int i = 0; i < R; i++) {
				for (int j = 0; j < C; j++) {
					a[i][j] = new_a[i][j]; 
				}
			}
			exp /= 2;
		}
		
		return ans;
	}
	public static double[][] mult(double[][] a, double[][] b, long mod) {
		int r1 = a.length;
		int c1 = a[0].length;
		int r2 = b.length;
		int c2 = b[0].length;
		//Requires: c1 = r2
		
		double[][] ans = new double[r1][c2];
		for (int r = 0; r < r1; r++) {
			for (int c = 0; c < c2; c++) {
				//Dot product of (a[r])^T and b[c] (as vectors in R^n (n = c1 = r2))
				double[] col_vector = new double[r2];
				double[] row_vector = new double[c1];
				
				for (int i = 0; i < r2; i++) {
					col_vector[i] = b[i][c];
				}
				for (int i = 0; i < c1; i++) {
					row_vector[i] = a[r][i]; 
				}
				
				ans[r][c] = dot_product(row_vector, col_vector, mod);
			}
		}
		return ans;
	}
	
	public static double dot_product(double[] a, double[] b, long mod) {
		double ans = 0;
		int N = a.length; //Requires: a and b are both vectors in R^n
		for (int i = 0; i < N; i++) {
			ans += a[i] * b[i];
		}
		return ans;
	}
	public static double max(double a, double b) {return Math.max(a, b);}
	public static double min(double a, double b) {return Math.min(a, b);}
	public static long min(long a, long b) {return Math.min(a,b);}
	public static long max(long a, long b) {return Math.max(a,b);}
	public static int min(int a, int b) {return Math.min(a,b);}
	public static int max(int a, int b) {return Math.max(a,b);}
	public static long abs(long x) {return Math.abs(x);}
	public static long abs(int x) {return Math.abs(x);}
	public static long ceil(long num, long den) {long ans = num/den; if (num%den!=0) 
	ans++; return ans;}
	public static long GCD(long a, long b) {
		if (a==0||b==0) return max(a,b);
		return GCD(min(a,b),max(a,b)%min(a,b));
	}
	public static long FastExp(long base, long exp) {
		long ans=1;
		while (exp>0) {
			if (exp%2==1) ans*=base;
			exp/=2;
			base*=base;
			base%=mod;
			ans%=mod;
		}
		return ans;
	}
	public static long ModInv(long num,long mod) {return FastExp(num,mod-2);}
	public static int pop(long x) { //Returns number of bits within a number
		int cnt = 0;
		while (x>0) {
			if (x%2==1) cnt++;
			x/=2;
		}
		return cnt;
	}
	static class FastScanner {
		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st=new StringTokenizer("""");
		String next() {
			while (!st.hasMoreTokens())
				try {
					st=new StringTokenizer(br.readLine());
				} catch (IOException e) {
					e.printStackTrace();
				}
			return st.",IQEmperor
250,"public class Solution{

    public static void main(String[] args){

        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
       
        int T = in.nextInt();
        int count=0;
        int i=1;
     while(i<=T){
            int nopan=in.nextInt();
         int x[]=new int[nopan+1];
            for(int j=0;i<=nopan;i++)
            {x[j]=in.nextInt();
            }
      for(int j=0;j<=nopan;j++)
            {if(nopan==1)
            {    count=1;
                    break;}
                    else
   {
                    if(x[j]<=x[nopan-1])
                            {count ++;
                            }
                    else if (x[j]>=x[nopan-1] && nopan>i)
                            {count ++;
                            nopan=nopan-1;
                            }
                            }
                            
            }
            
            
   i++;  }
     
           System.out.println(""Case #"" + i + "": ""+count);
                
        in.",Marwan
1024,"public class Solution {

    public static void main(String... args) {
        Scanner sc = new Scanner(System.in);
        int count = sc.nextInt();
        for (int i = 0; i < count; i++) {
            int size = sc.nextInt();
            Deque<Integer> pancakes = new LinkedList<>();
            for (int j = 0; j < size; j++) {
                pancakes.add(sc.nextInt());
            }
            System.out.println(""Case #"" + (i + 1) + "": "" + count(pancakes));
        }
    }

    public static int count(Deque<Integer> pancakes) {
        int prev = -1;
        int result = 0;
        throw new IllegalArgumentException("""" + pancakes);
        while(true) {
            if (pancakes.isEmpty()) {
                break;
            }
            int left = pancakes.getFirst();
            int right = pancakes.getLast();
            boolean leftValid = left >= prev;
            boolean rightValid = right >= prev;
            boolean takeLeft = left <= right;
            if (!leftValid && !rightValid) {
                break;
            }
            result++;
            int current = -1;
            if (leftValid && rightValid) {
                if (left < right) {
                    current = pancakes.getFirst();
                    pancakes.removeFirst();
                } else {
                    current = pancakes.getLast();
                    pancakes.removeLast();
                }
            }else if (leftValid) {
                current = pancakes.getFirst();
                pancakes.removeFirst();
            }else {
                current = pancakes.getLast();
                pancakes.removeLast();
            }
            
            prev = ",petrus
171,"public class Solution {

    public void solve(Scanner scanner) {
        int n = scanner.nextInt();
        int k = scanner.nextInt();
        int[] nums = new int[n];
        for (int i = 0; i < n; i++) {
            nums[i] = scanner.nextInt();
        }
        if (nums.length == 1 && nums[0] == 0) {
            System.out.println(""0"");
            return;
        }
        int sum = Arrays.stream(nums).sum();
        int squaredSum = Arrays.stream(nums)
                .map(i -> i * i)
                .sum();
        if (sum == 0) {
            System.out.println(""IMPOSSIBLE"");
        } else {
            int x = (squaredSum - (sum * sum)) / (2 * sum);
            System.out.println(x);
        }
    }

    public static void main(String[] args) throws Exception {
        Scanner scan = new Scanner(System.in);
        int problems = scan.nextInt();
        for (int count = ",KatieSanderson
367,"class Solution
{
    public static void main(String[] args) {
        Scanner in=new Scanner(System.in);
        int t=in.nextInt();
    
       for(int ca=1;ca<=t;ca++)
        {
            int n=in.nextInt();
            long arr[]=new long[n];
            for(int i=0;i<n;i++)
            {
                arr[i]=in.nextLong();
            }
            solve(arr,ca);
        }
    }

      static void solve( long arr[],int ca) {
           long max=0,count=0;
           for(int i=0;i<arr.length;i++)
           {
              
            for(int j=i;j<arr.length;j++)
            {
                for(int k=i;k<=j;k++)
                {

                
                if(arr[k]>count)
                {
                    count++;
                }
                 else if(arr[k]<count)
                {
                    break;
                }
              }
              max=Math.max(max,count);
              count=0;

            }
            
           
               
            }
            max=Math.max(max,count);
            count=0;
            for(int i=arr.length-1;i>=0;i--)
            {
               
             for(int j=i;j>=0;j--)
             {
                for(int k=i;k>=j;k--)
                {

                
                if(arr[k]>count)
                {
                    count++;
                }
                 else if(arr[k]<count)
                {
                    break;
                }
              }
              max=Math.max(max,count);
              count=0;
 
             }
             max=Math.max(max,count);
             count=0;
                
             }
             max=",SampathRajaRaghupathi
468,"public class Solution {

    public static void main(String[] args) {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        try {
            int T = Integer.parseInt(br.readLine());
            for (int ti = 1; ti <= T; ti++) {
                int N = Integer.parseInt(br.readLine());
                int[] s = new int[N];
                String[] temp = br.readLine().split("" "");
                for (int i = 0; i < N; i++) {
                    s[i] = Integer.parseInt(temp[i]);
                }
                System.out.println(""Case #"" + ti + "": "" + solve(N, s));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    public static int solve(int N, int[] s) {
        Arrays.sort(s);

        int l = 0;
        for (int i = 0, x = 1; i < N; i++) {
            if (x <= s[i]) {
                l++;
                x++;
            }
        }

        return l;
    }
}",absee
1183,"public class Solution {
    public static void main(String[] args) throws IOException {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt();
        for(int i = 1; i <= t; ++i){
            int n = scanner.nextInt();
            BigInteger values[] = new BigInteger[n];
            int links[] = new int[n];
            for(int j = 0; j < n; ++ j){
                values[j] = scanner.nextBigInteger();
            }
            for(int j = 0; j < n; ++ j){
                links[j] = scanner.nextInt() - 1;
            }
            System.out.println(String.format(""Case #%d: %s"",i,solve(values,links,n).toString()));
        }
    }

    public static BigInteger solve(BigInteger[] values, int[] links, int n){
        Node[] nodes = new Node[n];
        Node abyss = new Node(BigInteger.ZERO);
        for(int i = 0; i < n; ++i){
            nodes[i] = new Node(values[i]);
        }
        for(int i = 0; i < n; ++i){
            if(links[i] == -1){
                abyss.initiators.add(nodes[i]);
                nodes[i].next = abyss;
            }else{
                nodes[links[i]].initiators.add(nodes[i]);
                nodes[i].next = nodes[links[i]];
            }
        }
        Arrays.stream(nodes)
                .filter(nd -> nd.initiators.size()==1)
                .forEach(nd -> {
                    Node p = nd.initiators.get(0);
                    nd.val = nd.val.max(p.val);
                    nd.initiators = p.initiators;
                } );
        List<Node> a = new ArrayList<>(abyss.initiators);
        a.forEach(nd -> nd.normalize(abyss));
        return abyss.initiators.stream().map(nd -> nd.val).reduce(BigInteger::add).orElse(BigInteger.ZERO);
    }

    public static class Node implements Comparable<Node>{
        public BigInteger val;
        public List<Node> initiators;
        public Node next;

        public Node(BigInteger v){
            val = v;
            initiators = new ArrayList<>();
        }

        public void normalize(Node abyss){
            if(!initiators.isEmpty()) {
                initiators.forEach(node -> node.normalize(abyss));
                initiators.sort(Comparator.naturalOrder());
                val = val.max(initiators.get(0).val);
                int n = initiators.size();
                for(int i = 1; i < n; ++i){
                    abyss.initiators.add(initiators.remove(1));
                }
            }
        }

        @Override
        public int compareTo(Node o) {
            return val.",smartelf
1301,"class Solution {

  public static void main(String args[]) {
    //        test();
    scan();
  }

  static int R;
  static int C;
  static int MAX = 1000000;

  public static void scan() {
    Scanner in = new Scanner(System.in);
    int T = in.nextInt();
    for (int round = 0; round < T; round++) {
      int[] printers = {MAX,MAX,MAX,MAX};
      for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 4; j++) {
          printers[i] = Math.min(MAX, in.nextInt());
        }
      }

      String result = findBest(printers);

      System.out.println(""Case #"" + (round + 1) + "": "" + result);
    }
  }

  private static String findBest(int[] solution) {
    int sum = 0;
    for (int i = 0; i < 4; i++) {
      if (sum + solution[i] > MAX) {
        solution[i] = MAX - sum;
        if (solution[i] < 0) {
          solution[i] = 0;
        }
      }
      sum += solution[i];
      
    }
    if (sum == MAX) {
      return Arrays.stream(solution)
          .mapToObj(i -> Integer.toString(i))
          .collect(Collectors.joining("" ""));
    }
    return ""IMPOSSIBLE"";

  }

  public static void test() ",wala
1236,"public class Solution {

  // Template
  public static void main(String[] args) throws Exception {
    final InputReader in = new InputReader(System.in);
    final OutputWriter out = new OutputWriter(System.out);
    Locale.setDefault(Locale.US);
    int T = in.readInt();
    for (int t = 1; t <= T; t++) {
      // read
      int N = in.readInt();
      int[] cost = new int[N + 1];
      for (int i = 1; i <= N; i++) {
        cost[i] = in.readInt();
      }
      int[] parent = new int[N + 1];
      parent[0] = -1;
      int[] childCount = new int[N + 1];
      for (int i = 1; i <= N; i++) {
        parent[i] = in.readInt();
        childCount[parent[i]]++;
      }
      int[][] graph = new int[N + 1][];
      var leafs = new LinkedList<Integer>();
      for (int i = 0; i <= N; i++) {
        if (i > 0 && childCount[i] == 0) {
          leafs.add(i);
        }
        graph[i] = new int[childCount[i]];
      }
      for (int i = 1; i <= N; i++) {
        graph[parent[i]][--childCount[parent[i]]] = i;
      }
      // calc sol
      var todo = new LinkedList<>(leafs);
      int[] min = new int[N + 1];
      for (int i = 0; i <= N; i++) {
        min[i] = i;
      }

      while (!todo.isEmpty()) {
        var cur = todo.pollFirst();
        var par = parent[cur];
        if (par < 1) {
          continue;
        }
        if (min[par] == par || cost[min[par]] > cost[min[cur]]) {
          min[par] = min[cur];
        }
        if (++childCount[par] == graph[par].length) {
          todo.add(par);
          if (cost[par] > cost[min[par]]) {
            cost[min[par]] = cost[par];
          }
        }
      }

      int res = leafs.stream().mapToInt(i -> cost[i]).sum();

      // print
      out.printLine(nthcase(t) + "" "" + res);
    }
    out.close();
  }

  static String nthcase(int t) {
    return ""Case #"" + t + "":"";
  }

  static class InputReader {
    private InputStream stream;
    private byte[] buf = new byte[1024];
    private int curChar;
    private int numChars;

    public InputReader(InputStream stream) {
      this.stream = stream;
    }

    public int read() {
      if (numChars == -1) throw new InputMismatchException();
      if (curChar >= numChars) {
        curChar = 0;
        try {
          numChars = stream.read(buf);
        } catch (IOException e) {
          throw new InputMismatchException();
        }
        if (numChars <= 0) return -1;
      }
      return buf[curChar++];
    }

    public char readChar() {
      int c = read();
      while (isSpaceChar(c)) c = read();
      return (char) c;
    }

    public String readLine() {
      int c = read();
      while (isSpaceChar(c)) c = read();
      StringBuilder res = new StringBuilder();
      do {
        res.appendCodePoint(c);
        c = read();
      } while (!isEndOfLine(c));
      return res.toString();
    }

    public String readString() {
      int c = read();
      while (isSpaceChar(c)) c = read();
      StringBuilder res = new StringBuilder();
      do {
        res.appendCodePoint(c);
        c = read();
      } while (!isSpaceChar(c));
      return res.toString();
    }

    public long readLong() {
      int c = read();
      while (isSpaceChar(c)) c = read();
      int sgn = 1;
      if (c == '-') {
        sgn = -1;
        c = read();
      }
      long res = 0;
      do {
        if (c < '0' || c > '9') throw new InputMismatchException();
        res *= 10;
        res += c - '0';
        c = read();
      } while (!isSpaceChar(c));
      return res * sgn;
    }

    public int readInt() {
      int c = read();
      while (isSpaceChar(c)) c = read();
      int sgn = 1;
      if (c == '-') {
        sgn = -1;
        c = read();
      }
      int res = 0;
      do {
        if (c < '0' || c > '9') throw new InputMismatchException();
        res *= 10;
        res += c - '0';
        c = read();
      } while (!isSpaceChar(c));
      return res * sgn;
    }

    public boolean isSpaceChar(int c) {
      return c == ' ' || c == '
' || c == '\r' || c == '	' || c == -1;
    }

    public boolean isEndOfLine(int c) {
      return c == '
' || c == '\r' || c == -1;
    }
  }

  static class OutputWriter {
    private final PrintWriter writer;

    public OutputWriter(OutputStream outputStream) {
      writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
    }

    public OutputWriter(Writer writer) {
      this.writer = new PrintWriter(writer);
    }

    public void print(Object... objects) {
      for (int i = 0; i < objects.length; i++) {
        if (i != 0) writer.print(' ');
        writer.print(objects[i]);
      }
    }

    public void printLine(Object... objects) {
      print(objects);
      writer.println();
    }

    public void flush() {
      writer.flush();
    }
",thesamwiser
516,"public class Solution{

    static long MOD = 1_000_000_007L;
    //static long MOD = 998_244_353L;
    //static long MOD = 1_000_000_033L;
    static long inv2 = (MOD + 1) / 2;
    static long [] fac;
    static long [] pow;
    static long [] inv;
    static long [] invFac;
    static int[][] dir = new int[][]{{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
    static long lMax = 0x3f3f3f3f3f3f3f3fL;
    static int iMax = 0x3f3f3f3f;
    static HashMap <Long, Long> memo = new HashMap();
    static MyScanner sc = new MyScanner();
    //static ArrayList <Integer> primes;

    static long[] pow2;
    static int[] base;
    static int[] numOfDiv;
    static ArrayList <Integer> primes;
    //-----------PrintWriter for faster output---------------------------------
    public static PrintWriter out;
    public static void main(String[] args) {
        out = new PrintWriter(new BufferedOutputStream(System.out));
        // Start writing your solution here. -------------------------------------

        int nn = 300000;

        /*fac = new long[nn + 1];
        fac[1] = 1;
        for(int i = 2; i <= nn; i++)
            fac[i] = fac[i - 1] * 1L * i % MOD;*/

        /*pow = new long[nn + 1];
        pow[0] = 1L;
        for(int i = 1; i <= nn; i++)
            pow[i] = pow[i - 1] * 2L % MOD;
        pow[1] = 3L;*/

        /*
        pow2 = new long[nn + 1];
        pow2[0] = 1L;
        for(int i = 1; i <= nn; i++)
            pow2[i] = pow2[i - 1] * 2L;*/

        /*inv = new long[nn + 1];
        inv[1] = 1;
        for (int i = 2; i <= nn; ++i)
            inv[i] = (MOD - MOD / i) * inv[(int)(MOD % i)] % MOD;

        invFac = new long[nn + 1];
        invFac[1] = 1;
        for(int i = 2; i <= nn; i++)
            invFac[i] = invFac[i - 1] * inv[i] % MOD;*/

        //primes = sieveOfEratosthenes(100001);


        /*for(int i = 2; i <= 20000000; i++)
            if(numOfDiv[i] == 0)
                for(int j = i; j <= 20000000; j += i)
                    numOfDiv[j] ++;*/

        int t = 1, tt = 0;
        t = sc.ni();
        while(tt++ < t) {
            //long res = solve();
            //out.print(""Case #"" + tt + "": "");
            solve();
            //out.println(res);
        }
        out.close();
    }
    static void solve() {
        int N = sc.ni(), K = sc.ni();
        int pos = sc.ni(), cnt = sc.ni();
        long sum = cnt;
        int rand_int = pos;
        SecureRandom rand = new SecureRandom();
        rand = SecureRandom.getInstance(""SHA1PRNG"", ""SUN"");
        HashSet <Integer> set = new HashSet<>();
        set.add(pos);
        for(int i = 0; i < Math.min(N - 1, K); i++) {
            while (set.contains(rand_int)) {
                rand_int = rand.nextInt(N) + 1;
            }
            out.println(""T "" + rand_int);
            out.flush();
            pos = sc.ni();
            cnt = sc.ni();
            set.add(pos);
            sum += cnt;
        }
        long res = Math.round(0.5 * N * sum / (Math.min(N - 1, K) + 1));
        out.println(""E "" + res);
        out.flush();
    }

    static long c(int a, int b) {
        if(a <= 0 || b <= 0 || a <= b) return 1L;
        return fac[a] * invFac[b] % MOD * invFac[a - b] % MOD;
    }

    // SegmentTree range min/max query From uwi
    public static class SegmentTreeRMQ {
        public int M, H, N;
        public long[] st;

        public SegmentTreeRMQ(int n)
        {
            N = n;
            M = Integer.highestOneBit(Math.max(N-1, 1))<<2;
            H = M>>>1;
            st = new long[M];
            Arrays.fill(st, 0, M, Integer.MAX_VALUE);
        }

        public SegmentTreeRMQ(long[] a)
        {
            N = a.length;
            M = Integer.highestOneBit(Math.max(N-1, 1))<<2;
            H = M>>>1;
            st = new long[M];
            for(int i = 0;i < N;i++){
                st[H+i] = a[i];
            }
            Arrays.fill(st, H+N, M, Integer.MAX_VALUE);
            for(int i = H-1;i >= 1;i--)propagate(i);
        }

        public void update(int pos, int x)
        {
            st[H+pos] = x;
            for(int i = (H+pos)>>>1;i >= 1;i >>>= 1)propagate(i);
        }

        private void propagate(int i)
        {
            st[i] = Math.min(st[2*i], st[2*i+1]);
        }

        public long minx(int l, int r){
            long min = Long.MAX_VALUE;
            if(l >= r) return min;
            while(l != 0){
                int f = l&-l;
                if(l+f > r)break;
                long v = st[(H+l)/f];
                if(v < min)min = v;
                l += f;
            }

            while(l < r){
                int f = r&-r;
                long v = st[(H+r)/f-1];
                if(v < min) min = v;
                r -= f;
            }
            return min;
        }

        public long min(int l, int r){ return l >= r ? 0 : min(l, r, 0, H, 1);}

        private long min(int l, int r, int cl, int cr, int cur)
        {
            if(l <= cl && cr <= r){
                return st[cur];
            }else{
                int mid = cl+cr>>>1;
                long ret = Long.MAX_VALUE;
                if(cl < r && l < mid){
                    ret = Math.min(ret, min(l, r, cl, mid, 2*cur));
                }
                if(mid < r && l < cr){
                    ret = Math.min(ret, min(l, r, mid, cr, 2*cur+1));
                }
                return ret;
            }
        }
    }

    public static char[] rev(char[] a){char[] b = new char[a.length];for(int i = 0;i < a.length;i++)b[a.length-1-i] = a[i];return b;}
    public static int[] rev(int[] a, int start, int end){int[] b = a.clone();for(int i = start;i <= end;i++) b[start + end - i] = a[i];return b;}
    public static int[] rev(int[] a){return rev(a, 0, a.length - 1);}

    public static double dist(double a, double b){
        return Math.sqrt(a * a + b * b);
    }
    public static double dist(int[] A, int[] B){
        return dist(1.0 * A[0] - B[0], 1.0 * A[1] - B[1]);
    }

    public static long inv(long a){
        return quickPOW(a, MOD - 2);
    }

    public class Interval {
        int start;
        int end;
        public Interval(int start, int end) {
            this.start = start;
            this.end = end;
        }
    }

    public static ArrayList<Integer> sieveOfEratosthenes(int n) {
        boolean prime[] = new boolean[n + 1];
        Arrays.fill(prime, true);
        for (int p = 2; p * p <= n; p++) {
            if (prime[p]) {
                for (int i = p * 2; i <= n; i += p) {
                    prime[i] = false;
                }
            }
        }
        ArrayList<Integer> primeNumbers = new ArrayList<>();
        for (int i = 2; i <= n; i++) {
            if (prime[i]) {
                primeNumbers.add(i);
            }
        }
        return primeNumbers;
    }


    public static int lowerBound(int[] a, int v){ return lowerBound(a, 0, a.length, v); }
    public static int lowerBound(int[] a, int l, int r, int v)
    {
        if(l > r || l < 0 || r > a.length)throw new IllegalArgumentException();
        int low = l-1, high = r;
        while(high-low > 1){
            int h = high+low>>>1;
            if(a[h] >= v){
                high = h;
            }else{
                low = h;
            }
        }
        return high;
    }
    public static int rlowerBound(int[] a, int v){ return lowerBound(a, 0, a.length, v); }
    public static int rlowerBound(int[] a, int l, int r, int v)
    {
        if(l > r || l < 0 || r > a.length)throw new IllegalArgumentException();
        int low = l-1, high = r;
        while(high-low > 1){
            int h = high+low>>>1;
            if(a[h] <= v){
                high = h;
            }else{
                low = h;
            }
        }
        return high;
    }

    public static long C(int n, int m)
    {
        if(m == 0 || m == n) return 1l;
        if(m > n || m < 0) return 0l;
        long res = ",anhpp123
1195,"class aq1{
public static void main(String args[]){
    Scanner sin = new Scanner(System.in);
    int a = sin.nextInt();
    for(int i=0;i<a;i++ ){
         int r = sin.nextInt();
         int c = sin.nextInt();
         System.out.println(""Case #""+i);
         l1(r,c);
         l2(r,c);
         lr(r,c);
    }
    
    
   
}
static void l1(int r, int c){
    System.out.print("".."");
    for(int i =0;i<c-1;i++){
        System.out.print(""+-"");
    }
    System.out.println(""+"");
}
static void l2(int r,int c){
    System.out.print("".."");
    for(int i =0;i<c-1;i++){
        System.out.print(""|."");
    }
    System.out.println(""|"");
}
static void lr(int r,int c){
    for(int i =0;i<r-1;i++){
        for(int j =0;j<c;j++)
        {
            System.out.print(""+-"");
        }
        System.out.println(""+"");
        for(int k =0;k<c;k++)
        {
            System.out.print(""|."");
        }
        System.out.println(""|"");
        for(int y =0;y<c;y++)
        {
            System.out.print(""+-"");
        }
        System.",spsaivaraprasad
846,"class Solution{
    public static void main(String[] args){
        Scanner s = new Scanner(System.in);
        int t = s.nextInt();
        int R = s.nextInt();
        int C = s.nextInt();
        R = 2*R+1;
        C = 2*C+1;
        char[][] ans = new char[R][C];
        while(t-->0){
            System.out.print(""Case#""+(t-(t-1)));
            ans[0][0] = '.';
            ans[0][1] = '.';
            ans[1][0] = '.';
            ans[1][1] = '.';
            for(int i = 0;i<1;i++){
                for(int j=2;j<C;j++){
                    if(j%2 == 0){
                        ans[i][j] = '+';
                    }
                    else{
                        ans[i][j] = '-';
                    }
                }
            }
            for(int i = 1;i<2;i++){
                for(int j=2;j<C;j++){
                    if(j%2 == 0){
                        ans[i][j] = '|';
                    }
                    else{
                        ans[i][j] = '.';
                    }
                }
            }
            for(int i = 2;i<R;i++){
                for(int j=0;j<C;j++){
                    if(i%2==0){
                        if(i%2 == 0 && j%2 == 0){
                        ans[i][j] = '+';
                        }
                        else{
                            ans[i][j] = '-';
                        }
                    }
                    else{
                        if(j%2 == 0){
                        ans[i][j] = '|';
                        }
                        else{
                            ans[i][j] = '.';
                        }
                    }
                }
            }
            for(int i = 0;i<R;i++){
                for(int j=0;j<C;j++){
                    
                    System.out.print(ans[i][j]+"""");
                    if(j == C-1)System.",kaushik_0705
1171,"public class Solution {
    public static void main(String[] args) throws IOException {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt();
        for(int i = 1; i <= t; ++i){
            int n = scanner.nextInt();
            List<Integer> dq = IntStream.range(0,n).boxed().map(z -> scanner.nextInt()).collect(Collectors.toList());
            System.out.println(String.format(""Case #%d: %d"",i,solve(dq)));
        }
    }

    public static long solve(List<Integer> dq){
        if(dq.size() <= 2){
            return dq.size();
        }
        HashMap<Integer,HashMap<Integer,HashMap<Integer,Long>>> cache = new HashMap<>();
        return solve(dq,0, dq.size()-1,0,cache );


    }

    public static long solve(List<Integer> arr, int i, int j, int m, HashMap<Integer,HashMap<Integer,HashMap<Integer,Long>>> cache){

        Long cached = getCache(i,j,m,cache);
        if(cached != -1L){
            return cached;
        }

        if(i > j){
            return putCache(i,j,m,0L,cache);
        }

        if(i == j){
            return putCache(i,j,m,(arr.get(i) >= m ? 1L : 0L),cache);
        }

        Long s1 = solve(arr,i+1, j,Math.max(arr.get(i),m),cache) +( arr.get(i)>=m? 1L : 0L);
        Long s2 = solve(arr,i, j-1,Math.max(arr.get(j),m),cache) + (arr.get(j)>=m? 1L : 0L);

        Long rVal =  Math.max(s1,s2);
        return putCache(i,j,m,rVal,cache);

    }

    public static long getCache(int i, int j, int m, HashMap<Integer,HashMap<Integer,HashMap<Integer,Long>>> cache){
        return cache.computeIfAbsent(i,HashMap::new).computeIfAbsent(j,HashMap::new).getOrDefault(m,-1L);
    }

    public static long putCache(int i, int j, int m, long val, HashMap<Integer,HashMap<Integer,HashMap<Integer,Long>>> cache){
        cache.",smartelf
368,"class Solution
{
    public static void main(String[] args) {
        Scanner in=new Scanner(System.in);
        int t=in.nextInt();
    
       for(int ca=1;ca<=t;ca++)
        {
            int n=in.nextInt();
            long arr[]=new long[n];
            for(int i=0;i<n;i++)
            {
                arr[i]=in.nextInt();
            }
            solve(arr,ca);
        }
    }

      static void solve( long arr[],int ca) {
           long count=0;
           for(int i=0;i<arr.length;i++)
           {
               if(arr[i]>=count)
               {
                   count++;
               }//else{break;}
            

           }
           long max=count;
         count=0;
         for(int i=arr.length-1;i>=0;i--)
         {
             if(arr[i]>count)
             {
                 count++;
             }
         }
         max=",SampathRajaRaghupathi
957,"public class Solution {

	public static void main(String[] args) {
		Scanner s = new Scanner(System.in);
		int i, j, k, l, t, diferenca, temp;
		int p1[] = new int[4];
		int p2[] = new int[4];
		int p3[] = new int[4];
		int saida1[] = new int[4];
		int saida2[] = new int[4];
		int saida3[] = new int[4];
 		
		do {
			t = s.nextInt();
		} while(t < 1 || t > 100);
		
		for(i = 1; i <= t; i++) {
			l = 0;
			
				for(k = 0; k < 4; k++) {
					do {
						p1[k] = s.nextInt();
						
					} while(p1[k] < 0 || p1[k] > (int) Math.pow(10, 6));
				}
				
				for(k = 0; k < 4; k++) {
					do {
						p2[k] = s.nextInt();
						
					} while(p2[k] < 0 || p2[k] > (int) Math.pow(10, 6));
				}
				
				for(k = 0; k < 4; k++) {
 					do {
						p3[k] = s.nextInt();
						
					} while(p3[k] < 0 || p3[k] > (int) Math.pow(10, 6));
				}
			
			for(j = 0; j < 4; j++) {
				
				if(p1[j] >= p2[j] & p1[j] >= p3[j]) {
					saida1[l] = p1[j];
				} else if(p2[j] >= p3[j]) {
					saida1[l] = p2[j];
				} else {
					saida1[l] = p3[j];
				}
				
				if(p1[j] == 0)
					if(p2[j] >= p3[j])
						saida1[l] = p2[j];
					else
						saida1[l] = p3[j];
				
				if(p2[j] == 0)
					if(p1[j] >= p3[j])
						saida1[l] = p1[j];
					else
						saida1[l] = p3[j];
				
				if(p3[j] == 0)
					if(p1[j] >= p2[j])
						saida1[l] = p1[j];
					else
						saida1[l] = p2[j];
				
				if(p1[j] == 0 && p2[j] == 0)
					saida1[l] = p3[j];
				
				if(p2[j] == 0 && p3[j] == 0)
					saida1[l] = p1[j];
				
				if(p1[j] == 0 && p3[j] == 0)
					saida1[l] = p2[j];
				
				l++;
			}
			
			for(j = 0; j < 4; j++) {
				saida2[j] += p1[j] + p2[j] + p3[j];
			}

			l = 0;
			System.out.print(""Case #"" + i + "": "");
			
			if((saida2[0] + saida2[1] + saida2[2] + saida2[3]) >=  3 * Math.pow(10, 6)) {
				
				for(j = 0; j < 4; j++) {
					saida3[j] = saida1[j];
				}
				
				diferenca = saida2[0] + saida2[1] + saida2[2] + saida2[3] - 3 * 10 * 10 * 10 * 10 * 10 * 10;
				
				while(diferenca > 0 && (saida3[0] + saida3[1] + saida3[2] + saida3[3]) > 10 * 10 * 10 * 10 * 10 * 10) {
					
					while(saida3[l] > 0 && diferenca > 0) {
						saida3[l]--;
						diferenca--;
					}
					
					l++;
					diferenca--;
					
				}
				
				System.out.print(saida3[0] + "" "" + saida3[1] + "" "" + saida3[2] + "" "" + saida3[3]);
			} else {
				System.out.print(""IMPOSSIBLE"");
			}
			
			if(i != 1)
				System.",marcosph
547,"public class Solution {
//public class B2 {
    public static void main(String[] args) throws IOException {
        //BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(""in.txt"")));
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int ttt = Integer.parseInt(br.readLine());
        for (int tt = 1; tt <= ttt; ++tt) {
            String[] cc = br.readLine().split("" "");
            final int n = Integer.parseInt(cc[0]);
            final int p = Integer.parseInt(cc[1]);

            final int[][] all = new int[n][p];
            for (int nn = 0; nn < n; nn++) {
                cc = br.readLine().split("" "");
                for (int pp = 0; pp < p; pp++) {
                    all[nn][pp] = Integer.parseInt(cc[pp]);
                }
            }

            final int[][] q = new int[n][2];
            for (int i = 0; i < n; i++) {
                int min = Integer.MAX_VALUE;
                int max = Integer.MIN_VALUE;
                for (int x : all[i]) {
                    min = Math.min(min, x);
                    max = Math.max(max, x);
                }
                q[i][0] = min;
                q[i][1] = max;
            }

            long answ = 0;
            for (int[] x : q) {
                answ += (long) (x[1] - x[0]);
            }

            //System.out.println(answ);

            int[] elements = new int[n];
            for (int i = 0; i < n; i++) {
                elements[i] = i;
            }

            long best = Integer.MAX_VALUE;

            best = Math.min(calc(elements, q), best);

            System.out.println(""Case #"" + tt + "": "" + (answ + best));

        }
    }

    private static long calc(int[] elements, int[][] q) {
        long[][] res = new long[elements.length][2];
        res[0][0] = q[elements[0]][1] * 2 - q[elements[0]][0];
        res[0][1] = q[elements[0]][0];
        for (int i = 1; i < elements.length; i++) {
            final long prevTop = q[elements[i - 1]][1];
            final long prevBottom = q[elements[i - 1]][0];

            final long currTop = q[elements[i]][1];
            final long currBottom = q[elements[i]][0];

            res[i][0] = Math.min(abs(currTop, prevTop) + res[i - 1][1], abs(currTop, prevBottom) + res[i - 1][0]);
            res[i][1] = Math.min(abs(currBottom, prevTop) + res[i - 1][1], abs(currBottom, prevBottom) + res[i - 1][0]);
        }


        return Math.min(res[elements.length - 1][0], res[elements.length - 1][1]);
    }

    private static long abs(long a, long b) ",attila
459,"public class Solution {


    public static void main(String[] args) throws Exception {

        int t=sc.nextInt();
       out: while(t-->0){
            int cnt=8;
//            int cnt2=0;
//            int ii=0;
            while(true){
//                ii++;
//                if(ii%20==0)cnt=8;
                if(cnt==1)cnt=7;
                if(cnt==2)cnt=7;
                if(cnt==3)cnt=2;
                if(cnt==4)cnt=2;
                if(cnt==5)cnt=2;
                if(cnt==6)cnt=7;

                int S=(int)(Math.random()*255)+1;
                while(Integer.bitCount(S)!=cnt){
                    S=(int)(Math.random()*255)+1;
                }
                String s=Integer.toBinaryString(S);
                while(s.length()<8){
                    s=s+""0"";
                }
                pw.println(s);
                pw.flush();
                int x=sc.nextInt();
                cnt=x;
                if(x==-1){
                    break out;
                }
                if(x==0){
                    break;
                }

            }
        }

//        int[][]lol=new int[9][256];
//        for(int i=0;i<256;i++){
//            int x=Integer.bitCount(i);
//            for(int j=0;j<8;j++){
//                int y=((i<<j)&255)|(i>>(8-j));
//                if(y==i)
//                lol[x][y]++;
//            }
//        }
//        for(int i=0;i<9;i++)pw.println(Arrays.toString(lol[i]));
        pw.close();
    }

    static class Scanner {
        StringTokenizer st;
        BufferedReader br;

        public Scanner(InputStream s) {
            br = new BufferedReader(new InputStreamReader(s));
        }

        public Scanner(FileReader r) {
            br = new BufferedReader(r);
        }

        public String next() throws IOException {
            while (st == null || !st.hasMoreTokens())
                st = new StringTokenizer(br.readLine());
            return st.nextToken();
        }

        public int nextInt() throws IOException {
            return Integer.parseInt(next());
        }

        public long nextLong() throws IOException {
            return Long.parseLong(next());
        }

        public String nextLine() throws IOException {
            return br.readLine();
        }

        public double nextDouble() throws IOException {
            String x = next();
            StringBuilder sb = new StringBuilder(""0"");
            double res = 0, f = 1;
            boolean dec = false, neg = false;
            int start = 0;
            if (x.charAt(0) == '-') {
                neg = true;
                start++;
            }
            for (int i = start; i < x.length(); i++)
                if (x.charAt(i) == '.') {
                    res = Long.parseLong(sb.toString());
                    sb = new StringBuilder(""0"");
                    dec = true;
                } else {
                    sb.append(x.charAt(i));
                    if (dec)
                        f *= 10;
                }
            res += Long.parseLong(sb.toString()) / f;
            return res * (neg ? -1 : 1);
        }

        public long[] nextlongArray(int n) throws IOException {
            long[] a = new long[n];
            for (int i = 0; i < n; i++)
                a[i] = nextLong();
            return a;
        }

        public Long[] nextLongArray(int n) throws IOException {
            Long[] a = new Long[n];
            for (int i = 0; i < n; i++)
                a[i] = nextLong();
            return a;
        }

        public int[] nextIntArray(int n) throws IOException {
            int[] a = new int[n];
            for (int i = 0; i < n; i++)
                a[i] = nextInt();
            return a;
        }

        public Integer[] nextIntegerArray(int n) throws IOException {
            Integer[] a = new Integer[n];
            for (int i = 0; i < n; i++)
                a[i] = nextInt();
            return a;
        }

        public boolean ready() throws IOException {
            return br.ready();
        }

    }

    static class pair implements Comparable<pair> {
        long x;
        long y;

        public pair(long x, long y) {
            this.x = x;
            this.y = y;
        }

        public String toString() {
            return x + "" "" + y;
        }

        public boolean equals(Object o) {
            if (o instanceof pair) {
                pair p = (pair) o;
                return p.x == x && p.y == y;
            }
            return false;
        }

        public int hashCode() {
            return new Long(x).hashCode() * 31 + new Long(y).hashCode();
        }

        public int compareTo(pair other) {
            if (this.x == other.x) {
                return Long.compare(this.y, other.y);
            }
            return Long.compare(this.x, other.x);
        }
    }

    static class tuble implements Comparable<tuble> {
        int x;
        int y;
        int z;

        public tuble(int x, int y, int z) {
            this.x = x;
            this.y = y;
            this.z = z;
        }

        public String toString() {
            return x + "" "" + y + "" "" + z;
        }

        public int compareTo(tuble other) {
            if (this.x == other.x) {
                if (this.y == other.y) {
                    return this.z - other.z;
                }
                return this.y - other.y;
            } else {
                return this.x - other.x;
            }
        }
    }

    static long mod = 1000000007;
    static Random rn = new Random();
    static Scanner sc = ",ZerooCool
659,"public class Solution {

    public static void main(String[args]) {
        int caseNumber = 0;
        int diceValue = ",dtarde
779,"public class Solution {
    static int mod = (int) 1e9 + 7;
    public static void main(String[] argu) throws Exception {
        Reader br = new Reader();
        PrintWriter pw = new PrintWriter(System.out);
        int nt = br.nextInt();
        for (int t = 1; t <= nt; ++t) {
            int R = br.nextInt(), C = br.nextInt();
            pw.format(""Case #%d:
"", t);
            StringBuilder sb = new StringBuilder(""..+"");
            for (int j = 1; j < C; ++j) sb.append(""-+"");
            pw.println(sb.toString());
            for (int i = 0; i < R; ++i) {
                sb.setLength(0);
                sb.append(0 == i ? '.' : '|');
                for (int j = 0; j < C; ++j) sb.append("".|"");
                pw.println(sb.toString());
                sb.setLength(0);
                sb.append('+');
                for (int j = 0; j < C; ++j) sb.append(""-+"");
                pw.println(sb.toString());
            }
        }
        pw.close();
        br.close();
    }
    static class Reader
    {
        final private int BUFFER_SIZE = 1 << 16;
        private DataInputStream din;
        private byte[] buffer;
        private int bufferPointer, bytesRead;

        public Reader()
        {
            din = new DataInputStream(System.in);
            buffer = new byte[BUFFER_SIZE];
            bufferPointer = bytesRead = 0;
        }
        private void fillBuffer() throws IOException
        {
            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);
            if (bytesRead == -1)
                buffer[0] = -1;
        }

        private byte read() throws IOException
        {
            if (bufferPointer == bytesRead)
                fillBuffer();
            return buffer[bufferPointer++];
        }

        public void close() throws IOException
        {
            if (din == null)
                return;
            din.close();
        }
        public int nextInt() throws IOException
        {
            int ret = 0;
            byte c = read();
            while (c <= ' ')
                c = read();
            boolean neg = (c == '-');
            if (neg)
                c = read();
            do
            {
                ret = ret * 10 + c - '0';
            }  while ((c = read()) >= '0' && c <= '9');

            if (neg)
                return -ret;
            return ret;
        }
        public long nextLong() throws IOException
        {
            long ret = 0;
            byte c = read();
            while (c <= ' ')
                c = read();
            boolean neg = (c == '-');
            if (neg)
                c = read();
            do
            {
                ret = ret * 10 + c - '0';
            }  while ((c = read()) >= '0' && c <= '9');

            if (neg)
                return -ret;
            return ret;
        }

        public String readLine() throws IOException {
            byte[] buf = new byte[200001]; // line length
            int cnt = 0, c = read();
            if (-1 != c && '
' != c) buf[cnt++] = (byte) c;
            while ((c = read()) != -1)
            {
                if (c == '
')
                    break;
                buf[cnt++] = (byte) c;
            }
            return new String(buf, 0, cnt);
        }

    }
}",hdchen
1323,"public class Solution {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
		int n = scanner.nextInt();
        for (int i = 0; i < n; i++) {
            int Ci = Integer.MAX_VALUE;
            int Mi = Integer.MAX_VALUE;
            int Yi = Integer.MAX_VALUE;
            int Ki = Integer.MAX_VALUE;
            for(int j=0; j<3; j++) {
                Ci = Math.min(Ci, scanner.nextInt());
                Mi = Math.min(Mi, scanner.nextInt());
                Yi = Math.min(Yi, scanner.nextInt());
                Ki = Math.min(Ki, scanner.nextInt());
            }
			System.out.print(""Case #""+(i+1)+"": "");
            System.out.println(get(Ci, Mi, Yi, Ki));
		}

    }

    public static String get(int Ci, int Mi, int Yi, int Ki) {
        int total = 1000000;
        int cur = Math.min(total, Ci);
        String result = cur+"" "";
        total -= cur;

        cur = Math.min(total, Mi);
        result = result + cur+"" "";
        total -= cur;

        cur = Math.min(total, Yi);
        result = result + cur+"" "";
        total -= cur;

        cur = Math.min(total, Ki);
        result = ",xinyou
750,"public class Solution {
     public static  void main(String[] args){
        Scanner myObj = new Scanner(System.in);  
    
        int testcases = myObj.nextInt();
        
        for(int i = 0; i < testcases; i++) {
            int customers = myObj.nextInt();
            int products = myObj.nextInt();
            
            List<List<Integer>> ls = new ArrayList<>();
            for(int j = 0; j < customers; j++) {
                ls.add(new ArrayList<>());
                for(int k = 0; k < products; k++)
                ls.get(j).add(myObj.nextInt());
            }
            
            
            long minRes = helper(ls, 0);
            
            System.out.println(""Case #"" +(i+1)+ "": "" + minRes);

        }
        
    }
    
    static long calc(List<List<Integer>> prods) {
        int last = 0;
        long cnt = 0;
        for(var x : prods)
        for(var y : x) {
            cnt += Math.abs(last - y);
            last = y;
            // System.out.print(y + "" "");
        }
        // System.out.println();
        return cnt;
    }
    
    static long helper(List<List<Integer>> prods, int ind) {
        for(var l : prods)
        Collections.sort(l);
        
        long[][] dp = new long[prods.size()+1][2];
        // 0 : starts with low, ends with high
        
        long lastLow = 0;
        long lastHigh = 0;
        
        for(int i = 0; i < prods.size(); i++) {
            long curLow = prods.get(i).get(0);
            long curHigh = prods.get(i).get(prods.get(i).size()-1);
            long diff =  curHigh - curLow;
            dp[i + 1][0] = diff + Math.min(dp[i][0] + Math.abs(lastHigh - curLow), dp[i][1] + Math.abs(curLow - lastLow));
            dp[i + 1][1] = diff + Math.min(dp[i][0] + Math.abs(lastHigh - curHigh), dp[i][1] + Math.abs(curHigh - lastLow));
            lastLow = curLow;
            lastHigh = curHigh;
        }
        
        return Math.min(dp[prods.size()][0], dp[prods.size()][1]);
    }
    
    static List<List<Integer>> permutations;
    static void permute(List<Integer> ls, int ind) {
        Collections.sort(ls);
        List<Integer> newList = new ArrayList<>(ls);
        Collections.reverse(newList);
        permutations = ",gregordr
556,"public class Solution {
    static final int REL = 1;
    static final int TEST = 2;
    static int mode = REL;
    static PrintWriter pw;

    private static int max(int a, int b) {
        if(a >= b) { return a;} else {return b;}
    }

    private static int minIndex(int a, int b, int c) {
        if(a <= b && a <= c) {
            return 0;
        } else if(b <= a && b <= c) {
            return 1;
        } else {
            return 2;
        }
    }

    private static int min(int a, int b, int c) {
        if(a <= b && a <= c) {
            return a;
        } else if(b <= a && b <= c) {
            return b;
        } else {
            return c;
        }
    }

    public static boolean nextPermutation(List<Node> arr) {
        int len = arr.size();
        int left = len - 2;
        while (left >= 0 && arr.get(left).val >= arr.get(left+1).val) left--;
        if (left < 0) return false;
        int right = len - 1;
        while (arr.get(left).val >= arr.get(right).val) right--;
        {Node t = arr.get(left); arr.set(left, arr.get(right)); arr.set(right, t); }
        left++;
        right = len - 1;
        while (left < right) {
            { Node t = arr.get(left); arr.set(left, arr.get(right)); arr.set(right, t); }
          left++;
          right--;
        }
        return true;
      }

    private static class Node {
        int val;
        Node next = null;
        List<Node> pref = new ArrayList<>();
        boolean used = false;
        Node(int val) {
            this.val = val;
        }
    }

    static int factCalculator(int n){
        if( n == 0 || n ==1){
            return 1;
        }
        else{
            return n * factCalculator(n-1); 
        }
    }

    private static void initList(List<Node> list) {
        for(Node node : list) {
            node.used = false;
        }
    }

    public static void main(String[] args) {
        Scanner in = getScanner();
        if(in == null) {
            log(""get scanner fail"");
            return;
        }
        long start = System.currentTimeMillis();
        
        try {
            int t = in.nextInt();
            log(""t:"" + t);
            for (int i = 1; i <= t; ++i) {
                int N = in.nextInt();
                List<Integer> F = new ArrayList<>();
                List<Integer> P = new ArrayList<>();
                for(int j = 0; j < N; ++j) {
                    F.add(in.nextInt());
                }
                for(int j = 0; j < N; ++j) {
                    P.add(in.nextInt());
                }
                log(F);
                log(P);
                List<Node> list = new ArrayList<>();
                for(int j = 0; j < N; ++j) {
                    list.add(new Node(F.get(j)));
                }
                for(int j = 0; j < N; ++j) {
                    int nextIndex = P.get(j);
                    if(nextIndex > 0) {
                        list.get(j).next = list.get(nextIndex - 1);
                        list.get(nextIndex - 1).pref.add(list.get(j));
                    }
                }
                F.clear(); F = null; P.clear(); P = null;
                
                // initiators
                List<Node> initiators = new ArrayList<>();
                for(Node node : list) {
                    if(node.pref.size() == 0) {
                        initiators.add(node);
//                        log(""initiator:"" + node.val);
                    }
                }

                int score = 0;
                do{
                    log(""***"");
                    int curScore = 0;
                    for(Node node : initiators) {
                        Node cur = node;
                        Node maxNode = cur;
                        int maxScore = 0;
                        while(cur != null) {
                            if(!cur.used && cur.val >= maxScore) {
                                maxScore = cur.val;
                                maxNode = cur;
                            }
                            cur = cur.next;
                        }
                        maxNode.used = true;
                        curScore += maxNode.val;
                        log(""initiator:"" + node.val + "" score:"" + maxNode.val);
                    }
                    if(curScore > score) {
                        score = curScore;
                    }
                    initList(list);
                }while(nextPermutation(initiators));

                System.out.println(""Case #"" + i + "": "" + score);
            }
            in.close();
        }catch(Exception e) {
            log(e + "" "" + e.getMessage());
        }

        if(mode != REL) {
            log(""time:"" + (System.currentTimeMillis() - start));
            pw.close();
            test();
        }
    }

    private static void test() {
    }

    private static void log(String msg) {
        if(mode != REL) {
            System.out.print(""[log]"");
            System.out.println(msg);
            pw.println(msg);
        }
    }
    private static void log(List<Integer> list) {
        if(mode != REL) {
            System.out.print(""[log]"");
            for(Integer a : list) {
                System.out.print(a + "" "");
            }
            System.out.println("""");
        }
    }

    private static Scanner getScanner() {
        BufferedReader br;
        if(mode == REL) {
            br = new BufferedReader(new InputStreamReader(System.in));
        } else {
            try {
                br = new BufferedReader(
                    new InputStreamReader(new FileInputStream(""C:\\\\\Users\\	akafumi\\\Desktop\\\Java\\\codejam2022\\	est.txt""), ""UTF-8""));
                    FileWriter file = new FileWriter(""C:\\\\\Users\\	akafumi\\\Desktop\\\Java\\\codejam2022\\\out.txt"", false);
                    pw = new PrintWriter(new BufferedWriter(file));
           } catch(Exception e) ",azzurri992
1114,"public class Solution {

  static class Node {

    int fun;
    Node next;
    List<Node> prevs = new ArrayList<>();
  }

  public static void main(String[] args) {
    Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
    int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
    for (int i = 1; i <= t; i++) {
      int n = in.nextInt();
      Node[] nodes = new Node[n + 1];
      nodes[0] = new Node(); // abyss

      for (int j = 1; j <= n; j++) {
        nodes[j] = new Node();
        nodes[j].fun = in.nextInt();
      }

      for (int j = 1; j <= n; j++) {
        int tmp = in.nextInt();
        nodes[j].next = nodes[tmp];
        nodes[tmp].prevs.add(nodes[j]);
      }

      var result = solve(nodes);
      System.out.println(""Case #"" + i + "": "" + result);
    }
  }

  static int solve(Node[] nodes) {
    int sum = 0;
    for (int i = nodes.length - 1; i > 0; i--) {
      var node = nodes[i];
      if (node.prevs.size() == 1) {
        node.fun = Math.max(node.prevs.get(0).fun, node.fun);
      }
      if (node.prevs.size() > 1) {
        Node minPrev = node.prevs.get(0);
        for(var prev : node.prevs) {
          if (prev.fun < minPrev.fun) {
            minPrev = prev;
          }
        }
        for(var prev : node.prevs) {
          if (prev != minPrev) {
            sum += prev.fun;
          }
        }
        node.fun = Math.max(minPrev.fun, node.fun);
      }
      if (node.next == nodes[0]) {
        sum += node.",rk13
504,"public class Solution {

    public static String printDrawPunchCards(int noOfTests, int[][] dimensions){
        StringBuilder output = new StringBuilder();

        for (int i = 0; i < dimensions.length; i++) {
            int start = 0;
            String extra = """";
            String pipe = """";
            int count = 0;
            int row = dimensions[i][0];
            int column = dimensions[i][1];

            output.append(""Case #"").append(i+1).append("":
"");

            while(count != row){
                if(start == 0){
                    extra = ""..+"" + ""-+"".repeat(column - 1);
                    pipe = ""..|"" + "".|"".repeat(column - 1);
                }

                if(start != 0) pipe = ""|"" + "".|"".repeat(column);
                String below = ""+"" + ""-+"".repeat(column);

                if(start == 0) output.append(extra).append(""
"");
                output.append(pipe).append(""
"");
                output.append(below).append(""
"");

                count++;
                start++;
            }
        }

",adamson
792,"public class Solution {

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        PrintStream out = System.out;

        try {
            in = new Scanner(new BufferedReader(new FileReader(""/Users/Shared/Sources/CodingStudy/src/codejam/year2022/round_1B/PancakeDeque/sample/sample_ts1-in.txt"")));
            out = new PrintStream(new FileOutputStream(""/Users/Shared/Sources/CodingStudy/src/codejam/year2022/round_1B/PancakeDeque/sample/sample_ts1-out.txt""));
        } catch (Exception e) {
            e.printStackTrace();
            return;
        }

        int T = in.nextInt();
        for (int t = 1; t <= T; t++) {
            int N = in.nextInt();
            int[] D = new int[N];
            for (int n = 0; n < N; n++) {
                D[n] = in.nextInt();
            }

            int ans = getAnswer(t, D);
            out.printf(""Case #%d: %s
"", t, ans);

//            System.err.println(""------------------"");
        }
        in.close();
    }

    private static int getAnswer(int t, int[] D) {
        // Each time, compare head and tail for deque.
        // Select last delicious <= head,  last delicious <= tail,

        ArrayDeque<Integer> deque = new ArrayDeque<>(Arrays.stream(D).boxed().collect(Collectors.toList()));

        int count = 0;
        int lastDelicious = 0;
        for (int i = 0; i < D.length; i++) {
//            System.err.println(deque);
            int head = deque.peekFirst();
            int tail = deque.peekLast();

            int ele;
            if (head <= tail) {
                if (lastDelicious <= head) {
                    // Select head
                    count++;
                    ele = deque.pollFirst();
                } else if (lastDelicious <= tail) {
                    // Select tail
                    count++;
                    ele = deque.pollLast();
                } else {
                    // Select head without pay
                    ele = deque.pollFirst();
                }
            } else {
                if (lastDelicious <= tail) {
                    // Select tail
                    count++;
                    ele = deque.pollLast();
                } else if (lastDelicious <= head) {
                    // Select head
                    count++;
                    ele = deque.pollFirst();
                } else {
                    // Select tail without pay.
                    ele = deque.pollLast();
                }
            }

//            System.err.println(ele);

            if (lastDelicious <= ele)
                lastDelicious = ele;
            else
                break;
        }

        return count;
    }
}",id
673,"public class Solution {
    public static int[] F;
    public static int[][] graph;
    public static HashMap<Long,long[]> memo;
    public static void main(String[] args) throws IOException {
        FastScanner input = new FastScanner(false);
        int T = input.nextInt();
        for (int iter = 1; iter<=T; iter++) {
            int N = input.nextInt();
            F = new int[N+1];
            for (int i = 1; i<=N; i++) {
                F[i]=input.nextInt();
            }
            memo = new HashMap<>();
            graph = new int[N+1][];
            int[] sizes = new int[N+1];
            int[][] edges = new int[N][2];
            for (int i = 0; i<N; i++) {
                edges[i]=new int[]{input.nextInt(),i+1};
                sizes[edges[i][0]]++;
            }
            for (int i = 0; i<=N; i++) {
                graph[i]=new int[sizes[i]];
            }
            for (int i = 0; i<N; i++) {
                graph[edges[i][0]][--sizes[edges[i][0]]]=edges[i][1];
            }
            long t = System.currentTimeMillis();
            System.out.println(""Case #""+iter+"": ""+dfs(0,0)[0]);
            //System.out.println(System.currentTimeMillis()-t);
        }
    }
    public static long[] dfs(int node, long maxAncestor) {
        if (graph[node].length==0) {
            return new long[]{F[node],F[node]};
        }
        //System.out.println(node+""AAAAA"");
        long[] partialPaths = new long[graph[node].length];
        long[] minOfmaxOnPath = new long[graph[node].length];
        int smallestIdx = -1;
        long maxOnPath = Long.MAX_VALUE;
        for (int i = 0; i<graph[node].length; i++) {
            long[] temp = dfs(graph[node][i],0);
            partialPaths[i]=temp[0];
            minOfmaxOnPath[i]=temp[1];
            if (temp[1]<maxOnPath) {
                maxOnPath = temp[1];
                smallestIdx=i;
            }
        }
        long newSmallest = Math.max(F[node],maxOnPath);
        long res = 0;
        for (int i = 0; i<graph[node].length; i++) {
            res+=i==smallestIdx?partialPaths[i]+Math.max(F[node]-maxOnPath,0):partialPaths[i];
        }
        if (graph[node].length==0) res = Math.max(maxAncestor,F[node]);
        return new long[]{res,newSmallest};
    }
    private static class FastScanner {
        final private int BUFFER_SIZE = 1 << 16;
        private DataInputStream din;
        private byte[] buffer;
        private int bufferPointer, bytesRead;
        private FastScanner(boolean usingFile) throws IOException {
            if (usingFile) din=new DataInputStream(new FileInputStream(""C:\\\Users\\\skwek\\\IdeaProjects\\\HelloWorld\\\src\\	esting.in""));
            else din = new DataInputStream(System.in);
            buffer = new byte[BUFFER_SIZE];
            bufferPointer = bytesRead = 0;
        }
        private short nextShort() throws IOException {
            short ret = 0;
            byte c = read();
            while (c <= ' ') c = read();
            boolean neg = (c == '-');
            if (neg) c = read();
            do ret = (short)(ret * 10 + c - '0');
            while ((c = read()) >= '0' && c <= '9');
            if (neg) return (short)-ret;
            return ret;
        }
        private int nextInt() throws IOException {
            int ret = 0;
            byte c = read();
            while (c <= ' ') c = read();
            boolean neg = (c == '-');
            if (neg) c = read();
            do ret = ret * 10 + c - '0';
            while ((c = read()) >= '0' && c <= '9');
            if (neg) return -ret;
            return ret;
        }
        public long nextLong() throws IOException {
            long ret = 0;
            byte c = read();
            while (c <= ' ') c = read();
            boolean neg = (c == '-');
            if (neg) c = read();
            do ret = ret * 10 + c - '0';
            while ((c = read()) >= '0' && c <= '9');
            if (neg) return -ret;
            return ret;
        }
        private char nextChar() throws IOException {
            byte c = read();
            while (c <= ' ') c = read();
            return (char)c;
        }
        private String nextString() throws IOException {
            StringBuilder ret = new StringBuilder();
            byte c = read();
            while (c <=' ') c = read();
            do {
                ret.append((char)c);
            } while ((c = read())>' ');
            return ret.toString();
        }
        private void fillBuffer() throws IOException {
            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);
            if (bytesRead == -1)  buffer[0] = -1;
        }
        private byte read() throws IOException ",ekwek
852,"class Solution{
    public static void main(String[] args){
        Scanner s = new Scanner(System.in);
        int t = s.nextInt();
        int x = t;
        while(t>0){
            System.out.print(""Case #""+(x-(t-1))+"":"");
            int a1 = s.nextInt();
            int a2 = s.nextInt();
            int a3 = s.nextInt();
            int a4 = s.nextInt();
            int b1 = s.nextInt();
            int b2 = s.nextInt();
            int b3 = s.nextInt();
            int b4 = s.nextInt();
            int c1 = s.nextInt();
            int c2 = s.nextInt();
            int c3 = s.nextInt();
            int c4 = s.nextInt();
            int min1 = Math.min(a1, Math.min(b1, c1));
            int min2 = Math.min(a2, Math.min(b2, c2));
            int min3 = Math.min(a3, Math.min(b3, c3));
            int min4 = Math.min(a4, Math.min(b4, c4));
            if(min1+min2+min3+min4 <1000000){
                System.out.print("" IMPOSSIBLE"");
                System.out.println();
            }
            else{
                int twoSum = min1+min2;
                int rem = 1000000 - twoSum;
                int c  = 0;
                int d = 0;
                if(min3<rem && min4<rem){
                    if(min3+min4 == rem){
                        c = min3;
                        d = min4;
                    }
                    else{
                        c = rem-min3;
                        d = 1000000 -(c+twoSum);
                    }
                    
                }
                else if(min3>rem){
                    c= min3-rem;
                    d = 1000000 -(c+twoSum);
                }
                else if(min4>rem){
                    d = min4-rem;
                    c = 1000000 -(d+twoSum);
                }
                System.out.print("" ""+min1);
                System.out.print("" ""+min2);
                System.out.print("" ""+c);
                System.out.print("" ""+d);
                System.",kaushik_0705
755,"public class Solution {
     public static  void main(String[] args){
        Scanner myObj = new Scanner(System.in);  
    
        int testcases = myObj.nextInt();
        
        for(int i = 0; i < testcases; i++) {
            int n = myObj.nextInt();
            
            List<Integer> ls = new ArrayList<>();
            for(int j = 0; j < n; j++) ls.add(myObj.nextInt());
            
            int left = 0;
            int right = n-1;
            
            int cnt = 0;
            int biggest = 0;
            while(left <= right) {
                if(ls.get(left) < ls.get(right)) {
                    if(biggest <= ls.get(left))
                    cnt++;
                    
                    biggest = Math.max(biggest, ls.get(left++));
                } else {
                    if(biggest <= ls.get(right))
                    cnt++;
                    
                    biggest = Math.max(biggest, ls.get(right--));
                }
            }
            
            System.",gregordr
638,"public class Solution {

    private int N;
    private ArrayList<int[]> tables = new ArrayList<>();

    public static void main(String[] args) {

        Solution punchedCards = new Solution();
        punchedCards.readInput();

        for (int x=0; x<punchedCards.tables.size(); x++) {
            int[] table = punchedCards.tables.get(x);

            System.out.println(String.format(""Case #%d"", x+1));
            punchedCards.printPunchCard(table);
        }

    }

    private void printPunchCard(int[] dimensions) {
        int R = dimensions[0];
        int C = dimensions[1];

        String firstRowHeader = ""..+"";
        String rowHeaderPattern = ""-+"";
        firstRowHeader += rowHeaderPattern.repeat(C-1);
        System.out.println(firstRowHeader);

        String firstRow = ""..|"";
        String rowPattern = "".|"";
        firstRow += rowPattern.repeat(C-1);
        System.out.println(firstRow);

        String rowFooter = ""+-+"";
        String rowFooterPattern = ""-+"";
        rowFooter += rowFooterPattern.repeat(C-1);
        System.out.println(rowFooter);

        String restRows = ""|.|"";
        restRows += rowPattern.repeat(C-1);

        for (int i = 0; i < R-1; i++) {
            System.out.println(restRows);
            System.out.println(rowFooter);
        }

    }
    private void readInput() {

        Scanner reader = new Scanner(System.in);
        String data;

        if (reader.hasNextLine()) {
            data = reader.nextLine();
            N = Integer.parseInt(data);
        }

        for (int i = 0; i < N; i++) {

            data = reader.nextLine();
            int[] table = new int[2];

            String[] cells = data.split("" "", 0);
            table[0] = Integer.parseInt(cells[0]);
            table[1] = Integer.parseInt(cells[1]);


            tables.add(table);
        }

        reader.",dionysis_dt
354,"public class Solution {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        PrintWriter pw = new PrintWriter(System.out);

        int testCases = sc.nextInt();
        for (int testCase = 1; testCase <= testCases; testCase++) {
            Map<Integer, List<Integer>> map = new HashMap<>();
            List<Integer> resList = new ArrayList<>();

            int N = sc.nextInt();
            int[] F = new int[N + 1];
            int[] P = new int[N + 1];
            for (int i = 1; i <= N; i++)
                F[i] = sc.nextInt();

            for (int i = 1; i <= N; i++)
                P[i] = sc.nextInt();


            for (int i = 1; i <= N; i++) {
                map.putIfAbsent(P[i], new ArrayList<>());
                map.get(P[i]).add(i);
            }
            resList.add(helper(map, F, 0, resList));
            pw.println(""Case #"" + testCase + "": "" + resList.stream().reduce(0, Integer::sum));

        }

        pw.close();
        sc.close();
    }

    private static int helper(Map<Integer, List<Integer>> map, int[] F, int idx, List<Integer> resList) {
        if (!map.containsKey(idx)) {
            return F[idx];
        }

        List<Integer> next = map.get(idx);
        if (next.size() == 1) {
            return Math.max(F[idx], helper(map, F, next.get(0), resList));
        } else {
            int sum = 0;
            int min = Integer.MAX_VALUE;
            for (int i = 0; i < next.size(); i++) {
                int cur = helper(map, F, next.get(i), resList);
                min = Math.min(min, cur);
                sum += cur;
            }
            sum -= min;
            resList.add(sum);
            return Math.",S
308,"public class Solution {
static int[][] dp;
    public static void main(String[] args) throws InterruptedException {
        Scanner in = new Scanner(System.in);
        // Thread.sleep(3000);
        int T = in.nextInt();

        for (int t = 1; t <= T; t++) {
            int N= in.nextInt();
            int[] arr= new int[N];
            dp= new int[N+1][N+1];
            for(int i=0; i<arr.length; i++){
                arr[i]= in.nextInt();
            }
            Arrays.sort(arr);


            int len=dp(0,1,arr);;
//            for(int i=1; i<=arr.length; i++){
//                if(i<=arr[i-1])
//                    len++;
//            }

            System.out.println(""Case #""+t+"": ""+len);
        }
    }

    private static int  dp(int i, int t, int[] arr) {
        if(i==arr.length)
            return 0;
        if(dp[i][t]!=0) return dp[i][t];
        if( arr[i]>=t )
           return dp[i][t]=Math.max(1+dp(i+1,t+1, arr), dp(i+1,t, arr));
        return dp[i][t]=",Rawan321
1206,"class Solution{

public static int organize(int x,ArrayList<ArrayList<Integer>> matrix)
{
    return x;
}
public static void main(String args[]){
    
    Scanner sc = new Scanner(System.in);

int t = sc.nextInt();

for(int k=0;k<t;k++)
{
    int x = sc.nextInt();
    int size=2*x;
    // int[][] matrix = new int[size][size];
    // for(int i=0;i<size;i++)
    // {
    //   for(int j=0;j<size;j++){
    //       matrix[i][j] = sc.nextInt();
    //   }
    // }
    
    // ArrayList<ArrayList<Integer>> matrix = new ArrayList<>();
    // for(int i=0;i<size;i++){
    //     ArrayList<Integer> array = new ArrayList<>();
    //     while (sc.hasNextInt()) {
    //     int l = sc.nextInt();
    //     array.add(l);
    //     }
        
    //     matrix.add(array);
    // }
    // int result = organize(size,matrix);
    
    System.",sriniharika
1094,"public class Solution {

    public static void main(String[] args) {
        Scanner sc = null;
//        try {
//            sc = new Scanner(new FileInputStream(""in.txt""));
//        } catch (FileNotFoundException e) {
//            e.printStackTrace();
//        }
        sc=new Scanner(System.in);
        int T = sc.nextInt();
        for (int t = 0; t < T; t++) {
            String s=sc.next();
            String out="""";
            //System.out.println(s);
            char a=' ';
            char b=' ';
            for (int i=0;i<s.length()-1;i++){
                 a=s.charAt(i);
                 int c=1;
                 b=s.charAt(i+c);
                 while(b==a&&i+c<s.length()-1){
                     b=s.charAt(i+(++c));
                 }
                if (a<b){
                    out=out+""""+a+""""+a;
                }
                else{
                    out=out+""""+a;
                }
            }
            out+=b;
            System.",raver1975
1210,"class Solution{

public static int organize(int x,ArrayList<ArrayList<Long>> matrix)
{
    return x;
}
public static void main(String[] args){
    
    Scanner sc = new Scanner(System.in);

int t = sc.nextInt();

for(int k=0;k<t;k++)
{
    int x = sc.nextInt();
    int size=2*x;
    // int[][] matrix = new int[size][size];
    // for(int i=0;i<size;i++)
    // {
    //   for(int j=0;j<size;j++){
    //       matrix[i][j] = sc.nextInt();
    //   }
    // }
    
    ArrayList<ArrayList<Long>> matrix = new ArrayList<>();
    for(int i=0;i<size;i++){
        ArrayList<Long> array = new ArrayList<>();
        while (sc.hasNextInt()) {
        Long l = sc.nextLong();
        array.add(l);
        }
        
        matrix.add(array);
    }
    int result = ",sriniharika
252,"public class Solution{

    public static void main(String[] args){

        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        int T = in.nextInt();
        for (int i=1; i<=T; i++){
            int count=0;
            int z=in.nextInt();
            int [] array=new int[z];
            for (int j=0;j<z;j++)
            {array[j]=in.nextInt();
            }
            Arrays.sort(array);
            if(array[z-1]>z)
            { count=z;}
            else {
               for (int o=1;o<z;o++)
               { if(i<=array[0])
               {count++;}
               }
            
            
            }
           
                    System.out.println(""Case #"" + i + "": "" + count);
            }
        
        in.",Marwan
411,"public class Solution {
    static Scanner sc = new Scanner(System.in);

    public static void main(String[] args) {

        int cases = Integer.parseInt(sc.nextLine());
        for (int i = 0; i < cases; i++) {
            runTest();
        }


    }



    public static String runTest(){
        StringBuilder sb = new StringBuilder();
        boolean[] bits = new boolean[8];
        for (int i = 0; i < 300; i++) {
            System.out.print(String.format(""%8s"", Integer.toBinaryString((int)(Math.random() * 127))).replaceAll("" "", ""0""));
            int num = (sc.nextInt());
            if(num == 0 || num == -1){
                break;
            }
        }

        return sb.",SurgeM
562,"public class Solution {
    static final int REL = 1;
    static final int TEST = 2;
    static final int NOLOG = 3;
    static int mode = REL;
    static PrintWriter pw;

    private static int minIndex(int a, int b, int c) {
        if(a <= b && a <= c) {
            return 0;
        } else if(b <= a && b <= c) {
            return 1;
        } else {
            return 2;
        }
    }

    private static int min(int a, int b, int c) {
        if(a <= b && a <= c) {
            return a;
        } else if(b <= a && b <= c) {
            return b;
        } else {
            return c;
        }
    }

    public static void main(String[] args) {
        Scanner in = getScanner();
        if(in == null) {
            log(""get scanner fail"");
            return;
        }
        long start = System.currentTimeMillis();
        
        try {
            int t = in.nextInt();
            log(""t:"" + t);
            for (int i = 1; i <= t; ++i) {
                int c = 0; 
                int m = 0;
                int y = 0;
                int k = 0;
                List<Integer> l1 = new ArrayList<>();
                List<Integer> l2 = new ArrayList<>();
                List<Integer> l3 = new ArrayList<>();
                l1.add(in.nextInt()); l1.add(in.nextInt()); l1.add(in.nextInt()); l1.add(in.nextInt());
                l2.add(in.nextInt()); l2.add(in.nextInt()); l2.add(in.nextInt()); l2.add(in.nextInt());
                l3.add(in.nextInt()); l3.add(in.nextInt()); l3.add(in.nextInt()); l3.add(in.nextInt());
                log(l1); log(l2); log(l3);
                
                // l1
                c = min(l1.get(0), l2.get(0), l3.get(0));
                m = min(l1.get(1), l2.get(1), l3.get(1));
                y = min(l1.get(2), l2.get(2), l3.get(2));
                k = min(l1.get(3), l2.get(3), l3.get(3));
               
                int total = c + m + y + k;
                int rest = total - 1000000;
                log(""L1 c:"" + c + "" m:"" + m + "" y:"" + y + "" k:"" + k + "" total:"" + total + "" rest:"" + rest);
                if(total >= 1000000) {
                    //valid
                    if(rest > 0) {
                        if(rest > 0 && c > rest) { c -= rest; total -= rest; rest = 0;}
                        else if(rest > 0){total -= c; rest -= c; c = 0;}
                        log(""c:"" + c + "" total: "" + total + "" rest:"" + rest);
                        if(rest > 0 && m > rest) { m -= rest; total -= rest; rest = 0;}
                        else if(rest > 0){total -= m; rest -= m; m = 0;}
                        log(""m:"" + m + "" total: "" + total + "" rest:"" + rest);

                        if(rest > 0 && y > rest) { y -= rest; total -= rest; rest = 0;}
                        else if(rest > 0){total -= y; rest -= y; y = 0;}
                        log(""y:"" + y + "" total: "" + total + "" rest:"" + rest);

                        if(rest > 0 && k > rest) { k -= rest; total -= rest; rest = 0;}
                        else if(rest > 0){total -= k; rest -= k; k = 0;}
                        log(""k:"" + k + "" total: "" + total + "" rest:"" + rest);
                        log(""L1 c+m+y+k:"" + (c+m+y+k));
                    }
                    log(""L1 c:"" + c + "" m:"" + m + "" y:"" + y + "" k:"" + k + "" total:"" + total + "" rest:"" + rest);
                    System.out.println(""Case #"" + i + "": "" + c + "" "" + m + "" "" + y + "" "" + k);
                    continue;
                }
                System.out.println(""Case #"" + i + "": IMPOSSIBLE"");
            }
            in.close();
        }catch(Exception e) {
            log(e + "" "" + e.getMessage());
        }

        if(mode != REL) {
            log(""time:"" + (System.currentTimeMillis() - start));
            pw.close();
            test();
        }
    }

    private static void test() {
    }

    private static void log(String msg) {
        if(mode == TEST) {
            System.out.print(""[log]"");
            System.out.println(msg);
            pw.println(msg);
        }
    }
    private static void log(List<Integer> list) {
        if(mode == TEST) {
            System.out.print(""[log]"");
            for(Integer a : list) {
                System.out.print(a + "" "");
            }
            System.out.println("""");
        }
    }

    private static Scanner getScanner() {
        BufferedReader br;
        if(mode == REL) {
            br = new BufferedReader(new InputStreamReader(System.in));
        } else {
            try {
                br = new BufferedReader(
                    new InputStreamReader(new FileInputStream(""C:\\\\\Users\\	akafumi\\\Desktop\\\Java\\\codejam2022\\	est.txt""), ""UTF-8""));
                    FileWriter file = new FileWriter(""C:\\\\\Users\\	akafumi\\\Desktop\\\Java\\\codejam2022\\\out.txt"", false);
                    pw = new PrintWriter(new BufferedWriter(file));
           } catch(Exception e) ",azzurri992
283,"public class Solution {
  public static void main(String[] args) {
    Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
    int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
    List<int[][]> tests = new ArrayList<>(t);
    for (int i = 0; i < t; i++) {
      int n = in.nextInt();
      int[][] list = new int[2][n];
      for (int j = 0; j < n; j++) {
        list[0][j] = in.nextInt();
      }
      for (int j = 0; j < n; j++) {
        list[1][j] = in.nextInt();
      }
      tests.add(list);
    }
    for (int i = 0; i < t; i++) {
      System.out.println(""Case #"" + (i + 1) + "": "" + getMaxFun(tests.get(i)));
    }
  }

  static int leafFound = 0;

  private static int getMaxFun(int[][] fun) {
    int n = fun[0].length + 1;
    List<List<Integer>> adjList = new ArrayList<>(n);
    for (int i = 0; i < n; i++) {
      adjList.add(new LinkedList<>());
    }
    for (int i = 0; i < n - 1; i++) {
      adjList.get(fun[1][i]).add(i + 1);
    }
    PriorityQueue<Integer> q = new PriorityQueue<>();
    leafFound = 0;
    getMaxFun(adjList, q, fun[0], 0);
    int sum = 0;
    while (!q.isEmpty()) {
      sum += q.poll();
    }
    return sum;
  }

  private static void getMaxFun(List<List<Integer>> adjList, PriorityQueue<Integer> q, int[] fun, int curr) {
    List<Integer> children = adjList.get(curr);
    for (int child : children) {
      getMaxFun(adjList, q, fun, child);
    }
    if (curr != 0)
      q.add(fun[curr - 1]);

    if (children.isEmpty())
      leafFound++;

    while (q.size() > leafFound) {
      q.",Mr
632,"public class Solution {

    private int N;
    private ArrayList<int[][]> tables = new ArrayList<>();

    public static void main(String[] args) {

        Solution printing3D = new Solution();
        printing3D.readInput();

        for (int x = 0; x< printing3D.tables.size(); x++) {
            int[][] table = printing3D.tables.get(x);

            printing3D.solveTestCase(x, table);
        }

    }

    private void solveTestCase(int x, int[][] cartridges) {

        int[] CMYK = minimumCMYK(cartridges);
        boolean isPossible = isPossible(CMYK);
        calculateCMYK(CMYK);

        if(isPossible) {
            System.out.println(String.format(""Case #%d: %d %d %d %d"", x+1, CMYK[0], CMYK[1], CMYK[2], CMYK[3]));
        } else {
            System.out.println(String.format(""Case #%d: IMPOSSIBLE"", x+1));
        }
    }

    private void calculateCMYK(int[] CMYK) {
        int remainingInkUnits = 1000000;

        for(int i=0; i<CMYK.length; i++) {
            if(remainingInkUnits <= CMYK[i]) {
                CMYK[i] = remainingInkUnits;
            }
            remainingInkUnits -= CMYK[i];
        }
    }

    private int[] minimumCMYK(int[][] cartridges) {
        int[] CMYK = new int[4];
        CMYK[0] = cartridges[0][0];
        CMYK[1] = cartridges[0][1];
        CMYK[2] = cartridges[0][2];
        CMYK[3] = cartridges[0][3];

        for (int i = 0; i < cartridges.length; i++) {
            for (int j = 0; j < cartridges[i].length; j++){
                if(cartridges[i][j] < CMYK[j]) {
                    CMYK[j] = cartridges[i][j];
                }
            }
        }

        return CMYK;
    }

    private boolean isPossible(int[] CMYK) {
        int totalInkUnits = 0;
        for (int i = 0; i < CMYK.length; i++) {
            totalInkUnits += CMYK[i];
        }

        boolean isPossible = (totalInkUnits >= 1000000);
        return isPossible;
    }

    private void readInput() {

        Scanner reader = new Scanner(System.in);
        String data;

        if (reader.hasNextLine()) {
            data = reader.nextLine();
            N = Integer.parseInt(data);
        }

        for (int i = 0; i < N; i++) {
            int[][] table = new int[N][4];

            for (int j = 0; j < 3; j++) {
                data = reader.nextLine();

                String[] cells = data.split("" "", 0);
                table[j][0] = Integer.parseInt(cells[0]);
                table[j][1] = Integer.parseInt(cells[1]);
                table[j][2] = Integer.parseInt(cells[2]);
                table[j][3] = Integer.parseInt(cells[3]);
            }

            tables.add(table);
        }

        reader.",dionysis_dt
279,"public class Problem1 {
    public static void main(String[] args) {
        Scanner s = new Scanner(System.in) ;
        int n = s.nextInt() ;
        for (int i=1 ;i<=n ;i++) {
            System.out.print(""Case #""+i);
            check() ;
        }
    }

    public static void check() {
        String s = """" ;
        Scanner sc = new Scanner(System.in) ;
        String str = sc.nextLine() ;
        char[] l = str.toCharArray() ;

        boolean test = false ;
        for(int j=0 ; j<l.length-1 ; j++) {
            if(l[j]!=l[j+1]) {
                test = true ;
            }
        }

        if(!test) {
            System.out.println(str);
            return;
        }

        for(int i=0 ; i<l.length-1 ; i++) {
            if(  (int)l[i]<=(int)l[i+1] ) {
                s = s+l[i] ;
            }
            s+=l[i] ;
        }
        s+=l[l.length-1] ;
        System.",Mr
305,"public class Solution {
static int[][] dp;
    public static void main(String[] args) throws InterruptedException {
        Scanner in = new Scanner(System.in);
        // Thread.sleep(3000);
        int T = in.nextInt();

        for (int t = 1; t <= T; t++) {
            int N= in.nextInt();
            int[] arr= new int[N];
            dp= new int[N+1][N+1];
            for(int i=0; i<arr.length; i++){
                arr[i]= in.nextInt();
            }
            Arrays.sort(arr);


            int len=dp(0,1,arr);;
//            for(int i=1; i<=arr.length; i++){
//                if(i<=arr[i-1])
//                    len++;
//            }

            System.out.println(""Case #""+t+"": ""+len);
        }
    }

    private static int  dp(int i, int t, int[] arr) {
        if(i>=arr.length || t>arr.length)
            return 0;
        if(dp[i][t]!=0) return dp[i][t];
        if( arr[i]>=t )
           return dp[i][t]=Math.max(1+dp(i+1,t+1, arr), dp(i+1,t, arr));
        return dp[i][t]=",Rawan321
452,"public class Solution {


    public static void main(String[] args) throws Exception {

        int t=sc.nextInt();
       out: while(t-->0){
            int cnt=8;
//            int cnt2=0;
//            int ii=0;
            while(true){
//                ii++;
//                if(ii%20==0)cnt=8;
                if(cnt==1)cnt=7;
                if(cnt==2)cnt=7;
                if(cnt==3)cnt=3;
                if(cnt==4)cnt=3;
                if(cnt==5)cnt=3;
                if(cnt==6)cnt=7;

                int S=(int)(Math.random()*255)+1;
                while(Integer.bitCount(S)!=cnt){
                    S=(int)(Math.random()*255)+1;
                }
                String s=Integer.toBinaryString(S);
                while(s.length()<8){
                    s=s+""0"";
                }
                pw.println(s);
                pw.flush();
                int x=sc.nextInt();
                cnt=x;
                if(x==-1){
                    break out;
                }
                if(x==0){
                    break;
                }

            }
        }

//        int[][]lol=new int[9][256];
//        for(int i=0;i<256;i++){
//            int x=Integer.bitCount(i);
//            for(int j=0;j<8;j++){
//                int y=((i<<j)&255)|(i>>(8-j));
//                if(y==i)
//                lol[x][y]++;
//            }
//        }
//        for(int i=0;i<9;i++)pw.println(Arrays.toString(lol[i]));
        pw.close();
    }

    static class Scanner {
        StringTokenizer st;
        BufferedReader br;

        public Scanner(InputStream s) {
            br = new BufferedReader(new InputStreamReader(s));
        }

        public Scanner(FileReader r) {
            br = new BufferedReader(r);
        }

        public String next() throws IOException {
            while (st == null || !st.hasMoreTokens())
                st = new StringTokenizer(br.readLine());
            return st.nextToken();
        }

        public int nextInt() throws IOException {
            return Integer.parseInt(next());
        }

        public long nextLong() throws IOException {
            return Long.parseLong(next());
        }

        public String nextLine() throws IOException {
            return br.readLine();
        }

        public double nextDouble() throws IOException {
            String x = next();
            StringBuilder sb = new StringBuilder(""0"");
            double res = 0, f = 1;
            boolean dec = false, neg = false;
            int start = 0;
            if (x.charAt(0) == '-') {
                neg = true;
                start++;
            }
            for (int i = start; i < x.length(); i++)
                if (x.charAt(i) == '.') {
                    res = Long.parseLong(sb.toString());
                    sb = new StringBuilder(""0"");
                    dec = true;
                } else {
                    sb.append(x.charAt(i));
                    if (dec)
                        f *= 10;
                }
            res += Long.parseLong(sb.toString()) / f;
            return res * (neg ? -1 : 1);
        }

        public long[] nextlongArray(int n) throws IOException {
            long[] a = new long[n];
            for (int i = 0; i < n; i++)
                a[i] = nextLong();
            return a;
        }

        public Long[] nextLongArray(int n) throws IOException {
            Long[] a = new Long[n];
            for (int i = 0; i < n; i++)
                a[i] = nextLong();
            return a;
        }

        public int[] nextIntArray(int n) throws IOException {
            int[] a = new int[n];
            for (int i = 0; i < n; i++)
                a[i] = nextInt();
            return a;
        }

        public Integer[] nextIntegerArray(int n) throws IOException {
            Integer[] a = new Integer[n];
            for (int i = 0; i < n; i++)
                a[i] = nextInt();
            return a;
        }

        public boolean ready() throws IOException {
            return br.ready();
        }

    }

    static class pair implements Comparable<pair> {
        long x;
        long y;

        public pair(long x, long y) {
            this.x = x;
            this.y = y;
        }

        public String toString() {
            return x + "" "" + y;
        }

        public boolean equals(Object o) {
            if (o instanceof pair) {
                pair p = (pair) o;
                return p.x == x && p.y == y;
            }
            return false;
        }

        public int hashCode() {
            return new Long(x).hashCode() * 31 + new Long(y).hashCode();
        }

        public int compareTo(pair other) {
            if (this.x == other.x) {
                return Long.compare(this.y, other.y);
            }
            return Long.compare(this.x, other.x);
        }
    }

    static class tuble implements Comparable<tuble> {
        int x;
        int y;
        int z;

        public tuble(int x, int y, int z) {
            this.x = x;
            this.y = y;
            this.z = z;
        }

        public String toString() {
            return x + "" "" + y + "" "" + z;
        }

        public int compareTo(tuble other) {
            if (this.x == other.x) {
                if (this.y == other.y) {
                    return this.z - other.z;
                }
                return this.y - other.y;
            } else {
                return this.x - other.x;
            }
        }
    }

    static long mod = 1000000007;
    static Random rn = new Random();
    static Scanner sc = ",ZerooCool
292,"public class Solution {

  public static void main(String[] args) {
 /*   String aaa = ""3
"" +
        ""3 4
"" +
        ""2 2
"" +
        ""2 3"";
    final Stream<String> lines = Arrays.stream(aaa.split(""
"")); */
    
    final BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
    final Stream<String> lines = reader.lines();

    int T = 0;
    int cs = 1;
    int start = 1;
    int end = 2;
/*

    final String UPPER = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ"";
    final String LOWER = ""abcdefghijklmnopqrstuvwxyz"";
    final char [] upper = UPPER.toCharArray();
    final char [] lower = LOWER.toCharArray();
    String line="""";
    List<Long> l = Arrays.stream(line.split("" "")).map(Long::valueOf).collect(Collectors.toList());

*/

    final Iterator<String> iterator = lines.iterator();
    int i = 0;
    String[] temp;

    while (iterator.hasNext()) {
      final String line = iterator.next();
      if (i == 0) {
        T = Integer.valueOf(line);
      } else {
        if (i == start) {
          end = start;
          start += 1;
        }
        if (i == end) {
          temp = line.split("" "");
          int R = Integer.valueOf(temp[0]);
          int C = Integer.valueOf(temp[1]);

          if (cs <= T) {
            Test t = new Test(R,C);
            System.out.println(""Case #"" + cs + "": "");
            t.print();
            cs++;
            if (cs > T) {
              break;
            }
          }
        }
      }
      i++;
    }

  }

  public static class Test {

    int r;
    int c;
    public Test(int r, int c) {
      this.r = r;
      this.c = c;
    }

    public void print() {
      StringBuffer s1 = new StringBuffer(""..+"");
      StringBuffer s2 = new StringBuffer(""..|"");
      StringBuffer s3 = new StringBuffer(""+-+"");
      StringBuffer s4 = new StringBuffer(""|.|"");
      StringBuffer s5 = new StringBuffer();
      StringBuffer s6 = new StringBuffer();
      for (int i = 0; i < c-1; i++) {
        s5.append(""-+"");
        s6.append("".|"");
      }

      System.out.println(s1.append(s5));
      System.out.println(s2.append(s6));
      s3 = s3.append(s5);
      s4 = s4.append(s6);
      for (int i = 0; i < r-1; i++) {
        System.out.println(s3);
        System.out.println(s4);
      }
      System.",Obchelli
520,"public class Solution{

    static long MOD = 1_000_000_007L;
    //static long MOD = 998_244_353L;
    //static long MOD = 1_000_000_033L;
    static long inv2 = (MOD + 1) / 2;
    static long [] fac;
    static long [] pow;
    static long [] inv;
    static long [] invFac;
    static int[][] dir = new int[][]{{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
    static long lMax = 0x3f3f3f3f3f3f3f3fL;
    static int iMax = 0x3f3f3f3f;
    static HashMap <Long, Long> memo = new HashMap();
    static MyScanner sc = new MyScanner();
    //static ArrayList <Integer> primes;

    static long[] pow2;
    static int[] base;
    static int[] numOfDiv;
    static ArrayList <Integer> primes;
    //-----------PrintWriter for faster output---------------------------------
    public static PrintWriter out;
    public static void main(String[] args) {
        out = new PrintWriter(new BufferedOutputStream(System.out));
        // Start writing your solution here. -------------------------------------

        int nn = 300000;

        /*fac = new long[nn + 1];
        fac[1] = 1;
        for(int i = 2; i <= nn; i++)
            fac[i] = fac[i - 1] * 1L * i % MOD;*/

        /*pow = new long[nn + 1];
        pow[0] = 1L;
        for(int i = 1; i <= nn; i++)
            pow[i] = pow[i - 1] * 2L % MOD;
        pow[1] = 3L;*/

        /*
        pow2 = new long[nn + 1];
        pow2[0] = 1L;
        for(int i = 1; i <= nn; i++)
            pow2[i] = pow2[i - 1] * 2L;*/

        /*inv = new long[nn + 1];
        inv[1] = 1;
        for (int i = 2; i <= nn; ++i)
            inv[i] = (MOD - MOD / i) * inv[(int)(MOD % i)] % MOD;

        invFac = new long[nn + 1];
        invFac[1] = 1;
        for(int i = 2; i <= nn; i++)
            invFac[i] = invFac[i - 1] * inv[i] % MOD;*/

        //primes = sieveOfEratosthenes(100001);


        /*for(int i = 2; i <= 20000000; i++)
            if(numOfDiv[i] == 0)
                for(int j = i; j <= 20000000; j += i)
                    numOfDiv[j] ++;*/

        int t = 1, tt = 0;
        t = sc.ni();
        while(tt++ < t) {
            //long res = solve();
            //out.print(""Case #"" + tt + "": "");
            solve();
            //out.println(res);
        }
        out.close();
    }
    static void solve() {
        int N = sc.ni(), K = sc.ni();
        int pos = sc.ni(), cnt = sc.ni();
        long sum = cnt;
        int rand_int = pos;
        SecureRandom rand = new SecureRandom();
        rand = SecureRandom.getInstance(""PKCS11"");
        HashSet <Integer> set = new HashSet<>();
        set.add(pos);
        for(int i = 0; i < Math.min(N - 1, K); i++) {
            while (set.contains(rand_int)) {
                rand_int = rand.nextInt(N) + 1;
            }
            out.println(""T "" + rand_int);
            out.flush();
            pos = sc.ni();
            cnt = sc.ni();
            set.add(pos);
            sum += cnt;
        }
        long res = Math.round(0.5 * N * sum / (Math.min(N - 1, K) + 1));
        out.println(""E "" + res);
        out.flush();
    }

    static long c(int a, int b) {
        if(a <= 0 || b <= 0 || a <= b) return 1L;
        return fac[a] * invFac[b] % MOD * invFac[a - b] % MOD;
    }

    // SegmentTree range min/max query From uwi
    public static class SegmentTreeRMQ {
        public int M, H, N;
        public long[] st;

        public SegmentTreeRMQ(int n)
        {
            N = n;
            M = Integer.highestOneBit(Math.max(N-1, 1))<<2;
            H = M>>>1;
            st = new long[M];
            Arrays.fill(st, 0, M, Integer.MAX_VALUE);
        }

        public SegmentTreeRMQ(long[] a)
        {
            N = a.length;
            M = Integer.highestOneBit(Math.max(N-1, 1))<<2;
            H = M>>>1;
            st = new long[M];
            for(int i = 0;i < N;i++){
                st[H+i] = a[i];
            }
            Arrays.fill(st, H+N, M, Integer.MAX_VALUE);
            for(int i = H-1;i >= 1;i--)propagate(i);
        }

        public void update(int pos, int x)
        {
            st[H+pos] = x;
            for(int i = (H+pos)>>>1;i >= 1;i >>>= 1)propagate(i);
        }

        private void propagate(int i)
        {
            st[i] = Math.min(st[2*i], st[2*i+1]);
        }

        public long minx(int l, int r){
            long min = Long.MAX_VALUE;
            if(l >= r) return min;
            while(l != 0){
                int f = l&-l;
                if(l+f > r)break;
                long v = st[(H+l)/f];
                if(v < min)min = v;
                l += f;
            }

            while(l < r){
                int f = r&-r;
                long v = st[(H+r)/f-1];
                if(v < min) min = v;
                r -= f;
            }
            return min;
        }

        public long min(int l, int r){ return l >= r ? 0 : min(l, r, 0, H, 1);}

        private long min(int l, int r, int cl, int cr, int cur)
        {
            if(l <= cl && cr <= r){
                return st[cur];
            }else{
                int mid = cl+cr>>>1;
                long ret = Long.MAX_VALUE;
                if(cl < r && l < mid){
                    ret = Math.min(ret, min(l, r, cl, mid, 2*cur));
                }
                if(mid < r && l < cr){
                    ret = Math.min(ret, min(l, r, mid, cr, 2*cur+1));
                }
                return ret;
            }
        }
    }

    public static char[] rev(char[] a){char[] b = new char[a.length];for(int i = 0;i < a.length;i++)b[a.length-1-i] = a[i];return b;}
    public static int[] rev(int[] a, int start, int end){int[] b = a.clone();for(int i = start;i <= end;i++) b[start + end - i] = a[i];return b;}
    public static int[] rev(int[] a){return rev(a, 0, a.length - 1);}

    public static double dist(double a, double b){
        return Math.sqrt(a * a + b * b);
    }
    public static double dist(int[] A, int[] B){
        return dist(1.0 * A[0] - B[0], 1.0 * A[1] - B[1]);
    }

    public static long inv(long a){
        return quickPOW(a, MOD - 2);
    }

    public class Interval {
        int start;
        int end;
        public Interval(int start, int end) {
            this.start = start;
            this.end = end;
        }
    }

    public static ArrayList<Integer> sieveOfEratosthenes(int n) {
        boolean prime[] = new boolean[n + 1];
        Arrays.fill(prime, true);
        for (int p = 2; p * p <= n; p++) {
            if (prime[p]) {
                for (int i = p * 2; i <= n; i += p) {
                    prime[i] = false;
                }
            }
        }
        ArrayList<Integer> primeNumbers = new ArrayList<>();
        for (int i = 2; i <= n; i++) {
            if (prime[i]) {
                primeNumbers.add(i);
            }
        }
        return primeNumbers;
    }


    public static int lowerBound(int[] a, int v){ return lowerBound(a, 0, a.length, v); }
    public static int lowerBound(int[] a, int l, int r, int v)
    {
        if(l > r || l < 0 || r > a.length)throw new IllegalArgumentException();
        int low = l-1, high = r;
        while(high-low > 1){
            int h = high+low>>>1;
            if(a[h] >= v){
                high = h;
            }else{
                low = h;
            }
        }
        return high;
    }
    public static int rlowerBound(int[] a, int v){ return lowerBound(a, 0, a.length, v); }
    public static int rlowerBound(int[] a, int l, int r, int v)
    {
        if(l > r || l < 0 || r > a.length)throw new IllegalArgumentException();
        int low = l-1, high = r;
        while(high-low > 1){
            int h = high+low>>>1;
            if(a[h] <= v){
                high = h;
            }else{
                low = h;
            }
        }
        return high;
    }

    public static long C(int n, int m)
    {
        if(m == 0 || m == n) return 1l;
        if(m > n || m < 0) return 0l;
        long res = ",anhpp123
894,"public final class Solution
{    
	static PrintWriter out = new PrintWriter(System.out); 
	static StringBuilder ans=new StringBuilder();
	static FastReader in=new FastReader();
	static ArrayList<Integer> g[];
	static long mod=(long)998244353,INF=Long.MAX_VALUE;
	static boolean set[],col[]; 
	static int par[],tot[],partial[];
	static int Days[],P[][];
	static int sum=0,size[];
	static int seg[],vis[][];
	static long dp[][];
	public static void main(String args[])throws IOException
	{		
		/*
		 * star,rope,TPST
		 * BS,LST,MS,MQ
		 */
		int T=i();
		outer:for(int tt=1; tt<=T; tt++)
		{
			ArrayList<String > f[]=new ArrayList[10];
			for(int i=0; i<10; i++)f[i]=new ArrayList<>();
			for(int i=0; i<(1<<8); i++)
			{
				int p=1,c=0;
				String x="""";
				while(p<=i)
				{
					if((p&i)!=0)
					{
						x=1+""""+x;
						c++;
					}
					else x=0+""""+x;
				}
				f[c].add(x);
			}
			System.out.println(f[0]);
			int last=i();
			for(int i=1; i<300; i++)
			{
				if(last==8)
				{
					System.out.println(f[8]);
					i();
					break;				
				}
				int r=8-last;
				Random rnd = new Random();
				r=rnd.nextInt(f[r].size());
				System.out.println(f[8-last].get(r));
				r=i();
				if(r==-1)return;
				if(r==0)break;
				last=r;
			}
			//			ans.append(""Case #""+tt+"": ""+""
"");
		}



		out.println(ans);
		out.close();
	}
	static long cost=Long.MAX_VALUE;
	static long f(int i,int j,long A[][],int N,long p)
	{
		//		System.out.println(""comming from ""+j+"" to ""+i+"" with cost "");
		if(i==N+1)
		{
			return 0;
		}
		long min=A[i][0],max=A[i][0];
		int minIndex=0,maxIndex=0;
		int it=0;
		for(long a:A[i])
		{
			min=Math.min(min, a);
			max=Math.max(max, a);
			if(min==a)minIndex=it;
			if(max==a)maxIndex=it;
			it++;		
		}
		if(dp[i][j]==-1)
		{
			if(min<=p && max<=p)
			{
				//				System.out.println(1);
				long s=p-min;
				dp[i][j]=s+f(i+1,minIndex,A,N,min);
			}
			else if(min>=p && max>=p)
			{
				//				System.out.println(2);
				long s=max-p;
				dp[i][j]=s+f(i+1,maxIndex,A,N,max);
			}
			else
			{
				//				System.out.println(""3"");
				long a=p-min,b=max-p;
				long s=(a+b);
				long s1=s;
				s+=a;
				dp[i][j]=s+f(i+1,maxIndex,A,N,max);
				s1+=b;
				dp[i][j]=Math.min(dp[i][j], s1+f(i+1,minIndex,A,N,min));
			}
		}
		return dp[i][j];
	}
	static boolean palin(long n)
	{
		long s=0;
		long N=n;
		while(N!=0)
		{
			long r=N%10;
			s*=10L;
			s+=r;
			N/=10;
		}		
		return s==n;
	}
	static String fdp(char X[],int i,int N)
	{
		String Y="""";
		if(i+1==N)return X[N-1]+"""";




		return Y;
	}
	static long s=0;
	static long dfs(int n,int p,long F[])
	{
		long min=0,sum=0;
		for(int c:g[n])
		{
			if(c!=p)
			{
				long a=dfs(c,n,F);
				sum+=a;
				if(min==0)min=a;
				min=Math.min(a, min);
			}
		}
		//		System.out.println(n+"" ""+min+ "" ""+sum);
		s+=(sum-min);
		return Math.max(F[n-1], min);
	}
	static boolean fSmall(char X[],int i,int N)
	{
		if(i==N)
		{
			//if length of maximum palindrome is >=5
			int max=1;
			for(int l=0; l<N; l++)
			{
				for(int r=l+1; r<N; r++)
				{
					if(isPal(X,l,r))max=Math.max(max, r-l+1);
				}
			}
			return max<5;
		}
		if(X[i]=='?')
		{
			char Y[]=Arrays.copyOf(X,N);
			Y[i]='0';
			X[i]='1';
			return fSmall(X,i+1,N)|fSmall(Y,i+1,N);
		}
		return fSmall(X,i+1,N);
	}
	static boolean isPal(char X[],int l, int r)
	{
		while(l<r)
		{
			if(X[l]!=X[r])return false;
			l++;
			r--;
		}
		return true;
	}


	static boolean f(char X[],char Y[],int N,int M)
	{
		int j=0;
		for(char x:Y)
		{
			if(j<N && x==X[j])j++;
		}
		//	  System.out.println(j+"" ""+N);
		return j==N;
	}
	static int index(int a,ArrayList<Integer> A)
	{
		int l=-1,r=A.size();
		while(r-l>1)
		{
			int m=(l+r)/2;
			int x=A.get(m);
			if(x<=a)l=m;
			else r=m;
		}
		return r;
	}
	static long and(int i,int j)
	{
		System.out.println(""and ""+i+"" ""+j);
		return l();
	}
	static long or(int i,int j)
	{
		System.out.println(""or ""+i+"" ""+j);
		return l();",kkkkush
1245,"public class Solution {
	public static void input() {
		Scanner sc = new Scanner(System.in);
		int testCase = sc.nextInt();
		int countTest = 1;
		Deque<Integer> dq;
		while (testCase > 0) {
			dq = new ArrayDeque<>();
			int numCake = sc.nextInt();
			for (int i = 0; i < numCake; i++) {
				dq.add(sc.nextInt());
			}
			System.out.println(""Case #"" + countTest + "": "" + output(dq));
			testCase--;
			countTest++;
		}
	}

	public static int output(Deque<Integer> in) {

		int count = 1;
		int getFirst = in.getFirst();
		int getLast = in.getLast();
		if (in.size() == 2) {
			return 2;
		}
		while (in.size() > 1) {
			if (getFirst < getLast || getLast < getFirst) {
				if (in.size() == 2) {
					break;
				}
				if (count == 1) {
					if (in.getFirst() > in.getLast()) {
						getLast = in.getFirst();
						in.pollFirst();
						in.pollLast();
						getFirst = in.getFirst();
						count++;
					} else if (in.getFirst() < in.getLast()) {
						getLast = in.getLast();
						in.pollFirst();
						getFirst = in.getFirst();
						count++;
					}
				} else {
					if(getFirst > getLast) {
						count++;
						in.pollLast();
					}
					break;
				}
			} else if (getFirst == getLast) {
				in.pollFirst();
				getFirst = in.getFirst();
				getLast = in.getLast();
				count++;
			}
		}
		return count;
	}

	public static void main(String[] args) ",tonybuidn
458,"public class Solution {


    public static void main(String[] args) throws Exception {

        int t=sc.nextInt();
       out: while(t-->0){
            int cnt=1;
            while(true){
                String s="""";
                for(int i=0;i<cnt;i++)s=s+""1"";
                for(int i=0;i<8-cnt;i++)s=s+""0"";

                pw.println(s);
                pw.flush();
                int x=sc.nextInt();
                cnt=x;
                if(x==-1){
                    break out;
                }

                if(x==0){
                    break;
                }
            }
        }

        pw.close();
    }

    static class Scanner {
        StringTokenizer st;
        BufferedReader br;

        public Scanner(InputStream s) {
            br = new BufferedReader(new InputStreamReader(s));
        }

        public Scanner(FileReader r) {
            br = new BufferedReader(r);
        }

        public String next() throws IOException {
            while (st == null || !st.hasMoreTokens())
                st = new StringTokenizer(br.readLine());
            return st.nextToken();
        }

        public int nextInt() throws IOException {
            return Integer.parseInt(next());
        }

        public long nextLong() throws IOException {
            return Long.parseLong(next());
        }

        public String nextLine() throws IOException {
            return br.readLine();
        }

        public double nextDouble() throws IOException {
            String x = next();
            StringBuilder sb = new StringBuilder(""0"");
            double res = 0, f = 1;
            boolean dec = false, neg = false;
            int start = 0;
            if (x.charAt(0) == '-') {
                neg = true;
                start++;
            }
            for (int i = start; i < x.length(); i++)
                if (x.charAt(i) == '.') {
                    res = Long.parseLong(sb.toString());
                    sb = new StringBuilder(""0"");
                    dec = true;
                } else {
                    sb.append(x.charAt(i));
                    if (dec)
                        f *= 10;
                }
            res += Long.parseLong(sb.toString()) / f;
            return res * (neg ? -1 : 1);
        }

        public long[] nextlongArray(int n) throws IOException {
            long[] a = new long[n];
            for (int i = 0; i < n; i++)
                a[i] = nextLong();
            return a;
        }

        public Long[] nextLongArray(int n) throws IOException {
            Long[] a = new Long[n];
            for (int i = 0; i < n; i++)
                a[i] = nextLong();
            return a;
        }

        public int[] nextIntArray(int n) throws IOException {
            int[] a = new int[n];
            for (int i = 0; i < n; i++)
                a[i] = nextInt();
            return a;
        }

        public Integer[] nextIntegerArray(int n) throws IOException {
            Integer[] a = new Integer[n];
            for (int i = 0; i < n; i++)
                a[i] = nextInt();
            return a;
        }

        public boolean ready() throws IOException {
            return br.ready();
        }

    }

    static class pair implements Comparable<pair> {
        long x;
        long y;

        public pair(long x, long y) {
            this.x = x;
            this.y = y;
        }

        public String toString() {
            return x + "" "" + y;
        }

        public boolean equals(Object o) {
            if (o instanceof pair) {
                pair p = (pair) o;
                return p.x == x && p.y == y;
            }
            return false;
        }

        public int hashCode() {
            return new Long(x).hashCode() * 31 + new Long(y).hashCode();
        }

        public int compareTo(pair other) {
            if (this.x == other.x) {
                return Long.compare(this.y, other.y);
            }
            return Long.compare(this.x, other.x);
        }
    }

    static class tuble implements Comparable<tuble> {
        int x;
        int y;
        int z;

        public tuble(int x, int y, int z) {
            this.x = x;
            this.y = y;
            this.z = z;
        }

        public String toString() {
            return x + "" "" + y + "" "" + z;
        }

        public int compareTo(tuble other) {
            if (this.x == other.x) {
                if (this.y == other.y) {
                    return this.z - other.z;
                }
                return this.y - other.y;
            } else {
                return this.x - other.x;
            }
        }
    }

    static long mod = 1000000007;
    static Random rn = new Random();
    static Scanner sc = ",ZerooCool
359,"public class Solution {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        PrintWriter pw = new PrintWriter(System.out);

        int testCases = sc.nextInt();
        for (int testCase = 1; testCase <= testCases; testCase++) {
            int[] colors = new int[4];
            for (int i = 0; i < colors.length; i++) {
                colors[i] = sc.nextInt();
            }
            for (int i = 1; i < 3; i++) {
                for (int j = 0; j < colors.length; j++) {
                    colors[j] = Math.min(colors[j], sc.nextInt());
                }
            }

            int print = 0;
            for (int i = 0; i < colors.length; i++) {
                if (colors[i] > 0) {
                    print++;
                }
            }

            if (print < 3) {
                pw.println(""Case #"" + testCase + "": IMPOSSIBLE"");
                continue;
            } else if (Arrays.stream(colors).sum() > 1_000_000) {
                int remain = Arrays.stream(colors).sum() - 1_000_000;
                for (int i = 0; i < colors.length && remain > 0; i++) {
                    if (remain > colors[i]) {
                        remain -= colors[i];
                        colors[i] = 0;
                    } else {
                        colors[i] -= remain;
                        remain = 0;
                    }
                }
            }
            pw.println(""Case #"" + testCase + "": "" + colors[0] + "" "" + colors[1] + "" "" + colors[2] + "" "" + colors[3]);
        }

        pw.close();
        sc.",S
407,"public class Solution {
    static Scanner sc = new Scanner(System.in);

    public static void main(String[] args) {

        int cases = Integer.parseInt(sc.nextLine());
        for (int i = 0; i < cases; i++) {
            runTest();
            break;
        }


    }



    public static String runTest(){
        StringBuilder sb = new StringBuilder();
        boolean[] bits = new boolean[8];
        for (int i = 0; i < 300; i++) {
            System.out.println(String.format(""%8s"", Integer.toBinaryString((int)(Math.random() * 127))).replaceAll("" "", ""0""));
            int num = (sc.nextInt());
            if(num == 0 || num == -1){
                break;
            }
        }

        return sb.",SurgeM
1018,"public class Solution {
    public static void main(String[] args) {
        Scanner inp = new Scanner(System.in);

        int t = inp.nextInt();

        for (int j = 0; j < t; j++) {
            System.out.printf(""Case #%d: "",j+1);
            int c = inp.nextInt();
            int m = inp.nextInt();
            int y = inp.nextInt();
            int k = inp.nextInt();
            for (int i = 0; i <2 ; i++){
                int c1 = inp.nextInt();
                int m1 = inp.nextInt();
                int y1 = inp.nextInt();
                int k1 = inp.nextInt();

                c = (c1<c) ? c1 : c ;
                m = (m1<m) ? m1 : m ;
                y = (y1<y) ? y1 : y ;
                k = (k1<k) ? k1 : k ;

            }
            
            int[] arr = {c,m,y,k};
            
            int sum = 0;
            
            for(int i = 0; i<4;i++){
                sum += arr[i];
                if (sum >= 1000000){
                    arr[i] =1000000-sum+arr[i];
                    for(int l = i+1 ; l<4 ; l++){
                        arr[t]=0;
                    }
                    System.out.printf(""%d %d %d %d
"",arr[0],arr[1],arr[2],arr[3]);
                    i=5;
                }
                
                if(i==3)
                    System.out.println(""IMPOSSIBLE"");
                
            }


            
        }
    }
}",parthanos
799,"class Module {

    public long F;

    public int index;

    private boolean _dirty = true;

    private boolean isFork;

    private boolean isInitiator;

    public boolean isFork() {

        if (_dirty) {
            isFork = parents.size() > 1;
            isInitiator = parents.size() == 0;
            _dirty = false;
        }

        return isFork;
    }

    public boolean isInitiator() {

        if (_dirty) {
            isFork = parents.size() > 1;
            isInitiator = parents.size() == 0;
            _dirty = false;
        }

        return isInitiator;
    }

    public int child;
    public List<Integer> parents;

    public Module() {
        parents = new ArrayList<>();
    }
}

public class Solution {

    public int index;

    public Module[] modules;

    public Solution(int index, int nModules) {

        this.index = index;
        modules = new Module[nModules + 1];

        for (int i = 0; i < nModules + 1; i++) {
            modules[i] = new Module();
        }
    }

    public void solve() {

        var moduleFun = new long[modules.length];

        var forkIds = new ArrayList<Integer>();
        var initiatorIdxs = new ArrayList<Integer>();

        for (var module : modules) {
            if (module.isFork()) {
                forkIds.add(module.index);
            } else if (module.isInitiator()) {
                initiatorIdxs.add(module.index);
            }
        }

        forkIds.sort(Comparator.reverseOrder());

        int[] forkDetonator = new int[modules.length];

        for (var forkModuleIdx : forkIds) {

            var forkModule = modules[forkModuleIdx];
            int nParents = forkModule.parents.size();

            for (int i = 0; i < nParents; i++) {

                int parentIdx = forkModule.parents.get(i);

                var mod = modules[parentIdx];

                long f = 0;

                while (true) {

                    if (mod.isInitiator()) {
                        f = Math.max(f, mod.F);
                        break;
                    }

                    if (mod.isFork()) {
                        f = Math.max(f, moduleFun[mod.index]);
                        break;
                    }

                    f = Math.max(f, mod.F);

                    mod = modules[mod.parents.get(0)];
                }

                moduleFun[parentIdx] = f;
            }

            var detonatorId = forkModule.parents
                    .stream()
                    .min(Comparator.comparingLong(m -> moduleFun[m])).get();

            forkDetonator[forkModuleIdx] = detonatorId;
            moduleFun[forkModuleIdx] = Math.max(modules[forkModuleIdx].F, moduleFun[detonatorId]);
        }

        long score = 0;

        for (var initiatorIdx : initiatorIdxs) {

            int lastIdx = -1;
            long initiatorScore = 0;

            var idx = initiatorIdx;

            while (idx > 0) {

                var mod = modules[idx];
                if (mod.isFork()) {
                    if (forkDetonator[idx] != lastIdx) {
                        break;
                    } else {
                        initiatorScore = Math.max(initiatorScore, moduleFun[idx]);
                    }
                } else {
                    initiatorScore = Math.max(initiatorScore, mod.F);
                }

                lastIdx = idx;
                idx = mod.child;
            }

            score += initiatorScore;
        }

        // validation

        var scoresSorted = Arrays.stream(modules).map(mod -> mod.F).sorted(Comparator.reverseOrder()).collect(Collectors.toList());

        long maxPossibleScore = 0;
        for (int i = 0; i < initiatorIdxs.size(); i++) {
            maxPossibleScore += scoresSorted.get(i);
        }

        System.out.printf(""Case #%d: %d%n"", index + 1, score);
    }

    public static void main(String[] args) {

        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        int T = in.nextInt();

        for (int i = 0; i < T; i++) {

            int N = in.nextInt();

            var solution = new Solution(i, N);

            for (int j = 0; j < N; j++) {
                int F = in.nextInt();
                solution.modules[j + 1].F = F;
            }

            for (int j = 0; j < N; j++) {

                int index = j + 1;
                int child = in.nextInt();

                solution.modules[index].index = index;

                solution.modules[index].child = child;
                solution.modules[child].parents.add(index);
            }

            solution.",jaimuepe
165,"public class Solution {

    public void solve(Scanner scanner) {
        int n = scanner.nextInt();
        scanner.nextLine();
        List<String> towers = new ArrayList<>(Arrays.asList(scanner.nextLine().split("" "")));

        int i = 0;
        while (i <= towers.size()) {
            boolean mergeable = attemptMerge(i, towers, true);
            if (!mergeable) {
                i++;
            }
        }

        i = 0;
        while (i <= towers.size()) {
            boolean mergeable = attemptMerge(i, towers, false);
            if (!mergeable) {
                i++;
            }
        }

        String join = join(towers, """");
        HashSet<Character> checkedChars = new HashSet<>();
        for (int j = 0 ; j < join.length(); j++) {
            char currentChar = join.charAt(j);
            if (checkedChars.contains(currentChar)) {
                System.out.println(""IMPOSSIBLE"");
                return;
            }
            while ((j + 1 < join.length() && currentChar == join.charAt(j + 1))) {
                j++;
            }
            checkedChars.add(currentChar);
        }
        System.out.println(join);
    }

    public static String join(Collection var0, String var1) {
        StringBuffer var2 = new StringBuffer();

        for(Iterator var3 = var0.iterator(); var3.hasNext(); var2.append((String)var3.next())) {
            if (var2.length() != 0) {
                var2.append(var1);
            }
        }

        return var2.toString();
    }

    private boolean attemptMerge(int firstIndex, List<String> towers, boolean checkStart) {
        String first = towers.get(firstIndex);
        char firstChar;
        if (checkStart) {
            firstChar = first.charAt(0);
        } else {
            firstChar = first.charAt(first.length() - 1);
        }

        for (int i = 0; i < towers.size(); i++) {
            String second = towers.get(i);
            if (firstIndex == i) {
                continue;
            }
            char secondChar;
            if (checkStart) {
                secondChar = second.charAt(second.length() - 1);
            } else {
                secondChar = second.charAt(0);
            }
            if (firstChar == secondChar) {
                int index = towers.indexOf(first);
                towers.remove(first);
                towers.remove(second);
                String merged;
                if (checkStart) {
                    merged = second + first;
                } else {
                    merged = first + second;
                }
                towers.add(index, merged);
                return true;
            }
        }
        return false;
    }

    public static void main(String[] args) throws Exception {
        Scanner scan = new Scanner(System.in);
        int problems = Integer.parseInt(scan.nextLine());
        for (int count = ",KatieSanderson
1077,"public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        for(int Case = 1; Case <= T; Case ++){
            int N = sc.nextInt();
            int delicious[] = new int[N];
            for(int i = 0; i < N; i ++){
                delicious[i] = sc.nextInt();
            }
            int left = 0;
            int right = N - 1;
            int cnt = 0;
            int maxDeli = 0;
            int payNum = 0;
            while(cnt < N){
                if(delicious[left] <= delicious[right]){
                    if(delicious[left] >= maxDeli){
                        maxDeli = delicious[left];
                        payNum += 1;
                    }
                    cnt += 1;
                    left += 1;
                }
                else{
                    if(delicious[right] >= maxDeli){
                        maxDeli = delicious[right];
                        payNum += 1;
                    }
                    cnt += 1;
                    right -= 1;
                }
            }



//            int payNum[][] = new int[N][N];
//            int maxDeli[][] = new int[N][N];
//            for(int i = 0; i < N; i ++){
//                payNum[i][i] = 1;
//                maxDeli[i][i] = delicious[i];
//            }
//            for(int length = 2; length <= N; length ++){
//                for(int i = 0; i + length - 1 < N; i ++){
//                    int j = i + length - 1;
//                    maxDeli[i][j] = Math.max(maxDeli[i][j - 1], maxDeli[j][j]);
//                    int payRight = 1;
//                    if
//
//
//                    int payRight = payNum[i][j - 1];
//                    if(delicious[j] >= maxDeli[i][j - 1])
//                        payRight += 1;
//                    int payLeft = payNum[i + 1][j];
//                    if(delicious[i] >= maxDeli[i + 1][j])
//                        payLeft += 1;
//                    payNum[i][j] = Math.max(payLeft, payRight);
//                }
//            }

            System.",ql309
355,"public class Solution {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        PrintWriter pw = new PrintWriter(System.out);

        int testCases = sc.nextInt();
        for (int testCase = 1; testCase <= testCases; testCase++) {
            Map<Integer, Integer> map = new HashMap<>();
            PriorityQueue<Node> pq = new PriorityQueue<>(Comparator.comparingInt(i -> i.side));

            int N = sc.nextInt();
            for (int i = 0; i < N; i++) {
                int cur = sc.nextInt();
                map.put(cur, map.getOrDefault(cur, 0) + 1);
            }

            for (int side : map.keySet()) {
                pq.add(new Node(side, map.get(side)));
            }
            int res = 0;
            while (!pq.isEmpty()) {
                Node node = pq.remove();
                int side = node.side;
                int count = node.count;
                if (count + res < side) {
                    res += count;
                } else if (count + res >= side) {
                    res = side;
                }
            }
            pw.println(""Case #"" + testCase + "": "" + res);

        }

        pw.close();
        sc.close();
    }

    private static class Node {
        int side;
        int count;

        Node(int side, int count) {
            this.side = side;
            this.count = ",S
559,"public class Solution {
    static final int REL = 1;
    static final int TEST = 2;
    static final int NOLOG = 3;
    static int mode = REL;
    static PrintWriter pw;

    private static int minIndex(int a, int b, int c) {
        if(a <= b && a <= c) {
            return 0;
        } else if(b <= a && b <= c) {
            return 1;
        } else {
            return 2;
        }
    }

    private static int min(int a, int b, int c) {
        if(a <= b && a <= c) {
            return a;
        } else if(b <= a && b <= c) {
            return b;
        } else {
            return c;
        }
    }

    public static void main(String[] args) {
        Scanner in = getScanner();
        if(in == null) {
            log(""get scanner fail"");
            return;
        }
        long start = System.currentTimeMillis();
        
        try {
            int t = in.nextInt();
            log(""t:"" + t);
            for (int i = 1; i <= t; ++i) {
                int c = 0; 
                int m = 0;
                int y = 0;
                int k = 0;
                List<Integer> l1 = new ArrayList<>();
                List<Integer> l2 = new ArrayList<>();
                List<Integer> l3 = new ArrayList<>();
                l1.add(in.nextInt()); l1.add(in.nextInt()); l1.add(in.nextInt()); l1.add(in.nextInt());
                l2.add(in.nextInt()); l2.add(in.nextInt()); l2.add(in.nextInt()); l2.add(in.nextInt());
                l3.add(in.nextInt()); l3.add(in.nextInt()); l3.add(in.nextInt()); l3.add(in.nextInt());
                log(l1); log(l2); log(l3);
                
                // l1
                int minC = min(l1.get(0), l2.get(0), l3.get(0));
                if(l1.get(0) > minC) {
                    c = minC;
                } else {
                    c = l1.get(0);
                }
                int minM = min(l1.get(1), l2.get(1), l3.get(1));
                if(l1.get(1) > minM) {
                    m = minM;
                } else {
                    m = l1.get(1);
                }
                int minY = min(l1.get(2), l2.get(2), l3.get(2));
                if(l1.get(2) > minY) {
                    y = minY;
                } else {
                    y = l1.get(2);
                }
                int minK = min(l1.get(3), l2.get(3), l3.get(3));
                if(l1.get(3) > minK) {
                    k = minK;
                } else {
                    k = l1.get(3);
                }

                int total = c + m + y + k;
                int rest = total - 1000000;
                log(""L1 c:"" + c + "" m:"" + m + "" y:"" + y + "" k:"" + k + "" total:"" + total + "" rest:"" + rest);
                if(total >= 1000000) {
                    //valid
                    if(rest > 0) {
                        if(rest > 0 && c > rest) { c -= rest; total -= rest; rest = 0;}
                        else if(rest > 0){total -= c; rest -= c; c = 0;}
                        log(""c:"" + c + "" total: "" + total + "" rest:"" + rest);
                        if(rest > 0 && m > rest) { m -= rest; total -= rest; rest = 0;}
                        else if(rest > 0){total -= m; rest -= m; m = 0;}
                        log(""m:"" + m + "" total: "" + total + "" rest:"" + rest);

                        if(rest > 0 && y > rest) { y -= rest; total -= rest; rest = 0;}
                        else if(rest > 0){total -= y; rest -= y; y = 0;}
                        log(""y:"" + y + "" total: "" + total + "" rest:"" + rest);

                        if(rest > 0 && k > rest) { k -= rest; total -= rest; rest = 0;}
                        else if(rest > 0){total -= k; rest -= k; k = 0;}
                        log(""k:"" + k + "" total: "" + total + "" rest:"" + rest);
                        log(""L1 c+m+y+k:"" + (c+m+y+k));
                    }
                    log(""L1 c:"" + c + "" m:"" + m + "" y:"" + y + "" k:"" + k + "" total:"" + total + "" rest:"" + rest);
                    System.out.println(""Case #"" + i + "": "" + c + "" "" + m + "" "" + y + "" "" + k);
                    continue;
                }

                // l2
                if(l2.get(0) > minC) {
                    c = minC;
                } else {
                    c = l2.get(0);
                }
                if(l2.get(1) > minM) {
                    m = minM;
                } else {
                    m = l2.get(1);
                }
                if(l2.get(2) > minY) {
                    y = minY;
                } else {
                    y = l2.get(2);
                }
                minK = min(l1.get(3), l2.get(3), l3.get(3));
                if(l2.get(3) > minK) {
                    k = minK;
                } else {
                    k = l2.get(3);
                }

                total = c + m + y + k;
                log(""L2 c:"" + c + "" m:"" + m + "" y:"" + y + "" k:"" + k + "" total:"" + total);
                rest = total % 1000000;
                if(total >= 1000000) {
                    //valid
                    if(rest > 0) {
                        if(rest > 0 && c > rest) { c -= rest; total -= rest; rest = 0;}
                        else if(rest > 0){total -= c; rest -= c; c = 0;}
                        log(""c:"" + c + "" total: "" + total + "" rest:"" + rest);
                        if(rest > 0 && m > rest) { m -= rest; total -= rest; rest = 0;}
                        else if(rest > 0){total -= m; rest -= m; m = 0;}
                        log(""m:"" + m + "" total: "" + total + "" rest:"" + rest);

                        if(rest > 0 && y > rest) { y -= rest; total -= rest; rest = 0;}
                        else if(rest > 0){total -= y; rest -= y; y = 0;}
                        log(""y:"" + y + "" total: "" + total + "" rest:"" + rest);

                        if(rest > 0 && k > rest) { k -= rest; total -= rest; rest = 0;}
                        else if(rest > 0){total -= k; rest -= k; k = 0;}
                        log(""k:"" + k + "" total: "" + total + "" rest:"" + rest);
                        log(""L2 c+m+y+k:"" + (c+m+y+k));
                    }
                    System.out.println(""Case #"" + i + "": "" + c + "" "" + m + "" "" + y + "" "" + k);
                    continue;
                }

                // l3
                if(l3.get(0) > minC) {
                    c = minC;
                } else {
                    c = l3.get(0);
                }
                if(l3.get(1) > minM) {
                    m = minM;
                } else {
                    m = l3.get(1);
                }
                if(l3.get(2) > minY) {
                    y = minY;
                } else {
                    y = l3.get(2);
                }
                if(l3.get(3) > minK) {
                    k = minK;
                } else {
                    k = l3.get(3);
                }

                total = c + m + y + k;
                log(""L3 c:"" + c + "" m:"" + m + "" y:"" + y + "" k:"" + k + "" total:"" + total);
                rest = total % 1000000;
                if(total >= 1000000) {
                    //valid
                    if(rest > 0) {
                        if(rest > 0 && c > rest) { c -= rest; total -= rest; rest = 0;}
                        else if(rest > 0){total -= c; rest -= c; c = 0;}
                        log(""c:"" + c + "" total: "" + total + "" rest:"" + rest);
                        if(rest > 0 && m > rest) { m -= rest; total -= rest; rest = 0;}
                        else if(rest > 0){total -= m; rest -= m; m = 0;}
                        log(""m:"" + m + "" total: "" + total + "" rest:"" + rest);

                        if(rest > 0 && y > rest) { y -= rest; total -= rest; rest = 0;}
                        else if(rest > 0){total -= y; rest -= y; y = 0;}
                        log(""y:"" + y + "" total: "" + total + "" rest:"" + rest);

                        if(rest > 0 && k > rest) { k -= rest; total -= rest; rest = 0;}
                        else if(rest > 0){total -= k; rest -= k; k = 0;}
                        log(""k:"" + k + "" total: "" + total + "" rest:"" + rest);
                        log(""L3 c+m+y+k:"" + (c+m+y+k));
                    }
                    System.out.println(""Case #"" + i + "": "" + c + "" "" + m + "" "" + y + "" "" + k);
                    continue;
                }

                System.out.println(""Case #"" + i + "": IMPOSSIBLE"");
            }
            in.close();
        }catch(Exception e) {
            log(e + "" "" + e.getMessage());
        }

        if(mode != REL) {
            log(""time:"" + (System.currentTimeMillis() - start));
            pw.close();
            test();
        }
    }

    private static void test() {
    }

    private static void log(String msg) {
        if(mode == TEST) {
            System.out.print(""[log]"");
            System.out.println(msg);
            pw.",azzurri992
770,"public class Solution {
    public static void main(String[] argu) throws Exception {
        Reader br = new Reader();
        PrintWriter pw = new PrintWriter(System.out);
        int nt = br.nextInt();
        for (int t = 1; t <= nt; ++t) {
            int N = br.nextInt();
            long[] F = new long[N], maxF = new long[N];
            List<Integer>[] adj = new List[N];
            for (int i = 0; i < N; ++i) F[i] = br.nextLong();
            int[] P = new int[N], outDeg = new int[N], inDeg = new int[N];
            for (int i = 0; i < N; ++i) {
                adj[i] = new LinkedList();
                P[i] = br.nextInt() - 1;
                if (-1 == P[i]) continue;
                outDeg[i]++;
                inDeg[P[i]]++;
                adj[P[i]].add(i);
            }
            boolean[] seen = new boolean[N];
            PriorityQueue<Integer> pq = new PriorityQueue<Integer>(1, (a, b) -> Long.compare(F[b], F[a]));
            for (int i = 0; i < N; ++i) {
                if (0 != outDeg[i]) continue;
                pq.add(i);
                dfs(adj, i, F, maxF);
            }
            long res = 0;
            while (!pq.isEmpty()) {
                int cur = pq.poll();
                if (0 == inDeg[cur]) res += F[cur];
                int min = Integer.MAX_VALUE, next = -1;
                for (int dst : adj[cur]) {
                    pq.add(dst);
                    if (maxF[dst] < min) {
                        min = (int) maxF[dst];
                        next = dst;
                    }
                }
                if (-1 == next) continue;
                F[next] = Math.max(F[next], F[cur]);
            }
            pw.format(""Case #%d: %d"", t, res);
            pw.println();
        }
        pw.close();
        br.close();
    }
    private static void dfs(List<Integer>[] adj, int src, long[] F, long[] maxF) {
        if (0 != maxF[src]) return;
        maxF[src] = F[src];
        long min = Integer.MAX_VALUE;
        for (int dst : adj[src]) {
            dfs(adj, dst, F, maxF);
            min = Math.min(min, maxF[dst]);
        }
        if (min != Integer.MAX_VALUE) maxF[src] = Math.max(maxF[src], min);
    }
    static class Reader
    {
        final private int BUFFER_SIZE = 1 << 16;
        private DataInputStream din;
        private byte[] buffer;
        private int bufferPointer, bytesRead;

        public Reader()
        {
            din = new DataInputStream(System.in);
            buffer = new byte[BUFFER_SIZE];
            bufferPointer = bytesRead = 0;
        }
        private void fillBuffer() throws IOException
        {
            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);
            if (bytesRead == -1)
                buffer[0] = -1;
        }

        private byte read() throws IOException
        {
            if (bufferPointer == bytesRead)
                fillBuffer();
            return buffer[bufferPointer++];
        }

        public void close() throws IOException
        {
            if (din == null)
                return;
            din.close();
        }
        public int nextInt() throws IOException
        {
            int ret = 0;
            byte c = read();
            while (c <= ' ')
                c = read();
            boolean neg = (c == '-');
            if (neg)
                c = read();
            do
            {
                ret = ret * 10 + c - '0';
            }  while ((c = read()) >= '0' && c <= '9');

            if (neg)
                return -ret;
            return ret;
        }
        public long nextLong() throws IOException
        {
            long ret = 0;
            byte c = read();
            while (c <= ' ')
                c = read();
            boolean neg = (c == '-');
            if (neg)
                c = read();
            do
            {
                ret = ret * 10 + c - '0';
            }  while ((c = read()) >= '0' && c <= '9');

            if (neg)
                return -ret;
            return ret;
        }

        public String readLine() throws IOException {
            byte[] buf = new byte[200001]; // line length
            int cnt = 0, c = read();
            if (-1 != c && '
' != c) buf[cnt++] = (byte) c;
            while ((c = read()) != -1)
            {
                if (c == '
')
                    break;
                buf[cnt++] = (byte) c;
            }
            return new String(buf, 0, cnt);
        }

    }
}",hdchen
1344,"public class Solution {
    private static BufferedReader br;
    private static StringTokenizer st;
    private static PrintWriter pw;

    public static void main(String[] args) throws Exception {
        br = new BufferedReader(new InputStreamReader(System.in));
        pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
        int tt = readInt();
        for (int zz = 1; zz <= tt; zz++) {
            int n = readInt();
            Integer[] arr = new Integer[n * 2];
            int z = 1;
            StringBuilder sb = new StringBuilder();
            long sum = 0;
            for (int i = 0; i < n; i++) {
                arr[i] = z;
                sum += z;
                sb.append(z);
                if (i < n - 1) sb.append("" "");

                if (z == 1) z = 0;
                z += 10;
            }
            System.out.println(sb);
            System.out.flush();
            //            String ret = nextLine();
//            String[] arrS = ret.split("" "");
            for (int i = 0; i < n; i++) {
                int next = readInt();
                sum += next;
                arr[n + i] = next;
            }
            System.out.println(sb);
            System.out.flush();
            

            ab(arr, 0, 0, new HashSet<>(), sum / 2);
            sb = new StringBuilder();

            Set<Integer> set = new HashSet<>(Arrays.asList(arr));
            set.removeAll(nextHalf);
            for (Integer integer : nextHalf) {
                sb.append(integer).append("" "");
            }

            for (Integer integer : set) {
                sb.append(integer).append("" "");
            }
            System.out.println(sb);
            System.out.flush();
        }
        pw.close();

    }

    static boolean found = false;
    static Set<Integer> nextHalf;
    static Set<Long> memo = new HashSet<>();

    public static void ab(Integer[] arr, int idx, long sum, Set<Integer> curr, long target) {
        if (found || idx > arr.length - 1 || memo.contains(sum) || sum > target) return;
        if (sum == target) {
            found = true;
            nextHalf = curr;
            return;
        }

        curr.add(arr[idx]);
        ab(arr, idx + 1, sum + arr[idx], curr, target);
        if (found) return;
        curr.remove(arr[idx]);
        ab(arr, idx + 1, sum, curr, target);
        if (found) return;

        memo.add(sum);

    }

    private static void exitImmediately() {
        pw.close();
        System.exit(0);
    }

    private static long readLong() throws IOException {
        return Long.parseLong(nextToken());
    }

    private static double readDouble() throws IOException {
        return Double.parseDouble(nextToken());
    }

    private static int readInt() throws IOException {
        return Integer.parseInt(nextToken());
    }

    private static String nextLine() throws IOException {
        String s = br.readLine();
        if (s == null) {
            exitImmediately();
        }
        st = null;
        return s;
    }

    private static String nextToken() throws IOException {
        while (st == null || !st.hasMoreTokens()) {
            st = ",zubaidullo
76,"public class Solution 
{
	/*
	Reminder
	1. Make sure you read EVERYTHING listed in the limits sections of each problem
	2. Walk through all examples.
	3. Use Paper!
	4. Don't dismiss brute force/simulation/save all possibilities type solutions(comes up in A).
	5. Try solving each problem by thinking backwards. Start at the endcase and work your way forward.
	*/
    public static void main(String[] args) 
	{
		Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));//make scanner
		int t = in.nextInt();//number of test cases
		for (int i = 1; i <= t; i++) //iterate through test cases
		{
			int n = in.nextInt();
			int[] cakes = new int[n];
			
			int count = 0;
			for(int rep = 0; rep < n; rep++)
			{
				cakes[rep] = in.nextInt();
			}
			
			int start = 0;
			int end = n-1;
			
			int max = 0;
			
			for(int rep = 0; rep < n; rep++)
			{
				if(cakes[start] < cakes[end])
				{
					if(cakes[start] >= max)
					{
						max = cakes[start];
						count++;
					}
					start++;
				}
				else
				{
					if(cakes[end] >= max)
					{
						max = cakes[end];
						count++;
					}
					end--;
				}
			}

			System.out.println(""Case #"" + i + "": "" + count);
		}

		in.",CoCoCoder
1225,"public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        Random rng = new Random();
        int t = sc.nextInt();
        for (int i = 0; i < t; i++) {
            int numOnes = 4;
            while (true) {
                int[] bits = new int[8];
                for (int j = 0; j < numOnes; j++) {
                    int index = rng.nextInt(8);
                    while (bits[index] == 1) {
                        index = rng.nextInt(8);
                    }
                    bits[index] = 1;
                }
                System.out.println(String.join("""", Arrays.stream(bits).mapToObj(String::valueOf).toArray(String[]::new)));
                numOnes = sc.nextInt();
                if (numOnes == -1) {
                    return;
                } else if (numOnes == 0) ",teekaytai
749,"public class Solution {
  static final int WALK_LENGTH = 1000;

  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);

    int T = sc.nextInt();
    for (int tc = 1; tc <= T; ++tc) {
      int N = sc.nextInt();
      int K = sc.nextInt();

      int edgeSum = 0;
      boolean[] used = new boolean[N + 1];
      List<Integer> orders = IntStream.rangeClosed(1, N).boxed().collect(Collectors.toList());
      Collections.shuffle(orders);
      int orderIndex = 0;
      int seenCount = 0;
      int restWalk = WALK_LENGTH;
      for (int i = 0; i <= K; ++i) {
        int R = sc.nextInt();
        int P = sc.nextInt();

        if (!used[R]) {
          used[R] = true;
          edgeSum += P;
          ++seenCount;
        }

        if (seenCount == N) {
          break;
        }

        if (i != K) {
          if (restWalk == 0) {
            int next = -1;
            while (true) {
              next = orders.get(orderIndex);
              if (!used[next]) {
                break;
              }
              ++orderIndex;
            }

            System.out.println(String.format(""T %d"", next));
            System.out.flush();

            restWalk = WALK_LENGTH;
          } else {
            System.out.println(String.format(""W""));
            System.out.flush();

            --restWalk;
          }
        }
      }

      System.out.println(
          String.format(""E %d"", (long) Math.round((double) edgeSum * N / (2 * seenCount))));
      System.out.flush();
    }

    sc.",goalboy1015
1243,"public class Solution {

  // Template
  public static void main(String[] args) throws Exception {
    final InputReader in = new InputReader(System.in);
    final OutputWriter out = new OutputWriter(System.out);
    Locale.setDefault(Locale.US);
    int T = in.readInt();
    for (int t = 1; t <= T; t++) {
      // read
      int R = in.readInt(), C = in.readInt();

      // sol
      out.printLine(nthcase(t));
      line(out, C, '.', ""-+"");
      line(out, C, '.', "".|"");
      for (int r = 1; r < R; r++) {
        line(out, C, '+', ""-+"");
        line(out, C, '|', "".|"");
      }
      line(out, C, '+', ""-+"");
    }
    out.close();
  }

  static void line(OutputWriter out, int width, char firstChar, String nextChars) {
    out.print(firstChar);
    out.print(firstChar == '.' ? '.' : nextChars.charAt(0));
    out.print(nextChars.charAt(1));
    for (int i = 1; i < width; i++) {
      out.print(nextChars);
    }
    out.printLine();
  }

  static String nthcase(int t) {
    return ""Case #"" + t + "":"";
  }

  static class InputReader {
    private InputStream stream;
    private byte[] buf = new byte[1024];
    private int curChar;
    private int numChars;

    public InputReader(InputStream stream) {
      this.stream = stream;
    }

    public int read() {
      if (numChars == -1) throw new InputMismatchException();
      if (curChar >= numChars) {
        curChar = 0;
        try {
          numChars = stream.read(buf);
        } catch (IOException e) {
          throw new InputMismatchException();
        }
        if (numChars <= 0) return -1;
      }
      return buf[curChar++];
    }

    public char readChar() {
      int c = read();
      while (isSpaceChar(c)) c = read();
      return (char) c;
    }

    public String readLine() {
      int c = read();
      while (isSpaceChar(c)) c = read();
      StringBuilder res = new StringBuilder();
      do {
        res.appendCodePoint(c);
        c = read();
      } while (!isEndOfLine(c));
      return res.toString();
    }

    public String readString() {
      int c = read();
      while (isSpaceChar(c)) c = read();
      StringBuilder res = new StringBuilder();
      do {
        res.appendCodePoint(c);
        c = read();
      } while (!isSpaceChar(c));
      return res.toString();
    }

    public long readLong() {
      int c = read();
      while (isSpaceChar(c)) c = read();
      int sgn = 1;
      if (c == '-') {
        sgn = -1;
        c = read();
      }
      long res = 0;
      do {
        if (c < '0' || c > '9') throw new InputMismatchException();
        res *= 10;
        res += c - '0';
        c = read();
      } while (!isSpaceChar(c));
      return res * sgn;
    }

    public int readInt() {
      int c = read();
      while (isSpaceChar(c)) c = read();
      int sgn = 1;
      if (c == '-') {
        sgn = -1;
        c = read();
      }
      int res = 0;
      do {
        if (c < '0' || c > '9') throw new InputMismatchException();
        res *= 10;
        res += c - '0';
        c = read();
      } while (!isSpaceChar(c));
      return res * sgn;
    }

    public boolean isSpaceChar(int c) {
      return c == ' ' || c == '
' || c == '\r' || c == '	' || c == -1;
    }

    public boolean isEndOfLine(int c) {
      return c == '
' || c == '\r' || c == -1;
    }
  }

  static class OutputWriter {
    private final PrintWriter writer;

    public OutputWriter(OutputStream outputStream) {
      writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
    }

    public OutputWriter(Writer writer) {
      this.writer = new PrintWriter(writer);
    }

    public void print(Object... objects) {
      for (int i = 0; i < objects.length; i++) {
        if (i != 0) writer.print(' ');
        writer.print(objects[i]);
      }
    }

    public void printLine(Object... objects) {
      print(objects);
      writer.println();
    }

    public void flush() {
      writer.flush();
    }
",thesamwiser
878,"public class Solution {

    public static void main(String[] args) {
        try (PrintWriter out = new PrintWriter(System.out)) {
            FastScanner in = new FastScanner(System.in);
            solve(in, out);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    private static void solve(FastScanner in, PrintWriter out) throws IOException {
        Random random = new Random();

        int t = in.nextInt();
        for (int q = 1; q <= t; q++) {

            int N = in.nextInt();
            int K = in.nextInt();

            double sum = 0;

            int S = in.nextInt();
            int P = in.nextInt();

            if (N <= K) {
                for (int r = 1; r <= N; r++) {
                    out.println(""T "" + r);
                    out.flush();

                    S = in.nextInt();
                    P = in.nextInt();

                    sum += P;
                }

                sum = sum / 2;

                out.println(""E "" + Math.round(sum));
                out.flush();

                continue;
            }

            for (int i = 0; i < K; i++) {
                int r = random.nextInt(N) + 1;
                out.println(""T "" + r);
                out.flush();

                S = in.nextInt();
                P = in.nextInt();

                sum += P;
            }

            sum = sum * N / (2 * K);

            sum = sum * 3 / 2;

            out.println(""E "" + Math.round(sum));
            out.flush();

        }
    }

    private static class FastScanner {
        private final BufferedReader reader;
        private String[] tokens = null;
        private int cnt = -1;

        public FastScanner(InputStream inputStream) {
            reader = new BufferedReader(new InputStreamReader(inputStream, StandardCharsets.UTF_8));
        }

        public String next() throws IOException {
            if (tokens == null || cnt >= tokens.length) {
                String line = reader.readLine();
                if (line != null) {
                    tokens = line.split(""\\\s"");
                } else {
                    throw new RuntimeException(""not found"");
                }
                cnt = 0;
            }
            return tokens[cnt++];
        }

        public Integer nextInt() throws IOException {
            return Integer.parseInt(next());
        }

        public Long nextLong() throws IOException {
            return Long.parseLong(next());
        }

        public Double nextDouble() throws IOException {
            return Double.parseDouble(next());
        }
    }

    private static class Pair<S, T> {
        public S first;
        public T second;

        public Pair(S first, T second) {
            this.first = first;
            this.second = second;
        }
    }
}",khlyting
720,"public class Solution {

    public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        PrintWriter writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));

        int T = in.nextInt();
        for (int casNumero = 1; casNumero <= T; casNumero++) {
            StringBuilder resultat = new StringBuilder();
            resultat.append(""Case #"");
            resultat.append(casNumero);
            resultat.append("": "");

            writer.print(resultat.toString());

            int c = in.nextInt();
            int m = in.nextInt();
            int y = in.nextInt();
            int k = in.nextInt();

            int varC = in.nextInt();
            int varM = in.nextInt();
            int varY = in.nextInt();
            int varK = in.nextInt();

            if (varC < c) {
                c = varC;
            }
            if (varM < m) {
                m = varM;
            }
            if (varY < y) {
                y = varY;
            }
            if (varK < k) {
                k = varK;
            }

            varC = in.nextInt();
            varM = in.nextInt();
            varY = in.nextInt();
            varK = in.nextInt();

            if (varC < c) {
                c = varC;
            }
            if (varM < m) {
                m = varM;
            }
            if (varY < y) {
                y = varY;
            }
            if (varK < k) {
                k = varK;
            }

            int suma = c + m + y + k;
            if (suma < 1_000_000) {
                writer.print(""IMPOSSIBLE"");
            }
            else {
                int resta = suma - 1_000_000;
                if (k >= resta) {
                    k = k - resta;
                }
                else {
                    resta = resta - k;
                    k = 0;
                    if (y >= resta) {
                        y = y - resta;
                    }
                    else {
                        resta = resta - y;
                        y = 0;
                        if (m >= resta) {
                            m = m - resta;
                        }
                        else {
                            resta = resta - m;
                            m = 0;
                            c = c - resta;
                        }
                    }
                }
                writer.print(c);
                writer.print("" "");
                writer.print(m);
                writer.print("" "");
                writer.print(y);
                writer.print("" "");
                writer.print(k);
            }
            writer.println();
        }
        in.close();
        writer.",gerardmr
588,"public class Solution {
    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        int T = s.nextInt();
        for (int ii = 1; ii <= T; ii++) {
            int N = s.nextInt();

            int[] f = new int[N];

            int[] p = new int[N];

            HashMap<Integer, ArrayList<Integer>> adjM = new
                    HashMap<>();


            for (int i = 0; i < N; i++) {
                f[i] = s.nextInt();
            }

            for (int i = 0; i < N; i++) {
                p[i] = s.nextInt();
            }

            HashSet<Integer> intermediate = new HashSet<>();
            for (int i = 0; i < N; i++) {
                intermediate.add(p[i]);
                if (p[i] != 0) {
                    if (adjM.get(i + 1) != null) {
                        ArrayList<Integer> ar = adjM.get(i + 1);
                        ar.add(p[i]);
                        adjM.put(i + 1, ar);
                    } else {
                        ArrayList<Integer> ar = new ArrayList<>();
                        ar.add(p[i]);
                        adjM.put(i + 1, ar);
                    }


                }
            }
            Integer[] leaf = new Integer[N - intermediate.size() + 1];
            int j = 0;
            for (int i = 0; i < N; i++) {
                if (!intermediate.contains(i + 1)) {
                    leaf[j] = i + 1;
                    j++;
                }
            }
            boolean[] visited = new boolean[N + 1];
            long ans = 0;
            int n = 0;
            long max = -1;
            List<Integer> permute = Arrays.asList(leaf);

            for(int i=0; i < Math.min(leaf.length * (leaf.length),500); i++){
                visited = new boolean[N + 1];
                ans = 0;

                for(Integer i1 : permute){
                    if (!visited[i1]) {
                        // System.out.println(""v="" + leaf[i]);
                        ans = ans + dfs(i1, adjM, visited, f);

                    }
                }
                max = Math.max(max, ans);
                Collections.shuffle(permute);
            }


            System.out.println(""Case #"" + ii + "": "" + max);


        }
    }

    static long dfs(int src,
                    HashMap<Integer, ArrayList<Integer>> adjM,
                    boolean[] visited, int[] f) {
        visited[src] = true;
        long funValue = f[src - 1];

        Stack<Integer> stk = new Stack<Integer>();
        stk.push(src);

        while (!stk.isEmpty()) {
            int u = stk.pop();
            if (adjM.get(u) != null) {
                for (Integer v : adjM.get(u)) {
                    if (!visited[v]) {
                        stk.push(v);
                        funValue = Math.max(funValue, f[v - 1]);
                        visited[v] = true;
                    }
                }
            }
        }

        return funValue;

    }

    public static List<List<Integer>> permute(int[] arr) {
        List<List<Integer>> list = new ArrayList<>();
        permuteHelper(list, new ArrayList<>(), arr);
        return list;
    }

    private static void permuteHelper(List<List<Integer>> list, List<Integer> resultList, int[] arr) {

        // Base case
        if (resultList.size() == arr.length) {
            list.add(new ArrayList<>(resultList));
        } else {
            for (int i = 0; i < arr.length; i++) {

                if (resultList.contains(arr[i])) {
                    // If element already exists in the list then skip
                    continue;
                }
                // Choose element
                resultList.add(arr[i]);
                // Explore
                permuteHelper(list, resultList, arr);
                // Unchoose element
                resultList.",dattap
661,"public class Solution {
    public static int N;
    public static HashSet<Integer> seen;
    public static long total;
    public static void main(String[] args) throws IOException {
        FastScanner input = new FastScanner(false);
        int T = input.nextInt();
        for (int iter = 1; iter<=T; iter++) {
            int N = input.nextInt();
            int K = input.nextInt();
            seen = new HashSet<>();
            System.out.println(""E ""+trial(N,K));
        }
    }
    public static long trial(int N, int K) throws IOException {
        FastScanner input = new FastScanner(false);
        total = 0;
        for (int i = 0; i<K; i++) {
            int R = input.nextInt();
            int P = input.nextInt();
            seen.add(R);
            total+=P;
            if (seen.size()==N) {
                return total/2;
            }
            int next = 1+(int)(Math.random()*N);
            while (seen.contains(next)) next = 1+(int)(Math.random()*N);
            System.out.println(""T ""+next);
        }
        int R = input.nextInt();
        int P = input.nextInt();
        seen.add(R);
        total+=P;
        return total*N/2/seen.size();
    }
    private static class FastScanner {
        final private int BUFFER_SIZE = 1 << 16;
        private DataInputStream din;
        private byte[] buffer;
        private int bufferPointer, bytesRead;
        private FastScanner(boolean usingFile) throws IOException {
            if (usingFile) din=new DataInputStream(new FileInputStream(""C:\\\Users\\\skwek\\\IdeaProjects\\\HelloWorld\\\src\\	esting.in""));
            else din = new DataInputStream(System.in);
            buffer = new byte[BUFFER_SIZE];
            bufferPointer = bytesRead = 0;
        }
        private short nextShort() throws IOException {
            short ret = 0;
            byte c = read();
            while (c <= ' ') c = read();
            boolean neg = (c == '-');
            if (neg) c = read();
            do ret = (short)(ret * 10 + c - '0');
            while ((c = read()) >= '0' && c <= '9');
            if (neg) return (short)-ret;
            return ret;
        }
        private int nextInt() throws IOException {
            int ret = 0;
            byte c = read();
            while (c <= ' ') c = read();
            boolean neg = (c == '-');
            if (neg) c = read();
            do ret = ret * 10 + c - '0';
            while ((c = read()) >= '0' && c <= '9');
            if (neg) return -ret;
            return ret;
        }
        public long nextLong() throws IOException {
            long ret = 0;
            byte c = read();
            while (c <= ' ') c = read();
            boolean neg = (c == '-');
            if (neg) c = read();
            do ret = ret * 10 + c - '0';
            while ((c = read()) >= '0' && c <= '9');
            if (neg) return -ret;
            return ret;
        }
        private char nextChar() throws IOException {
            byte c = read();
            while (c <= ' ') c = read();
            return (char)c;
        }
        private String nextString() throws IOException {
            StringBuilder ret = new StringBuilder();
            byte c = read();
            while (c <=' ') c = read();
            do {
                ret.append((char)c);
            } while ((c = read())>' ');
            return ret.toString();
        }
        private void fillBuffer() throws IOException {
            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);
            if (bytesRead == -1)  buffer[0] = -1;
        }
        private byte read() throws IOException ",ekwek
803,"class Module {

    public int F;

    public int index;

    private boolean _dirty = true;

    private boolean isFork;

    private boolean isInitiator;

    public boolean isFork() {

        if (_dirty) {
            isFork = parents.size() > 1;
            isInitiator = parents.size() == 0;
            _dirty = false;
        }

        return isFork;
    }

    public boolean isInitiator() {

        if (_dirty) {
            isFork = parents.size() > 1;
            isInitiator = parents.size() == 0;
            _dirty = false;
        }

        return isInitiator;
    }

    public int child;
    public List<Integer> parents;

    public Module() {
        parents = new ArrayList<>();
    }
}

public class Solution {

    public int index;

    public Module[] modules;

    public Solution(int index, int nModules) {

        this.index = index;
        modules = new Module[nModules + 1];

        for (int i = 0; i < nModules + 1; i++) {
            modules[i] = new Module();
        }
    }

    public void solve() {

        int[] moduleFun = new int[modules.length];

        var forkIds = new ArrayList<Integer>();
        var initiatorIdxs = new ArrayList<Integer>();

        for (var module : modules) {
            if (module.isFork()) {
                forkIds.add(module.index);
            } else if (module.isInitiator()) {
                initiatorIdxs.add(module.index);
            }
        }

        forkIds.sort(Comparator.reverseOrder());

        int[] forkDetonator = new int[modules.length];

        for (var forkModuleIdx : forkIds) {

            var forkModule = modules[forkModuleIdx];
            int nParents = forkModule.parents.size();

            for (int i = 0; i < nParents; i++) {

                int parentIdx = forkModule.parents.get(i);

                int f = 0;

                if (moduleFun[parentIdx] == 0) {

                    var idx = parentIdx;

                    while (moduleFun[idx] == 0) {

                        if (modules[idx].isInitiator()) {
                            break;
                        }

                        idx = modules[idx].parents.get(0);
                    }

                    while (idx >= parentIdx) {
                        f = Math.max(modules[idx].F, f);
                        idx = modules[idx].child;
                    }

                    moduleFun[parentIdx] = f;
                }
            }

            var ordered = forkModule.parents
                    .stream()
                    .sorted(Comparator.comparingInt(m -> moduleFun[m]))
                    .collect(Collectors.toList());

            var detonatorId = ordered.get(0);
            forkDetonator[forkModuleIdx] = detonatorId;
            moduleFun[forkModuleIdx] = Math.max(modules[forkModuleIdx].F, moduleFun[detonatorId]);
        }

        int score = 0;

        for (var initiatorIdx : initiatorIdxs) {

            int lastIdx = -1;
            var initiatorScore = 0;

            var idx = initiatorIdx;

            while (idx > 0) {

                var mod = modules[idx];
                if (mod.isFork()) {
                    if (forkDetonator[idx] != lastIdx) {
                        break;
                    } else {
                        initiatorScore = Math.max(initiatorScore, moduleFun[idx]);
                    }
                } else {
                    initiatorScore = Math.max(initiatorScore, mod.F);
                }

                lastIdx = idx;
                idx = mod.child;
            }

            score += initiatorScore;
        }

        System.out.printf(""Case #%d: %d%n"", index + 1, score);
    }

    public static void main(String[] args) {

        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int T = in.nextInt();

        for (int i = 0; i < T; i++) {

            int N = in.nextInt();

            var solution = new Solution(i, N);

            for (int j = 0; j < N; j++) {

                int F = in.nextInt();
                solution.modules[j + 1].F = F;
            }

            for (int j = 0; j < N; j++) {

                int index = j + 1;
                int child = in.nextInt();

                solution.modules[index].index = index;

                solution.modules[index].child = child;
                solution.modules[child].parents.add(index);
            }

            solution.",jaimuepe
961,"public class Solution{
    public static void main(String [] args)
    {
        Scanner sc=new Scanner(System.in);
        int t=sc.nextInt();
        sc.nextLine();
        int ans[]=new int[t];
        int h=0;
        while(t-->0)
        {

            int n=sc.nextInt();
            sc.nextLine();
            int a[]=new int[n];
            int count=0;

            PriorityQueue<Integer> p=new PriorityQueue<>();
            for(int i=0;i<n;i++)
            {
                a[i]=sc.nextInt();
                p.add(a[i]);



            }
            count=0;
            while (p.size()>0&&count<p.poll())
            {
                count++;
            }


            ans[h]=count;
            h++;
            sc.nextLine();
        }
        for(int i=",mukhtarsetas_gmail
693,"class Solution {
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int t = scan.nextInt();
        for (int i = 0; i < t; i++) {
            String word = scan.next();    
            String wordDouble = doubling(word);
            System.out.println(""Case #"" + (i+1) + "": "" + wordDouble);
        }
    }
    
    public static String doubling(String word) {
        String wordDouble = """";
        for (int i = 0; i < word.length()-1; i ++) { //don't compare the last one with the next(donesn't exist)
            char a = word.charAt(i);
            char b = word.charAt(i+1);
            wordDouble+= a;
            if (a < b) {
                wordDouble += a;
            }
        }
        return wordDouble + word.",forky01
776,"public class Solution {
    public static void main(String[] argu) throws Exception {
        Reader br = new Reader();
        PrintWriter pw = new PrintWriter(System.out);
        int T = br.nextInt();
        String[] cmd = new String[]{""10000000"", ""01000000"", ""00100000"", ""00010000"", ""00001000"", ""00000100"", ""00000010"", ""00000001""};
        int st = 0;
        for (int t = 1; t <= T; ++t) {
            st++;
            pw.println(""10000000"");
            pw.flush();
            int init = br.nextInt(), j = 0;
            while (j < 8) {
                pw.println(cmd[j]);
                pw.flush();
                st++;
                int num = br.nextInt();
                //System.err.format(""t = %d, cmd = %s, num = %d, st = %d
"", t, cmd[j], num, st);
                if (0 == num) break;
                if (-1 == num) return;
                if (num < init) j++;
                init = num;
            }
            /*char[] cs = new char[8];
              for (int i = 0, p = 0, pcnt = 0; i < 300; ++i) {
              int num = br.nextInt();
              if (0 == num) break;
              if (-1 == num) return;
              if (num < pcnt) p = (p + 1) % 8;
              for (int j = 0; j < 8; ++j) cs[j] = '0';
              for (int j = 0; j < num; ++j) cs[(j + p) % 8] = '1';
            //System.err.format(""num = %d, pcnt = %d, p = %d, cs = %s
"", num, pcnt, p, new String(cs));
            pcnt = num;
            pw.println(new String(cs));
            pw.flush();
            }*/
        }
        pw.close();
        br.close();
    }
    static class Reader
    {
        final private int BUFFER_SIZE = 1 << 16;
        private DataInputStream din;
        private byte[] buffer;
        private int bufferPointer, bytesRead;

        public Reader()
        {
            din = new DataInputStream(System.in);
            buffer = new byte[BUFFER_SIZE];
            bufferPointer = bytesRead = 0;
        }
        private void fillBuffer() throws IOException
        {
            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);
            if (bytesRead == -1)
                buffer[0] = -1;
        }

        private byte read() throws IOException
        {
            if (bufferPointer == bytesRead)
                fillBuffer();
            return buffer[bufferPointer++];
        }

        public void close() throws IOException
        {
            if (din == null)
                return;
            din.close();
        }
        public int nextInt() throws IOException
        {
            int ret = 0;
            byte c = read();
            while (c <= ' ')
                c = read();
            boolean neg = (c == '-');
            if (neg)
                c = read();
            do
            {
                ret = ret * 10 + c - '0';
            }  while ((c = read()) >= '0' && c <= '9');

            if (neg)
                return -ret;
            return ret;
        }
        public long nextLong() throws IOException
        {
            long ret = 0;
            byte c = read();
            while (c <= ' ')
                c = read();
            boolean neg = (c == '-');
            if (neg)
                c = read();
            do
            {
                ret = ret * 10 + c - '0';
            }  while ((c = read()) >= '0' && c <= '9');

            if (neg)
                return -ret;
            return ret;
        }

        public String readLine() throws IOException {
            byte[] buf = new byte[500001]; // line length
            int cnt = 0, c = read();
            if (-1 != c && '
' != c) buf[cnt++] = (byte) c;
            while ((c = read()) != -1)
            {
                if (c == '
')
                    break;
                buf[cnt++] = (byte) c;
            }
            return new String(buf, 0, cnt);
        }

    }
}",hdchen
1067,"public class Solution {
    public static Random random = new Random();

    public static String generate(int n){
//        n = Math.min(n, 8 - n);
        List<Character> string = new LinkedList<>();
        for(int i = 0; i < 8; i ++){
            string.add('0');
        }
        List<Integer> indices = new LinkedList<>();
        for(int i = 0; i < 8; i ++){
            indices.add(i);
        }
        Collections.shuffle(indices);
        for(int i = 0; i < n; i ++){
            int index = indices.get(i);
            string.set(index, '1');
        }
        StringBuilder sb = new StringBuilder();
        for(Character c : string){
            sb.append(c);
        }
        return sb.toString();
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        boolean flag = true;
        for(int Case = 1; Case <= T; Case ++){
            if(!flag){
                break;
            }
            int startN = random.nextInt(8);
            String string = generate(startN);
            for(int i = 0; i < 300; i ++){
                System.out.println(string);
                int n = sc.nextInt();
                if(n == 0){
                    break;
                }
                else if(n == -1){
//                    System.out.println(""Error"");
                    flag = false;
                    break;
                }
                else{
                    string = ",ql309
1056,"public class Solution {

	static Scanner sc = new Scanner(System.in);
	static int [] BIT;
	static int [] count;

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int testCases = sc.nextInt();
		
		for (int i = 1; i <= testCases; ++i) {
			solve(i);
		}
	}
	
	private static void solve(int t) {
		int n = sc.nextInt();
		
		int k = sc.nextInt();
		
		count = new int [n + 1];
		BIT = new int [n + 1];
		int currentNode, pas;
		int size = n;
		Random rand = new Random();
		int next;
		
		List<Double> data = new ArrayList<>();
		Set<Integer> set;
		
		double sum;
		int cnt;
		
		for (int i = 0; i < 160; ++i) {
			
			sum = 0;
			cnt = 0;
			set = new HashSet<>();
			
			if (i == 0) {
				next = sc.nextInt();
				pas = sc.nextInt();
				sum += pas;
				++cnt;
				set.add(next);
			}
			
			for (int j = 0; j < 50; ++j) {
				next = 1 + rand.nextInt(n);
				System.out.println(""T "" + next);
				next = sc.nextInt();
				pas = sc.nextInt();
				
				if (set.add(next)) {
					sum += pas;
					++cnt;
				}
			}
			
			data.add(sum / cnt);
		}
		
		double mean = solve(data);
		
		mean /= 2;
		
		print((long)Math.round(mean * n));
		
	}
	
	
	private static double solve(List<Double> samples) {
		double r;
		Collections.sort(samples);
		double max = samples.get(samples.size() - 1);
		
		double mean = 0;
		
		for (double val : samples)
			mean += val;
		
		mean /= samples.size();
		int maxCount = 0;
		int currentCount = 0;
		int rIdx = 0;
		int lIdx = 0;
		
		for (double l = 0.1; l <= max; l += 0.1) {
			r = l * 3 / 2;
			
			while (rIdx < samples.size() && samples.get(rIdx) <= r) {
				++currentCount;
				++rIdx;
			}
			
			while (lIdx < samples.size() && samples.get(lIdx) < l) {
				--currentCount;
				++lIdx;
			}
			
			if (currentCount >= maxCount) {
				maxCount = currentCount;
				mean = (l + r) / 2;
			}
		}
		
		return mean;
	}
	
	public static void print(long result) {
		System.",profchi
321,"public class Solution {
	
	public static void solveCase() {
		int n = in.nextInt(), k = in.nextInt();
		HashSet<Integer> investigate = new HashSet<>();
		for(int i = 1; i<=n; i++) investigate.add(i);
		long total = 0;
		int room = in.nextInt(), passages = in.nextInt();
		total += passages;
		investigate.remove(room);
		
		for(int i = 0; i<k && (!investigate.isEmpty()); i++) {
			int v = investigate.iterator().next();
			investigate.remove(v);
			out.println(""T ""+v);
			out.flush();
			room = in.nextInt();
			passages = in.nextInt();
			total += passages;
			investigate.remove(room);
		}
		if(n<=k) {
			out.println(""E ""+(total/2));
		}else {
			long p = (total*n)/k;
			out.println(""E ""+(p/2));
		}
		out.flush();
	}
	
	public static void solve() {
		int t = in.nextInt();
		for (int i = 1; i <= t; i++) {
			solveCase();
		}
	}

	public static void main(String[] args) {
		in = new Reader();
		out = new Writer();
		solve();
		out.exit();
	}

	static Reader in;
	static Writer out;

static class Reader {
	static BufferedReader br;
	static StringTokenizer st;
	
	public Reader() {
		this.br = new BufferedReader(new InputStreamReader(System.in));
	}
	
	public Reader(String f){
		try {
			this.br = new BufferedReader(new FileReader(f));
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	public int[] na(int n) {
		int[] a = new int[n];
		for (int i = 0; i < n; i++) a[i] = nextInt();
		return a;
	}

	public double[] nd(int n) {
		double[] a = new double[n];
		for (int i = 0; i < n; i++) a[i] = nextDouble();
		return a;
	}
	
	public long[] nl(int n) {
		long[] a = new long[n];
		for (int i = 0; i < n; i++) a[i] = nextLong();
		return a;
	}

	public char[] nca() {
		return next().toCharArray();
	}

	public String[] ns(int n) {
		String[] a = new String[n];
		for (int i = 0; i < n; i++) a[i] = next();
		return a;
	}

	public int nextInt() {
		ensureNext();
		return Integer.parseInt(st.nextToken());
	}

	public double nextDouble() {
		ensureNext();
		return Double.parseDouble(st.nextToken());
	}

	public Long nextLong() {
		ensureNext();
		return Long.parseLong(st.nextToken());
	}

	public String next() {
		ensureNext();
		return st.nextToken();
	}
	
	public String nextLine() {
		try {
			return br.readLine();
		} catch (Exception e) {
			e.printStackTrace();
			return null;
		}
	}
	
	private void ensureNext() {
		if (st == null || !st.hasMoreTokens()) {
			try {
				st = new StringTokenizer(br.readLine());
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	}
}

static class Util{
		private static Random random = new Random();
		static long[] fact;
		
		public static void initFactorial(int n, long mod) {
			fact = new long[n+1];
			fact[0] = 1;
			for (int i = 1; i < n+1; i++) fact[i] = (fact[i - 1] * i) % mod;
		}
		
		public static long modInverse(long a, long MOD) {
			long[] gcdE = gcdExtended(a, MOD);
			if (gcdE[0] != 1) return -1; // Inverted doesn't exist
			long x = gcdE[1];
			return (x % MOD + MOD) % MOD;
		}
		
		public static long[] gcdExtended(long p, long q) {
			if (q == 0) return new long[] { p, 1, 0 };
			long[] vals = gcdExtended(q, p % q);
			long tmp = vals[2];
			vals[2] = vals[1] - (p / q) * vals[2];
			vals[1] = tmp;
			return vals;
		}
		
		public static long nCr(int n, int r, long MOD) {
			if (r == 0) return 1;
			return (fact[n] * modInverse(fact[r], MOD) % MOD * modInverse(fact[n - r], MOD) % MOD) % MOD;
		}
		
		public static long nCr(int n, int r) {
			return (fact[n]/fact[r])/fact[n-r];
		}
		
		public static long nPr(int n, int r, long MOD) {
			if (r == 0) return 1;
			return (fact[n] * modInverse(fact[n - r], MOD) % MOD) % MOD;
		}
		public static long nPr(int n, int r) {
			return fact[n]/fact[n-r];
		}
		
		public static boolean isPrime(int n) { 
	        if (n <= 1) return false; 
	        if (n <= 3) return true; 
	        if (n % 2 == 0 || n % 3 == 0) return false; 
	        for (int i = 5; i * i <= n; i = i + 6) 
	            if (n % i == 0 || n % (i + 2) == 0) 
	            return false; 
	        return true; 
	    }
		
	    public static boolean[] getSieve(int n) {
	        boolean[] isPrime = new boolean[n+1];
	        for (int i = 2; i <= n; i++) isPrime[i] = true;
	        for (int i = 2; i*i <= n; i++) if (isPrime[i]) 
	                for (int j = i; i*j <= n; j++) isPrime[i*j] = false;
	        return isPrime;
	    }
	    
	    static long pow(long x, long pow, long mod){
	    	long res = 1;
	    	x = x % mod;
	    	if (x == 0) return 0;
	    	while (pow > 0){
	    		if ((pow & 1) != 0) res = (res * x) % mod;
	        	pow >>= 1;
	        	x = (x * x) % mod;
	    	}
	    	return res;
	    }
	    
	    public static int gcd(int a, int b) { 
	    	int tmp = 0;
	    	while(b != 0) {
	    		tmp = b;
	    		b = a%b;
	    		a = tmp;
	    	}
	    	return a;
	    }
	    
	    public static long gcd(long a, long b) { 
	    	long tmp = 0;
	    	while(b != 0) {
	    		tmp = b;
	    		b = a%b;
	    		a = tmp;
	    	}
	    	return a;
	    }
	    
	    public static int random(int min, int max) {
	    	return random.nextInt(max-min+1)+min;
	    }
	    
		public static void dbg(Object... o) { 
			System.out.println(Arrays.deepToString(o)); 
		}
		
		public static void reverse(int[] s, int l , int r) {
			for(int i = ",Restricted
956,"public class Solution {

	public static void main(String[] args) {
		Scanner s = new Scanner(System.in);
		int i, j, k, l, t, diferenca;
		int p1[] = new int[4];
		int p2[] = new int[4];
		int p3[] = new int[4];
		int saida1[] = new int[4];
		int saida2[] = new int[4];
 		
		do {
			t = s.nextInt();
		} while(t < 1 || t > 100);
		
		for(i = 1; i <= t; i++) {
			l = 0;
			
				for(k = 0; k < 4; k++) {
					do {
						p1[k] = s.nextInt();
						
					} while(p1[k] < 0 || p1[k] > (int) Math.pow(10, 6));
				}
				
				for(k = 0; k < 4; k++) {
					do {
						p2[k] = s.nextInt();
						
					} while(p2[k] < 0 || p2[k] > (int) Math.pow(10, 6));
				}
				
				for(k = 0; k < 4; k++) {
 					do {
						p3[k] = s.nextInt();
						
					} while(p3[k] < 0 || p3[k] > (int) Math.pow(10, 6));
				}
			
			for(j = 0; j < 4; j++) {
				
				if(p1[j] <= p2[j] & p1[j] <= p3[j]) {
					saida1[l] = p1[j];
				} else if(p2[j] <= p3[j]) {
					saida1[l] = p2[j];
				} else {
					saida1[l] = p3[j];
				}
				
				if(p1[j] == 0)
					if(p2[j] <= p3[j])
						saida1[l] = p2[j];
					else
						saida1[l] = p3[j];
				
				if(p2[j] == 0)
					if(p1[j] <= p3[j])
						saida1[l] = p1[j];
					else
						saida1[l] = p3[j];
				
				if(p3[j] == 0)
					if(p1[j] <= p2[j])
						saida1[l] = p1[j];
					else
						saida1[l] = p2[j];
				
				if(p1[j] == 0 && p2[j] == 0)
					saida1[l] = p3[j];
				
				if(p2[j] == 0 && p3[j] == 0)
					saida1[l] = p1[j];
				
				if(p1[j] == 0 && p3[j] == 0)
					saida1[l] = p2[j];
				
				l++;
			}

			l = 0;
			System.out.print(""Case #"" + i + "": "");
			
			if((saida1[0] + saida1[1] + saida1[2] + saida1[3]) >=  Math.pow(10, 6)) {
				
				diferenca = saida1[0] + saida1[1] + saida1[2] + saida1[3] - 10 * 10 * 10 * 10 * 10 * 10;
				
				while(diferenca > 0) {
					saida1[l]--;
					diferenca--;
					l++;
					
					if(l == 3)
						l = 0;
				}
				
				saida1[0] = saida1[0] / 3 + saida1[0] % 3;
				saida1[1] = saida1[1] / 3 + saida1[1] % 3;
				saida1[2] = saida1[2] / 3 + saida1[2] % 3;
				saida1[3] = saida1[3] / 3 + saida1[3] % 3;
				
				System.out.print(saida2[0] + "" "" + saida2[1] + "" "" + saida2[2] + "" "" + saida2[3]);
			} else {
				System.out.print(""IMPOSSIBLE"");
			}
			
			if(i != 1)
				System.",marcosph
358,"public class Solution {

    public static void main(String[] args) throws IOException {
        Scanner sc = new Scanner(System.in);
        PrintWriter pw = new PrintWriter(System.out);

        int testCases = sc.nextInt();
        for (int testCase = 1; testCase <= testCases; testCase++) {
            int[] colors = new int[4];
            for (int i = 0; i < 4; i++) {
                colors[i] = sc.nextInt();
            }
            for (int i = 0; i < 2; i++) {
                for (int j = 0; j < 4; j++) {
                    colors[j] = Math.min(colors[j], sc.nextInt());
                }
            }

            if (colors[0] == 0 || colors[1] == 0 || colors[2] == 0 || colors[3] == 0) {
                pw.println(""Case #"" + testCase + "": IMPOSSIBLE"");
                continue;
            } else if (Arrays.stream(colors).sum() > 1_000_000) {
                int remain = Arrays.stream(colors).sum() - 1_000_000;
                for (int i = 0; i < 4 && remain > 0; i++) {
                    if (remain > colors[i]) {
                        remain -= colors[i];
                        colors[i] = 0;
                    } else {
                        colors[i] -= remain;
                        remain = 0;
                    }
                }
            }
            pw.println(""Case #"" + testCase + "": "" + colors[0] + "" "" + colors[1] + "" "" + colors[2] + "" "" + colors[3]);
        }

        pw.close();
        sc.",S
126,"class Solution {
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        List<String> output = new ArrayList<>();
        for(int i = 1; i <= n; i ++){
            int size = sc.nextInt();
            Deque<Integer> deque = new ArrayDeque<>();
            for (int j = 0; j < size; j ++) {
                deque.add(sc.nextInt());
            }
            output.add(""Case #"" + i + "": "" + check(deque));
        }
        output.forEach(System.out::println);
    }

    public static int check(Deque<Integer> deque){

        int res = 0;
        int prev = 0;
        while(!deque.isEmpty()) {
            int first = deque.peekFirst();
            int last = deque.peekLast();
            if (first < prev && last < prev) {
                break;
            }
            if (first < last) {
                if (first >= prev) {
                    prev = deque.pollFirst();
                    res ++;
                } else {
                    deque.pollFirst();
                }
            } else {
                if (last >= prev) {
                    res ++;
                    prev = deque.pollLast();
                } else {
                    deque.pollLast();
                }
            }
        }

        return res;

    }
",Em11
546,"public class Solution {
//public class B2 {
    public static void main(String[] args) throws IOException {
        //BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(""in.txt"")));
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int ttt = Integer.parseInt(br.readLine());
        for (int tt = 1; tt <= ttt; ++tt) {
            String[] cc = br.readLine().split("" "");
            final int n = Integer.parseInt(cc[0]);
            final int p = Integer.parseInt(cc[1]);

            final int[][] all = new int[n][p];
            for (int nn = 0; nn < n; nn++) {
                cc = br.readLine().split("" "");
                for (int pp = 0; pp < p; pp++) {
                    all[nn][pp] = Integer.parseInt(cc[pp]);
                }
            }

            final int[][] q = new int[n][2];
            for (int i = 0; i < n; i++) {
                int min = Integer.MAX_VALUE;
                int max = Integer.MIN_VALUE;
                for (int x : all[i]) {
                    min = Math.min(min, x);
                    max = Math.max(max, x);
                }
                q[i][0] = min;
                q[i][1] = max;
            }

            long answ = 0;
            for (int[] x : q) {
                answ += (long) (x[1] - x[0]);
            }

            //System.out.println(answ);

            int[] elements = new int[n];
            for (int i = 0; i < n; i++) {
                elements[i] = i;
            }

            long best = Integer.MAX_VALUE;

            best = Math.min(calc(elements, q), best);

            System.out.println(""Case #"" + tt + "": "" + (answ + best));

        }
    }

    private static long calc(int[] elements, int[][] q) {
        long[][] res = new long[elements.length][2];
        res[0][0] = q[elements[0]][1] * 2 - q[elements[0]][0];
        res[0][1] = q[elements[0]][0];
        for (int i = 1; i < elements.length; i++) {
            final int prevTop = q[elements[i - 1]][1];
            final int prevBottom = q[elements[i - 1]][0];

            final int currTop = q[elements[i]][1];
            final int currBottom = q[elements[i]][0];

            res[i][0] = Math.min(Math.abs(currTop - prevTop) + res[i - 1][1], Math.abs(currTop - prevBottom) + res[i - 1][0]);
            res[i][1] = Math.min(Math.abs(currBottom - prevTop) + res[i - 1][1], Math.abs(currBottom - prevBottom) + res[i - 1][0]);
        }


        return Math.min(res[elements.length - 1][0], res[elements.length - 1][1]);
    }

    private static void swap(int[] input, int a, int b) {
        int tmp = input[a];
        input[a] = input[b];
        input[b] = ",attila
1181,"public class Solution {
    public static void main(String[] args) throws IOException {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt();
        for(int i = 0; i < t; ++ i){
            testCase(scanner);
        }
    }

    public static void testCase(final Scanner scanner){
        long n = scanner.nextLong();
        long s1 =  (n * (n + 1)) / 2;
        long f = s1;
        System.out.println(LongStream.range(1,n+1).boxed().map(String::valueOf).collect(Collectors.joining("" "")));
        List<Long> others = LongStream.range(1,n+1).boxed().map(x -> scanner.nextLong()).sorted().collect(Collectors.toList());
        long s2 = others.stream().reduce((x, y) -> x + y).orElse(0L);

        List<Long> cdf = new ArrayList<>();
        long sum = 0;
        for(Long x : others){
            sum += x;
            cdf.add(sum);
        }
        int i = 0;
        int j = 0;


       for(i = 0; i < others.size(); ++i){
           for(j = i + 1; j < others.size(); ++ j){
               if(cdf.get(j) - cdf.get(i) <= f){
                   break;
               }
           }
       }

       Long d = cdf.get(j) - cdf.get(i);
       List<Long> rVal1 = LongStream.range(1,n+1).boxed().filter(x -> x == d).collect(Collectors.toList());
       List<Long> rVal2 = ",smartelf
454,"public class Solution {


    public static void main(String[] args) throws Exception {

        int t=sc.nextInt();
       out: while(t-->0){
            int cnt=8;
            int ii=0;
            while(true){
                ii++;
                if(ii%20==0)cnt=8;
                int S=(int)(Math.random()*256)+1;
                while(Integer.bitCount(S)!=cnt){
                    S=(int)(Math.random()*256)+1;
                }
                String s=Integer.toBinaryString(S);

                pw.println(s);
                pw.flush();
                int x=sc.nextInt();
                cnt=x;
                if(x==-1){
                    break out;
                }
                if(x==0){
                    break;
                }

            }
        }

        pw.close();
    }

    static class Scanner {
        StringTokenizer st;
        BufferedReader br;

        public Scanner(InputStream s) {
            br = new BufferedReader(new InputStreamReader(s));
        }

        public Scanner(FileReader r) {
            br = new BufferedReader(r);
        }

        public String next() throws IOException {
            while (st == null || !st.hasMoreTokens())
                st = new StringTokenizer(br.readLine());
            return st.nextToken();
        }

        public int nextInt() throws IOException {
            return Integer.parseInt(next());
        }

        public long nextLong() throws IOException {
            return Long.parseLong(next());
        }

        public String nextLine() throws IOException {
            return br.readLine();
        }

        public double nextDouble() throws IOException {
            String x = next();
            StringBuilder sb = new StringBuilder(""0"");
            double res = 0, f = 1;
            boolean dec = false, neg = false;
            int start = 0;
            if (x.charAt(0) == '-') {
                neg = true;
                start++;
            }
            for (int i = start; i < x.length(); i++)
                if (x.charAt(i) == '.') {
                    res = Long.parseLong(sb.toString());
                    sb = new StringBuilder(""0"");
                    dec = true;
                } else {
                    sb.append(x.charAt(i));
                    if (dec)
                        f *= 10;
                }
            res += Long.parseLong(sb.toString()) / f;
            return res * (neg ? -1 : 1);
        }

        public long[] nextlongArray(int n) throws IOException {
            long[] a = new long[n];
            for (int i = 0; i < n; i++)
                a[i] = nextLong();
            return a;
        }

        public Long[] nextLongArray(int n) throws IOException {
            Long[] a = new Long[n];
            for (int i = 0; i < n; i++)
                a[i] = nextLong();
            return a;
        }

        public int[] nextIntArray(int n) throws IOException {
            int[] a = new int[n];
            for (int i = 0; i < n; i++)
                a[i] = nextInt();
            return a;
        }

        public Integer[] nextIntegerArray(int n) throws IOException {
            Integer[] a = new Integer[n];
            for (int i = 0; i < n; i++)
                a[i] = nextInt();
            return a;
        }

        public boolean ready() throws IOException {
            return br.ready();
        }

    }

    static class pair implements Comparable<pair> {
        long x;
        long y;

        public pair(long x, long y) {
            this.x = x;
            this.y = y;
        }

        public String toString() {
            return x + "" "" + y;
        }

        public boolean equals(Object o) {
            if (o instanceof pair) {
                pair p = (pair) o;
                return p.x == x && p.y == y;
            }
            return false;
        }

        public int hashCode() {
            return new Long(x).hashCode() * 31 + new Long(y).hashCode();
        }

        public int compareTo(pair other) {
            if (this.x == other.x) {
                return Long.compare(this.y, other.y);
            }
            return Long.compare(this.x, other.x);
        }
    }

    static class tuble implements Comparable<tuble> {
        int x;
        int y;
        int z;

        public tuble(int x, int y, int z) {
            this.x = x;
            this.y = y;
            this.z = z;
        }

        public String toString() {
            return x + "" "" + y + "" "" + z;
        }

        public int compareTo(tuble other) {
            if (this.x == other.x) {
                if (this.y == other.y) {
                    return this.z - other.z;
                }
                return this.y - other.y;
            } else {
                return this.x - other.x;
            }
        }
    }

    static long mod = 1000000007;
    static Random rn = new Random();
    static Scanner sc = ",ZerooCool
608,"public class Solution {
    public static void main(String[] args) {
        (new Solution()).readInput();
    }


    public void readInput() {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int caseCount = in.nextInt();
        for (int caseId = 1; caseId <= caseCount; ++caseId) {
            int n = in.nextInt();
            Deque<Integer> deque = new ArrayDeque<>();
            for (int i=0;i<n;i++){
                int di = in.nextInt();
                deque.add(di);
            }
            System.out.println(""Case #"" + caseId + "": "" + solve(deque));
        }
    }


    private int solve(Deque<Integer> deque){
        int score=0;
        int previous=0;
        while(deque.size()>0){

            int first = deque.getFirst();
            int last = deque.getLast();

            if (first>=previous && last>=previous){
                if (first<last){
                    previous = deque.removeFirst();
                    score++;
                } else{
                    previous = deque.removeLast();
                    score++;
                }
            } else if (first>=previous){
                previous = deque.removeFirst();
                score++;
            } else if (last>=previous){
                previous = deque.removeLast();
                score++;
            } else ",dboteanu
260,"public class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        int t = in.nextInt();
        for (int i=1; i<=t; i++) {
            int n = in.nextInt();
            int k = in.nextInt();
            int firstRoom = in.nextInt();
            int roomQueries = 1;
            long links = in.nextInt();;
            int roomIndex = 1;
            while(k>0 && roomIndex<=n) {
                if (roomIndex == firstRoom)
                    roomIndex +=1;
                System.out.println(""T "" + roomIndex);
                in.nextInt();
                int thisLink = in.nextInt();
                roomQueries += 1;
                links += thisLink;
                roomIndex +=1;
                k -= 1;
            }
            if (roomQueries<n) {
                links += (links/roomQueries)*(n-roomQueries);
            }
            links = ",MehdiKalhori
780,"public class Solution {

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        PrintStream out = System.out;

        try {
            // in = new Scanner(new BufferedReader(new FileReader(""/Users/Shared/Sources/CodingStudy/src/codejam/year2022/round_1B/PancakeDeque/sample/sample_ts1-in.txt"")));
            // out = new PrintStream(new FileOutputStream(""/Users/Shared/Sources/CodingStudy/src/codejam/year2022/round_1B/PancakeDeque/sample/sample_ts1-out.txt""));
        } catch (Exception e) {
            e.printStackTrace();
            return;
        }

        int T = in.nextInt();
        for (int t = 1; t <= T; t++) {
            int N = in.nextInt();
            int[] D = new int[N];
            for (int n = 0; n < N; n++) {
                D[n] = in.nextInt();
            }

            int ans = getAnswer(t, D);
            out.printf(""Case #%d: %s
"", t, ans);

//            System.err.println(""------------------"");
        }
        in.close();
    }

    private static int getAnswer(int t, int[] D) {
        // Each time, compare head and tail for deque.
        // Select last delicious <= head,  last delicious <= tail,

        ArrayDeque<Integer> deque = new ArrayDeque<>(Arrays.stream(D).boxed().collect(Collectors.toList()));

        int count = 0;
        int lastDelicious = 0;
        for (int i = 0; i < D.length; i++) {
//            System.err.println(deque);
            int head = deque.peekFirst();
            int tail = deque.peekLast();

            int ele;
            if (head <= tail) {
                if (lastDelicious <= head) {
                    // Select head
                    count++;
                    ele = deque.pollFirst();
                } else if (lastDelicious <= tail) {
                    // Select tail
                    count++;
                    ele = deque.pollLast();
                } else {
                    // Select head without pay
                    ele = deque.pollFirst();
                }
            } else {
                if (lastDelicious <= tail) {
                    // Select tail
                    count++;
                    ele = deque.pollLast();
                } else if (lastDelicious <= head) {
                    // Select head
                    count++;
                    ele = deque.pollFirst();
                } else {
                    // Select tail without pay.
                    ele = deque.pollLast();
                }
            }

//            System.err.println(ele);

            if (lastDelicious <= ele)
                lastDelicious = ele;
            else
                break;
        }

        return count;
    }
}",id
62,"public class Solution {
	static Scanner sc;
	static StringBuffer s;

  public static void main(String[] args)throws Exception{
	  sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
	  //sc = new Scanner(new BufferedReader(new InputStreamReader(new FileInputStream(new File(""src/input.txt""))))); 
    
     int nbTest = sc.nextInt();
     
	 for(int test = 1;test<=nbTest;test++){ 	   	 	
	 	solve(test);
	 }   
	 
  }
  
  static void solve (int test) {
	  int N = sc.nextInt();
	  List<Integer> list = new ArrayList<Integer>();
	  List<Integer> buf = new ArrayList<Integer>();
	  int[] tab = new int[1000000];
	  int res = 0;
	  int a;
	  for (int i = 0; i<N;i++) {
		  a = sc.nextInt();
		  list.add(a);
		  tab[a+1]++;
	  }
	  
	  int max = Collections.max(list);
	  boolean flag = false;
	  
	  for (int i = 1; i<=N;i++) {
		  
		  for (int j = i; j<=max ; j++) {
			  if (tab[j] > 0) {
				  tab[j]--;
				  flag = true;
				  break;
			  } 			  
		  }
		  
		  if (flag==false) {
			  System.out.println(""Case #""+test+"": ""+i);
			  return;
		  }
			  
		  flag = false;
		  
		  res = ",Bil1983
676,"public class Solution {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        FastScanner in = new FastScanner(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        E_TwistyLittlePassages solver = new E_TwistyLittlePassages();
        solver.solve(1, in, out);
        out.close();
    }

    static class E_TwistyLittlePassages {
        public void solve(int testNumber, FastScanner in, PrintWriter out) {
            SplittableRandom random = new SplittableRandom(0);

            int numTests = in.nextInt();
            for (int test = 0; test < numTests; test++) {
                int n = in.nextInt();
                int k = in.nextInt();
                if (k != 8000) {
                    throw new AssertionError(""bad k: "" + k);
                }
                int[] deg = new int[n];
                Arrays.fill(deg, -1);

                long edgesSeen = 0;
                int roomsSeen = 0;
                for (int iter = 0; iter < k; iter++) {
                    int v = in.nextInt() - 1;
                    int d = in.nextInt();
                    boolean newRoom = false;
                    if (deg[v] < 0) {
                        roomsSeen += 1;
                        edgesSeen += d;
                        newRoom = true;
                    }
                    deg[v] = d;

                    if (d > 3) {
                        out.println(""W"");
                        out.flush();
                    } else {
                        out.println(""T "" + (random.nextInt(n) + 1));
                        out.flush();
                    }
                }

                in.nextInt();
                in.nextInt();
                long ans = edgesSeen * n / roomsSeen / 2;
                out.println(""E "" + ans);
                out.flush();
            }
            out.close();
        }

    }

    static class FastScanner {
        private BufferedReader in;
        private StringTokenizer st;

        public FastScanner(InputStream stream) {
            in = new BufferedReader(new InputStreamReader(stream));
        }

        public String next() {
            while (st == null || !st.hasMoreTokens()) {
                try {
                    st = new StringTokenizer(in.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return st.nextToken();
        }

        public int nextInt() {
            return Integer.",fetetriste
1032,"public class Solution {

    public static void main(String... args) {
        Scanner sc = new Scanner(System.in);
        int count = sc.nextInt();
        for (int i = 0; i < count; i++) {
            int size = sc.nextInt();
            Deque<Integer> pancakes = new LinkedList<>();
            for (int j = 0; j < size; j++) {
                pancakes.add(sc.nextInt());
            }
            System.out.println(""Case #"" + (i + 1) + "": "" + count(pancakes));
        }
    }

    public static int count(Deque<Integer> pancakes) {
        int prev = -1;
        int result = 0;
        if (!pancakes.isEmpty()) {
            throw new IllegalArgumentException("""" + pancakes);
        }
        
        while(true) {
            if (pancakes.isEmpty()) {
                break;
            }
            int left = pancakes.getFirst();
            int right = pancakes.getLast();
            boolean leftValid = left >= prev;
            boolean rightValid = right >= prev;
            boolean takeLeft = left <= right;
            if (!leftValid && !rightValid) {
                break;
            }
            result++;
            int current = -1;
            if (leftValid && rightValid) {
                if (left < right) {
                    current = pancakes.getFirst();
                    pancakes.removeFirst();
                } else {
                    current = pancakes.getLast();
                    pancakes.removeLast();
                }
            }else if (leftValid) {
                current = pancakes.getFirst();
                pancakes.removeFirst();
            }else {
                current = pancakes.getLast();
                pancakes.removeLast();
            }
            
            prev = ",petrus
687,"public class Solution {
    public static void main(String[] args) {
        InputStream inputStream = System.in;
        OutputStream outputStream = System.out;
        FastScanner in = new FastScanner(inputStream);
        PrintWriter out = new PrintWriter(outputStream);
        E_TwistyLittlePassages solver = new E_TwistyLittlePassages();
        solver.solve(1, in, out);
        out.close();
    }

    static class E_TwistyLittlePassages {
        public void solve(int testNumber, FastScanner in, PrintWriter out) {
            SplittableRandom random = new SplittableRandom(0);

            int numTests = in.nextInt();
            for (int test = 0; test < numTests; test++) {
                int n = in.nextInt();
                int k = in.nextInt();
                if (k != 8000) {
                    throw new AssertionError(""bad k: "" + k);
                }
                int[] deg = new int[n];
                Arrays.fill(deg, -1);

                long edgesSeen = 0;
                int roomsSeen = 0;

                long edgesFromBigSeen = 0;
                int bigRoomsSeen = 0;
                for (int iter = 0; iter < k; iter++) {
                    int v = in.nextInt() - 1;
                    int d = in.nextInt();
                    boolean newRoom = false;
                    if (deg[v] < 0) {
                        roomsSeen += 1;
                        edgesSeen += d;
                        newRoom = true;
                        if (d > 300) {
                            bigRoomsSeen += 1;
                            edgesFromBigSeen += d;
                        }
                    }
                    deg[v] = d;

                    if (d > 2 && d < 300) {
                        out.println(""W"");
                        out.flush();
                    } else {
                        out.println(""T "" + (random.nextInt(n) + 1));
                        out.flush();
                    }
                }

                in.nextInt();
                in.nextInt();
                long ans = edgesSeen * n / roomsSeen / 2;
                if (bigRoomsSeen > 0) {
                    ans = edgesFromBigSeen / 2;
                }
                out.println(""E "" + ans);
                out.flush();
            }
            out.close();
        }

    }

    static class FastScanner {
        private BufferedReader in;
        private StringTokenizer st;

        public FastScanner(InputStream stream) {
            in = new BufferedReader(new InputStreamReader(stream));
        }

        public String next() {
            while (st == null || !st.hasMoreTokens()) {
                try {
                    st = new StringTokenizer(in.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return st.nextToken();
        }

        public int nextInt() {
            return Integer.",fetetriste
802,"class Module {

    public int F;

    public int index;

    private boolean _dirty = true;

    private boolean isFork;

    private boolean isInitiator;

    public boolean isFork() {

        if (_dirty) {
            isFork = parents.size() > 1;
            isInitiator = parents.size() == 0;
            _dirty = false;
        }

        return isFork;
    }

    public boolean isInitiator() {

        if (_dirty) {
            isFork = parents.size() > 1;
            isInitiator = parents.size() == 0;
            _dirty = false;
        }

        return isInitiator;
    }

    public int child;
    public List<Integer> parents;

    public Module() {
        parents = new ArrayList<>();
    }
}

public class Solution {

    public int index;

    public Module[] modules;

    public Solution(int index, int nModules) {

        this.index = index;
        modules = new Module[nModules + 1];

        for (int i = 0; i < nModules + 1; i++) {
            modules[i] = new Module();
        }
    }

    public void solve() {

        int[] moduleFun = new int[modules.length];

        var forkIds = new ArrayList<Integer>();
        var initiatorIdxs = new ArrayList<Integer>();

        for (var module : modules) {
            if (module.isFork()) {
                forkIds.add(module.index);
            } else if (module.isInitiator()) {
                initiatorIdxs.add(module.index);
            }
        }

        forkIds.sort(Comparator.reverseOrder());

        int[] forkDetonator = new int[modules.length];

        for (var forkModuleIdx : forkIds) {

            var forkModule = modules[forkModuleIdx];
            int nParents = forkModule.parents.size();

            for (int i = 0; i < nParents; i++) {

                int parentIdx = forkModule.parents.get(i);

                if (moduleFun[parentIdx] == 0) {

                    var idx = parentIdx;

                    while (moduleFun[idx] == 0) {

                        if (modules[idx].isInitiator()) {
                            break;
                        }

                        idx = modules[idx].parents.get(0);
                    }

                    int f = 0;

                    while (idx >= parentIdx) {
                        f = Math.max(modules[idx].F, f);
                        idx = modules[idx].child;
                    }

                    moduleFun[parentIdx] = f;
                }
            }

            var detonatorId = forkModule.parents
                    .stream()
                    .min(Comparator.comparingInt(m -> moduleFun[m])).get();

            forkDetonator[forkModuleIdx] = detonatorId;
            moduleFun[forkModuleIdx] = Math.max(modules[forkModuleIdx].F, moduleFun[detonatorId]);
        }

        long score = 0;

        for (var initiatorIdx : initiatorIdxs) {

            int lastIdx = -1;
            var initiatorScore = 0;

            var idx = initiatorIdx;

            while (idx > 0) {

                var mod = modules[idx];
                if (mod.isFork()) {
                    if (forkDetonator[idx] != lastIdx) {
                        break;
                    } else {
                        initiatorScore = Math.max(initiatorScore, moduleFun[idx]);
                    }
                } else {
                    initiatorScore = Math.max(initiatorScore, mod.F);
                }

                lastIdx = idx;
                idx = mod.child;
            }

            score += initiatorScore;
        }

        System.out.printf(""Case #%d: %d%n"", index + 1, score);
    }

    public static void main(String[] args) {

        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int T = in.nextInt();

        for (int i = 0; i < T; i++) {

            int N = in.nextInt();

            var solution = new Solution(i, N);

            for (int j = 0; j < N; j++) {

                int F = in.nextInt();
                solution.modules[j + 1].F = F;
            }

            for (int j = 0; j < N; j++) {

                int index = j + 1;
                int child = in.nextInt();

                solution.modules[index].index = index;

                solution.modules[index].child = child;
                solution.modules[child].parents.add(index);
            }

            solution.",jaimuepe
315,"public class Solution {
	
	public static void solveCase() {
		int n = in.nextInt();
		int[] a = in.na(n);
		Arrays.sort(a);
		int curIdx = 0;
		for(int i : a) {
			if(i <= curIdx) continue;
			curIdx++;
		}
		out.println(curIdx);
	}
	
	public static void solve() {
		int t = in.nextInt();
		for (int i = 1; i <= t; i++) {
			out.print(""Case #"" + i + "": "");
			solveCase();
		}
	}

	public static void main(String[] args) {
		in = new Reader();
		out = new Writer();
		solve();
		out.exit();
	}

	static Reader in;
	static Writer out;

static class Reader {
	static BufferedReader br;
	static StringTokenizer st;
	
	public Reader() {
		br = new BufferedReader(new InputStreamReader(System.in));
	}
	
	public Reader(String f){
		try {
			br = new BufferedReader(new FileReader(f));
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	public int[] na(int n) {
		int[] a = new int[n];
		for (int i = 0; i < n; i++) a[i] = nextInt();
		return a;
	}

	public double[] nd(int n) {
		double[] a = new double[n];
		for (int i = 0; i < n; i++) a[i] = nextDouble();
		return a;
	}
	
	public long[] nl(int n) {
		long[] a = new long[n];
		for (int i = 0; i < n; i++) a[i] = nextLong();
		return a;
	}

	public char[] nca() {
		return next().toCharArray();
	}

	public String[] ns(int n) {
		String[] a = new String[n];
		for (int i = 0; i < n; i++) a[i] = next();
		return a;
	}

	public int nextInt() {
		ensureNext();
		return Integer.parseInt(st.nextToken());
	}

	public double nextDouble() {
		ensureNext();
		return Double.parseDouble(st.nextToken());
	}

	public Long nextLong() {
		ensureNext();
		return Long.parseLong(st.nextToken());
	}

	public String next() {
		ensureNext();
		return st.nextToken();
	}
	
	public String nextLine() {
		try {
			return br.readLine();
		} catch (Exception e) {
			e.printStackTrace();
			return null;
		}
	}
	
	private void ensureNext() {
		if (st == null || !st.hasMoreTokens()) {
			try {
				st = new StringTokenizer(br.readLine());
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	}
}

static class Util{
		private static Random random = new Random();
		static long[] fact;
		
		public static void initFactorial(int n, long mod) {
			fact = new long[n+1];
			fact[0] = 1;
			for (int i = 1; i < n+1; i++) fact[i] = (fact[i - 1] * i) % mod;
		}
		
		public static long modInverse(long a, long MOD) {
			long[] gcdE = gcdExtended(a, MOD);
			if (gcdE[0] != 1) return -1; // Inverted doesn't exist
			long x = gcdE[1];
			return (x % MOD + MOD) % MOD;
		}
		
		public static long[] gcdExtended(long p, long q) {
			if (q == 0) return new long[] { p, 1, 0 };
			long[] vals = gcdExtended(q, p % q);
			long tmp = vals[2];
			vals[2] = vals[1] - (p / q) * vals[2];
			vals[1] = tmp;
			return vals;
		}
		
		public static long nCr(int n, int r, long MOD) {
			if (r == 0) return 1;
			return (fact[n] * modInverse(fact[r], MOD) % MOD * modInverse(fact[n - r], MOD) % MOD) % MOD;
		}
		
		public static long nCr(int n, int r) {
			return (fact[n]/fact[r])/fact[n-r];
		}
		
		public static long nPr(int n, int r, long MOD) {
			if (r == 0) return 1;
			return (fact[n] * modInverse(fact[n - r], MOD) % MOD) % MOD;
		}
		public static long nPr(int n, int r) {
			return fact[n]/fact[n-r];
		}
		
		public static boolean isPrime(int n) { 
	        if (n <= 1) return false; 
	        if (n <= 3) return true; 
	        if (n % 2 == 0 || n % 3 == 0) return false; 
	        for (int i = 5; i * i <= n; i = i + 6) 
	            if (n % i == 0 || n % (i + 2) == 0) 
	            return false; 
	        return true; 
	    }
		
	    public static boolean[] getSieve(int n) {
	        boolean[] isPrime = new boolean[n+1];
	        for (int i = 2; i <= n; i++) isPrime[i] = true;
	        for (int i = 2; i*i <= n; i++) if (isPrime[i]) 
	                for (int j = i; i*j <= n; j++) isPrime[i*j] = false;
	        return isPrime;
	    }
	    
	    static long pow(long x, long pow, long mod){
	    	long res = 1;
	    	x = x % mod;
	    	if (x == 0) return 0;
	    	while (pow > 0){
	    		if ((pow & 1) != 0) res = (res * x) % mod;
	        	pow >>= 1;
	        	x = (x * x) % mod;
	    	}
	    	return res;
	    }
	    
	    public static int gcd(int a, int b) { 
	    	int tmp = 0;
	    	while(b != 0) {
	    		tmp = b;
	    		b = a%b;
	    		a = tmp;
	    	}
	    	return a;
	    }
	    
	    public static long gcd(long a, long b) { 
	    	long tmp = 0;
	    	while(b != 0) {
	    		tmp = b;
	    		b = a%b;
	    		a = tmp;
	    	}
	    	return a;
	    }
	    
	    public static int random(int min, int max) {
	    	return random.nextInt(max-min+1)+min;
	    }
	    
		public static void dbg(Object... o) { 
			System.out.println(Arrays.deepToString(o)); 
		}
		
		public static void reverse(int[] s, int l , int r) {
			for(int i = l; i<=(l+r)/2; i++) {
				int tmp = s[i];
				s[i] = s[r+l-i];
				s[r+l-i] = tmp;
			}
	    }
		
		public static void reverse(int[] s) {
			reverse(s, 0, s.length-1);
	    }
		
		public static void reverse(long[] s, int l , int r) {
			for(int i = l; i<=(l+r)/2; i++) {
				long tmp = s[i];
				s[i] = s[r+l-i];
				s[r+l-i] = ",Restricted
1141,"public class Solution {

    public static void main(String[] args) {

        try {
            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
            int numTests = Integer.parseInt(br.readLine());
            int cnt = 1;
            while (cnt <= numTests) {
                String NandK = br.readLine();

                String[] split = NandK.split("" "");
                int n = Integer.parseInt(split[0]); // rooms
                int K = Integer.parseInt(split[1]); // operations

                int minPassages = n/2;
                int maxPassages = (n * (n-1))/2;
                
                int minPassagesPerRoom = 1;
                int maxPassagesPerRoom = n-1;
                
                Map<Integer, Integer> roomNumToPassage = new HashMap<>();
                String estimate = ""E"";

                for (int i = 0; i < K; i++) {
                    // read room num and passages
                    String[] roomAndNumPassages = br.readLine().split("" "");
                    int roomNum = Integer.parseInt(roomAndNumPassages[0]); // rooms
                    int passages = Integer.parseInt(roomAndNumPassages[1]); // operations
                    
                    if (roomNumToPassage.get(roomNum) == null) {
                        roomNumToPassage.put(roomNum, passages);
                        int diff = maxPassagesPerRoom - passages;
                        maxPassages -= diff;
                    }

                    String walkPassage = ""W"";
                    String teleport = ""T"";

                    // make move
                    System.out.println(teleport);
                }

                // print estimate
                System.out.println(estimate+((minPassages + maxPassages)/2));

                cnt++;
            }
        } catch (Exception ex) ",skyfugl
333,"class Solution {
    static int overMax = Integer.MIN_VALUE;
    static boolean isFirstPass = true;

    public static int printHelper(ArrayList<Integer> list, Deque<Integer> deque, int prev, int count) {
        if (deque.size() == 1) {
            if (prev <= deque.getFirst()) {
                overMax = Math.max(overMax, count + 1);
                return count + 1;
            } else {
                overMax = Math.max(overMax, count);
            }
        }
        int res = 0, currPrev = prev;
        if (isFirstPass == true) {
            isFirstPass = false;
            prev = deque.getFirst();
            deque.removeFirst();
            res = Math.max(res, printHelper(list, deque, prev, count + 1));
            int max1 = overMax;
            deque.addFirst(prev);
            prev = deque.getLast();
            deque.removeLast();
            res = Math.max(res, printHelper(list, deque, prev, count + 1));
            int max2 = overMax;
            deque.addLast(prev);
        } else if (deque.getFirst() >= prev) {
            // System.out.println(deque.getFirst() + "" "" + prev + "" "" + count);
            prev = deque.getFirst();
            deque.removeFirst();
            res = Math.max(res, printHelper(list, deque, prev, count + 1));
            deque.addFirst(prev);
            prev = deque.getLast();
            deque.removeLast();
            if (currPrev <= prev) {
                res = Math.max(res, printHelper(list, deque, prev, count + 1));
            } else {
                prev = currPrev;
                res = Math.max(res, printHelper(list, deque, prev, count));
            }
            deque.addLast(prev);

        } else if (deque.getLast() >= prev) {
            // System.out.println(deque.getLast() + "" "" + prev + "" "" + count);
            prev = deque.getLast();
            deque.removeLast();
            res = Math.max(res, printHelper(list, deque, prev, count + 1));
            deque.addLast(prev);
            prev = deque.getFirst();
            deque.removeFirst();
            if (currPrev <= prev)
                res = Math.max(res, printHelper(list, deque, prev, count + 1));
            else {
                prev = currPrev;
                res = Math.max(res, printHelper(list, deque, prev, count));
            }
            deque.addFirst(prev);

        }
        return res;
    }

    public static int printOutput(ArrayList<Integer> list) {
        overMax = Integer.MIN_VALUE;
        Deque<Integer> deque = new LinkedList<Integer>();
        for (int k : list)
            deque.add(k);
        int prev = Integer.MIN_VALUE;
        isFirstPass = true;
        printHelper(list, deque, prev, 0);
        return overMax;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        // int[][] input = new int[n][2];
        ArrayList<ArrayList<Integer>> input = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            int len = sc.nextInt();
            input.add(new ArrayList<Integer>());
            for (int j = 0; j < len; j++) {
                input.get(i).add(sc.nextInt());
            }
        }

        for (int i = 0; i < n; i++) {
            int res = ",Roshan
338,"class Solution {
    static boolean found = false;

    public static void findMin(int cMin, int mMin, int yMin, int kMin, int a) {
        if (cMin + mMin + yMin + kMin == 1000000) {
            System.out.println(""Case #"" + (a + 1) + "": "" + cMin + "" "" + mMin + "" "" + yMin + "" "" + kMin);
            return;
        }
        // findMin(cMin - 1, mMin, yMin, kMin, a);
        // findMin(cMin, mMin - 1, yMin, kMin, a);
        // findMin(cMin, mMin, yMin - 1, kMin, a);
        // findMin(cMin, mMin, yMin, kMin - 1, a);
    }

    public static void compute3D(ArrayList<ArrayList<Integer>> list, int a) {
        PriorityQueue<Integer> c = new PriorityQueue<>();
        PriorityQueue<Integer> m = new PriorityQueue<>();
        PriorityQueue<Integer> y = new PriorityQueue<>();
        PriorityQueue<Integer> k = new PriorityQueue<>();
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 4; j++) {
                if (j == 0) {
                    c.add(list.get(i).get(j));
                } else if (j == 1) {
                    m.add(list.get(i).get(j));
                } else if (j == 2) {
                    y.add(list.get(i).get(j));
                } else if (j == 3) {
                    k.add(list.get(i).get(j));
                }
            }
        }
        int cMin = c.peek();
        int mMin = m.peek();
        int yMin = y.peek();
        int kMin = k.peek();
        int total = cMin + mMin + yMin + kMin;
        if (total < 1000000) {
            System.out.println(""Case #"" + (a + 1) + "": IMPOSSIBLE"");
        } else if (total == 1000000) {
            System.out.println(""Case #"" + (a + 1) + "": "" + cMin + "" "" + mMin + "" "" + yMin + "" "" + kMin);
        } else {
            findMin(cMin, mMin, yMin, kMin, a);
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int input = sc.nextInt();
        int n = 3;
        ArrayList<ArrayList<ArrayList<Integer>>> printerAll = new ArrayList<>();

        for (int a = 0; a < input; a++) {
            // PriorityQueue<Integer> c = new PriorityQueue<>();
            // PriorityQueue<Integer> m = new PriorityQueue<>();
            // PriorityQueue<Integer> y = new PriorityQueue<>();
            // PriorityQueue<Integer> k = new PriorityQueue<>();
            ArrayList<ArrayList<Integer>> printerCol = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                printerCol.add(new ArrayList<Integer>());
                for (int j = 0; j < 4; j++) {
                    int in = sc.nextInt();
                    printerCol.get(i).add(in);
                    // if (j == 0) {
                    // c.add(in);
                    // } else if (j == 1) {
                    // m.add(in);
                    // } else if (j == 2) {
                    // y.add(in);
                    // } else if (j == 3) {
                    // k.add(in);
                    // }
                }
            }
            // int cMin = c.peek();
            // int mMin = m.peek();
            // int yMin = y.peek();
            // int kMin = k.peek();
            // int total = cMin + mMin + yMin + kMin;
            // if (total < 1000000) {
            // System.out.println(""Case #"" + (a + 1) + "": IMPOSSIBLE"");
            // } else if (total == 1000000) {
            // System.out.println(""Case #"" + (a + 1) + "": "" + cMin + "" "" + mMin + "" "" + yMin
            // + "" "" + kMin);
            // } else {
            // System.out.println(total + "" "" + cMin + "" "" + mMin + "" "" + yMin + "" "" +
            // kMin);
            // }
            printerAll.add(printerCol);
        }
        for (int i = ",Roshan
694,"class Solution {
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int t = Integer.parseInt(scan.nextLine());
        for (int i = 0; i < t; i++) {
            String word = scan.nextLine();    
            String wordDouble = doubling(word);
            System.out.println(""Case #"" + (i+1) + "": "" + wordDouble);
        }
    }
    
    public static String doubling(String word) {
        String wordDouble = """";
        for (int i = 0; i < word.length()-1; i ++) { //don't compare the last one with the next(donesn't exist)
            char a = word.charAt(i);
            char b = word.charAt(i+1);
            wordDouble+= a;
            if (a < b) {
                wordDouble += a;
            }
        }
        return wordDouble + word.",forky01
805,"class Room {
    public boolean visited = false;
    public int index;
    public List<Integer> neighbors;
}

public class Solution {

    public static void main(String[] args) {

        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        int T = in.nextInt();

        for (int i = 0; i < T; i++) {

            int N = in.nextInt();
            int K = in.nextInt();

            Room[] rooms = new Room[N];

            int lastRoomIdx = -1;

            for (int j = 0; j <= K; j++) {

                int R = in.nextInt() - 1;
                int P = in.nextInt();

                if (rooms[R] == null) {

                    rooms[R] = new Room();
                    rooms[R].index = R;
                    rooms[R].neighbors = new ArrayList<>(P);

                    for (int k = 0; k < P; k++) {
                        rooms[R].neighbors.add(-1);
                    }
                }

                var room = rooms[R];
                room.visited = true;

                if (lastRoomIdx != -1) {

                    for (int k = 0; k < room.neighbors.size(); k++) {
                        if (room.neighbors.get(k) == -1) {
                            room.neighbors.set(k, lastRoomIdx);
                            break;
                        }
                    }

                    for (int k = 0; k < rooms[lastRoomIdx].neighbors.size(); k++) {
                        if (rooms[lastRoomIdx].neighbors.get(k) == -1) {
                            rooms[lastRoomIdx].neighbors.set(k, R);
                            break;
                        }
                    }
                }

                if (j == K) {
                    break;
                }

                var unknownNeighbors = room.neighbors.stream().filter(n -> n == -1).count();

                var chance = (float) unknownNeighbors / room.neighbors.size();

                if (chance > 0.75f) {
                    lastRoomIdx = R;
                    System.out.println(""W"");
                } else {
                    boolean teleported = false;

                    for (int k = 0; k < rooms.length; k++) {
                        if (rooms[k] == null) {
                            teleported = true;
                            System.out.printf(""T %d%n"", k + 1);
                            break;
                        }
                    }

                    if (teleported) {
                        lastRoomIdx = -1;
                    } else {
                        // all rooms are visited, go somewhere randomly
                        lastRoomIdx = R;
                        System.out.println(""W"");
                    }
                }

                System.out.flush();
            }

            var knownPendingRooms = new ArrayList<Integer>();
            var unknownPendingRooms = new ArrayList<Integer>();

            int nPassages = 0;

            for (int j = 0; j < N; j++) {

                var room = rooms[j];

                if (room == null) {
                    unknownPendingRooms.add(j);
                    continue;
                }

                boolean hasUnknownPassages = false;

                for (int k = 0; k < room.neighbors.size(); k++) {

                    if (room.neighbors.get(k) == -1) {

                        if (!hasUnknownPassages) {
                            knownPendingRooms.add(j);
                            hasUnknownPassages = true;
                        }

                    } else {

                        if (room.neighbors.get(k) > j) {
                            nPassages++;
                        }
                    }
                }
            }

//            boolean[][] connections = new boolean[N][];
//
//            for (int j = 0; j < N; j++) {
//
//                connections[j] = new boolean[N];
//
//                if (rooms[j] != null) {
//
//                    for (int k = 0; k < rooms[j].neighbors.size(); k++) {
//
//                        var neig = rooms[j].neighbors.get(k);
//
//                        if (neig != -1) {
//                            connections[j][rooms[j].neighbors.get(k)] = true;
//                        }
//                    }
//                }
//            }

//            while (knownPendingRooms.size() > 0) {
//
//                var pendingRoom = knownPendingRooms.get(0);
//
//                var room = rooms[pendingRoom];
//
//                if (!room.visited && room.neighbors.size() > 0) {
//                    knownPendingRooms.remove(pendingRoom);
//                    continue;
//                }
//
//                for (int j = 0; j < room.neighbors.size(); j++) {
//
//                    if (room.neighbors.get(j) == -1) {
//
//                        if (unknownPendingRooms.size() > 0) {
//
//                            var unknownIndex = unknownPendingRooms.remove(0);
//
//                            var unknownRoom = new Room();
//                            unknownRoom.index = unknownIndex;
//                            unknownRoom.neighbors = new ArrayList<>();
//                            unknownRoom.neighbors.add(pendingRoom);
//
//                            rooms[unknownIndex] = unknownRoom;
//
//                            knownPendingRooms.add(unknownIndex);
//                            room.neighbors.set(j, unknownIndex);
//
//                            connections[pendingRoom][unknownIndex] = true;
//                            connections[unknownIndex][pendingRoom] = true;
//
//                            nPassages++;
//
//                        } else {
//
//                            for (var r : knownPendingRooms) {
//
//                                if (r.equals(pendingRoom)) {
//                                    continue;
//                                }
//
//                                if (connections[pendingRoom][r]) {
//                                    continue;
//                                }
//
//                                var otherRoom = rooms[r];
//
//                                if (!otherRoom.visited) {
//
//                                    room.neighbors.set(j, r);
//                                    otherRoom.neighbors.add(pendingRoom);
//
//                                } else {
//
//                                    int c = 0;
//                                    int firstNeigh = -1;
//
//                                    for (int h = 0; h < otherRoom.neighbors.size(); h++) {
//
//                                        var neigh = otherRoom.neighbors.get(h);
//
//                                        if (neigh == -1) {
//                                            if (firstNeigh == -1) {
//                                                firstNeigh = h;
//                                            }
//                                            c += 1;
//                                        }
//                                    }
//
//                                    room.neighbors.set(j, r);
//                                    otherRoom.neighbors.set(firstNeigh, pendingRoom);
//
//                                    if (c == 1) {
//                                        knownPendingRooms.remove(Integer.valueOf(otherRoom.index));
//                                    }
//                                }
//
//                                nPassages++;
//
//                                connections[pendingRoom][r] = true;
//                                connections[r][pendingRoom] = true;
//
//                                break;
//                            }
//                        }
//                    }
//                }
//
//                if (room.visited) {
//                    knownPendingRooms.remove(pendingRoom);
//                }
//            }

            System.out.printf(""E %d%n"", nPassages);
            System.",jaimuepe
946,"public class Solution {

	public static void main(String[] args) {
		Scanner s = new Scanner(System.in);
		int i, j, k, l, t;
		int p1[] = new int[4];
		int p2[] = new int[4];
		int p3[] = new int[4];
		int saida[] = new int[4];

		
		do {
			t = s.nextInt();
		} while(t < 1 || t > 100);
		
		for(i = 1; i <= t; i++) {
			l = 0;
			
				for(k = 0; k < 4; k++) {
					do {
						p1[k] = s.nextInt();
						
					} while(p1[k] < 0 || p1[k] > (int) Math.pow(10, 6));
				}
				
				for(k = 0; k < 4; k++) {
					do {
						p2[k] = s.nextInt();
						
					} while(p2[k] < 0 || p2[k] > (int) Math.pow(10, 6));
				}
				
				for(k = 0; k < 4; k++) {
 					do {
						p3[k] = s.nextInt();
						
					} while(p3[k] < 0 || p3[k] > (int) Math.pow(10, 6));
				}
			
			for(j = 0; j < 4; j++) {
				
				if(p1[j] >= p2[j] & p1[j] >= p3[j]) {
					saida[l] = p1[j];
				} else if(p2[j] >= p3[j]) {
					saida[l] = p2[j];
				} else {
					saida[l] = p3[j];
				}
				
				
				if(p1[j] == 0)
					if(p2[j] >= p3[j])
						saida[l] = p2[j];
					else
						saida[l] = p3[j];
				
				if(p2[j] == 0)
					if(p1[j] >= p3[j])
						saida[l] = p1[j];
					else
						saida[l] = p3[j];
				
				if(p3[j] == 0)
					if(p1[j] >= p2[j])
						saida[l] = p1[j];
					else
						saida[l] = p2[j];
				
				if(p1[j] == 0 && p2[j] == 0)
					saida[l] = p3[j];
				
				if(p2[j] == 0 && p3[j] == 0)
					saida[l] = p1[j];
				
				if(p1[j] == 0 && p3[j] == 0)
					saida[l] = p2[j];
				
				l++;
			}
			
			l = 0;
			System.out.print(""Case #"" + i + "": "");
			
			if((saida[0] + saida[1] + saida[2] + saida[3]) == (int) Math.pow(10, 6)) {
				System.out.print(saida[0] + "" "" + saida[1] + "" "" + saida[2] + "" "" + saida[3]);
			} else {
				System.out.print(""IMPOSSIBLE"");
			}
			
			if(i != t)
				System.",marcosph
1255,"public class Solution {
	public static void input() {
		Scanner sc = new Scanner(System.in);
		int testCase = sc.nextInt();
		int countTest = 1;
		int[] pr1, pr2, pr3;
		while (testCase > 0) {
			pr1 = new int[4];
			pr2 = new int[4];
			pr3 = new int[4];
			for (int i = 0; i < 4; i++) {
				pr1[i] = sc.nextInt();
			}
			for (int i = 0; i < 4; i++) {
				pr2[i] = sc.nextInt();
			}
			for (int i = 0; i < 4; i++) {
				pr3[i] = sc.nextInt();
			}
			System.out.print(""Case #"" + countTest + "": "");
			output(pr1, pr2, pr3);
			System.out.println("""");
			countTest++;
			testCase--;
		}
	}

	public static void output(int[] pr1, int[] pr2, int[] pr3) {
		int len = 4;
		int maxColor = (int) Math.pow(10, 6);

		// Find the maximum the color for each printers in case 1
		int getIsZeroFirst = 0, getIsZeroSecond = 0, getIsZeroThird = 0;
		for (int i = 0; i < len; i++) {
			int countMaxColor = 0, getIndexMax = 0;
			if (pr1[i] == maxColor) {
				countMaxColor++;
				getIndexMax = i;

			} else if (pr1[i] == 0) {
				getIsZeroFirst++;
			}
			if (pr2[i] == maxColor) {
				countMaxColor++;

			} else if (pr2[i] == 0) {
				getIsZeroSecond++;
			}
			if (pr3[i] == maxColor) {
				countMaxColor++;

			} else if (pr3[i] == 0) {
				getIsZeroThird++;
			}

			if (getIsZeroFirst >= 2 && (getIsZeroSecond == 1 || getIsZeroThird == 1)
					|| getIsZeroSecond >= 2 && (getIsZeroSecond == 1 || getIsZeroThird == 1)
					|| getIsZeroThird >= 2 && (getIsZeroFirst == 1 || getIsZeroSecond == 1)) {
				if (countMaxColor == len - 1) {
					for (int j = 0; j < len; j++) {
						if (j != getIndexMax) {
							System.out.print(0 + "" "");
						} else {
							System.out.println(Math.pow(10, 6));
						}
					}
					return;
				} else {
					System.out.println(""IMPOSSIBLE"");
					return;
				}
			}

		}

		List<Integer> getMin = new LinkedList<>();
		List<Integer> output = new LinkedList<>();

		for (int i = 0; i < len; i++) {
			if (pr1[i] <= pr2[i] && pr1[i] <= pr3[i]) {
				getMin.add(pr1[i]);
			} else if (pr2[i] <= pr1[i] && pr2[i] <= pr3[i]) {
				getMin.add(pr2[i]);
			} else if (pr3[i] <= pr1[i] && pr3[i] <= pr2[i]) {
				getMin.add(pr3[i]);
			}
		}

		// int firstMin = getMin.get(0);
		int countColorCase2 = 0;
		for (int i = 0; i < len - 1; i++) {
			countColorCase2 += getMin.get(i);
			if (i == 0) {
				int remainColor = maxColor - countColorCase2;
				if (remainColor == 0) {
					int mockForAddColor = i;
					for (int j = 0; j < len; j++) {
						if (j == mockForAddColor) {
							System.out.print(countColorCase2 + "" "");
						} else {
							System.out.print(0 + "" "");
						}
					}
					return;
				}
			}
			if (i >= 1) {
				int reachToMax = 0;
				int remainColor = maxColor - countColorCase2;
				int mockForAddColor = i;
				if (remainColor <= getMin.get(i + 1)) {
					mockForAddColor = i + 1;
					for (int j = 0; j < len; j++) {
						if (getMin.get(j) != 0 && j != mockForAddColor && j < mockForAddColor) {
							System.out.print(getMin.get(j) + "" "");
						} else if (j == mockForAddColor) {
							System.out.print(remainColor + "" "");
						} else {
							System.out.print(0 + "" "");
						}
					}
					return;
				} else {
					for (int j = 0; j < len; j++) {
						if (j < i + 1) {
							output.add(getMin.get(j));
							//System.out.print(getMin.get(j) + "" "");
							reachToMax += getMin.get(j);
							remainColor = maxColor - reachToMax;
						} else {
							if (remainColor <= getMin.get(j)) {
								output.add(remainColor);
								//System.out.print(remainColor + "" "");
								reachToMax += remainColor;
							} else if (remainColor > getMin.get(j)) {
								output.add(getMin.get(j));
								//System.out.print(getMin.get(j) + "" "");
								reachToMax += getMin.get(j);
								remainColor = remainColor - getMin.get(j);
							} else {
								output.add(0);
								//System.out.print(0 + "" "");
							}
						}
					}
					if(reachToMax == maxColor) {
						for(int j = 0; j < len; j++) {
							System.out.print(output.get(j) + "" "");
						}
						return;
					}else {
						System.out.println(""IMPOSSIBLE"");
						return;
					}
				}
			}
		}
	}

	public static void main(String[] args) ",tonybuidn
44,"public class Solution {

    /**
     * @param args the command line arguments
     */
    
 
    
    public static void main(String[] args) {
          Scanner keyboard = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
    int a;
    int[][]array1;
int c=0;
int m=0;
int y=0;
int k=0;
    
    a = keyboard.nextInt();
    array1 = new int[a][12];

    
for (int b = 0; b<a; b++)
{
    for (int z = 0; z < 12; z++)
    {
  array1[b][z]=keyboard.nextInt();
    }
}
for (int d = 0; d < a; d++)
{

   if ((array1[d][0]<=array1[d][4])&&(array1[d][0]<=array1[d][8]))
           {
               c = array1[d][0];
           }
   else if (array1[d][4]<=array1[d][8])
   {        
               c = array1[d][4];
   }
   else
               c = array1[d][8];

   if ((array1[d][1]<=array1[d][5])&&(array1[d][1]<=array1[d][9]))
           {
               m = array1[d][1];
           }
   else if (array1[d][5]<=array1[d][9])
   {        
               m = array1[d][5];
   }
   else
               m = array1[d][9];

   if ((array1[d][2]<=array1[d][6])&&(array1[d][2]<=array1[d][10]))
           {
               y = array1[d][2];
           }
   else if (array1[d][6]<=array1[d][10])
   {        
               y = array1[d][5];
   }
   else
               y = array1[d][10];
   
      if ((array1[d][3]<=array1[d][7])&&(array1[d][3]<=array1[d][11]))
           {
               k = array1[d][3];
           }
   else if (array1[d][7]<=array1[d][11])
   {        
               k = array1[d][7];
   }
   else
               k = array1[d][11];



        if ((c+m+y+k)<1000000)
{
    System.out.println(""Case #""+(d+1)+"": IMPOSSIBLE"");
}
         
        else if (c+m+y+k>=1000000)
        {
            if (c==1000000)
            {
                y = 0;
                m = 0; 
                k = 0;
            }
            
            else if (m==1000000)
            {
                y = 0;
                c = 0; 
                k = 0;
            }
            else if (y==1000000)
            {
                c = 0;
                m = 0; 
                k = 0;
            }
            else if (k==1000000)
            {
                y = 0;
                m = 0; 
                c = 0;
            }
        
            else if (c+m>=1000000)
        {
               if (c+m>1000000)
               {
                   m = (1000000 - (c));
                   y=0;
                   k = 0;
               }
               else
               {
                   y = 0;
                   k = 0;
               }
        }
         else if (c+y>=1000000)
        {
               if (c+y>1000000)
               {
                   y = (1000000 - (c));
                   m=0;
                   k = 0;
               }
               else
               {
                   m = 0;
                   k = 0;
               }
        }   
         else if (c+k>=1000000)
        {
               if (c+k>1000000)
               {
                   k = (1000000 - (c));
                   m=0;
                   y = 0;
               }
               else
               {
                   m = 0;
                   y = 0;
               }
        }   
         else if (m+y>=1000000)
        {
               if (m+y>1000000)
               {
                   m = (1000000 - (k));
                   c=0;
                   y = 0;
               }
               else
               {
                   c = 0;
                   y = 0;
               }
        }
         
         else if (m+k>=1000000)
        {
               if (m+k>1000000)
               {
                   k = (1000000 - (m));
                   c=0;
                   y = 0;
               }
               else
               {
                   c = 0;
                   y = 0;
               }
        }
         
         else if (y+k>=1000000)
        {
               if (y+k>1000000)
               {
                   k = (1000000 - (y));
                   m=0;
                   c = 0;
               }
               else
               {
                   m = 0;
                   c = 0;
               }
        }       
            
            
            
            
            else if (c+m+y>=1000000)
        {
               if (c+m>1000000)
               {
                   y = (1000000 - (c+m));
                   k = 0;
               }
               else 
                   k=0;
        }
            
        else if (c+m+k>=1000000)
        {
               if (c+m>1000000)
               {
                   k = (1000000 - (c+m));
                   y = 0;
               }
               else 
                   y = 0;
        }    
            
                else if (y+m+k>=1000000)
        {
               if (y+k>1000000)
               {
                   m = ",Ak9
525,"public class Solution {

    private static final Boolean FROM_FILE = Boolean.FALSE;
    private static final int MAXLEN = 100000;
    private static final int BUFF_READ_SIZE = 1000*8192;

    /**
     * What can I say, I like'em Turing machines
     */
    private static int numLeaf, x, y;
    private static int[] indexLeaf = new int[MAXLEN];
    private static int[] detectLeaf = new int[MAXLEN];
    private static int[] f = new int[MAXLEN];
    private static int[] p = new int[MAXLEN];
    private static int[] height = new int[MAXLEN];
    private static int[] firstChild = new int[MAXLEN];
    private static int[] lastChild = new int[MAXLEN];
    private static int[] hasBrothers = new int[MAXLEN];

    private static void insertLeaf(int j){
        if(j>=0){
            indexLeaf[j]=numLeaf;
            detectLeaf[numLeaf++]=j;
        }
    }

    private static boolean isLeaf(int j){
        return j >= 0 && -1 != indexLeaf[j];
    }

    private static void removeLeaf(int j){
        if(isLeaf(j)){
            if(indexLeaf[j] == numLeaf-1){
                // no exchange needed, just move the head
                numLeaf--;
                indexLeaf[j]=-1;
            } else if(numLeaf > 1){
                x = detectLeaf[--numLeaf];
                y = indexLeaf[j];
                indexLeaf[j]=-1;
                indexLeaf[x]=y;
                detectLeaf[y]=x;
            } else {// numLeaf
                indexLeaf[j]=-1;
                if(numLeaf == 1){
                    //last leaf
                    numLeaf--;
                }
                // else pretend it's raining 'cause RE doesn't say much does it.
            }
        }
    }

    private static int isLeafWithGreatestHeight(){
        int biggestHeight = -1;
        int leafWithBiggestHeight = -1;

        for(int l = numLeaf-1; l >= 0; l--){
            // leaf detection
            if(isLeaf(detectLeaf[l])){
                if(height[detectLeaf[l]] > biggestHeight){
                    biggestHeight = height[detectLeaf[l]];
                    leafWithBiggestHeight = detectLeaf[l];
                }
            }
        }
        return leafWithBiggestHeight;
    }

    public static void main(String[] args) throws IOException{
        BufferedReader br;
        BufferedWriter bw;

        if(FROM_FILE){
            br = new BufferedReader(new FileReader(""C2022QR1Dinput.in""), BUFF_READ_SIZE);
        } else {
            br = new BufferedReader(new InputStreamReader(System.in), BUFF_READ_SIZE);
        }

        try {
            if(FROM_FILE) {
                File file = new File(""C2022QR1D.out"");
                if (!file.exists()) {
                    file.createNewFile();
                }
                bw = new BufferedWriter(new FileWriter(file.getAbsoluteFile()));
            } else {
                bw = new BufferedWriter(new OutputStreamWriter(System.out));
            }

            String line = br.readLine();
            String[] q,r;

            int tests = Integer.parseInt(line);//100
            int n;

            int i,j,k,u, min, m;
            int leafWithBiggestHeight;

            long max;

            // long start = System.currentTimeMillis();

            for(i = 0; i < tests; i++){
                line = br.readLine();
                n = Integer.parseInt(line);

                line = br.readLine();
                q = line.split(""\\\s+"");

                line = br.readLine();
                r = line.split(""\\\s+"");

                Arrays.fill(firstChild,0,n,-1);
                Arrays.fill(lastChild,0,n,-1);
                Arrays.fill(hasBrothers,0,n,-1);
                //Arrays.fill(indexLeaf,0,n,-1);
                //Arrays.fill(detectLeaf,0,n,-1);

                // XXY: reset detected leaves
                numLeaf = 0;

                // input and abyss detection
                for(j = 0;j<n; j++){
                    f[j] = Integer.parseInt(q[j]);
                    // 0 <= Pi <= i-1, for all i.
                    // XXX: why less than i. Oh, these are ordered!
                    p[j] = Integer.parseInt(r[j])-1;

                    // XXY: detect leaves beforehand
                    insertLeaf(j);

                    // abyss
                    if(-1 == p[j]){
                        height[j] = 0; // root
                        // noChildren[j]=0;
                    } else {
                        // p[j] has no children
                        if(isLeaf(p[j])){
                            firstChild[p[j]] = j;
                            lastChild[p[j]] = j;
                            // hasBrothers[j] = -1;
                            // XXY: p[j] no longer a leaf now
                            // exchange with last detected leaf and decrement counter
                            removeLeaf(p[j]);
                        } else {
                            // p[j] already has children, insert child as last brother
                            m = lastChild[p[j]];
                            hasBrothers[m] = j;
                            lastChild[p[j]] = j;
                        }

                        // because of XXX ordering his parent's height was already counted
                        height[j] = height[p[j]]+1;
                    }
                }

                max = 0L;

                // XXX: Pk cannot be triggered by Pk+1...Pn, so walk backwards to fold trees
                for(k = n-1; k >= 0; ){
                    // #0 skip nodes with no fun
                    if(f[k] == 0) {
                        removeLeaf(k);
                        k--;
                        continue;
                    }

                    // #00 count roots
                    if(p[k] == -1){
                        max += f[k];
                        f[k] = 0;
                        removeLeaf(k);
                        k--;
                        continue;
                    }

                    // #1 optimize - reduce leafs that are only childs
                    // has fun left && is not a root && is a leaf && only child
                    if(isLeaf(k) && firstChild[p[k]] == lastChild[p[k]]){
                        // reduce fun of parent as max of leaf and parent, they get triggered at once anyways!
                        f[p[k]] = Math.max(f[k], f[p[k]]);
                        f[k] = 0;
                        // parent becomes a leaf after reduce
                        firstChild[p[k]] = -1;
                        lastChild[p[k]] = -1;

                        // XXY: add parent in detected leaves
                        insertLeaf(p[k]);
                        removeLeaf(k);

                        k--;
                        // skip anything this turn
                        continue;
                    }

                    // #2A detect leaf with greatest height

                    // XXY: much quicker now
                    leafWithBiggestHeight = isLeafWithGreatestHeight();

                    if( -1 != leafWithBiggestHeight){
                        // #2B reduce leafWithBiggestHeight
                        // parent, not visited yet because of XXX ordering
                        m = p[leafWithBiggestHeight];

                        // only child, again simple
                        if(firstChild[m] == lastChild[m]){
                            // reduce fun of parent as max of leaf and parent, they get triggered at once anyways!
                            f[m] = Math.max(f[leafWithBiggestHeight], f[m]);
                            // parent becomes a leaf after reduce
                            firstChild[m] = -1;
                            insertLeaf(m);

                            // make leaf no fun, it has been reduced
                            f[leafWithBiggestHeight] = 0;
                            removeLeaf(leafWithBiggestHeight);
                        } else {
                            // parent has at least 2 children.
                            // find the minimal fun child and merge with parent
                            u = firstChild[m];
                            min = f[u];
                            max += f[u];
                            // make leaf no fun, it has been reduced
                            f[u]=0;
                            removeLeaf(u);

                            do {
                                u = hasBrothers[u];
                                max += f[u];
                                if(f[u] > 0 && f[u] < min){
                                    min = f[u];
                                }
                                // make leaf no fun, it has been reduced
                                f[u]=0;
                                removeLeaf(u);
                            } while(-1 != hasBrothers[u]);

                            // minimal fun gets reduced into parent
                            // reduce fun of parent as max of leaf and parent, they get triggered at once anyways!
                            f[m] = Math.max(min, f[m]);
                            // already added it to max, value in parent should be counted ... eventually
                            max -= min;
                            // parent becomes a leaf after reduce
                            firstChild[m] = -1;

                            // XXY: add parent in detected leaves
                            insertLeaf(m);
                        }
                    }
                    // else something is wrong, should see TLE
                }

                bw.write(""Case #""+(i+1)+"": "" + max + ""
"");
                bw.flush();
            }

            // long end = System.currentTimeMillis();

            // bw.write((end-start) +"" miliseconds!"");
            bw.flush();

            if(FROM_FILE) {
                bw.close();
            }
        } finally {
            if(FROM_FILE) {
                br.close();
            }
        }
    }
}",araver
751,"public class Solution {
     public static  void main(String[] args){
        Scanner myObj = new Scanner(System.in);  
    
        int testcases = myObj.nextInt();
        
        xxas: for(int i = 0; i < testcases; i++) {
            int n = myObj.nextInt();
            int k = myObj.nextInt();
            
            int a = 0;
            int b = 0;
            for(int j = 0; j < n; j++) {
                int nxt = myObj.nextInt();
                a += nxt;
                b += nxt*nxt;
            }
            
            //
            if(k == 1) {
                if(a == 0) {
                    System.out.println(""Case #"" +(i+1)+ "": "" + (b==0 ? 0 : ""IMPOSSIBLE"") );
                }else
                    System.out.println(""Case #"" +(i+1)+ "": "" + ((b-a*(long)a)%(2*a)==0 ? (b-a*(long)a)/(2*a) : ""IMPOSSIBLE"") );
                    continue xxas;
            }
            
            String zeros = """";
            while(k != 2) {
                zeros += ' 0';
                k--;
            }
            
            for(int x= -1000; x <= 1000; x++) {
                
                a += x;
                b += x*x;
                
                if(a == 0 && b == 0) {
                    System.out.println(""Case #"" +(i+1)+ "": "" + ""0 0"" +  zeros );
                    continue xxas;
                }
                
                if((b-a*(long)a)%(2*a)==0) {
                    System.out.println(""Case #"" +(i+1)+ "": "" + x + "" "" + (b-a*(long)a)/(2*a) + zeros );
                    continue xxas;
                }
                    
                a -= x;
                b -= x*x;
            }
            System.out.println(""Case #"" +(i+1)+ "": "" + ""IMPOSSIBLE"" );

        }
        
    }
    
    static public boolean isValid(String s) {
        boolean[] taken = new boolean[40];
        for(int i = 0; i< s.length();) {
            char c = s.charAt(i);
            if(taken[c-'A'])
            return false;
            taken[c-'A'] = true;
            while(i < s.",gregordr
264,"public class Solution {
    public static int solve(int[] f, int[] p) {
        int[] f2 = new int[f.length];
        Map<Integer, List<Integer>> tree = new HashMap<>();
        List<Integer> initiators = new ArrayList<>();
        for (int i=0; i<p.length; i++){
            List<Integer> children = tree.get(p[i]);
            if (children == null) {
                children = new ArrayList<Integer>();
                tree.put(p[i], children);
            }
            children.add(i+1);
        }
        for (int i=1; i<=f.length; i++) {
            if (!tree.containsKey(i)){
                initiators.add(i);
            }
        }
        for (int initiator: initiators) {
            int nodeId = initiator;
            f2[nodeId-1] = f[nodeId-1];
            while(p[nodeId-1] != 0) {
                f2[p[nodeId-1]-1] =  f[p[nodeId-1]-1];
                if (f[nodeId - 1] > f2[p[nodeId-1]-1]) {
                    f2[p[nodeId-1]-1] =  f[nodeId - 1];
                }
                nodeId = p[nodeId-1];
            }
        }
        Deque<Integer> queue = new ArrayDeque<>();
        queue.addFirst(0);
        while(!queue.isEmpty()) {
            int nodeId = queue.pollFirst();
            int min = Integer.MAX_VALUE;
            int minChild = 0;
            if (!tree.containsKey(nodeId)) continue;
            for(int child: tree.get(nodeId)) {
                if (f2[child-1] < min) {
                    min = f2[child-1];
                    minChild = child;
                }
            }
            for(int child: tree.get(nodeId)) {
                if (nodeId==0 || child != minChild) {
                    queue.addFirst(child);
                } else {
                    if (f[nodeId-1] > f2[child-1]) {
                        f2[child-1] = f[nodeId-1];
                    }
                }
            }
        }

        int result = 0;
        for (int initiator: initiators) {
            result += f2[initiator-1];
        }

        return result;
    }
    public static void main(String[] args) {
        // Read input from stdin, write output to stdout
        Scanner in;
        try {
            in = new Scanner(new BufferedReader(new FileReader(""input.txt"")));
        } catch (IOException e) {
            // e.printStackTrace();
            in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        }

        int t = in.nextInt();
        for (int i=1; i<=t; i++) {
            int n = in.nextInt();
            int[] f = new int[n];
            int[] p = new int[n];
            for (int j=0; j<n; j++) {
                f[j] = in.nextInt();
            }
            for (int j=0; j<n; j++) {
                p[j] = in.nextInt();
            }
            int c = ",MehdiKalhori
1330,"public class Solution {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
		int n = scanner.nextInt();
        for (int i = 0; i < n; i++) {
            int Ci = Integer.MAX_VALUE;
            int Mi = Integer.MAX_VALUE;
            int Yi = Integer.MAX_VALUE;
            int Ki = Integer.MAX_VALUE;
            for(int j=0; j<3; j++) {
                Ci = Math.min(Ci, scanner.nextInt());
                Mi = Math.min(Mi, scanner.nextInt());
                Yi = Math.min(Yi, scanner.nextInt());
                Ki = Math.min(Ki, scanner.nextInt());
            }
			System.out.print(""Case #""+(i+1)+""+: "");
            System.out.println(get(Ci, Mi, Yi, Ki));
		}

    }

    public static String get(int Ci, int Mi, int Yi, int Ki) {
        int total = 1000000;
        String result = Math.min(total, Ci)+"" "";
        total -= Math.min(total, Ci);
        result = result + Math.min(total, Mi)+"" "";
        total -= Math.min(total, Mi);
        result = result + Math.min(total, Yi)+"" "";
        total -= Math.min(total, Yi);
        result = ",xinyou
1161,"class Solution {

	public static void main ( String [] args ) {
		Scanner s = new Scanner ( System.in);
			
		int T = s.nextInt(); 
		for ( int t=1; t<=T; t++) {  
			int n = s.nextInt();
			int [] f = new int[n+1];
			List<Integer> [] varf = new List[n+1];
			//List<Integer> [] dp = new List[n+1];
			
			int [] p = new int[n+1];
			int [] c = new int[n+1]; 
			for ( int i=1; i<=n; i++) {
				f[i] = s.nextInt(); 
			}
			for ( int i=1; i<=n; i++) {
				varf[i] = new ArrayList();
				p[i] = s.nextInt();
				c[p[i]] ++;
			}
			
			Queue<Integer> q = new LinkedList<>();
			for ( int i=1; i<=n; i++) {
				if (c[i]==0) {
					q.add(i);
				}
			}

			int sol=0;
			while (q.size()>0) {
				int current = q.poll();
				Collections.sort(varf[current]);
				
				if (varf[current].size()==0) {
					varf[current].add(f[current]); 
				} else {
					int min = varf[current].get(0);
					varf[current].set( 0, Math.max(min, f[current]));
					for ( int j=1; j<varf[current].size(); j++) {
						sol += varf[current].get(j);
					}
				}
				
				//System.out.println(current);
				int parent = p[current];
				if (parent>0) {
					c[parent]--;
					varf[parent].add(varf[current].get(0));
					varf[current].clear();
					if (c[parent]==0) {
						q.add(parent);
					}
				}
			}
			for ( int i=1; i<=n; i++) {
				if (p[i]==0) {
					for ( int v : varf[i]) {
						sol += v;
						break;
					}
				}
			}
			System.",slycer
979,"public class Solution {

	public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        
        int numberOfCases = in.nextInt();
        
        for (int i = 1; i <= numberOfCases; ++i) {
        	int[] result = new int[] {0,0,0,0,0,0,0,0};
        	int N = 10;
        	while(N>0) {
        		System.out.println(""01010101"");
        		N = ",nicolasD
753,"public class Solution {
     public static  void main(String[] args){
        Scanner myObj = new Scanner(System.in);  
    
        int testcases = myObj.nextInt();
        
        xxas: for(int i = 0; i < testcases; i++) {
            int n = myObj.nextInt();
            int k = myObj.nextInt();
            
            int a = 0;
            int b = 0;
            for(int j = 0; j < n; j++) {
                int nxt = myObj.nextInt();
                a += nxt;
                b += nxt*nxt;
            }
            
            //
            if(k == 1) {
                if(a == 0) {
                    System.out.println(""Case #"" +(i+1)+ "": "" + (b==0 ? 0 : ""IMPOSSIBLE"") );
                }else
                    System.out.println(""Case #"" +(i+1)+ "": "" + ((b-a*(long)a)%(2*a)==0 ? (b-a*(long)a)/(2*a) : ""IMPOSSIBLE"") );
                    continue xxas;
            }
            
            String zeros = """";
            
            for(int x= -1000000; x <= 1000000; x++) {
                
                a += x;
                b += x*x;
                
                if(a == 0 && b == 0) {
                    System.out.println(""Case #"" +(i+1)+ "": "" + ""0 0"" +  zeros );
                    continue xxas;
                }
                
                if((b-a*(long)a)%(2*a)==0) {
                    System.out.println(""Case #"" +(i+1)+ "": "" + x + "" "" + (b-a*(long)a)/(2*a) + zeros );
                    continue xxas;
                }
                    
                a -= x;
                b -= x*x;
            }
            System.out.println(""Case #"" +(i+1)+ "": "" + ""IMPOSSIBLE"" );

        }
        
    }
    
    static public boolean isValid(String s) {
        boolean[] taken = new boolean[40];
        for(int i = 0; i< s.length();) {
            char c = s.charAt(i);
            if(taken[c-'A'])
            return false;
            taken[c-'A'] = true;
            while(i < s.",gregordr
303,"public class Solution {

    public static void main(String[] args) throws InterruptedException {
        Scanner in = new Scanner(System.in);
        // Thread.sleep(3000);
        int T = in.nextInt();

        for (int t = 1; t <= T; t++) {
            String s= in.next();
            StringBuilder sb= new StringBuilder();
            HashSet<Character> diff= new HashSet<>();
        for(int i=0; i<s.length()-1; i++){
            diff.add(s.charAt(i));
            sb.append(s.charAt(i));
            char c= s.charAt(i);
            if(s.charAt(i)<s.charAt(i+1))
                sb.append(s.charAt(i));
            else if(s.charAt(i)==s.charAt(i+1)){
                int count=0;
                while(i<s.length()-1 && s.charAt(i)==c){
                    count++;
                    i++;
                }

                if(s.charAt(i)>c){
                    count=2*count;
                    while(count-->1)
                        sb.append(c);

                }
                else{
                    while(count-->1)
                        sb.append(c);
                }
                if(i<s.length()-1)
                    sb.append(s.charAt(i));
            }
        }
        sb.append(s.charAt(s.length()-1));
        diff.add(s.charAt(s.length()-1));
        if(diff.size()==1)
            System.out.println(""Case #""+t+"": ""+s);
        else
            System.",Rawan321
181,"public class Solution {

	public static void main(String[] args) {
		Scanner s = new Scanner(System.in);
		int cases = s.nextInt();
		for(int i=0;i<cases;i++) {
			System.out.println(""Case #""+(i+1)+"":"");
			int rows = s.nextInt();
			int columns = s.nextInt();
			
			
			for(int row=0;row<rows;row++) {
				
				for(int column=0;column<columns;column++) {
					if(row == 0 && column == 0) {
						System.out.print("".."");
					}else {
						System.out.print(""+-"");
					}
				}
				
				System.out.println(""+"");
				
				for(int column=0;column<columns;column++) {
					if(row == 0 && column == 0) {
						System.out.print("".."");
					}else {
						System.out.print(""|."");
					}
				}
				System.out.println(""|"");
				
				
			}
			
			for(int column=0;column<columns;column++) {
				System.out.print(""+-"");
			}
			System.out.println(""+"");
		}
		
		s.",KovacsA22
722,"public class Solution {

    public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        PrintWriter writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));

        int T = in.nextInt();
        for (int casNumero = 1; casNumero <= T; casNumero++) {
            StringBuilder resultat = new StringBuilder();
            resultat.append(""Case #"");
            resultat.append(casNumero);
            resultat.append("": "");

            int n = in.nextInt();
            int[] f = new int[n];
            for (int i = 0; i < n; i++) {
                f[i] = in.nextInt();
            }
            int[] p = new int[n];
            for (int i = 0; i < n; i++) {
                p[i] = in.nextInt();
            }

            List<Integer> triggers = new ArrayList<>();
            for (int i = 1; i < n+1; i++) {
                int finalI = i;
                if (Arrays.stream(p).noneMatch(a -> a == finalI)) {
                    triggers.add(finalI);
                }
            }
            List<Integer> used = new ArrayList<>();
            int sumFun = 0;
            while (!used.containsAll(triggers)) {
                int minFun = 0;
                int bestTrigger = 0;
                for (Integer trigger : triggers) {
                    if (!used.contains(trigger)) {
                        int fun = getFun(trigger.intValue(), f, p, used);
                        if (minFun == 0 || minFun > fun) {
                            minFun = fun;
                            bestTrigger = trigger.intValue();
                        }
                        else if (minFun == fun) {
                            int commonModule = getCommonModule(bestTrigger, trigger, p);
                            if (commonModule == 0 && f[trigger - 1] < f[bestTrigger - 1]) {
                                minFun = fun;
                                bestTrigger = trigger.intValue();
                            }
                            else if (commonModule != 0) {
                                used.add(commonModule);
                                if (getFun(trigger.intValue(), f, p, used) < getFun(bestTrigger, f, p, used)) {
                                    minFun = fun;
                                    bestTrigger = trigger.intValue();
                                }
                                used.remove(Integer.valueOf(commonModule));
                            }
                        }
                    }
                }
                sumFun += minFun;
                used.addAll(getRelations(bestTrigger, p, used));
            }
            resultat.append(sumFun);
            writer.print(resultat.toString());
            writer.println();
        }
        in.close();
        writer.close();
    }

    private static int getCommonModule(int index1, int index2, int[] p) {
        int currentIndex1 = p[index1 - 1];
        int currentIndex2 = p[index2 - 1];
        int commonModule = 0;
        while (commonModule == 0 && currentIndex1 != 0 && currentIndex2 != 0) {
            if (currentIndex1 == currentIndex2) {
                commonModule = currentIndex1;
            }
            else if (currentIndex1 > currentIndex2) {
                currentIndex1 = p[currentIndex1 - 1];
            }
            else {
                currentIndex2 = p[currentIndex2 - 1];
            }
        }
        return commonModule;
    }

    private static List<Integer> getRelations(int index, int[] p, List<Integer> used) {
        List<Integer> relations = new ArrayList<>();
        relations.add(index);
        int currentIndex = index;
        while (!used.contains(currentIndex) && p[currentIndex - 1] != 0) {
            currentIndex = p[currentIndex - 1];
            relations.add(currentIndex);
        }
        return relations;
    }

    private static int getFun(int index, int[] f, int[] p, List<Integer> used) {
        int fun = f[index - 1];
        int relation = p[index - 1];
        if (relation != 0 && !used.contains(relation)) {
            int relationFun = getFun(relation, f, p, used);
            if (relationFun > fun) {
                fun = ",gerardmr
421,"public class Solution {
    public static void main(String[] args) {
        try {
            Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
            int tests = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.

            for (int currentTest = 1; currentTest <= tests; ++currentTest) {
                int N = in.nextInt();
                int K = in.nextInt();
                int r = in.nextInt();
                int p = in.nextInt();

                long pSum = p;
                long queries = K;
                Set<Integer> visited = new HashSet<>();
                visited.add(r);
                if(N <=1){
                    System.out.println(""E 0"");
                    System.out.flush();
                }else if(N == 2){
                    System.out.println(""E 1"");
                    System.out.flush();
                }
                else if(N <= K){
                    long count = 0;
                    for(int i = 1; i <= N; i++){
                        System.out.println(""T "" + i);
                        System.out.flush();
                        r = in.nextInt();
                        if(r == -1) System.exit(3);
                        p = in.nextInt();
                        if(p == -1) System.exit(3);
                        count += p;
                        queries --;
                    }
                    String ans = ""E "" + (count/2);
                    System.out.println(ans);
                    System.out.flush();
                }else {
                    boolean needToJump = false;
                    int jumpCounter = 0;
                    while (queries > 0) {

                        if(needToJump) {
                            int nxt = (int) (Math.random() * N + 1);
                            while(visited.contains(nxt)){
                                nxt = (int) (Math.random() * N + 1);
                            }
                            System.out.println(""T "" + nxt);
                            System.out.flush();
                            r = in.nextInt();
                            if (r == -1) System.exit(3);
                            p = in.nextInt();
                            if (p == -1) System.exit(3);
                            needToJump = false;
                            pSum += p;
                            visited.add(r);
                        }else{
                            System.out.println(""W"");
                            System.out.flush();
                            r = in.nextInt();  if (r == -1) System.exit(3);
                            p = in.nextInt();  if (p == -1) System.exit(3);
                            if(visited.contains(r)){
                                needToJump = true;
                                jumpCounter = 0;
                            }else{
                                pSum += p;
                                visited.add(r);
                            }
                            jumpCounter ++;
                            if(jumpCounter > 20){
                                needToJump = true;
                                jumpCounter = 0;
                            }

                        }

                        queries--;
                    }
                    double avg = (double) pSum / visited.size();
                    long mid = (long) ((N * avg) / 2.0);
                    long minT = N/2 + N%2;
                    long maxT = ((long)N*(N-1))/2;
                    maxT = maxT - (long)( maxT/3.5);
                    minT = minT + (long) (minT/3.5);
                    if(mid < minT) mid = minT;
                    if(mid > maxT) mid = maxT;
                    String ans = ""E "" + mid;
                    System.out.println(ans);
                    System.out.flush();
                }
            }
        }catch (Exception e){
            System.err.println(e.getMessage());
            e.printStackTrace();
            System.",Vlad
850,"class Solution{
    public static void main(String[] args){
        Scanner s = new Scanner(System.in);
        int t = s.nextInt();
        int x = t;
        while(t>0){
            System.out.print(""Case #""+(x-(t-1))+"":"");
            int a1 = s.nextInt();
            int a2 = s.nextInt();
            int a3 = s.nextInt();
            int a4 = s.nextInt();
            int b1 = s.nextInt();
            int b2 = s.nextInt();
            int b3 = s.nextInt();
            int b4 = s.nextInt();
            int c1 = s.nextInt();
            int c2 = s.nextInt();
            int c3 = s.nextInt();
            int c4 = s.nextInt();
            int min1 = Math.min(a1, Math.min(b1, c1));
            int min2 = Math.min(a2, Math.min(b2, c2));
            int min3 = Math.min(a3, Math.min(b3, c3));
            int min4 = Math.min(a4, Math.min(b4, c4));
            int c  = 0;
            int d = 0;
            if(min1+min2+min3+min4 <1000000){
                System.out.print("" IMPOSSIBLE"");
                System.out.println();
            }
            else if(min1+min2+min3+min4 ==1000000){
                System.out.print("" ""+min1);
                System.out.print("" ""+min2);
                System.out.print("" ""+min3);
                System.out.print("" ""+min4);
                System.out.println();
            }
            
            else{
                int twoSum = min1+min2;
                int rem = 1000000 - twoSum;
                
                if(min3< rem && min4> rem){
                    c = min3;
                    d = 1000000 - (c+twoSum);
                }
                if(min3> rem && min4< rem){
                    d = min3;
                    c = 1000000 - (d+twoSum);
                }
                else if(min3<rem && min4<rem){
                    if(min3+min4 == rem){
                        c = min3;
                        d = min4;
                    }
                    else{
                        c = rem-min3;
                        d = 1000000 -(c+twoSum);
                    }
                    
                }
                else if(min3>rem){
                    c= min3-rem;
                    d = 1000000 -(c+twoSum);
                }
                else if(min4>rem){
                    d = min4-rem;
                    c = 1000000 -(d+twoSum);
                }
                System.out.print("" ""+min1);
                System.out.print("" ""+min2);
                System.out.print("" ""+c);
                System.out.print("" ""+d);
                System.",kaushik_0705
782,"public class Solution {

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        PrintStream out = System.out;

        try {
//            in = new Scanner(new BufferedReader(new FileReader(""/Users/Shared/Sources/CodingStudy/src/codejam/year2022/round_QA/ChainReactions/sample/sample_ts1-in.txt"")));
//            out = new PrintStream(new FileOutputStream(""/Users/Shared/Sources/CodingStudy/src/codejam/year2022/round_QA/ChainReactions/sample/sample_ts1-out.txt""));

//            in = new Scanner(new BufferedReader(new FileReader(""/Users/Shared/Sources/CodingStudy/src/codejam/year2022/round_QA/ChainReactions/sample/sample_ts2-in.txt"")));
//            out = new PrintStream(new FileOutputStream(""/Users/Shared/Sources/CodingStudy/src/codejam/year2022/round_QA/ChainReactions/sample/sample_ts2-out.txt""));

        } catch (Exception e) {
            e.printStackTrace();
            return;
        }

        int T = in.nextInt();
        for (int t = 1; t <= T; t++) {
            int N = in.nextInt();

            int[] F = new int[N];
            for( int i=0;i<N;i++){
                F[i] = in.nextInt();
            }
            int[] parent = new int[N];
            for( int i=0;i<N;i++){
                parent[i] = in.nextInt();
            }

            long ans = getAnswer(N, F, parent);

            out.printf(""Case #%d: %d
"", t, ans);
        }
        in.close();
    }


    private static long getAnswer(int N, int[] F, int[] parent) {

        Map<Integer, List<Integer>> graph = new HashMap<>();

        Map<Integer,Integer> inDegree = new HashMap<>();
        Map<Integer,Integer> outDegree = new HashMap<>();

        Map<Integer,Boolean> visited = new HashMap<>();

        /* 1. Build graph. */
        for(int i=1;i<=N;i++) {
            graph.put(i, new ArrayList<>());
            inDegree.put(i, 0);
            outDegree.put(i, 0);
            visited.put(i, false);
        }

        for(int i=0;i<N;i++){
            int childNo = i + 1;
            int parentNo = parent[i];

            if( parentNo != 0) {
                graph.get(parentNo).add(childNo);
                inDegree.put(parentNo, inDegree.get(parentNo) + 1);
                outDegree.put(childNo, 1);
            }else{
                outDegree.put(childNo, 0);
            }

        }

        /* 3. Do DFS by maxEst */
        long ans = doDFSByMaxEst(N, F, graph, outDegree, visited);
        return ans;
    }

    private static long doDFSByMaxEst(int N, int[] F, Map<Integer, List<Integer>> graph, Map<Integer, Integer> outDegree, Map<Integer,Boolean> visited) {
        long sum = 0;
        for(Map.Entry<Integer,Integer> entry : outDegree.entrySet()){
            int rootNo = entry.getKey();
            if(entry.getValue() == 0 && visited.get(rootNo) == false){
                long val = doDFSByMaxEst(N, F, graph, rootNo, visited);
                sum += val;
            }
        }

        return sum;
    }

    private static long doDFSByMaxEst(int N, int[] F, Map<Integer, List<Integer>> graph, int rootNo, Map<Integer,Boolean> visited) {
        visited.put(rootNo, true);

        // Leaf node
        if( graph.get(rootNo).size() == 0){
            return F[rootNo-1];
        }

        // Non-leaf node
        List<Long> cands = new ArrayList<>();
        for(int childNo: graph.get(rootNo)){
            if(childNo < rootNo)   {
                continue;
            }

            if( visited.get(childNo) == false) {
                long val = doDFSByMaxEst(N, F, graph, childNo, visited);
                cands.add(val);
            };
        }

        Collections.sort(cands);
        long smallest = cands.remove(0);
        if( smallest < F[rootNo-1]){
            cands.add( Long.valueOf(F[rootNo-1]));
        }else{
            cands.add(smallest);
        }


        long sum = cands.stream()
                .collect(Collectors.summingLong(Long::longValue));
//        System.err.printf(""RootNo: %d Ret: %d Values: %s
"", rootNo, sum, cands);

        return sum;
    }
}",id
370,"class Solution
{
    public static void main(String[] args) {
        Scanner in=new Scanner(System.in);
        int t=in.nextInt();
    
       for(int ca=1;ca<=t;ca++)
        {
            int n=in.nextInt();
            long arr[]=new long[n];
            for(int i=0;i<n;i++)
            {
                arr[i]=in.nextLong();
            }
            solve(arr,ca);
        }
    }

      static void solve( long arr[],int ca) {
        long count=0;
        for(int i=0;i<arr.length;i++)
        {
            if(arr[i]>count)
            {
                count++;
            }//else{break;}
         

        }
        long max=count;
      count=0;
      for(int i=arr.length-1;i>=0;i--)
      {
          if(arr[i]>count)
          {
              count++;
          }
      }
      max=",SampathRajaRaghupathi
881,"public class Solution {

    public static void main(String[] args) {
        try (PrintWriter out = new PrintWriter(System.out)) {
            FastScanner in = new FastScanner(System.in);
            solve(in, out);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    private static void solve(FastScanner in, PrintWriter out) throws IOException {
        Random random = new Random();

        int t = in.nextInt();
        for (int q = 1; q <= t; q++) {

            int N = in.nextInt();
            int K = in.nextInt();

            double sum = 0;

            int S = in.nextInt();
            int P = in.nextInt();

            for (int i = 0; i < K; i++) {
                int r = random.nextInt(N) + 1;
                out.println(""T "" + r);
                out.flush();

                S = in.nextInt();
                P = in.nextInt();

                sum += P;
            }

            sum = sum * N / (2 * K);

            if (sum < 2 * N - 2) {
                sum = 2 * N - 2;
            }

            //sum = sum * 4 / 3;

            out.println(""E "" + Math.round(sum));
            out.flush();

        }
    }

    private static class FastScanner {
        private final BufferedReader reader;
        private String[] tokens = null;
        private int cnt = -1;

        public FastScanner(InputStream inputStream) {
            reader = new BufferedReader(new InputStreamReader(inputStream, StandardCharsets.UTF_8));
        }

        public String next() throws IOException {
            if (tokens == null || cnt >= tokens.length) {
                String line = reader.readLine();
                if (line != null) {
                    tokens = line.split(""\\\s"");
                } else {
                    throw new RuntimeException(""not found"");
                }
                cnt = 0;
            }
            return tokens[cnt++];
        }

        public Integer nextInt() throws IOException {
            return Integer.parseInt(next());
        }

        public Long nextLong() throws IOException {
            return Long.parseLong(next());
        }

        public Double nextDouble() throws IOException {
            return Double.parseDouble(next());
        }
    }

    private static class Pair<S, T> {
        public S first;
        public T second;

        public Pair(S first, T second) {
            this.first = first;
            this.second = second;
        }
    }
}",khlyting
620,"public class Solution {

    private static CodeJamIO io = new CodeJamIO();

    /**
     * @param args
     */
    public static void main(String[] args) {

        try {
            init();

            int numCases = Integer.parseInt(io.readNextLine()[0]);
            for (int i=1; i <= numCases; i++) {
                io.debug(""Solving Case #"" + i + ""..."");
                solveCase(i);
                io.debug(""Case #"" + i + "" solved!"");
            }

        } catch (Exception e) {
            e.printStackTrace();
        }

    }

    /**
     * Performs initial computations
     */
    private static void init() {

    }

    /**
     * Solves a Test Case
     *
     * @param caseNum
     * @throws IOException
     */
    private static void solveCase(int caseNum) throws IOException {
        // Read input
        String[] tokens = io.readNextLine();
        int n = Integer.parseInt(tokens[0]);
        Node[] nodes = new Node[n+1];
        nodes[0] = new Node(0);
        tokens = io.readNextLine();
        for (int i=1; i<n+1; i++) {
            nodes[i] = new Node(Long.parseLong(tokens[i-1]));
        }
        tokens = io.readNextLine();
        for (int i=1; i<n+1; i++) {
            int next = Integer.parseInt(tokens[i-1]);
            nodes[next].previous.add(nodes[i]);
        }

        // Do the work
        long totalFun = calcMaxFuns(nodes[0]).stream().mapToLong(Long::longValue).sum();

        // Print results
        io.printCase(caseNum).println(totalFun);
    }

    private static Deque<Long> calcMaxFuns(Node node) {
        if (node.previous.isEmpty()) {
            return new LinkedList<>(){{ add(node.fun); }};
        }
        Node[] previous = node.previous.toArray(new Node[0]);
        long[] previousFuns = new long[previous.length];
        Deque<Long> allFuns = new LinkedList<>();
        for (int i=0; i < previous.length; i++) {
            Long[] maxFuns = calcMaxFuns(previous[i]).toArray(new Long[0]);
            previousFuns[i] = maxFuns[0];
            Arrays.stream(maxFuns, 1, maxFuns.length).forEach(f -> allFuns.add(f));
        }
        Arrays.sort(previousFuns);
        if (node.fun > previousFuns[0]) {
            previousFuns[0] = node.fun;
        }
        Arrays.stream(previousFuns).forEach(f -> allFuns.push(f));
        return allFuns;
    }

    private static class Node {
        private long fun;
        private List<Node> previous;

        private Node(long fun) {
            this.fun = fun;
            previous = new LinkedList<>();
        }
    }

    /**
     * Input and Output CodeJam style
     *
     */
    private static class CodeJamIO {
        private static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        private static PrintWriter out = new PrintWriter(System.out, true);
        private static PrintWriter err = new PrintWriter(System.err, true);

        public String[] readNextLine() throws IOException {
            String line = in.readLine();
            String[] tokens = line.split(""\\\s+"");
            return tokens;
        }

        public CodeJamIO printCase(int caseNum) { return print(""Case #"" + caseNum + "": "" ); }

        public CodeJamIO print(Object o) { out.print(o); return this; }

        public CodeJamIO print(Object o[]) { return print(concat(o)); }

        public CodeJamIO print(Object o[][]) { return print(concat(o)); }

        public CodeJamIO println() { out.println(); return this; }

        public CodeJamIO printlnCase(int caseNum) { return printCase(caseNum).println(); }

        public CodeJamIO println(Object o) { return print(o).println(); }

        public CodeJamIO println(Object o[]) { return print(o).println(); }

        public CodeJamIO println(Object o[][]) { return print(concat(o)).println(); }

        public CodeJamIO println(List<Integer[]> l) { return print(concat(l)).println(); }


        private String concat(Object[] o) {
            StringBuffer buf = new StringBuffer(10*o.length);

            String delim = """";
            for (int i=0; i < o.length; i++) {
                buf.append(delim).append(o[i]);
                delim = "" "";
            }
            return buf.toString();
        }

        private String concat(Object[][] o) {
            StringBuffer buf = new StringBuffer(100*o.length);
            for (int i=0; i < o.length; i++) {
                buf.append(concat(o[i])).append(""
"");
            }
            return buf.toString();
        }

        private String concat(List<Integer[]> list) {
            StringBuffer buf = new StringBuffer();
            String delim = """";
            for (Object[] elm : list) {
                buf.append(delim).append(concat(elm)).append(""
"");
            }
            return buf.toString();
        }

        public void debug(String message) {
            err.println(Calendar.getInstance().getTime() + "": "" + message);
        }

        public void debug(String message, Object[] o) {
            err.println(Calendar.getInstance().getTime() + "": "" + message);
            err.println(""	"" + concat(o));
        }

        public void debug(String message, Object[][] o) {
            err.println(Calendar.getInstance().getTime() + "": "" + message);
            String values = concat(o);
            err.println(""	"" + values.replaceAll(""
"", ""
	""));
        }

        public void debug(String message, List<Integer[]> list) {
            err.println(Calendar.getInstance().getTime() + "": "" + message);
            String values = concat(list);
            err.println(""	"" + values.replaceAll(""
"", ""
	""));
        }

        public void flush() {
            out.flush();
            err.flush();
        }

    }
",ddimi
395,"class Solution{
    static int maxans;
    public Solution(){
        maxans=0;
    }
    
    public static LinkedList<Integer> adj[];
    public static void Com(int end,int[] initiator,int N,List<Integer> temp,boolean[] tracker,int [] fun){
        if(temp.size()==end){
            int ans=0;
            boolean[] tracke = new boolean[N+1];
            tracke[0]=true;
            for(Integer v: temp){
                ans+=DFS(v,fun,tracke);
            }
            maxans=Math.max(maxans,ans);
            return;
        }
        for(int i=0 ;i<end;i++){
            if(!tracker[i]){
                temp.add(initiator[i]);
                tracker[i]=true;
                Com(end,initiator,N,temp,tracker,fun);
                temp.remove(temp.size()-1);
                tracker[i]=false;
            }
        }
        
    }
    
    public static int DFS(int s,int[] fun,boolean[] tracker){
        if(tracker[s]){
            return 0;
        }
        int max=fun[s-1];
        tracker[s]=true;
        Iterator<Integer> i = adj[s].listIterator();
        while(i.hasNext()){
            int n= i.next();
            if(!tracker[n]){
                int score = DFS(n,fun,tracker);
                max=Math.max(score,max);
                
            }
        }
        
        return max;
    }
    
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        int index=T;
        while(T-- > 0){
            new Solution();
            int N = sc.nextInt();
            int[] fun = new int[N];
            int[] edge = new int[N];
            for(int i=0;i<N;i++){
                fun[i]=sc.nextInt();
            }
            for(int i=0;i<N;i++){
                edge[i]=sc.nextInt();
            }
            int[] degree = new int[N+1];
            for(int i=0;i<N;i++){
                degree[edge[i]]+=1;
            }
            adj=new LinkedList[N+1];
            for(int i=0;i<N+1;i++){
                adj[i]=new LinkedList();
            }
            for(int i=0;i<N;i++){
                adj[i+1].add(edge[i]);
            }
            
            
            int[] initiator = new int[N];
            int k=0;
            for(int i=1;i<N+1;i++){
                if(degree[i]==0){
                    initiator[k++]=i;
                }
            }
           
            List<Integer> temp = new ArrayList<>();
            boolean[] t = new boolean[k];
            Com(k,initiator,N,temp,t,fun);
            
                System.",Sujit_Das
730,"public class Solution {

    public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        PrintWriter writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));

        int T = in.nextInt();
        for (int casNumero = 1; casNumero <= T; casNumero++) {
            StringBuilder resultat = new StringBuilder();
            resultat.append(""Case #"");
            resultat.append(casNumero);
            resultat.append("": "");

            int n = in.nextInt();
            long[] f = new long[n];
            for (int i = 0; i < n; i++) {
                f[i] = in.nextLong();
            }
            int[] p = new int[n];
            for (int i = 0; i < n; i++) {
                p[i] = in.nextInt();
            }

            List<Integer> triggers = new ArrayList<>();
            for (int i = 1; i < n+1; i++) {
                int finalI = i;
                if (Arrays.stream(p).noneMatch(a -> a == finalI)) {
                    triggers.add(finalI);
                }
            }
            List<Integer> used = new ArrayList<>();
            long sumFun = 0;
            while (!used.containsAll(triggers)) {
                long minFun = 0;
                int bestTrigger = 0;
                for (Integer trigger : triggers) {
                    if (!used.contains(trigger)) {
                        long fun = getFun(trigger.intValue(), f, p, used);
                        if (minFun == 0 || minFun > fun) {
                            minFun = fun;
                            bestTrigger = trigger.intValue();
                        }
                        else if (minFun == fun) {
                            int commonModule = getCommonModule(bestTrigger, trigger, p);
                            if (commonModule == 0 && f[trigger - 1] < f[bestTrigger - 1]) {
                                minFun = fun;
                                bestTrigger = trigger.intValue();
                            }
                            else if (commonModule != 0) {
                                used.add(commonModule);
                                if (getFun(trigger.intValue(), f, p, used) < getFun(bestTrigger, f, p, used)) {
                                    minFun = fun;
                                    bestTrigger = trigger.intValue();
                                }
                                used.remove(Integer.valueOf(commonModule));
                            }
                        }
                    }
                }
                sumFun += minFun;
                used.addAll(getRelations(bestTrigger, p, used));
            }
            resultat.append(sumFun);
            writer.print(resultat.toString());
            writer.println();
        }
        in.close();
        writer.close();
    }

    private static int getCommonModule(int index1, int index2, int[] p) {
        int currentIndex1 = p[index1 - 1];
        int currentIndex2 = p[index2 - 1];
        int commonModule = 0;
        while (commonModule == 0 && currentIndex1 != 0 && currentIndex2 != 0) {
            if (currentIndex1 == currentIndex2) {
                commonModule = currentIndex1;
            }
            else if (currentIndex1 > currentIndex2) {
                currentIndex1 = p[currentIndex1 - 1];
            }
            else {
                currentIndex2 = p[currentIndex2 - 1];
            }
        }
        return commonModule;
    }

    private static List<Integer> getRelations(int index, int[] p, List<Integer> used) {
        List<Integer> relations = new ArrayList<>();
        relations.add(index);
        int currentIndex = index;
        while (!used.contains(currentIndex) && p[currentIndex - 1] != 0) {
            currentIndex = p[currentIndex - 1];
            relations.add(currentIndex);
        }
        return relations;
    }

    private static long getFun(int index, long[] f, int[] p, List<Integer> used) {
        long fun = f[index - 1];
        int relation = p[index - 1];
        if (relation != 0 && !used.contains(relation)) {
            long relationFun = getFun(relation, f, p, used);
            if (relationFun > fun) {
                fun = ",gerardmr
644,"public class Solution {

    private int N;
    private ArrayList<int[][]> tables = new ArrayList<>();

    public static void main(String[] args) {

        Solution printing3D = new Solution();
        printing3D.readInput();

        for (int x = 0; x< printing3D.tables.size(); x++) {
            int[][] table = printing3D.tables.get(x);

            printing3D.solveTestCase(x, table);
        }

    }

    private void solveTestCase(int x, int[][] cartridges) {

        int[] CMYK = minimumCMYK(cartridges);
        boolean isPossible = isPossible(CMYK);

        if(isPossible) {
            int[] finalCMYK = calculateCMYK(CMYK);
            System.out.println(String.format(""Case #%d: %d %d %d %d"", x+1, finalCMYK[0], finalCMYK[1], finalCMYK[2], finalCMYK[3]));
        } else {
            System.out.println(String.format(""Case #%d: IMPOSSIBLE"", x+1));
        }
    }

    private int[] calculateCMYK(int[] CMYK) {
        int remainingInkUnits = 1000000;
        int[] finalCMYK = new int[4];

        for(int i=0; i<CMYK.length; i++) {
            if (remainingInkUnits==0) {
                finalCMYK[i] = 0;
            }

            if(remainingInkUnits >= CMYK[i]) {
                finalCMYK[i] = CMYK[i];
            } else {
                finalCMYK[i] = remainingInkUnits;
            }

            remainingInkUnits -= finalCMYK[i];
        }
        return finalCMYK;
    }

    private int[] minimumCMYK(int[][] cartridges) {
        int[] CMYK = new int[4];
        CMYK[0] = cartridges[0][0];
        CMYK[1] = cartridges[0][1];
        CMYK[2] = cartridges[0][2];
        CMYK[3] = cartridges[0][3];

        for (int i = 0; i < cartridges.length; i++) {
            for (int j = 0; j < cartridges[i].length; j++){
                if(cartridges[i][j] < CMYK[j]) {
                    CMYK[j] = cartridges[i][j];
                }
            }
        }

        return CMYK;
    }

    private boolean isPossible(int[] CMYK) {
        boolean isPossible;

        int totalInkUnits = 0;
        for (int i = 0; i < CMYK.length; i++) {
            if(CMYK[i]<0) return false;
            totalInkUnits += CMYK[i];
        }

        isPossible = (totalInkUnits >= 1000000);
        return isPossible;
    }

    private void readInput() {

        Scanner reader = new Scanner(System.in);
        String data;

        if (reader.hasNextLine()) {
            data = reader.nextLine();
            N = Integer.parseInt(data);
        }

        for (int i = 0; i < N; i++) {
            int[][] table = new int[N][4];

            for (int j = 0; j < 3; j++) {
                data = reader.nextLine();

                String[] cells = data.split("" "", 0);
                table[j][0] = Integer.parseInt(cells[0]);
                table[j][1] = Integer.parseInt(cells[1]);
                table[j][2] = Integer.parseInt(cells[2]);
                table[j][3] = Integer.parseInt(cells[3]);
            }

            tables.add(table);
        }

        reader.",dionysis_dt
389,"public class Solution {
    public static Scanner scan;
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int runtime = scan.nextInt();
        int a=1000000000;
        for(int i=0;i<runtime;i++){
            int num=scan.nextInt();
            int [] array=new int[num];
            int [] array2=new int[num];
            for(int j=0;j<num;j++){
                int numside=scan.nextInt();
                array[j]=numside;
            }
            for(int d=0;d<array.length;d++) {
                for (int c = d+1; c < array.length; c++) {
                    if (array[d] > array[c]) {
                        a = array[d];
                        array[d] = array[c];
                        array[c] = a;
                    }
                }
            }
            System.out.print(""Case #""+"" ""+(i+1)+"":"");
            int t=0;
            for(int d=0;d<array.length;d++) {
                t++;
                if (array[d]<t) {
                    t--;
                }
            }
            System.",ShuoXu
1334,"public class Solution {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
		int n = scanner.nextInt();
        for (int i = 0; i < n; i++) {
            int N = scanner.nextInt();
            List<Node> rootList = new ArrayList<>();
            Node[] arr = new Node[N];
            for(int j=0; j<N; j++) {
                arr[j] = new Node(j+1, scanner.nextLong());
		    }
            for(int j=0; j<N; j++) {
                int p = scanner.nextInt();
                if(p==0) {
                    rootList.add(arr[j]);
                } else {
                    Node node = arr[p-1];
                    node.son.add(arr[j]);
                    arr[p-1] = node;
                }
            }
            long total = 0;
            for (int k=0; k<rootList.size(); k++) {
                total += dfs(rootList.get(k)).sum;
            }
            System.out.print(""Case #""+(i+1)+"": "");
            System.out.println(total);
       }
    }

    public static Data dfs(Node node) {
        if(node.son.size()==0) {
            return new Data(node.value, node.value);
        }
        int n = node.son.size();
        long minSon = Long.MAX_VALUE;
        int sum = 0;
        for (int i = 0; i < n; i++) {
            Data sonData = dfs(node.son.get(i));
            minSon = Math.min(sonData.minV, minSon);
            sum += sonData.sum;
        }

        if(node.value > minSon) {
            return new Data(sum+(node.value-minSon), node.value);
        } else {
            return new Data(sum, minSon);
        }
    }

    static class Data {
        long sum;
        long minV;
        public Data(long sum, long minV) {
            this.sum = sum;
            this.minV = minV;
        }
    }

    static class Node {
        public long value;
        public int i;
        public List<Node> son;
        public Node(int i, long value) {
            this.i = i;
            this.value = value;
            son = ",xinyou
844,"class Solution{
    public static void main(String[] args){
        Scanner s = new Scanner(System.in);
        int t = s.nextInt();
        int x = t;
        while(t>0){
            System.out.print(""Case #""+(x-(t-1))+"":"");
            int a1 = s.nextInt();
            int a2 = s.nextInt();
            int a3 = s.nextInt();
            int a4 = s.nextInt();
            int b1 = s.nextInt();
            int b2 = s.nextInt();
            int b3 = s.nextInt();
            int b4 = s.nextInt();
            int c1 = s.nextInt();
            int c2 = s.nextInt();
            int c3 = s.nextInt();
            int c4 = s.nextInt();
            int min1 = Math.min(a1, Math.min(b1, c1));
            int min2 = Math.min(a2, Math.min(b3, c2));
            int min3 = Math.min(a3, Math.min(b3, c3));
            int min4 = Math.min(a4, Math.min(b4, c4));
            if(min1+min2+min3+min4 <1000000){
                System.out.print("" IMPOSSIBLE"");
                System.out.println();
            }
            else{
                int twoSum = min1+min2;
                int rem = 1000000 - twoSum;
                int c  = 0;
                int d = 0;
                if(min3<rem && min4<rem){
                    c = rem-min3;
                    d = 1000000 -(c+twoSum);
                }
                else if(min3>rem){
                    c= min3-rem;
                    d = 1000000 -(c+twoSum);
                }
                else if(min4>rem){
                    d = min4-rem;
                    c = 1000000 -(d+twoSum);
                }
                System.out.print("" ""+min1);
                System.out.print("" ""+min2);
                System.out.print("" ""+c);
                System.out.print("" ""+d);
                System.",kaushik_0705
832,"public class Solution {

    public static void main(String[] args) {

        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.

        int N;
        int[] dices;
        for (int i = 1; i <= t; i++) {
            N = in.nextInt();
            dices = new int[N];
            for (int j = 0; j < N; j++) {
                dices[j] = in.nextInt();
            }
            System.out.print(""Case #"" + i + "": "");
            getStairs(dices);
            if(t!=i)
                System.out.println("""");
        }

    }

    public static void getStairs(int[] dices){

        long x = 0;
        long max = Arrays.stream(dices).min().isPresent() ? Arrays.stream(dices).max().getAsInt() : 0;
        while(true){

            long min = Arrays.stream(dices).min().isPresent() ? Arrays.stream(dices).min().getAsInt() : 0;
            long times = Arrays.stream(dices).filter( i -> i==min).count();

            x += Math.min(times, min);
            if(x>min) x = min;
            if(min == max) break;

            dices = ",jonathan38m
616,"public class Solution {

    private static CodeJamIO io = new CodeJamIO();

    /**
     * @param args
     */
    public static void main(String[] args) {

        try {
            init();

            int numCases = Integer.parseInt(io.readNextLine()[0]);
            for (int i=1; i <= numCases; i++) {
                io.debug(""Solving Case #"" + i + ""..."");
                solveCase(i);
                io.debug(""Case #"" + i + "" solved!"");
            }

        } catch (Exception e) {
            e.printStackTrace();
        }

    }

    /**
     * Performs initial computations
     */
    private static void init() {

    }

    /**
     * Solves a Test Case
     *
     * @param caseNum
     * @throws IOException
     */
    private static void solveCase(int caseNum) throws IOException {
        // Read input
        String[] tokens = io.readNextLine();
        int n = Integer.parseInt(tokens[0]);
        int k = Integer.parseInt(tokens[1]);
        if (k > n) {
            k = n;
        }

        // Interact
        double[] p = new double[k];
        double e = 0;
        Set<Integer> rooms = new HashSet<>();

        tokens = io.readNextLine();
        rooms.add(Integer.parseInt(tokens[0]));
        int passages = Integer.parseInt(tokens[1]);
        p[0] = passages;
        e += p[0];
        double sum = 0;

        for (int i=0; i<k; i++) {
            if (p[i] > i) {
                io.println(""W"");
            } else {
                io.println(""T "" + String.valueOf(pickRoom(n, rooms)));
            }
            tokens = io.readNextLine();
            rooms.add(Integer.parseInt(tokens[0]));
            passages = Integer.parseInt(tokens[1]);
            if (p[i] > i) {
                p[i+1] = passages - 1;
            } else {
                p[i+1] = passages - p[i] / (n-1);
            }
            p[i+1] -= sum / (n-1);
            e += p[i+1];
            sum += p[i];
        }
        e *= 1.0 * n / k;

        // Print results
        io.println(""E "" + String.valueOf(Math.round(e)));
    }

    private static int pickRoom(int n, Set<Integer> rooms) {
        for (int i=0; i<n; i++) {
            if (!rooms.contains(i+1)) {
                return i+1;
            }
        }
        throw new RuntimeException();
    }

    /**
     * Input and Output CodeJam style
     *
     */
    private static class CodeJamIO {
        private static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        private static PrintWriter out = new PrintWriter(System.out, true);
        private static PrintWriter err = new PrintWriter(System.err, true);

        public String[] readNextLine() throws IOException {
            String line = in.readLine();
            String[] tokens = line.split(""\\\s+"");
            return tokens;
        }

        public CodeJamIO printCase(int caseNum) { return print(""Case #"" + caseNum + "": "" ); }

        public CodeJamIO print(Object o) { out.print(o); return this; }

        public CodeJamIO print(Object o[]) { return print(concat(o)); }

        public CodeJamIO print(Object o[][]) { return print(concat(o)); }

        public CodeJamIO println() { out.println(); return this; }

        public CodeJamIO printlnCase(int caseNum) { return printCase(caseNum).println(); }

        public CodeJamIO println(Object o) { return print(o).println(); }

        public CodeJamIO println(Object o[]) { return print(o).println(); }

        public CodeJamIO println(Object o[][]) { return print(concat(o)).println(); }

        public CodeJamIO println(List<Integer[]> l) { return print(concat(l)).println(); }


        private String concat(Object[] o) {
            StringBuffer buf = new StringBuffer(10*o.length);

            String delim = """";
            for (int i=0; i < o.length; i++) {
                buf.append(delim).append(o[i]);
                delim = "" "";
            }
            return buf.toString();
        }

        private String concat(Object[][] o) {
            StringBuffer buf = new StringBuffer(100*o.length);
            for (int i=0; i < o.length; i++) {
                buf.append(concat(o[i])).append(""
"");
            }
            return buf.toString();
        }

        private String concat(List<Integer[]> list) {
            StringBuffer buf = new StringBuffer();
            String delim = """";
            for (Object[] elm : list) {
                buf.append(delim).append(concat(elm)).append(""
"");
            }
            return buf.toString();
        }

        public void debug(String message) {
            err.println(Calendar.getInstance().getTime() + "": "" + message);
        }

        public void debug(String message, Object[] o) {
            err.println(Calendar.getInstance().getTime() + "": "" + message);
            err.println(""	"" + concat(o));
        }

        public void debug(String message, Object[][] o) {
            err.println(Calendar.getInstance().getTime() + "": "" + message);
            String values = concat(o);
            err.println(""	"" + values.replaceAll(""
"", ""
	""));
        }

        public void debug(String message, List<Integer[]> list) {
            err.println(Calendar.getInstance().getTime() + "": "" + message);
            String values = concat(list);
            err.println(""	"" + values.replaceAll(""
"", ""
	""));
        }

        public void flush() {
            out.flush();
            err.flush();
        }

    }
",ddimi
263,"public class Solution {
    public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        int t = in.nextInt();
        for (int i=1; i<=t; i++) {
            int n = in.nextInt();
            int k = in.nextInt();
            List<Integer> randoms = new ArrayList<>();
            for (int j=1; j<=n; j++) {
                randoms.add(j);
            }
            int firstRoom = in.nextInt();
            randoms.remove(Integer.valueOf(firstRoom));
            int roomQueries = 1;
            long links = in.nextInt();
            while(k>0 && roomQueries<n) {
                int rand = (int)(Math.random() * randoms.size()); 
                System.out.println(""T "" + randoms.remove(rand));
                in.nextInt();
                int thisLink = in.nextInt();
                roomQueries += 1;
                links += thisLink;
                k -= 1;
            }
            if (roomQueries<n) {
                links += links*(n-roomQueries)/roomQueries;
            }
            links = ",MehdiKalhori
541,"public class Solution {
//public class C {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int ttt = Integer.parseInt(br.readLine());
        for (int tt = 1; tt <= ttt; ++tt) {
            int prev = -1;

            for (int i = 0; i < 301; i++) {
                final int curr = Integer.parseInt(br.readLine());
                if (curr == -1) {
                    System.exit(0);
                } else if (curr == 0) {
                    break;
                } else if (curr == 1) {
                    send(3);
                } else if (curr == 2) {
                    send(2);
                } else if (curr == 3) {
                    send(1);
                } else if (curr == 4) {
                    if (prev == 4) {
                        System.out.println(""11110000"");
                    } else {
                        send(4);
                    }
                } else if (curr == 5) {
                    send(3);
                } else if (curr == 6) {
                    send(2);
                } else if (curr == 7) {
                    send(3);
                } else if (curr == 8) {
                    send(8);
                }
                prev = curr;
            }
        }
    }

    private static void send(int i) {
        System.out.println(get(i));
    }

    private static String get(int i) {
        if (i == 8) return ""11111111"";
        if (i == 3) return ""10101000"";
        if (i == 4) return ""10101010"";
        if (i == 1) return ""10000000"";
        throw new IllegalStateException();
    }

",attila
1019,"public class Solution {
    public static void main(String[] args) {
        Scanner inp = new Scanner(System.in);

        int t = inp.nextInt();

        for (int j = 0; j < t; j++) {
            System.out.printf(""Case #:%d
"",j);
            int r = inp.nextInt();
            int c = inp.nextInt();
            inp.nextLine();

            for(int ri = 0; ri < 2*r + 1 ; ri++){
              for(int ci = 0 ; ci < 2*c + 1; ci++ ){
                  if(ri%2==0){
                      if(((ri==0)||(ri==1))&&((ci==0)||(ci==1))) {
                          System.out.print(""."");
                      }
                      else if(ci%2==0){ System.out.print(""+"");}
                      else System.out.print(""-"");

                      if(ci==2*c)
                          System.out.println("""");
                  }
                  if(ri%2==1){
                      if(((ri==0)||(ri==1))&&((ci==0)||(ci==1))) {
                          System.out.print(""."");
                      }
                      else if(ci%2==0){ System.out.print(""|"");}
                      else System.out.print(""."");
                      if(ci==2*c)
                          System.out.println("""");
                  }

              }
            }




        }
    }
}",parthanos
203,"public class Solution {
    public static void main(String[] args) throws FileNotFoundException {
        try (Scanner reader = new Scanner(System.in)){
            if (reader.hasNextLine() && reader.hasNextInt()) {
                // Read the number of test cases
                int T = Integer.parseInt(reader.nextLine());
                int cap = 1000000;
                for (int t = 0; t < T; t++) {
                    int availableCyan = cap;
                    int availableMagenta = cap;
                    int availableYellow = cap;
                    int availableBlack = cap;
                    for (int i = 0; i < 3; i++) {
                        int printerCyan = reader.nextInt();
                        int printerMagenta = reader.nextInt();
                        int printerYellow = reader.nextInt();
                        int printerBlack = reader.nextInt();
                        if (printerCyan < availableCyan) {
                            availableCyan = printerCyan;
                        }
                        if (printerMagenta < availableMagenta) {
                            availableMagenta = printerMagenta;
                        }
                        if (printerYellow < availableYellow) {
                            availableYellow = printerYellow;
                        }
                        if (printerBlack < availableBlack) {
                            availableBlack = printerBlack;
                        }
                    }
                    System.out.print(""Case #"" + (t + 1) + "": "");
                    if (availableCyan == cap) {
                        availableMagenta = 0;
                        availableYellow = 0;
                        availableBlack = 0;
                    } else if (availableCyan + availableMagenta >= cap) {
                        availableMagenta = cap - availableCyan;
                        availableYellow = 0;
                        availableBlack = 0;

                    } else if (availableCyan + availableMagenta + availableYellow >= cap) {
                        availableYellow = cap - availableCyan - availableMagenta;
                        availableBlack = 0;
                    } else if (availableCyan + availableMagenta + availableYellow + availableBlack >= cap) {
                        availableBlack = cap - availableCyan - availableMagenta - availableYellow;
                    } else {
                        System.out.println(""IMPOSSIBLE"");
                        continue;
                    }
                    System.",Larsvr
11,"public class Solution {

  private static Random RANDOM=new Random();

  public static void main(String[] args) throws Throwable {
    try (BufferedReader in=new BufferedReader(new InputStreamReader(System.in))) {
      try (PrintStream out=System.out) {
        final int T=Integer.parseInt(in.readLine());
        for (int c=1; c<=T; c++) {
          int W=0;
          while (true) {
            out.println(byteToString(W));
            out.flush();
            final int b=Integer.parseInt(in.readLine());
            if (b==0) break;
            if (b==-1) return;
            W=getRandomW(b);
          }
        }
      }
    }
  }

  public static int rotate(int X, int r) {
    return (X>>>r)|((X<<(8-r))&0xFF);
  }

  public static String byteToString(int number) {
    final String string=Integer.toBinaryString(number);
    return new String(new char[8-string.length()]).replace('\\0','0')+string;
  }

  public static void simulateRandom() {
    for (int iteration=0; iteration<100; iteration++) {
      int X=1+RANDOM.nextInt(255);
      int W=0b00000000;
      for (int i=0; i<300&&X!=0; i++) {
        int r=RANDOM.nextInt(8);
        X=rotate(X,r)^W;
        final int b=Integer.bitCount(X);
        if (b==0) {
          System.out.println(""WIN	""+i);
          break;
        }
      }
    }
  }

  public static int getRandomW(int b) {
    final List<Integer> options=new ArrayList<>();
    for (int Wp=",ASotelo
865,"public class Solution {
    
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        int T = Integer.parseInt(in.readLine());
        for (int e = 0; e < T; e++) {
            System.out.print(""Case #"" + (e + 1) + "": "");
            StringTokenizer st = new StringTokenizer(in.readLine());
            int N = Integer.parseInt(st.nextToken()), P = Integer.parseInt(st.nextToken());
            long[][] X = new long[N + 1][P + 1];
            long[] smallest = new long[N + 1];
            long[] biggest = new long[N + 1];
            long[] smallestTwo = new long[N + 1];
            long[] biggestTwo = new long[N + 1];
            for (int i = 1; i <= N; i++) {
                StringTokenizer st1 = new StringTokenizer(in.readLine());
                for (int j = 1; j <= P; j++) {
                	X[i][j] = Long.parseLong(st1.nextToken());
                	if (j == 1) {
                		smallest[i] = X[i][j];
                		smallestTwo[i] = X[i][j];
                		biggest[i] = X[i][j];
                		biggestTwo[i] = X[i][j];
                	}
                	if (X[i][j] < smallest[i]) {
                		smallestTwo[i] = smallest[i];
                		smallest[i] = X[i][j];
                	} else if (X[i][j] < smallestTwo[i]) {
                		smallestTwo[i] = X[i][j];
                	}
                	if (X[i][j] > biggest[i]) {
                		biggestTwo[i] = biggest[i];
                		biggest[i] = X[i][j];
                	} else if (X[i][j] > biggestTwo[i]) {
                		biggestTwo[i] = X[i][j];
                	}
                }
            }
            long[][] dp = new long[N + 1][P + 1];
        	long goToLo = Long.MAX_VALUE, goToHi = Long.MAX_VALUE, pGoToLo = smallest[1], pGoToHi = biggest[1];
            for (int i = 1; i <= N; i++) {
            	for (int j = 1; j <= P; j++) {
            		long distA = pGoToLo + biggest[i] - smallest[i] + biggest[i] - X[i][j];
            		long distB = pGoToHi + biggest[i] - smallest[i] + X[i][j] - smallest[i];
            		dp[i][j] = Math.min(distA, distB);
            		if (i < N) goToLo = Math.min(goToLo, dp[i][j] + Math.abs(X[i][j] - smallest[i + 1]));
            		if (i < N) goToHi = Math.min(goToHi, dp[i][j] + Math.abs(X[i][j] - biggest[i + 1]));
            	}
            	pGoToLo = goToLo;
            	pGoToHi = goToHi;
            	goToLo = Long.MAX_VALUE;
            	goToHi = Long.MAX_VALUE;
            }
            long ans = Long.MAX_VALUE;
            for (int i = 1; i <= P; i++) {
            	ans = ",kevinz1423
633,"public class Solution {

    private int T;
    private ArrayList<Integer[]> deliciousnessList = new ArrayList<>();

    public static void main(String[] args) {

        Solution solution = new Solution();
        solution.readInput();

        for (int x = 0; x<solution.T; x++) {
            Integer[] deliciousness = solution.deliciousnessList.get(x);
            int customersCounter = solution.solveTestCase(deliciousness);

            System.out.println(String.format(""Case #%d: %d"", x+1, customersCounter));
        }

    }

    private int solveTestCase(Integer[] deliciousness) {

        // Initialise
        int customersCounter = 0;
        int totalMax = Integer.MIN_VALUE;
        int leftIndex = 0;
        int rightIndex=deliciousness.length-1;

        // Variable definitions
        int leftValue;
        int rightValue;
        int currentMax;

        for(int i=0; i<deliciousness.length; i++) {
            leftValue = deliciousness[leftIndex];
            rightValue = deliciousness[rightIndex];
            currentMax = Math.min(leftValue, rightValue);

            if(currentMax<totalMax) {
                if(Math.max(leftValue, rightValue)>=totalMax) customersCounter++;
                break;
            }

            customersCounter++;
            totalMax = currentMax;

            if (leftValue<=rightValue) {
                leftIndex++;
            } else {
                rightIndex--;
            }
        }

        return customersCounter;
    }

    private void readInput() {

        Scanner reader = new Scanner(System.in);
        String data;

        if (reader.hasNextLine()) {
            data = reader.nextLine();
            T = Integer.parseInt(data);
        }

        for (int i = 0; i < T; i++) {
            data = reader.nextLine();
            int N = Integer.parseInt(data);

            Integer[] deliciousness = new Integer[N];
            data = reader.nextLine();
            String[] cells = data.split("" "", 0);

            for(int j=0; j<cells.length; j++) {
                deliciousness[j] = Integer.parseInt(cells[j]);
            }

            deliciousnessList.add(deliciousness);
        }

        reader.",dionysis_dt
1120,"public class Solution {

  static Scanner in;

  public static void main(String[] args) {
    in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
    int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
    for (int i = 1; i <= t; i++) {
      int n = in.nextInt();
      int k = in.nextInt();
      solve(n, k);
    }
  }

  static void solve(int n, int k) {
    var rng = new Random();
    long sum = 0;
    var set = new HashSet<Integer>();

    sum += in.nextInt();
    boolean flag = true;
    for (int i = 0; i < k; i++) {

      set.add(t);
      if (flag && i % 3 == 0) {
        System.out.println(""W"");
      } else {
        int t = rng.nextInt(n) + 1;
        int tries = 100;
        while (set.contains(t) && tries > 0) {
          t = rng.nextInt(n) + 1;
          tries--;
        }
        System.out.println(""T "" + t);
      }
      set.add(in.nextInt());
      var z = in.nextInt();
      flag = z != 1;
      sum += z;
    }
    long r = ",rk13
68,"public class Solution {
	static Scanner sc;
	static StringBuffer s;

  public static void main(String[] args)throws Exception{
	  //sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
	  sc = new Scanner(new BufferedReader(new InputStreamReader(new FileInputStream(new File(""src/input.txt""))))); 
    
     int nbTest = sc.nextInt();
     
	 for(int test = 1;test<=nbTest;test++){ 	   	 	
	 	solve(test);
	 }   
	 
  }
  
  static void solve (int test) {
	  
	  List<Integer> list1 = new ArrayList<Integer>();
	  List<Integer> list2 = new ArrayList<Integer>();
	  List<Integer> list3 = new ArrayList<Integer>();
	  List<Integer> result = new ArrayList<Integer>();
	  int s = 1000000;
	  for (int i = 0; i<4; i++) list1.add(sc.nextInt()); 
	  for (int i = 0; i<4; i++) list2.add(sc.nextInt());
	  for (int i = 0; i<4; i++) list3.add(sc.nextInt());
	  
	  if (somme(list1)<s) {
		  System.out.println(""Case #""+test+"": IMPOSSIBLE"");
		  return;
	  }
	  if (somme(list2)<s) {
		  System.out.println(""Case #""+test+"": IMPOSSIBLE"");
		  return;
	  }
	  if (somme(list3)<s) {
		  System.out.println(""Case #""+test+"": IMPOSSIBLE"");
		  return;
	  }
	  int minC = minimum(list1.get(0), list2.get(0), list3.get(0));
	  int minM = minimum(list1.get(1), list2.get(1), list3.get(1));
	  int minY = minimum(list1.get(2), list2.get(2), list3.get(2));
	  int minK = minimum(list1.get(3), list2.get(3), list3.get(3));
	  
	  /*if(minC+minM+minY+minK < s) {
		  System.out.println(""Case #""+test+"": IMPOSSIBLE"");
		  return;
	  }*/
	  
	  
	  if(minC==s) {
		  System.out.println(""Case #""+test+"": ""+minC+"" 0 0 0"");
		  return;
	  }
	  
	  result.add(minC);
	  
	  if(minC+minM>=s) {
		  System.out.println(""Case #""+test+"": ""+minC+"" ""+(s-minM)+"" 0 0"");
		  return;
	  }else {
		  result.add(minM);
	  }
	  
	  if (minC+minM+minY>=s) {
		  System.out.println(""Case #""+test+"": ""+minC+"" ""+minM+"" ""+(s-(minC+minM))+"" 0"");
		  return;
	  } else {
		  result.add(minY);
	  }
	  
	  if (s-(minC+minM+minY) <= minK){
		  System.out.println(""Case #""+test+"": ""+minC+"" ""+minM+"" ""+minY+"" ""+
		                                        (s-(minC+minM+minY)));
	  }else {
		  System.out.println(""Case #""+test+"": IMPOSSIBLE"");
	  }


  }
  

  public static int  minimum (int a, int b, int c) {	 
		return Math.min(Math.min(a, b), c);
	}
  public static int somme(List<Integer> list) {
	  int res = 0;
	  for (int i = ",Bil1983
141,"public class Solution { //Solution
	static int INF = (int)(1e9);
	static long mod = (long)(1e9)+7;
	static long mod2 = 998244353;
	static long[] segtree;
	static char[] curans;
	static long ans;	
	static String S;
	static ArrayList<Integer>[] graph;
	static boolean[] vis;
	static int[] a;
	static int N;
	static long K;
	static long[] fact;
	static ArrayList<Long> pos;
	static ArrayList<Long> neg;
	static long[] max;
	static int[] dp;
	static long mx;
	static long[] fun;
	public static void main(String[] args) {  //Cash out
		/*(Notes)
		 * OPTIMIZE LOCALLY (pick 300 / 8 -> 37 binary strings).
		 * For each of the 37 strings, spam the same string 8 times 
		 * (uniformally get all rotation values r ranging from [0,7].
		 * 
		 * */
		FastScanner I = new FastScanner(); //Input
		OutPut O = new OutPut(); //Output
		
		int T = I.nextInt();
		
		ArrayList<String> S = new ArrayList<String>();
		ArrayList<String>[] g = new ArrayList[9];
		
		for (int i = 0; i <= 8; i++) {
			g[i] = new ArrayList<String>();
		}
		
		for (int i = 0; i < 1 << 8; i++) {
			int cur = i;
			int bit = 0;
			char[] b = new char[8];
			int cnt = 0;
			
			while (bit < 8) {
				if (cur % 2 == 1) {
					b[bit] = '1';
					cnt++;
				}else {
					b[bit] = '0';
				}
				cur /= 2;
				bit++;
			}
			
			S.add(new String(b));
			g[cnt].add(new String(b));
		}
		
		int idx = 0;
		int cnt = 1;
		
		for (int t = 1; t <= T; t++) {
			
			while (true) {
				O.pln(g[4].get(idx));
				idx++;
				
				idx %= g[4].size();
				
				int bits = I.nextInt();
				if (bits == 0) {
					break;
				}
			}
			
			//O.pln(""Case #"" + t + "": "" + ans);
		}
		
	}
	
	public static boolean pal(String x) {
		int N = x.length();
		
		for (int i = 0; i < N / 2; i++) {
			if (x.charAt(i) != x.charAt(N - i - 1)) {
				return false;
			}
		}
		
		return true;
	}
	
	public static ArrayList<String> perms(int N, int upper){
		if (N==1) {
			ArrayList<String> ret = new ArrayList<String>();
			for (int i = 1; i<=upper; i++) ret.add(Integer.toString(i)+"" "");
			return ret;
		}
		ArrayList<String> prev = perms(N-1,upper);
		ArrayList<String> ret = new ArrayList<String>();
		for (int i = 0; i < prev.size(); i++) {
			boolean[] vis = new boolean[upper+1];
			String cur = prev.get(i);
			String[] parts = cur.split("" "");
			for (int j = 0; j < parts.length; j++) {
				vis[Integer.parseInt(parts[j])]=true;
			}
			for (int j = 1; j <= upper; j++) {
				if (!vis[j]) {
					String curans = cur;
					curans+=Integer.toString(j)+"" "";
					ret.add(curans);
				}
			}
		}
		return ret;
	}
	
	public static void DFS(int start) {
		if (start == 0) {
			return;
		}
		
		vis[start] = true;
		mx = Math.max(mx, fun[start]);
		int next = graph[start].get(0); // We only ever point to one node at a time
		if (vis[next]) {
			return;
		}
		
		DFS(next);
	}
	
	public static long C(int N, int K) {
		long ans = fact[N];
		ans *= FastExp(fact[K], mod - 2);
		ans %= mod;
		
		ans *= FastExp(fact[N - K], mod - 2);
		ans %= mod;
		
		return ans;
	}
	
	
	public static double[][] matrix_exp(double[][] a, long exp, long mod) {
		int R = a.length;
		int C = a[0].length;
		double[][] ans = new double[R][C];
		
		boolean mult_yet = false;
		
		while (exp > 0) {
			if (exp % 2 == 1) {
				if (!mult_yet) {
					mult_yet = true;
					for (int i = 0; i < R; i++) {
						for (int j = 0; j < C; j++) {
							ans[i][j] = a[i][j]; 
						}
					}
				}else {
					double[][] new_ans = mult(ans, a, mod);
					for (int i = 0; i < R; i++) {
						for (int j = 0; j < C; j++) {
							ans[i][j] = new_ans[i][j]; 
						}
					}
				}
			}
			
			double[][] new_a = mult(a, a, mod); // a = a^2 (binary exponentiation on matrices)
			for (int i = 0; i < R; i++) {
				for (int j = 0; j < C; j++) {
					a[i][j] = new_a[i][j]; 
				}
			}
			exp /= 2;
		}
		
		return ans;
	}
	public static double[][] mult(double[][] a, double[][] b, long mod) {
		int r1 = a.length;
		int c1 = a[0].length;
		int r2 = b.length;
		int c2 = b[0].length;
		//Requires: c1 = r2
		
		double[][] ans = new double[r1][c2];
		for (int r = 0; r < r1; r++) {
			for (int c = 0; c < c2; c++) {
				//Dot product of (a[r])^T and b[c] (as vectors in R^n (n = c1 = r2))
				double[] col_vector = new double[r2];
				double[] row_vector = new double[c1];
				
				for (int i = 0; i < r2; i++) {
					col_vector[i] = b[i][c];
				}
				for (int i = 0; i < c1; i++) {
					row_vector[i] = a[r][i]; 
				}
				
				ans[r][c] = dot_product(row_vector, col_vector, mod);
			}
		}
		return ans;
	}
	
	public static double dot_product(double[] a, double[] b, long mod) {
		double ans = 0;
		int N = a.length; //Requires: a and b are both vectors in R^n
		for (int i = 0; i < N; i++) {
			ans += a[i] * b[i];
		}
		return ans;
	}
	public static double max(double a, double b) {return Math.max(a, b);}
	public static double min(double a, double b) {return Math.min(a, b);}
	public static long min(long a, long b) {return Math.min(a,b);}
	public static long max(long a, long b) {return Math.max(a,b);}
	public static int min(int a, int b) {return Math.min(a,b);}
	public static int max(int a, int b) {return Math.max(a,b);}
	public static long abs(long x) {return Math.abs(x);}
	public static long abs(int x) {return Math.abs(x);}
	public static long ceil(long num, long den) {long ans = num/den; if (num%den!=0) 
	ans++; return ans;}
	public static long GCD(long a, long b) {
		if (a==0||b==0) return max(a,b);
		return GCD(min(a,b),max(a,b)%min(a,b));
	}
	public static long FastExp(long base, long exp) {
		long ans=1;
		while (exp>0) {
			if (exp%2==1) ans*=base;
			exp/=2;
			base*=base;
			base%=mod;
			ans%=mod;
		}
		return ans;
	}
	public static long ModInv(long num,long mod) {return FastExp(num,mod-2);}
	public static int pop(long x) { //Returns number of bits within a number
		int cnt = ",IQEmperor
796,"class Room {

    public boolean visited = false;
    public int index;
    public List<Integer> neighbors;

    public int nextNeighbor = 0;
}

public class Solution {

    public static final int MAX_N = 100001;

    public static void main(String[] args) {

        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        int T = in.nextInt();

        var rooms = new Room[MAX_N];

        boolean[][] connections = new boolean[MAX_N][];

        for (int j = 0; j < MAX_N; j++) {
            connections[j] = new boolean[MAX_N];
        }

        for (int i = 0; i < T; i++) {

            int N = in.nextInt();
            int K = in.nextInt();

            for (int j = 0; j < N; j++) {
                rooms[j] = null;
            }

            for (int j = 0; j < N; j++) {
                for (int k = 0; k < N; k++) {
                    connections[j][k] = false;
                }
            }

            int lastRoomIdx = -1;

            for (int j = 0; j <= K; j++) {

                int R = in.nextInt() - 1;
                int P = in.nextInt();

                if (rooms[R] == null) {

                    rooms[R] = new Room();
                    rooms[R].index = R;
                    rooms[R].neighbors = new ArrayList<>();

                    rooms[R].nextNeighbor = 0;

                    for (int k = 0; k < P; k++) {
                        rooms[R].neighbors.add(-1);
                    }
                }

                var room = rooms[R];
                room.visited = true;

                if (lastRoomIdx != -1) {
                    room.neighbors.set(room.nextNeighbor++, lastRoomIdx);
                    rooms[lastRoomIdx].neighbors.set(rooms[lastRoomIdx].nextNeighbor++, R);
                }

                if (j == K) {
                    break;
                }

                var unknownNeighbors = room.neighbors.size() - room.nextNeighbor;

                var chance = (float) unknownNeighbors / room.neighbors.size();

                if (chance > 0.75f) {
                    lastRoomIdx = R;
                    System.out.println(""W"");
                } else {
                    boolean teleported = false;

                    for (int k = 0; k < N; k++) {
                        if (rooms[k] == null) {
                            teleported = true;
                            System.out.printf(""T %d%n"", k + 1);
                            break;
                        }
                    }

                    if (teleported) {
                        lastRoomIdx = -1;
                    } else {
                        // all rooms are visited, go somewhere randomly
                        lastRoomIdx = R;
                        System.out.println(""W"");
                    }
                }

                System.out.flush();
            }

            var knownPendingRooms = new ArrayList<Integer>();
            var unknownPendingRooms = new ArrayList<Integer>();

            int nPassages = 0;

            for (int j = 0; j < N; j++) {

                var room = rooms[j];

                if (room == null) {
                    unknownPendingRooms.add(j);
                    continue;
                }

                boolean hasUnknownPassages = false;

                for (int k = 0; k < room.neighbors.size(); k++) {

                    if (room.neighbors.get(k) == -1) {

                        if (!hasUnknownPassages) {
                            knownPendingRooms.add(j);
                            hasUnknownPassages = true;
                        }

                    } else {

                        if (room.neighbors.get(k) > j) {
                            nPassages++;
                        }
                    }
                }
            }

            for (int pendingRoom : knownPendingRooms) {

                for (int k = 0; k < rooms[pendingRoom].neighbors.size(); k++) {

                    var neig = rooms[pendingRoom].neighbors.get(k);

                    if (neig == -1) {
                        break;
                    }

                    connections[pendingRoom][neig] = true;
                    connections[neig][pendingRoom] = true;
                }
            }

            while (knownPendingRooms.size() > 0) {

                var pendingRoom = knownPendingRooms.get(0);

                var room = rooms[pendingRoom];

                if (!room.visited && room.neighbors.size() > 0) {
                    knownPendingRooms.remove(pendingRoom);
                    continue;
                }

                for (int j = 0; j < room.neighbors.size(); j++) {

                    if (room.neighbors.get(j) == -1) {

                        if (unknownPendingRooms.size() > 0) {

                            var unknownIndex = unknownPendingRooms.remove(0);

                            var unknownRoom = new Room();
                            unknownRoom.index = unknownIndex;
                            unknownRoom.neighbors = new ArrayList<>();
                            unknownRoom.neighbors.add(pendingRoom);

                            rooms[unknownIndex] = unknownRoom;

                            knownPendingRooms.add(unknownIndex);
                            room.neighbors.set(j, unknownIndex);

                            connections[pendingRoom][unknownIndex] = true;
                            connections[unknownIndex][pendingRoom] = true;

                            nPassages++;

                        } else {

                            for (var r : knownPendingRooms) {

                                if (r.equals(pendingRoom)) {
                                    continue;
                                }

                                if (connections[pendingRoom][r]) {
                                    continue;
                                }

                                var otherRoom = rooms[r];

                                if (!otherRoom.visited) {

                                    room.neighbors.set(j, r);
                                    otherRoom.neighbors.add(pendingRoom);

                                } else {

                                    int c = 0;
                                    int firstNeigh = -1;

                                    for (int h = 0; h < otherRoom.neighbors.size(); h++) {

                                        var neigh = otherRoom.neighbors.get(h);

                                        if (neigh == -1) {
                                            if (firstNeigh == -1) {
                                                firstNeigh = h;
                                            }
                                            c += 1;
                                        }
                                    }

                                    room.neighbors.set(j, r);
                                    otherRoom.neighbors.set(firstNeigh, pendingRoom);

                                    if (c == 1) {
                                        knownPendingRooms.remove(Integer.valueOf(otherRoom.index));
                                    }
                                }

                                nPassages++;

                                connections[pendingRoom][r] = true;
                                connections[r][pendingRoom] = true;

                                break;
                            }
                        }
                    }
                }

                if (room.visited) {
                    knownPendingRooms.remove(pendingRoom);
                }
            }

            System.out.printf(""E %d%n"", nPassages);
            System.",jaimuepe
119,"class Solution{
    public static void main(String[] args){
        Scanner s = new Scanner(System.in);
        int t= s.nextInt();
        for(int i =1;i<=t;i++){
            int r = s.nextInt();
            int c= s.nextInt();
            System.out.println(""Case#""+i+"":"");
            printPattern(r,c);
        }
        //return;
    }
    public static void printPattern(int r , int c){
        for(int i =0 ;i< r;i++){
            for(int j =0; j<c ;j++){
                if(i==0 && j==0){
                    System.out.print("".."");
                    j++;
                }
                System.out.print(""+-"");
            }
            System.out.print(""+"");
            System.out.println();
            for(int j =0 ;j<c;j++){
               if(i==0&& j==0){
                  System.out.print("".."");
                  j++;
               }
               System.out.print(""|."");
            }
            System.out.print(""|"");
            System.out.println();
        }
        for(int el=",Dyeahhh
240,"public class Solution{

    public static void main(String[] args){

        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        int T = in.nextInt();
        for (int i=1; i<=T; i++){
            int count=0;
            int z=in.nextInt();
            int [] array=new int[z];
            for (int j=0;j<z;j++)
            {array[j]=in.nextInt();
            }
            Arrays.sort(array);
           
               for (int o=1;o<=z;o++)
               { if(array[o-1]>=o)
               {count++;}
               }
            
            
            
           
                    System.out.println(""Case #"" + i + "": "" + count);
            }
        
        in.",Marwan
514,"public class Solution{

    static long MOD = 1_000_000_007L;
    //static long MOD = 998_244_353L;
    //static long MOD = 1_000_000_033L;
    static long inv2 = (MOD + 1) / 2;
    static long [] fac;
    static long [] pow;
    static long [] inv;
    static long [] invFac;
    static int[][] dir = new int[][]{{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
    static long lMax = 0x3f3f3f3f3f3f3f3fL;
    static int iMax = 0x3f3f3f3f;
    static HashMap <Long, Long> memo = new HashMap();
    static MyScanner sc = new MyScanner();
    //static ArrayList <Integer> primes;

    static long[] pow2;
    static int[] base;
    static int[] numOfDiv;
    static ArrayList <Integer> primes;
    //-----------PrintWriter for faster output---------------------------------
    public static PrintWriter out;
    public static void main(String[] args) {
        out = new PrintWriter(new BufferedOutputStream(System.out));
        // Start writing your solution here. -------------------------------------

        int nn = 300000;

        /*fac = new long[nn + 1];
        fac[1] = 1;
        for(int i = 2; i <= nn; i++)
            fac[i] = fac[i - 1] * 1L * i % MOD;*/

        /*pow = new long[nn + 1];
        pow[0] = 1L;
        for(int i = 1; i <= nn; i++)
            pow[i] = pow[i - 1] * 2L % MOD;
        pow[1] = 3L;*/

        /*
        pow2 = new long[nn + 1];
        pow2[0] = 1L;
        for(int i = 1; i <= nn; i++)
            pow2[i] = pow2[i - 1] * 2L;*/

        /*inv = new long[nn + 1];
        inv[1] = 1;
        for (int i = 2; i <= nn; ++i)
            inv[i] = (MOD - MOD / i) * inv[(int)(MOD % i)] % MOD;

        invFac = new long[nn + 1];
        invFac[1] = 1;
        for(int i = 2; i <= nn; i++)
            invFac[i] = invFac[i - 1] * inv[i] % MOD;*/

        //primes = sieveOfEratosthenes(100001);


        /*for(int i = 2; i <= 20000000; i++)
            if(numOfDiv[i] == 0)
                for(int j = i; j <= 20000000; j += i)
                    numOfDiv[j] ++;*/

        int t = 1, tt = 0;
        t = sc.ni();
        while(tt++ < t) {
            //long res = solve();
            //out.print(""Case #"" + tt + "": "");
            solve();
            //out.println(res);
        }
        out.close();
    }
    static void solve() {
        int N = sc.ni();
        long sum = 0, curSum = 0;
        int[] A = new int[N];
        ArrayList <Integer> list = new ArrayList();
        int thres = Math.min(N, 31);
        for(int i = 0; i < thres; i++) A[i] = 1 << (thres - i - 1);
        for(int i = thres; i < N; i++) {
            A[i] = 500 + i;
            list.add(A[i]);
        }
        for(int i = 0; i < N; i++) System.out.print(A[i] + "" "");
        System.out.println();
        System.out.flush();
        int[] B = sc.na(N);
        for(int i = 0; i < N; i++) list.add(B[i]);
        for(int i : A) sum += i;
        for(int i : B) sum += i;
        System.out.println(list);
        HashSet <Integer> AA = new HashSet(), BB = new HashSet();
        for(int i : list) {
            if(curSum + i <= sum / 2) {
                AA.add(i);
                curSum += i;
            } else BB.add(i);
        }
        for(int i = 0; i < thres; i++) {
            if(curSum + A[i] <= sum / 2) {
                AA.add(A[i]);
                curSum += A[i];
            } else BB.add(A[i]);
        }
        System.out.println(""AA: "" + AA);
        System.out.println(""BB: "" + BB);
        for(int i : AA) System.out.print(i + "" "");
        System.out.println();
    }

    static long c(int a, int b) {
        if(a <= 0 || b <= 0 || a <= b) return 1L;
        return fac[a] * invFac[b] % MOD * invFac[a - b] % MOD;
    }

    // SegmentTree range min/max query From uwi
    public static class SegmentTreeRMQ {
        public int M, H, N;
        public long[] st;

        public SegmentTreeRMQ(int n)
        {
            N = n;
            M = Integer.highestOneBit(Math.max(N-1, 1))<<2;
            H = M>>>1;
            st = new long[M];
            Arrays.fill(st, 0, M, Integer.MAX_VALUE);
        }

        public SegmentTreeRMQ(long[] a)
        {
            N = a.length;
            M = Integer.highestOneBit(Math.max(N-1, 1))<<2;
            H = M>>>1;
            st = new long[M];
            for(int i = 0;i < N;i++){
                st[H+i] = a[i];
            }
            Arrays.fill(st, H+N, M, Integer.MAX_VALUE);
            for(int i = H-1;i >= 1;i--)propagate(i);
        }

        public void update(int pos, int x)
        {
            st[H+pos] = x;
            for(int i = (H+pos)>>>1;i >= 1;i >>>= 1)propagate(i);
        }

        private void propagate(int i)
        {
            st[i] = Math.min(st[2*i], st[2*i+1]);
        }

        public long minx(int l, int r){
            long min = Long.MAX_VALUE;
            if(l >= r) return min;
            while(l != 0){
                int f = l&-l;
                if(l+f > r)break;
                long v = st[(H+l)/f];
                if(v < min)min = v;
                l += f;
            }

            while(l < r){
                int f = r&-r;
                long v = st[(H+r)/f-1];
                if(v < min) min = v;
                r -= f;
            }
            return min;
        }

        public long min(int l, int r){ return l >= r ? 0 : min(l, r, 0, H, 1);}

        private long min(int l, int r, int cl, int cr, int cur)
        {
            if(l <= cl && cr <= r){
                return st[cur];
            }else{
                int mid = cl+cr>>>1;
                long ret = Long.MAX_VALUE;
                if(cl < r && l < mid){
                    ret = Math.min(ret, min(l, r, cl, mid, 2*cur));
                }
                if(mid < r && l < cr){
                    ret = Math.min(ret, min(l, r, mid, cr, 2*cur+1));
                }
                return ret;
            }
        }
    }

    public static char[] rev(char[] a){char[] b = new char[a.length];for(int i = 0;i < a.length;i++)b[a.length-1-i] = a[i];return b;}
    public static int[] rev(int[] a, int start, int end){int[] b = a.clone();for(int i = start;i <= end;i++) b[start + end - i] = a[i];return b;}
    public static int[] rev(int[] a){return rev(a, 0, a.length - 1);}

    public static double dist(double a, double b){
        return Math.sqrt(a * a + b * b);
    }
    public static double dist(int[] A, int[] B){
        return dist(1.0 * A[0] - B[0], 1.0 * A[1] - B[1]);
    }

    public static long inv(long a){
        return quickPOW(a, MOD - 2);
    }

    public class Interval {
        int start;
        int end;
        public Interval(int start, int end) {
            this.start = start;
            this.end = end;
        }
    }

    public static ArrayList<Integer> sieveOfEratosthenes(int n) {
        boolean prime[] = new boolean[n + 1];
        Arrays.fill(prime, true);
        for (int p = 2; p * p <= n; p++) {
            if (prime[p]) {
                for (int i = p * 2; i <= n; i += p) {
                    prime[i] = false;
                }
            }
        }
        ArrayList<Integer> primeNumbers = new ArrayList<>();
        for (int i = 2; i <= n; i++) {
            if (prime[i]) {
                primeNumbers.add(i);
            }
        }
        return primeNumbers;
    }


    public static int lowerBound(int[] a, int v){ return lowerBound(a, 0, a.length, v); }
    public static int lowerBound(int[] a, int l, int r, int v)
    {
        if(l > r || l < 0 || r > a.length)throw new IllegalArgumentException();
        int low = l-1, high = r;
        while(high-low > 1){
            int h = high+low>>>1;
            if(a[h] >= v){
                high = h;
            }else{
                low = h;
            }
        }
        return high;
    }
    public static int rlowerBound(int[] a, int v){ return lowerBound(a, 0, a.length, v); }
    public static int rlowerBound(int[] a, int l, int r, int v)
    {
        if(l > r || l < 0 || r > a.length)throw new IllegalArgumentException();
        int low = l-1, high = r;
        while(high-low > 1){
            int h = high+low>>>1;
            if(a[h] <= v){
                high = ",anhpp123
526,"public class Solution {

    private static final Boolean FROM_FILE = Boolean.FALSE;
    private static final int MAX = 1000000001;
    private static final int MAXLEN = 1000;

    public static void main(String[] args) throws IOException{
        BufferedReader br;
        BufferedWriter bw;

        if(FROM_FILE){
            br = new BufferedReader(new FileReader(""C2022QR1D.in""));
        } else {
            br = new BufferedReader(new InputStreamReader(System.in));
        }

        try {
            if(FROM_FILE) {
                File file = new File(""C2022QR1D.out"");
                if (!file.exists()) {
                    file.createNewFile();
                }
                bw = new BufferedWriter(new FileWriter(file.getAbsoluteFile()));
            } else {
                bw = new BufferedWriter(new OutputStreamWriter(System.out));
            }

            String line = br.readLine();
            String[] q,r;

            int tests = Integer.parseInt(line);//100
            int n;
            int[] f = new int[MAXLEN];
            int[] p = new int[MAXLEN];
            int[] height = new int[MAXLEN];
            int[] firstChild = new int[MAXLEN];
            int[] noChildren = new int[MAXLEN];
            int[] hasBrothers = new int[MAXLEN];

            int i,j,k,l,u, min, found, m, biggestHeight, leafWithBiggestHeight;
            long max;

            for(i = 0; i < tests; i++){
                line = br.readLine();
                n = Integer.parseInt(line);

                line = br.readLine();
                q = line.split(""\\\s+"");

                line = br.readLine();
                r = line.split(""\\\s+"");

                Arrays.fill(f,0,n,-1);
                Arrays.fill(p,0,n,-1);
                Arrays.fill(height,0,n,0);
                Arrays.fill(firstChild,0,n,-1);
                Arrays.fill(hasBrothers,0,n,-1);
                Arrays.fill(noChildren,0,n,0);

                // input and abyss detection
                for(j = 0;j<n; j++){
                    f[j] = Integer.parseInt(q[j]);
                    // 0 <= Pi <= i-1, for all i.
                    // XXX: why less than i. Oh, these are ordered!
                    p[j] = Integer.parseInt(r[j])-1;

                    // abyss
                    if(-1 == p[j]){
                        height[j] = 0; // root
                        // noChildren[j]=0;
                    } else {
                        // p[j] has children
                        // upstream.get(p[j]).add(j);
                        if(0 == noChildren[p[j]]){
                            noChildren[p[j]] = 1;
                            firstChild[p[j]] = j;
                            // hasBrothers[j] = -1;
                        } else {
                            noChildren[p[j]]++;

                            // insert child as last brother
                            m = firstChild[p[j]];

                            while(-1 != hasBrothers[m]){
                                m = hasBrothers[m];
                            }

                            hasBrothers[m] = j;
                        }

                        // because of XXX ordering his parent's height was already counted
                        height[j] = height[p[j]]+1;
                    }
                }

                max = 0L;

                // XXX: Pk cannot be triggered by Pk+1...Pn, so walk backwards to fold trees
                for(k = n-1; k >= 0; ){
                    // #0 skip nodes with no fun
                    if(f[k] == 0) {
                        k--;
                        continue;
                    }

                    // #00 count roots
                    if(p[k] == -1){
                        max += f[k];
                        f[k] = 0;
                        k--;
                        continue;
                    }

                    // #1 optimize - reduce leafs that are only childs
                    // is not a root && is a leaf && only child
                    if(noChildren[k] == 0 &&
                            noChildren[p[k]] == 1){
                        // reduce fun of parent as max of leaf and parent, they get triggered at once anyways!
                        f[p[k]] = Math.max(f[k], f[p[k]]);
                        f[k] = 0;
                        // parent becomes a leaf after reduce
                        noChildren[p[k]] = 0;
                        k--;
                        // skip anything this turn
                        continue;
                    }

                    // #2A detect leaf with greatest height
                    biggestHeight = -1;
                    leafWithBiggestHeight = -1;

                    for(l = k; l >= 0; l--){
                        // leaf detection (backwards because of XXX order, first big height is resolved first!)
                        // only consider nodes with fun left
                        if(f[l] > 0 && noChildren[l] == 0){
                            if(height[l] > biggestHeight){
                                biggestHeight = height[l];
                                leafWithBiggestHeight = l;
                            }
                        }
                    }

                    // #2B reduce leafWithBiggestHeight
                    // parent, not visited yet because of XXX ordering
                    m = p[leafWithBiggestHeight];

                    // only child, again simple
                    if(noChildren[m] == 1){
                        // reduce fun of parent as max of leaf and parent, they get triggered at once anyways!
                        f[m] = Math.max(f[leafWithBiggestHeight], f[m]);
                        // parent becomes a leaf after reduce
                        noChildren[m] = 0;
                        // make leaf no fun, it has been reduced
                        f[leafWithBiggestHeight] = 0;
                    } else {
                        // parent has at least 2 children.
                        // find the minimal fun child and merge with parent
                        u = firstChild[m];
                        min = f[u];
                        found = u;

                        do {
                            u = hasBrothers[u];
                            if(f[u] > 0 && f[u] < min){
                                min = f[u];
                                found = u;
                            }
                        } while(-1 != hasBrothers[u]);

                        // minimal fun gets reduced into parent
                        // reduce fun of parent as max of leaf and parent, they get triggered at once anyways!
                        f[m] = Math.max(f[found], f[m]);
                        // make leaf no fun, it has been reduced
                        f[found] = 0;

                        // count the fun of the other children (they are leaves because of XXX sorting after height step)

                        u = firstChild[m];
                        max+=f[u];
                        f[u]=0;
                        do{
                            u = hasBrothers[u];
                            max += f[u];
                            f[u] = 0;
                        } while(-1 != hasBrothers[u]);

                        // parent becomes a leaf after reduce
                        noChildren[m] = 0;
                    }
                }

                bw.write(""Case #""+(i+1)+"": "" + max + ""
"");
                bw.flush();
            }

            if(FROM_FILE) {
                bw.close();
            }
        } finally {
            if(FROM_FILE) {
                br.close();
            }
        }
    }
}",araver
475,"public class Solution {

    public static void main(String[] args) {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        try {
            int T = Integer.parseInt(br.readLine());
            for (int ti = 1; ti <= T; ti++) {
                String[] temp = br.readLine().split("" "");
                int N = Integer.parseInt(temp[0]);
                int K = Integer.parseInt(temp[1]);

                temp = br.readLine().split("" "");
                int R = Integer.parseInt(temp[0]);
                int P = Integer.parseInt(temp[1]);

                List<Integer> roomNumbers = new ArrayList<>();
                for (int i = 1; i <= N; i++) {
                    if (R != i) {
                        roomNumbers.add(i);
                    }
                }
                long sumP = P;
                int k = 0;
                int flag = 1;
                HashMap<Integer, Integer> pMap = new HashMap<>();
                for (int i = 0; i < K && i < N; i++) {
                    if (roomNumbers.size() == 0) {
                        break;
                    }
                    if (flag == 0) {
                        int roomIndex = (int) (Math.random() * roomNumbers.size());
                        System.out.println(""T "" + roomNumbers.get(roomIndex));
                    } else {
                        System.out.println(""W"");
                    }
                    flag = (flag + 1) % 3;
                    
                    temp = br.readLine().split("" "");
                    R = Integer.parseInt(temp[0]);
                    int idx = Collections.binarySearch(roomNumbers, R);

                    if (idx >= 0) {
                        roomNumbers.remove(idx);
                        P = Integer.parseInt(temp[1]);
                        Integer pCount = pMap.get(P);
                        if (pCount == null) {
                            pCount = 1;
                        } else {
                            pCount++;
                        }
                        pMap.put(P, pCount);

                        sumP += P;
                        k++;
                    }
                }

                int remainRoomCount = N - k - 1;
                double predictSum = sumP;
                if (remainRoomCount > 0) {
                    for (Map.Entry<Integer, Integer> entry : pMap.entrySet()) {
                        Integer pNumber = entry.getKey();
                        Integer pCount = entry.getValue();
                        predictSum += pNumber * (remainRoomCount * (pCount / (k + 1.0)));
                    }
                    predictSum /= 2.0;
                }
                System.out.println(""E "" + Math.round(predictSum));
            }
        } catch (IOException e) {
            e.",absee
1289,"public class Solution {

	static boolean verb=true;
	static void log(Object X){if (verb) System.err.println(X);}
	static void log(Object[] X){if (verb) {for (Object U:X) System.err.print(U+"" "");System.err.println("""");}}
	static void log(int[] X){if (verb) {for (int U:X) System.err.print(U+"" "");System.err.println("""");}}
	static void logWln(Object X){if (verb) System.err.print(X);}
	static void info(Object o){	System.out.println(o);}
	static void output(Object o){outputWln(""""+o+""
"");	}
	static void outputWln(Object o){try {out.write(""""+ o);} catch (Exception e) {}}





	// Global vars


	static BufferedWriter out;
	static InputReader reader;



	static int R,P;

	static void ask(int node) throws Exception {
		System.out.println(""T ""+(node+1));
		System.out.flush();
		R=reader.readInt()-1;
		P=reader.readInt();
	}

	static void answer(long x) {
		System.out.println(""E ""+x);
		System.out.flush();

	}

	static void process() throws Exception {

		//out = new BufferedWriter(new OutputStreamWriter(System.out));
		reader=new InputReader(System.in);
		Locale.setDefault(Locale.US);	




		int T=reader.readInt();



		for (int t=1;t<=T;t++) {


			int n=reader.readInt();
			int K=reader.readInt();

			R=reader.readInt()-1;
			P=reader.readInt();
			long tot=0;
			tot+=P;
		
			if (K>=n) {
				for (int i=0;i<n;i++) {
					if (i!=R) {
						ask(i);
						tot+=P;
					}
				}
				answer(tot/2);

			} else {
				// take some randoms
				ArrayList<Integer> list=new ArrayList<Integer>();
				for (int i=0;i<n;i++) {
					if (i!=R) {
						list.add(i);
					}
				}
				Collections.shuffle(list);
				Collections.shuffle(list);
				for (int i=0;i<K-1;i++) {
					ask(list.get(i));
					tot+=P;
				}
				tot*=n;
				tot/=K;
				answer(tot/2);
				
			}


			//String ss="""";
			

			//output(""Case #""+t+"": ""+ss);
		}
		//log(""ok"");
		/*
		try {
			out.close();
		}
		catch (Exception EX){}
*/
	}








	public static void main(String[] args) throws Exception {
		process();

	}

	static final class InputReader {
		private final InputStream stream;
		private final byte[] buf = new byte[1024];
		private int curChar;
		private int numChars;

		public InputReader(InputStream stream) {
			this.stream = stream;
		}

		private int read() throws IOException {
			if (curChar >= numChars) {
				curChar = 0;
				numChars = stream.read(buf);
				if (numChars <= 0) {
					return -1;
				}
			}
			return buf[curChar++];
		}


		public final String readString() throws IOException {
			int c = read();
			while (isSpaceChar(c)) {
				c = read();
			}
			StringBuilder res=new StringBuilder();
			do {
				res.append((char)c);
				c = read();
			} while (!isSpaceChar(c));
			return res.toString();
		}

		public final int readInt() throws IOException {
			int c = read();
			boolean neg=false;
			while (isSpaceChar(c)) {
				c = read();
			}
			char d=(char)c;
			//log(""d:""+d);
			if (d=='-') {
				neg=true;
				c = read();
			}
			int res = 0;
			do {
				res *= 10;
				res += c - '0';
				c = read();
			} while (!isSpaceChar(c));
			//log(""res:""+res);
			if (neg)
				return -res;
			return res;

		}

		public final long readLong() throws IOException {
			int c = read();
			boolean neg=false;
			while (isSpaceChar(c)) {
				c = read();
			}
			char d=(char)c;
			//lo)g(""d:""+d);
			if (d=='-') {
				neg=true;
				c = read();
			}
			long res = 0;
			do {
				res *= 10;
				res += c - '0';
				c = read();
			} while (!isSpaceChar(c));
			//log(""res:""+res);
			if (neg)
				return -res;
			return res;

		}



",vincent
1214,"class Main{

public static int organize(int x,int[][] matrix)
{
    return x;
}
public static void main(String args[]){
    
    Scanner sc = new Scanner(System.in);

int t = sc.nextInt();

for(int k=0;k<t;k++)
{
    // int x = sc.nextInt();
    // int size=2*x;
    // int[][] matrix = new int[size][size];
    // for(int i=0;i<size;i++)
    // {
    //   for(int j=0;j<size;j++){
    //       matrix[i][j] = sc.nextInt();
    //   }
    // }
    
    ArrayList<ArrayList<Integer>> matrix = new ArrayList<>();
    for(int i=0;i<size;i++){
        ArrayList<Integer> array = new ArrayList<>();
        while (sc.hasNextInt()) {
        int i = sc.nextInt();
        array.add(i);
        }
        
        matrix.add(array);
    }
    int result = ",sriniharika
607,"public class Solution {
    public static void main(String[] args) {
        (new Solution()).readInput();
        //(new Solution()).test();
    }

    public void test(){
        int testCount=10;
        Random r = new Random(0);
        for (int t=0;t<testCount;t++){
            int n = r.nextInt(5)+1;
            Deque<Integer> deque = new ArrayDeque<>();
            for (int i=0;i<n;i++){
                int v = r.nextInt(10)+1;
                deque.add(v);
            }

            Deque<Integer> copy = new ArrayDeque<>();
            copy.addAll(deque);

            long score1 = solve(copy);

            copy = new ArrayDeque<>();
            copy.addAll(deque);
            long score2 = solveExhaustive(copy);

            if (score1!=score2){
                System.out.println(""Score1: ""+score1+""	""+""Score2: ""+score2);
            }
        }
    }

    public void readInput() {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int caseCount = in.nextInt();
        for (int caseId = 1; caseId <= caseCount; ++caseId) {
            int n = in.nextInt();
            Deque<Integer> deque = new ArrayDeque<>();
            for (int i=0;i<n;i++){
                int di = in.nextInt();
                deque.add(di);
            }
            solveExhaustive(deque);
            System.out.println(""Case #"" + caseId + "": "" + solve(deque));
        }
    }

    private long solve(Deque<Integer> deque){
        int score=0;
        int previous=0;
        while(deque.size()>0){

            int first = deque.getFirst();
            int last = deque.getLast();

            int current;
            if (first<last){
                current = deque.removeFirst();
            } else{
                current = deque.removeLast();
            }

            if (current>=previous){
                score++;
            }
            previous = Math.max(current,previous);

        }
        return score;
    }

    private long solveExhaustive(Deque<Integer> deque){
        long bestScore=0;
        List<Integer> start = new ArrayList<>();
        List<List<Integer>> combinations = generateAllPossibleCombinations(deque, start);
        for (List<Integer> combination : combinations){
            long score = testCombination(combination);
            bestScore = Math.max(score,bestScore);
        }
        return bestScore;
    }

    private int testCombination(List<Integer> combination) {
        int score=0;
        int last=0;

        for(int i : combination) {
            if (i>=last){
                score++;
            }
            last=i;
        }
        return score;
    }


    public List<List<Integer>> generateAllPossibleCombinations(Deque<Integer> deque, List<Integer> start){
        List<List<Integer>> solutions = new ArrayList<>();
        if (deque.size()==0){
            System.out.println(""This should not happen"");
        }
        if (deque.size()==1){
            List<Integer> solution1 = new ArrayList<>();
            solution1.addAll(start);
            solution1.add(deque.getFirst());
            solutions.add(solution1);
        } else {
            List<Integer> solution1 = new ArrayList<>();
            solution1.addAll(start);
            Integer first = deque.removeFirst();
            solution1.add(first);
            solutions.addAll(generateAllPossibleCombinations(deque, solution1));
            deque.addFirst(first);

            List<Integer> solution2 = new ArrayList<>();
            solution2.addAll(start);
            Integer last = deque.removeLast();
            solution2.add(last);
            solutions.addAll(generateAllPossibleCombinations(deque, solution2));
            deque.",dboteanu
1057,"public class Solution {
	
	static Scanner sc = new Scanner(System.in);
	
	static List<List<Integer>> list;
	static Stack<int []> stack;
	static boolean [] visited;
	static boolean [] visited2;
	static long [][] arrPos;
	static long [][] arrSweet;

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		int testCases = sc.nextInt();
		
		for (int i = 1; i <= testCases; ++i) {
			solve(i);
		}
	}
	
	private static void solve(int t) {
		int n = sc.nextInt();
		
		arrPos = new long [n + 1][2];
		arrSweet = new long [n + 2][2];
		
		int a, b;
		
		for (int i = 1; i <= n; ++i) {
			arrPos[i][0] = sc.nextLong();
			arrPos[i][1] = sc.nextLong();
		}
		
		for (int i = 1; i <= n+1; ++i) {
			arrSweet[i][0] = sc.nextLong();
			arrSweet[i][1] = sc.nextLong();
		}
		
		list = new ArrayList<>();
		stack = new Stack<>();
		
		visited = new boolean [n + 1];
		visited2 = new boolean [n + 2];
		
		if (generatePermutations(n)) {
			print(t, ""POSSIBLE"");
			for (int [] rArr : stack) {
				System.out.println(rArr[0] + "" "" + rArr[1]);
			}
			return;
		}
		
		
		print(t, ""IMPOSSIBLE"");
		return;
	}
	
	private static boolean generatePermutations(int n) {
		if (stack.size() == n) {
			//list.add(new ArrayList<>(stack));
			return true;
		}
		
		long dist;
		long min = Long.MAX_VALUE;
		long x,y;
		int pos;
		
		for (int a = 1; a <= n; ++a) {
			if (visited[a]) continue;
			
			visited[a] = true;
			pos = 0;
			min = Long.MAX_VALUE;
			
			for (int i = 1; i < arrSweet.length; ++i) {
				if (visited2[i]) continue;
				
				x = arrPos[a][0] - arrSweet[i][0];
				y = arrPos[a][1] - arrSweet[i][1];
				
				dist = x*x + y*y;
				
				if (dist <= min) {
					min = dist;
					pos = i;
				}
			}
			
			stack.push(new int [] {a , pos});
			visited2[pos] = true;
			
			if(pos > 1 && generatePermutations(n))
				return true;
			
			visited2[pos] = false;
			stack.pop();
			visited[a] = false;
		}
		
		return false;
	}
	
	public static void print(int test, String result) {
		System.",profchi
628,"public class Solution {

    private static CodeJamIO io = new CodeJamIO();

    /**
     * @param args
     */
    public static void main(String[] args) {

        try {
            init();

            int numCases = Integer.parseInt(io.readNextLine()[0]);
            for (int i=1; i <= numCases; i++) {
                io.debug(""Solving Case #"" + i + ""..."");
                solveCase(i);
                io.debug(""Case #"" + i + "" solved!"");
            }

        } catch (Exception e) {
            e.printStackTrace();
        }

    }

    /**
     * Performs initial computations
     */
    private static void init() {

    }

    /**
     * Solves a Test Case
     *
     * @param caseNum
     * @throws IOException
     */
    private static void solveCase(int caseNum) throws IOException {
        // Read input
        String[] tokens = io.readNextLine();
        int n = Integer.parseInt(tokens[0]);
        int k = Integer.parseInt(tokens[1]);
        if (k > n) {
            k = n;
        }

        // Interact
        double[] p = new double[k];
        double e = 0;
        Set<Integer> rooms = new HashSet<>();

        tokens = io.readNextLine();
        rooms.add(Integer.parseInt(tokens[0]));
        int passages = Integer.parseInt(tokens[1]);
        p[0] = passages;
        e += p[0];
        double sum = 0;

        for (int i=0; i<k; i++) {
            if (p[i] > i) {
                io.println(""W"");
            } else {
                io.println(""T "" + String.valueOf(pickRoom(n, rooms)));
            }
            tokens = io.readNextLine();
            rooms.add(Integer.parseInt(tokens[0]));
            passages = Integer.parseInt(tokens[1]);
            passages -= sum / (n-1);
            if (p[i] > i) { // this will always be true for i==0
                p[i+1] = passages - 1;
            } else {
                p[i+1] = passages - p[i-1] / (n-1);
            }
            e += p[i+1];
            sum += p[i];
        }

        // Print results
        io.println(""E "" + String.valueOf(Math.round(e)));
    }

    private static int pickRoom(int n, Set<Integer> rooms) {
        for (int i=0; i<n; i++) {
            if (!rooms.contains(i+1)) {
                return i+1;
            }
        }
        throw new RuntimeException();
    }
    
    /**
     * Input and Output CodeJam style
     *
     */
    private static class CodeJamIO {
        private static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        private static PrintWriter out = new PrintWriter(System.out, true);
        private static PrintWriter err = new PrintWriter(System.err, true);

        public String[] readNextLine() throws IOException {
            String line = in.readLine();
            String[] tokens = line.split(""\\\s+"");
            return tokens;
        }

        public CodeJamIO printCase(int caseNum) { return print(""Case #"" + caseNum + "": "" ); }

        public CodeJamIO print(Object o) { out.print(o); return this; }

        public CodeJamIO print(Object o[]) { return print(concat(o)); }

        public CodeJamIO print(Object o[][]) { return print(concat(o)); }

        public CodeJamIO println() { out.println(); return this; }

        public CodeJamIO printlnCase(int caseNum) { return printCase(caseNum).println(); }

        public CodeJamIO println(Object o) { return print(o).println(); }

        public CodeJamIO println(Object o[]) { return print(o).println(); }

        public CodeJamIO println(Object o[][]) { return print(concat(o)).println(); }

        public CodeJamIO println(List<Integer[]> l) { return print(concat(l)).println(); }


        private String concat(Object[] o) {
            StringBuffer buf = new StringBuffer(10*o.length);

            String delim = """";
            for (int i=0; i < o.length; i++) {
                buf.append(delim).append(o[i]);
                delim = "" "";
            }
            return buf.toString();
        }

        private String concat(Object[][] o) {
            StringBuffer buf = new StringBuffer(100*o.length);
            for (int i=0; i < o.length; i++) {
                buf.append(concat(o[i])).append(""
"");
            }
            return buf.toString();
        }

        private String concat(List<Integer[]> list) {
            StringBuffer buf = new StringBuffer();
            String delim = """";
            for (Object[] elm : list) {
                buf.append(delim).append(concat(elm)).append(""
"");
            }
            return buf.toString();
        }

        public void debug(String message) {
            err.println(Calendar.getInstance().getTime() + "": "" + message);
        }

        public void debug(String message, Object[] o) {
            err.println(Calendar.getInstance().getTime() + "": "" + message);
            err.println(""	"" + concat(o));
        }

        public void debug(String message, Object[][] o) {
            err.println(Calendar.getInstance().getTime() + "": "" + message);
            String values = concat(o);
            err.println(""	"" + values.replaceAll(""
"", ""
	""));
        }

        public void debug(String message, List<Integer[]> list) {
            err.println(Calendar.getInstance().getTime() + "": "" + message);
            String values = concat(list);
            err.println(""	"" + values.replaceAll(""
"", ""
	""));
        }

        public void flush() {
            out.flush();
            err.flush();
        }

    }
",ddimi
920,"public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        int cases = Integer.parseInt(in.readLine());
        for (int i = 1; i <= cases; i++) {
            int[] nums = new int[Integer.parseInt(in.readLine())];
            StringTokenizer split = new StringTokenizer(in.readLine());
            for (int j = 0; j < nums.length; j++) nums[j] = Integer.parseInt(split.nextToken());
            int left = 0;
            int right = nums.length - 1;
            int count = 0;
            int max = 0;
            while (right > left) {
                if (nums[right] < nums[left]) {
                    if (nums[right] >= max) {
                        count++;
                        max = nums[right];
                    }
                    right--;
                } else if (nums[left] < nums[right]) {
                    if (nums[left] >= max) {
                        count++;
                        max = nums[left];
                    }
                    left++;
                } else {
                    int diff = 1;
                    while (right - diff > left + diff && nums[right - diff] == nums[left + diff]) diff++;
                    if (nums[right - diff] > nums[left + diff]) {
                        if (nums[left] >= max) {
                            count++;
                            max = nums[left];
                        }
                        left++;
                    } else {
                        if (nums[right] >= max) {
                            count++;
                            max = nums[right];
                        }
                        right--;
                    }
                }
            }
            if (nums[left] >= max) count++;
            System.",lavikj
1288,"public class Solution {

	static boolean verb=true;
	static void log(Object X){if (verb) System.err.println(X);}
	static void log(Object[] X){if (verb) {for (Object U:X) System.err.print(U+"" "");System.err.println("""");}}
	static void log(int[] X){if (verb) {for (int U:X) System.err.print(U+"" "");System.err.println("""");}}
	static void logWln(Object X){if (verb) System.err.print(X);}
	static void info(Object o){	System.out.println(o);}
	static void output(Object o){outputWln(""""+o+""
"");	}
	static void outputWln(Object o){try {out.write(""""+ o);} catch (Exception e) {}}





	// Global vars


	static BufferedWriter out;
	static InputReader reader;



	static long R,P;

	static void ask(int node) throws Exception {
		System.out.println(""T ""+(node+1));
		System.out.flush();
		R=reader.readLong()-1;
		P=reader.readLong();
	}

	static void answer(long x) {
		System.out.println(""E ""+x);
		System.out.flush();

	}

	static void process() throws Exception {

		//out = new BufferedWriter(new OutputStreamWriter(System.out));
		reader=new InputReader(System.in);
		Locale.setDefault(Locale.US);	




		int T=reader.readInt();



		for (int t=1;t<=T;t++) {


			int n=reader.readInt();
			int K=reader.readInt();

			R=reader.readLong()-1;
			P=reader.readLong();
			long tot=0;
			tot+=P;
		
			if (K>=n) {
				for (int i=0;i<n;i++) {
					if (i!=R) {
						ask(i);
						tot+=P;
					}
				}
				answer(tot/2);

			} else {
				// take some randoms
				ArrayList<Integer> list=new ArrayList<Integer>();
				for (int i=0;i<n;i++) {
					if (i!=R) {
						list.add(i);
					}
				}
				//Collections.shuffle(list);
				for (int i=0;i<K-1;i++) {
					ask(list.get(i));
					tot+=P;
				}
				tot*=n;
				tot/=K;
				tot/=2;
				long max=n;
				max*=n-1;
				max/=3;
				
				long min=(2*n)/3;
				if (tot<min)
					tot=min;
				if (tot>max)
					tot=max;
				
				answer(tot);
				
			}


			//String ss="""";
			

			//output(""Case #""+t+"": ""+ss);
		}
		//log(""ok"");
		/*
		try {
			out.close();
		}
		catch (Exception EX){}
*/
	}








	public static void main(String[] args) throws Exception {
		process();

	}

	static final class InputReader {
		private final InputStream stream;
		private final byte[] buf = new byte[1024];
		private int curChar;
		private int numChars;

		public InputReader(InputStream stream) {
			this.stream = stream;
		}

		private int read() throws IOException {
			if (curChar >= numChars) {
				curChar = 0;
				numChars = stream.read(buf);
				if (numChars <= 0) {
					return -1;
				}
			}
			return buf[curChar++];
		}


		public final String readString() throws IOException {
			int c = read();
			while (isSpaceChar(c)) {
				c = read();
			}
			StringBuilder res=new StringBuilder();
			do {
				res.append((char)c);
				c = read();
			} while (!isSpaceChar(c));
			return res.toString();
		}

		public final int readInt() throws IOException {
			int c = read();
			boolean neg=false;
			while (isSpaceChar(c)) {
				c = read();
			}
			char d=(char)c;
			//log(""d:""+d);
			if (d=='-') {
				neg=true;
				c = read();
			}
			int res = 0;
			do {
				res *= 10;
				res += c - '0';
				c = read();
			} while (!isSpaceChar(c));
			//log(""res:""+res);
			if (neg)
				return -res;
			return res;

		}

		public final long readLong() throws IOException {
			int c = read();
			boolean neg=false;
			while (isSpaceChar(c)) {
				c = read();
			}
			char d=(char)c;
			//lo)g(""d:""+d);
			if (d=='-') {
				neg=true;
				c = read();
			}
			long res = 0;
			do {
				res *= 10;
				res += c - '0';
				c = read();
			} while (!isSpaceChar(c));
			//log(""res:""+res);
			if (neg)
				return -res;
			return res;

		}



",vincent
966,"public class Solution
{
    public static void main(String args[])
    {
        Scanner sc=new Scanner(System.in);
        int t=sc.nextInt();
        
        while(t-->0)
        {
            int r=sc.nextInt();
            int c=sc.nextInt();
            if(r<2||c<2||r>10||c>10)
            {
                return;
            }
            
            for(int i=0;i<2*r+1;i++)
            {
                for(int j=0;j<2*c+1;j++)
                {
                    if((i==0||i==1)&&j<2)
                    {
                        System.out.print(""."");
                    }
                    else if(i%2==0&&j%2==0)
                    {
                        System.out.print(""+"");
                    }
                    else if(i%2==0&&j%2!=0)
                    {
                        System.out.print(""-"");
                    }
                    else if(i%2!=0&&j%2==0)
                    {
                        System.out.print(""|"");
                    }
                    else if(i%2!=0&&j%2!=0)
                    {
                        System.out.print(""."");
                    }
                }
                System.",mukhtarsetas_gmail
74,"public class Solution {
	static Scanner sc;
	static StringBuffer s;

  public static void main(String[] args)throws Exception{
	  sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
	 // sc = new Scanner(new BufferedReader(new InputStreamReader(new FileInputStream(new File(""src/input.txt""))))); 
    
     int nbTest = sc.nextInt();
     
	 for(int test = 1;test<=nbTest;test++){ 	   	 	
	 	solve(test);
	 }   
	 
  }
  
  static void solve (int test) {
	  int N = sc.nextInt();
	  List<Integer> list = new ArrayList<Integer>();
	  List<Integer> buf = new ArrayList<Integer>();
	  int[] tab = new int[1000000];
	  int res = 1;
	  int a;
	  for (int i = 0; i<N;i++) {
		  a = sc.nextInt();
		  list.add(a);
		  tab[a]++;
	  }
	  
	  int max = Collections.max(list);
	  //for(int i = 0; i<=max+1; i++) System.out.print(tab[i]+""-"");
	  boolean flag = false;
	  
	  for (int i = 1; i<=N;i++) {
		  for (int j = i; j<=max ; j++) {
			  if (tab[j] > 0) {
				  tab[j]--;
				  flag = true;
				  break;
			  } 			  
		  }
		  
		  if (flag==false) {
			  System.out.println(""Case #""+test+"": ""+res);
			  return;
		  }
			  
		  flag = false;
		  
		  res = i;
		  
	  }
	  
	  System.out.println(""Case #""+test+"": ""+(res));
  
  }
  

  public static int  minimum (int a, int b, int c) {	 
		return Math.min(Math.min(a, b), c);
	}
  public static int somme(List<Integer> list) {
	  int res = 0;
	  for (int i = ",Bil1983
1119,"public class Solution {
  public static void main(String[] args) {
    Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
    int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
    for (int i = 1; i <= t; ++i) {
      int n = in.nextInt();
      int m = in.nextInt();
      System.out.println(""Case #"" + i + "":"");
      printCard(n,m);
    }
  }
  
  static void printCard(int r, int c) {
    int rows = 2 * r + 1;
    int cols = 2 * c + 1;
    
    for(int i=0; i<rows; i++) {
      for(int j=0; j<cols; j++) { 
        if (i<2 && j<2) {
            System.out.print('.');
            continue;
        }
        if (i % 2 == 0) {
         if (j % 2 == 0) {
            System.out.print('+'); 
         } else {
            System.out.print('-');  
         }
        } else {
         if (j % 2 == 0) {
            System.out.print('|'); 
         } else {
            System.out.print('.');  
         }
        }
      }  
      System.",rk13
1173,"public class Solution {
    public static void main(String[] args) throws IOException {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt();
        for(int i = 1; i <= t; ++i){
            String word = scanner.next();
            System.out.println(String.format(""Case #%d: %s"",i,firstWord(word.toCharArray())));
        }
    }




    public static String firstWord(final char[] word) {
        ArrayList<Character> rVal = new ArrayList<>(word.length * 2);

        if (word == null || word.length == 0)
            return """";

        if (word.length == 1) {
            return String.valueOf(word);
        }

        Character[] nc = new Character[word.length];
        Character prev = '\\0';
        for(int i = word.length - 1; i >= 0; --i){
            nc[i] = prev;
            if(i > 0){
                if(word[i] != word[i-1]){
                    prev = word[i];
                }
            }
        }

        for (int i = 0; i < word.length; ++i) {
            if (i + 1 >= word.length)
                rVal.add(word[i]);
            else if (nc[i] == '\\0') {
                rVal.add(word[i]);
            } else if (nc[i] > word[i]){
                rVal.add(word[i]);
                rVal.add(word[i]);
            }else {
                rVal.add(word[i]);
            }
        }
        return rVal.",smartelf
1179,"public class Solution {
    public static void main(String[] args) throws IOException {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt();
        for(int i = 0; i < t; ++ i){
            testCase(scanner);
        }
    }

    public static void testCase(final Scanner scanner){
        long n = scanner.nextLong();
        long s1 =  (n * (n + 1)) / 2;
        long f = s1;
        System.out.println(LongStream.range(1,n+1).boxed().map(String::valueOf).collect(Collectors.joining("" "")));
        List<Long> others = LongStream.range(1,n+1).boxed().map(x -> scanner.nextLong()).sorted().collect(Collectors.toList());
        long s2 = others.stream().reduce((x, y) -> x + y).orElse(0L);

        List<Long> cdf = new ArrayList<>();
        long sum = 0;
        for(Long x : others){
            sum += x;
            cdf.add(sum);
        }
        int i = 0;
        int j = 0;

        outer:
       for(i = 0; i < others.size(); ++i){
           for(j = i + 1; j < others.size(); ++ j){
               if(cdf.get(j) - cdf.get(i) <= f){
                   break outer;
               }
           }
       }

        Long d = (i == j) ? 0L : cdf.get(j) - cdf.get(i);
       List<Long> rVal1 = LongStream.range(1,n+1).boxed().filter(x -> x != d).collect(Collectors.toList());
       List<Long> rVal2 = ",smartelf
1065,"public class Solution {
    public static Random random = new Random();

    public static String generate(int n){
        List<Character> string = new LinkedList<>();
        for(int i = 0; i < 8; i ++){
            string.add('0');
        }
        List<Integer> indices = new LinkedList<>();
        for(int i = 0; i < 8; i ++){
            indices.add(i);
        }
        Collections.shuffle(indices);
        for(int i = 0; i < n; i ++){
            int index = indices.get(i);
            string.set(index, '1');
        }
        StringBuilder sb = new StringBuilder();
        for(Character c : string){
            sb.append(c);
        }
        return sb.toString();
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        boolean flag = true;
        for(int Case = 1; Case <= T; Case ++){
            if(!flag){
                break;
            }
            int startN = random.nextInt(8);
            String string = generate(startN);
            for(int i = 0; i < 300; i ++){
                System.out.println(string);
                int n = sc.nextInt();
                if(n == 0){
                    break;
                }
                else if(n == -1){
//                    System.out.println(""Error"");
                    flag = false;
                    break;
                }
                else{
                    string = ",ql309
789,"public class Solution {

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        PrintStream out = System.out;

        try {
//            in = new Scanner(new BufferedReader(new FileReader(""/Users/Shared/Sources/CodingStudy/src/codejam/year2022/round_QA/ChainReactions/sample/sample_ts1-in.txt"")));
//            out = new PrintStream(new FileOutputStream(""/Users/Shared/Sources/CodingStudy/src/codejam/year2022/round_QA/ChainReactions/sample/sample_ts1-out.txt""));

//            in = new Scanner(new BufferedReader(new FileReader(""/Users/Shared/Sources/CodingStudy/src/codejam/year2022/round_QA/ChainReactions/sample/sample_ts2-in.txt"")));
//            out = new PrintStream(new FileOutputStream(""/Users/Shared/Sources/CodingStudy/src/codejam/year2022/round_QA/ChainReactions/sample/sample_ts2-out.txt""));

        } catch (Exception e) {
            e.printStackTrace();
            return;
        }

        int T = in.nextInt();
        for (int t = 1; t <= T; t++) {
            int N = in.nextInt();

            int[] F = new int[N];
            for( int i=0;i<N;i++){
                F[i] = in.nextInt();
            }
            int[] parent = new int[N];
            for( int i=0;i<N;i++){
                parent[i] = in.nextInt();
            }

            long ans = getAnswer(N, F, parent);

            out.printf(""Case #%d: %d
"", t, ans);
        }
        in.close();
    }


    private static long getAnswer(int N, int[] F, int[] parents) {

        Map<Integer,Integer> inDegree = new HashMap<>();

        Map<Integer,Boolean> visited = new HashMap<>();

        /* 1. Build graph. */
        for(int i=1;i<=N;i++) {
            inDegree.put(i, 0);
            visited.put(i, false);
        }

        for(int i=0;i<N;i++){
            int parentNo = parents[i];

            if( parentNo != 0) {
                inDegree.put(parentNo, inDegree.get(parentNo) + 1);
            }
        }

        /* 3. Do DFS by maxEst */
        List<Integer> initiators = new ArrayList<>();
        for(int i=1;i<=N;i++){
            if(inDegree.get(i) ==0){
                initiators.add(i);
            }
        }

        long ans = travel(N, F, parents, initiators);
        return ans;
    }

    private static long travel(int N, int[] F, int[] parents, List<Integer> initiator) {
        // Permutation.
        int[] in = initiator.stream().mapToInt(Integer::intValue).toArray();
        int[] path = new int[initiator.size()];
        boolean[] visitedB = new boolean[initiator.size()];
        List<List<Integer>> permuations = new ArrayList<>();
        r_permutate(in, path, 0, visitedB, permuations);

        int maxSum = Integer.MIN_VALUE;
        for(List<Integer> initiators : permuations){
//            System.out.println(initiators);
            int sum=0;
            Map<Integer, Boolean> visited = new HashMap<>();
            for(int nodeNo: initiators){
                List<Integer> values = new ArrayList<>();
                travel(N, F, parents, visited, nodeNo, values);

                Collections.sort(values, Collections.reverseOrder());
                sum = sum + values.get(0);

//                System.out.printf(""values: %s
"", values);
//                System.out.printf(""Max: %d
"", sum);
            }
            maxSum = Math.max(maxSum, sum);

//            System.out.printf(""maxSum: %d
"", maxSum);
        }

        return maxSum;
    }

    public static void r_permutate(int[] in, int[] path, int level, boolean[] visited, List<List<Integer>> output){

        if( in.length == level ){
            output.add(Arrays.stream(path).boxed().collect(Collectors.toList()));
            return;
        }

        for(int i = 0; i < in.length; i++){
            if(visited[i])  continue;

            visited[i] = true;
            path[level] = in[i];
            r_permutate(in, path, level + 1, visited, output);
            visited[i] = false;

        }
    }

    private static void travel(int n, int[] f, int[] parents, Map<Integer, Boolean> visited, int nodeNo, List<Integer> values) {
        if( visited.getOrDefault(nodeNo, false))    return;
        visited.put(nodeNo, true);
        values.add(f[nodeNo-1]);

        int next = parents[nodeNo-1];
        if( next ==0)   return;
        travel(n, f, parents, visited, next, values);
    }

",id
584,"public class Solution {
    private final PrintStream out;
    Scanner scanner;

    public Solution(InputStream in, PrintStream out) {
        scanner = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        this.out = out;
    }

    public static void main(String[] args) throws IOException {
        new Solution(System.in, System.out).solve();
    }

    void solve() {
        int T = scanner.nextInt();
        for (int t = 1; t <= T; t++) {
            int n = scanner.nextInt();
            int k = scanner.nextInt();
            int r = scanner.nextInt();
            int pnum = scanner.nextInt();
            Map<Integer, Integer> map = new HashMap<>();
            map.put(r,  pnum);
            List<Integer> lst = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                lst.add(i + 1);
            }
            Collections.shuffle(lst);
            int i = 0;
            int j = 0;
            while ( i < k) {
                if(i>=n) break;
                out.println(String.format(""T %d"", lst.get(j)));
                i++;
                out.flush();
                r = scanner.nextInt();
                pnum = scanner.nextInt();
                map.put(r, pnum);
                if(i>=k) break;
                if(pnum==1) {
                    out.println(""W"");
                    out.flush();
                    r = scanner.nextInt();
                    pnum = scanner.nextInt();
                    map.put(r, pnum);
                    i++;
                }

                j++;
            }

            double avg = 0;
            for(int v : map.values()) {
                avg += v;
            }
            double sum = avg;
            avg /= map.size();
            int missing = n - map.size();
            sum += missing*avg;
            sum /= 2;
            String cmd = ",bdomokos74
923,"public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        int cases = Integer.parseInt(in.readLine());
        for (int i = 1; i <= cases; i++) {
            System.out.println(""11111000"");
            boolean done = false;
            while (!done) {
                switch(Integer.parseInt(in.readLine())) {
                    case 0:
                        done = true;
                        break;
                    case 1:
                        System.out.println(""10000000"");
                        break;
                    case 2:
                        System.out.println(""11000000"");
                        break;
                    case 3:
                        System.out.println(""11100000"");
                        break;
                    case 4:
                        System.out.println(""11110000"");
                        break;
                    case 5:
                        System.out.println(""11111000"");
                        break;
                    case 6:
                        System.out.println(""11111100"");
                        break;
                    case 7:
                        System.out.println(""11111110"");
                        break;
                    case 8:
                        System.",lavikj
428,"public class Solution {
    public static void main(String[] args) {
        try {
            Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
            int tests = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
            for (int currentTest = 1; currentTest <= tests; ++currentTest) {
                int N = in.nextInt();
                int K = in.nextInt();
                int r = in.nextInt();
                int p = in.nextInt();
                long pSum = p;
                long queries = K;
                if(N == 2){
                    System.out.println(""E 1"");
                    System.out.flush();

                }else if(N <= 100){
                    Set<String> set = new HashSet<>();
                    int prev = r;
                    while (queries > 0) {
                        if(queries%30 == 0){
                            int nxt = (int) (Math.random() * N + 1);
                            System.out.println(""T "" + nxt);
                            System.out.flush();
                            prev = in.nextInt();
                            p = in.nextInt();
                            queries --;
                        }
                        System.out.println(""W"");
                        System.out.flush();
                        r = in.nextInt();
                        p = in.nextInt();
                        set.add(Math.min(r,prev) +  ""_"" + Math.max(r,prev));
                        queries--;
                        prev = r;
                    }
                    System.out.println(""E "" + set.size());
                    System.out.flush();
                }else {
                    while (queries > 0) {
                        int nxt = (int) (Math.random() * N + 1);
                        System.out.println(""T "" + nxt);
                        System.out.flush();
                        r = in.nextInt();
                        p = in.nextInt();
                        pSum += p;
                        queries--;
                    }
                    double avg = (double) pSum / (K + 1);
                    long mid = (long) ((N * avg) / 2.0);
                    System.out.println(""E "" + mid);
                    System.out.flush();
                }
            }
        }catch (Exception e){
            System.err.println(e.getMessage());
            e.printStackTrace();
            System.exit(1);
        }
    }

    public static String arrToStr(int[][] arr) {
        StringBuilder str = new StringBuilder();
        for (int[] ints : arr) {
            String s = ",Vlad
182,"public class Solution {
	
	long totalPassages=0;
	int steps=0, currentRoom=1;
	Scanner s;
	
	public static void main(String[] args) {
		new Solution().start();
	}
	
	
	public void start() {
		
		s = new Scanner(System.in);
		int cases = s.nextInt();
		for(int caseIndex=0;caseIndex<cases;caseIndex++) {
			int roomCount = s.nextInt();
			int maximumTries = s.nextInt();
			totalPassages=0;
			steps=0;
			
			long estimation = 0;

			sync();
			teleport(roomCount/2);
			
			int skip = (int)(roomCount*1f/maximumTries);
			for(int step=0;step<maximumTries-1;step++) {

				if(step % 10 == 0) {
					walk();
				}else {
					teleport(((currentRoom+skip)%roomCount)+1);
				}
				
				
			}
			
			estimation = (long)(totalPassages*1f*roomCount/maximumTries/2);
			
			System.out.println(""E ""+estimation);
		}
		
		s.close();

	}
	
	private void teleport(int room) {
		System.out.println(""T ""+room);
		sync();
	}
	
	private void walk() {
		System.out.println(""W"");
		sync();
	}
	
	private void sync() {
		currentRoom = s.nextInt();
		long passageCount = ",KovacsA22
856,"public class Solution {
    
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        int T = Integer.parseInt(in.readLine());
        for (int e = 0; e < T; e++) {
            StringTokenizer st = new StringTokenizer(in.readLine());
            int N = Integer.parseInt(st.nextToken()), K = Integer.parseInt(st.nextToken());
            double ans = 0;
            for (int i = 0; i < K; i++) {
                StringTokenizer st2 = new StringTokenizer(in.readLine());
                int R = Integer.parseInt(st2.nextToken()), P = Integer.parseInt(st2.nextToken());
                ans += P;
                System.out.println(""T "" + ((int)(Math.random()*N + 1)));
            }
            ans = ans / 2;
            ans = ",kevinz1423
1088,"public class Solution {

    public static void main(String[] args) {
        Scanner sc = null;
        sc = new Scanner(System.in);
        int T = sc.nextInt();
        for (int t = 0; t < T; t++) {
            int N = sc.nextInt();
            int[] F = new int[N];
            int[] P = new int[N];
            for (int i = 0; i < N; i++) {
                F[i] = sc.nextInt();
            }
            for (int i = 0; i < N; i++) {
                P[i] = sc.nextInt();
            }

            Node[] nodes = new Node[N + 1];
            nodes[0] = new Node(0, 0);  //abyss
            nodes[0].out = new Edge(nodes[0], nodes[0]);
            for (int i = 0; i < N; i++) {
                Node n = new Node(i + 1, F[i]);
                nodes[i + 1] = n;
                Edge e1 = new Edge(n, nodes[P[i]]);
                n.out = e1;
                Edge e2 = new Edge(nodes[P[i]], n);
                nodes[P[i]].in.add(e2);
            }

            /*Stack<Node> stack = new Stack<Node>();

            // Mark all the vertices as not visited
            boolean visited[] = new boolean[N + 1];
            for (int i = 0; i < N + 1; i++) {
                visited[i] = false;
            }
            for (int i = 0; i < N + 1; i++)
                if (visited[i] == false)
                    topologicalSortUtil(nodes[i], visited, stack);
*/
            // Print contents of stack
            //make chain
//            Collections.reverse(stack);
            ArrayList<ArrayList<Node>> al = new ArrayList<>();
            for (Node n : nodes) {
//                Node n = stack.pop();
//                if (debug)
                if (n.in.size() == 0) {
                    ArrayList<Node> chain = new ArrayList();
                    Node n1 = n;
                    chain.add(n1);
                    do {
                        n1 = n1.out.to;
                        chain.add(n1);
                    }
                    while (n1.id != 0);
                    al.add((ArrayList<Node>) chain.clone());
                    /*int size = N;
                    int oldSize = chain.size();
                    while (size-- > 0) {
                        ArrayList<Node> cl = (ArrayList<Node>) chain.clone();
                        while (cl.size() > 1 && cl.get(cl.size() - 1).in.size() >= size) {
                            cl.remove(cl.size() - 1);
//                    chain.remove(0);
                        }
                        if (cl.size() != oldSize) {
                            al.add((ArrayList<Node>) cl.clone());
                            oldSize = cl.size();
                        }
                    }*/
                    //find combinations of chains to equal full set
//                    int max=recurs(al);

                }
            }


//            for (ArrayList<Node> chain : al) {
//                int max = Integer.MIN_VALUE;
////                int min = Integer.MAX_VALUE;
//                for (int i = 0; i < chain.size(); i++) {
//                    max = Math.max(chain.get(i).fun, max);
////                    min = Math.min(chain.get(i).fun, min);
//                }
//            }

            //recursion
            //F(x)=max(click it, don't click it)
//            boolean[] vector=new boolean[al.size()];
//            int max=recurs(al,vector);

            int answer = recurs(al, new ArrayList<Node>(), N);
            System.out.println(""Case #"" + (t + 1) + "": "" + answer);
        }

    }

    private static int recurs(ArrayList<ArrayList<Node>> al, ArrayList<Node> nodes, int N) {
        boolean[] visited = new boolean[N + 1];
        int cnt = 0;
        if (nodes.size() == al.size()) {

            for (int i = 0; i < nodes.size(); i++) {
                int max1 = 0;
                Node n54 = nodes.get(i);
                while (n54.id > 0) {
                    //System.out.println(n54.id+"":""+n54.fun+"" ""+max1);
                    if (!visited[n54.id]) {
                        max1 = Math.max(max1, n54.fun);
                        visited[n54.id] = true;

                    } else {
                        break;
                    }
                    n54 = n54.out.to;
//                    else break;

                }
                //System.out.println(n54.id+"":""+n54.fun+"" ""+max1);
                cnt += max1;
            }
            //System.out.println(cnt+""	""+Arrays.toString(nodes.toArray()));
            return cnt;
        } else {
 /*       if (cnt==N+1){
            return max1;
        }
        max1=Integer.MIN_VALUE;*/
            int mm = 0;
            for (int i = 0; i < al.size(); i++) {
                if (nodes.contains(al.get(i).get(0))) {
                    continue;
                }
//            int mm=0;
                ArrayList<Node> n1 = (ArrayList<Node>) nodes.clone();
//            for (Node n2:al.get(i)){
//                n1.add(n2);
//                mm+=n2.fun;
//            }
                n1.add(al.get(i).get(0));
                mm = Math.max(recurs(al, n1, N), mm);
            }
//            System.out.println(""*""+mm+""	""+Arrays.toString(nodes.toArray()));
            if (mm == 0) {
                return recurs(al, nodes, N);
            }
            return mm;
        }
    }


    // A recursive function used by topologicalSort
    static void topologicalSortUtil(Node n, boolean[] visited, Stack<Node> stack) {
        // Mark the current node as visited.
        visited[n.id] = true;
        Edge i;

        // Recur for all the vertices adjacent
        // to thisvertex
        Iterator<Edge> it = n.in.iterator();
        while (it.hasNext()) {
            i = it.next();
            if (!visited[i.to.id])
                topologicalSortUtil(i.to, visited, stack);
        }

        // Push current vertex to stack
        // which stores result
        stack.push(n);
    }


    static class Node {
        Edge out;
        ArrayList<Edge> in = new ArrayList<>();
        int id;
        int fun;

        @Override
        public String toString() {
            return ""Node{"" +
                    ""out="" + out +
                    "", in="" + in.size() +
                    "", id="" + id +
                    "", fun="" + fun +
                    '}';
        }

        Node(int id, int fun) {
            this.id = id;
            this.fun = fun;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Node node = (Node) o;
            return id == node.id;
        }

        @Override
        public int hashCode() {
            return Objects.hash(id);
        }
    }

    static class Edge {
        Node from;
        Node to;

        @Override
        public String toString() {
            return ""Edge{"" +
                    ""from="" + from.id +
                    "", to="" + to.id +
                    '}';
        }

        public Edge(Node from, Node to) {
            this.from = from;
            this.to = ",raver1975
132,"class Solution {
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        List<String> output = new ArrayList<>();
        for(int i = 1; i <= n; i ++){
            int size = sc.nextInt();
            Deque<Integer> deque = new ArrayDeque<>();
            for (int j = 0; j < size; j ++) {
                deque.add(sc.nextInt());
            }
            output.add(""Case #"" + i + "": "" + check(deque));
        }
        output.forEach(System.out::println);
    }

    public static int check(Deque<Integer> deque){

        int res = 0;
        int prev = 0;
        while(!deque.isEmpty()) {
            int first = deque.peekFirst();
            int last = deque.peekLast();
            if (first < prev && last < prev) {
                break;
            }
            res ++;
            if (first < last) {
                if (first >= prev) {
                    prev = deque.pollFirst();
                } else {
                    prev = deque.pollLast();
                }
            } else {
                if (last >= prev) {
                    prev = deque.pollLast();
                } else {
                    prev = deque.pollFirst();
                }
            }
        }

        return res;

    }
",Em11
958,"public class Solution {

	public static void main(String[] args) {
		Scanner s = new Scanner(System.in);
		int i, j, k, l, t, diferenca;
		int p1[] = new int[4];
		int p2[] = new int[4];
		int p3[] = new int[4];
		int saida1[] = new int[4];
 		
		do {
			t = s.nextInt();
		} while(t < 1 || t > 100);
		
		for(i = 1; i <= t; i++) {
			l = 0;
			
				for(k = 0; k < 4; k++) {
					do {
						p1[k] = s.nextInt();
						
					} while(p1[k] < 0 || p1[k] > (int) Math.pow(10, 6));
				}
				
				for(k = 0; k < 4; k++) {
					do {
						p2[k] = s.nextInt();
						
					} while(p2[k] < 0 || p2[k] > (int) Math.pow(10, 6));
				}
				
				for(k = 0; k < 4; k++) {
 					do {
						p3[k] = s.nextInt();
						
					} while(p3[k] < 0 || p3[k] > (int) Math.pow(10, 6));
				}
			
			for(j = 0; j < 4; j++) {
				
				if(p1[j] <= p2[j] & p1[j] <= p3[j]) {
					saida1[l] = p1[j];
				} else if(p2[j] <= p3[j]) {
					saida1[l] = p2[j];
				} else {
					saida1[l] = p3[j];
				}
				
				if(p1[j] == 0)
					if(p2[j] <= p3[j])
						saida1[l] = p2[j];
					else
						saida1[l] = p3[j];
				
				if(p2[j] == 0)
					if(p1[j] <= p3[j])
						saida1[l] = p1[j];
					else
						saida1[l] = p3[j];
				
				if(p3[j] == 0)
					if(p1[j] <= p2[j])
						saida1[l] = p1[j];
					else
						saida1[l] = p2[j];
				
				if(p1[j] == 0 && p2[j] == 0)
					saida1[l] = p3[j];
				
				if(p2[j] == 0 && p3[j] == 0)
					saida1[l] = p1[j];
				
				if(p1[j] == 0 && p3[j] == 0)
					saida1[l] = p2[j];
				
				l++;
			}

			l = 0;
			System.out.print(""Case #"" + i + "": "");
			
			if((saida1[0] + saida1[1] + saida1[2] + saida1[3]) >= (int) 3*Math.pow(10, 6)) {
				
				diferenca = saida1[0] + saida1[1] + saida1[2] + saida1[3] - 3 * 10 * 10 * 10 * 10 * 10 * 10;
				
				while(diferenca > 0) {
					saida1[j]--;
					diferenca--;
					j++;
					
					if(j == 4)
						j = 0;
				}
				
				System.out.print(saida1[0] + "" "" + saida1[1] + "" "" + saida1[2] + "" "" + saida1[3]);
			} else {
				System.out.print(""IMPOSSIBLE"");
			}
			
			if(i != 1)
				System.",marcosph
1130,"public class Solution {
    Scanner sc       = new Scanner(System.in);
    static final String FILENAME = ""A-small"";
    static final String IN       = FILENAME + "".in"";
    static final String OUT      = FILENAME + "".out"";
    PrintStream out      = System.out;

    private void run() throws Exception {
        // out = new PrintStream(new FileOutputStream(OUT));
        int T = sc.nextInt();
        for (int t = 1; t <= T; t++) {
            int n = sc.nextInt(); int k = sc.nextInt();
            int [] rooms = new int[n];
            for(int i = 0; i<n; i++)
                rooms[i] = i + 1;

            int stats[] = new int[n];
            Arrays.fill(stats, 0);
            shuffleArray(rooms);;
            int startPos = sc.nextInt();
            int deg = sc.nextInt();
            stats[deg] ++;
            for(int i = 0; i<k; i++) {
                if(rooms[i] == startPos) {
                    i ++;
                }
                out.println(""T "" + (rooms[i % n]));
                out.flush();
                int u = sc.nextInt();
                deg = sc.nextInt();
                stats[deg] ++;
            }

            double p = 0.;
            for(int i = 0; i<n; i++) {
                if(stats[i] > 0) {
                    double m = (i * stats[i] * 1.) / k;
                    p += m;
                }
            }

            p = p / (1. * (n - 1));
//            p = p / (k * 1.);
            double exp1 = p * n * ( n - 1) / 2.;
            double exp2 = (1 - p) * n * ( n - 1) / 2.;
            double exp = (exp1 + exp2) / 2;
            out.println(""E "" + (int) Math.ceil(exp));
            out.flush();
        }
        sc.close();
        out.flush();
        out.close();
    }

    static void shuffleArray(int[] ar)
    {
        Random rnd = new Random(System.currentTimeMillis());
        for (int i = ar.length - 1; i > 0; i--)
        {
            int index = rnd.nextInt(i + 1);
            // Simple swap
            int a = ar[index];
            ar[index] = ar[i];
            ar[i] = a;
        }
    }

    public static void main(String args[]) throws Exception {
        new Solution().",rkamun
710,"public class Solution {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        final int numCases = Integer.parseInt(input.nextLine());
        for (int i = 1; i <= numCases; i++) {
            System.out.print(String.format(""Case #%d: "", i));
            
            final int[][] printer = new int[3][4];
            
            int maxCyan = 1000000;
            int maxMagenta = 1000000;
            int maxYellow = 1000000;
            int maxBlack = 1000000;
            
            for (int j = 0; j < 3; j++) {
                final String line = input.nextLine();
                final String[] parts = line.split(""\\\s"");
            
                printer[j][0] = Integer.parseInt(parts[0]);
                printer[j][1] = Integer.parseInt(parts[1]);
                printer[j][2] = Integer.parseInt(parts[2]);
                printer[j][3] = Integer.parseInt(parts[3]);
                
                if (printer[j][0] < maxCyan) {
                    maxCyan = printer[j][0];
                }
                
                if (printer[j][1] < maxMagenta) {
                    maxMagenta = printer[j][1];
                }
                
                if (printer[j][2] < maxYellow) {
                    maxYellow = printer[j][2];
                }
                
                if (printer[j][3] < maxBlack) {
                    maxBlack = printer[j][3];
                }
            }
            
            String r;
            
            if ((maxCyan + maxMagenta + maxYellow + maxBlack) < 1000000) {
                r = ""IMPOSSIBLE"";
            } else {
                int excess = (maxCyan + maxMagenta + maxYellow + maxBlack) - 1000000;
                int c = maxCyan;
                int m = maxMagenta;
                int y = maxYellow;
                int k = maxBlack;
                
                while (excess > 0) {
                    // remove excess from cyan
                    if (c < (excess / 4)) {
                        excess -= c;
                        c = 0;
                    } else {
                        c -= (excess / 4);
                        excess -= (excess / 4);
                    }
                    
                    // remove excess from magenta
                    if (m < (excess / 3)) {
                        excess -= m;
                        m = 0;
                    } else {
                        m -= (excess / 3);
                        excess -= (excess / 3);
                    }
                    
                    // remove excess from yellow
                    if (y < (excess / 2)) {
                        excess -= y;
                        y = 0;
                    } else {
                        y -= (excess / 2);
                        excess -= (excess / 2);
                    }
                    
                    // remove excess from black
                    if (k < excess) {
                        System.out.println(""IMPOSSIBLE"");
                        return;
                    } else {
                        k -= excess;
                    }
                }
                
                r = String.format(""%d %d %d %d"", c, m, y, k);
            }
            System.out.println(r);
        }
    }
}",gawallace25
1000,"public class Solution
{
    int iter = 1;
    void calculate(int r, int c)
    {
        int rows = 2*r + 1;
        int columns = 2*c + 1;
        char[][] matrix = new char[rows][columns];
        
        matrix[0][0] = '.';
        matrix[0][1] = '.';
        matrix[1][0] = '.';
        matrix[1][1] = '.';
        for(int i=0; i<rows; i++)
        {
            for(int j=0; j<columns; j++)
            {
                if((i==0 && j==0) || (i==0 && j==1) || (i==1 && j==0) || (i==1 && j==1))
                    continue;
                if(i%2==0 && j%2==0)
                    matrix[i][j] = '+';
                else if(i%2==0 && j%2==1)
                    matrix[i][j] = '-';
                else if(i%2==1 && j%2==0)
                    matrix[i][j] = '|';
                else
                    matrix[i][j] = '.';
            }
        }
        System.out.println(""Case #""+(iter++)+"": "");
        for(int i=0; i<rows; i++)
        {
            for(int j=0; j<columns; j++)
            {
                System.out.print(matrix[i][j]);
            }
            System.out.println();
        }
    }
    public static void main(String[] args)
    {
        Solution obj = new Solution();
        Scanner sc = new Scanner (System.in);
        int t = sc.nextInt();
        String dummy = sc.nextLine();
        String[] r_string = new String[t];
        String[] c_string = new String[t];
        for(int i=0; i<t; i++)
        {
            r_string[i] = sc.next();
            c_string[i] = sc.next();
        }
        for(int i=",nocturnalspider
431,"public class Solution {
    public static void main(String[] args) {
        try {
            Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
            int tests = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
            for (int currentTest = 1; currentTest <= tests; ++currentTest) {
                int[] col = new int[4];
                for(int i = 0; i < 4; i ++){
                    col[i] = Integer.MAX_VALUE;
                }
                for(int r = 0; r< 3; r ++){
                    for(int c = 0; c< 4; c ++){
                        col[c] = Math.min(col[c], in.nextInt());
                    }
                }
                int sum = 0;
                int reserve = 1_000_000;
                int[] res = new int[4];
                for(int i = 0; i < col.length; i++){
                    sum += col[i];
                    int  left = Math.min(reserve, col[i]);
                    res[i] = left;
                    reserve = Math.max(0, reserve - col[i]);
                }

                System.out.println(""Case #"" + currentTest + "": "" + (sum >=1000_000?arrToStr(res): ""IMPOSSIBLE""));
            }
        }catch (Exception e){
            System.err.println(e.getMessage());
            e.printStackTrace();
        }
    }

    public static String arrToStr(int[] arr) {
        StringBuilder str = new StringBuilder();
        for (int i : arr) {
             str.append("" "");
            str.append(i);

        }
        return str.",Vlad
527,"public class Solution {

    private static final Boolean FROM_FILE = Boolean.FALSE;

    public static void main(String[] args) throws IOException{
        BufferedReader br;
        BufferedWriter bw;

        if(FROM_FILE){
            br = new BufferedReader(new FileReader(""C2022QR1B.in""));
        } else {
            br = new BufferedReader(new InputStreamReader(System.in));
        }

        try {
            if(FROM_FILE) {
                File file = new File(""C2022QR1B.out"");
                if (!file.exists()) {
                    file.createNewFile();
                }
                bw = new BufferedWriter(new FileWriter(file.getAbsoluteFile()));
            } else {
                bw = new BufferedWriter(new OutputStreamWriter(System.out));
            }

            String line = br.readLine();
            String[] p;

            int tests = Integer.parseInt(line);//100
            int n = 1000000;
            int c,y,m,k;
            int c1,y1,m1,k1;
            int c2,y2,m2,k2;
            int c3,y3,m3,k3;

            for(int i = 0; i < tests; i++){
                line = br.readLine();
                p = line.split(""\\\s+"");
                c1 = Integer.parseInt(p[0]);
                m1 = Integer.parseInt(p[1]);
                y1 = Integer.parseInt(p[2]);
                k1 = Integer.parseInt(p[3]);

                line = br.readLine();
                p = line.split(""\\\s+"");
                c2 = Integer.parseInt(p[0]);
                m2 = Integer.parseInt(p[1]);
                y2 = Integer.parseInt(p[2]);
                k2 = Integer.parseInt(p[3]);

                line = br.readLine();
                p = line.split(""\\\s+"");
                c3 = Integer.parseInt(p[0]);
                m3 = Integer.parseInt(p[1]);
                y3 = Integer.parseInt(p[2]);
                k3 = Integer.parseInt(p[3]);

                c = Math.min(c1,Math.min(c2,c3));
                y = Math.min(y1,Math.min(y2,y3));
                m = Math.min(m1,Math.min(m2,m3));
                k = Math.min(k1,Math.min(k2,k3));

                //output
                bw.write(""Case #""+(i+1)+"": "");
                if(c+y+m+k < n){
                    bw.write(""IMPOSSIBLE
"");
                } else {
                    k = n-c-y-m;
                    if(k < 0) {
                        k = 0;
                        m = n-c-y;
                        if(m < 0){
                            m = 0;
                            y = n-c;
                            if(y<0){
                                y = 0;
                            }
                        }
                    }
                    bw.write(""""+c+"" ""+y+"" ""+m+"" ""+k+""
"");
                }

                bw.flush();
            }

            if(FROM_FILE) {
                bw.close();
            }
        } finally {
            if(FROM_FILE) {
                br.close();
            }
        }
    }
}",araver
545,"public class Solution {
//public class B2 {
    public static void main(String[] args) throws IOException {
        //BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(""in.txt"")));
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int ttt = Integer.parseInt(br.readLine());
        for (int tt = 1; tt <= ttt; ++tt) {
            String[] cc = br.readLine().split("" "");
            final int n = Integer.parseInt(cc[0]);
            final int p = Integer.parseInt(cc[1]);

            final int[][] all = new int[n][p];
            for (int nn = 0; nn < n; nn++) {
                cc = br.readLine().split("" "");
                for (int pp = 0; pp < p; pp++) {
                    all[nn][pp] = Integer.parseInt(cc[pp]);
                }
            }

            final int[][] q = new int[n][2];
            for (int i = 0; i < n; i++) {
                int min = Integer.MAX_VALUE;
                int max = Integer.MIN_VALUE;
                for (int x : all[i]) {
                    min = Math.min(min, x);
                    max = Math.max(max, x);
                }
                q[i][0] = min;
                q[i][1] = max;
            }

            long answ = 0;
            for (int[] x : q) {
                answ += (long) (x[1] - x[0]);
            }

            //System.out.println(answ);

            int[] elements = new int[n];
            for (int i = 0; i < n; i++) {
                elements[i] = i;
            }

            long best = Integer.MAX_VALUE;

            best = Math.min(calc(elements, q), best);

            System.out.println(""Case #"" + tt + "": "" + (answ + best));

        }
    }

    private static long calc(int[] elements, int[][] q) {
        long[][] res = new long[elements.length][2];
        res[0][0] = (long)q[elements[0]][1] * 2L - (long)q[elements[0]][0];
        res[0][1] = q[elements[0]][0];
        for (int i = 1; i < elements.length; i++) {
            final long prevTop = q[elements[i - 1]][1];
            final long prevBottom = q[elements[i - 1]][0];

            final long currTop = q[elements[i]][1];
            final long currBottom = q[elements[i]][0];

            res[i][0] = Math.min(Math.abs(currTop - prevTop) + res[i - 1][1], Math.abs(currTop - prevBottom) + res[i - 1][0]);
            res[i][1] = Math.min(Math.abs(currBottom - prevTop) + res[i - 1][1], Math.abs(currBottom - prevBottom) + res[i - 1][0]);
        }


        return Math.min(res[elements.length - 1][0], res[elements.length - 1][1]);
    }

    private static void swap(int[] input, int a, int b) {
        int tmp = input[a];
        input[a] = input[b];
        input[b] = ",attila
1219,"public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        for (int t = 0; t < T; t++) {
            int N = sc.nextInt();
            int K = sc.nextInt();
            if (N - 1 <= K) {
                int startRoom = sc.nextInt();
                long total = sc.nextInt();
                for (int i = 1; i <= N; i++) {
                    if (i == startRoom) {
                        continue;
                    }
                    System.out.println(""T "" + i);
                    sc.nextInt();
                    total += sc.nextInt();
                }
                System.out.println(""E "" + total / 2);
            } else {
                int[] passages = new int[N + 1];
                int startRoom = sc.nextInt();
                passages[startRoom] = sc.nextInt();
                long total = passages[startRoom];
                int roomsVisited = 1;
                int minUnvisited = startRoom == 1 ? 2 : 1;
                boolean walk = true;
                for (int i = 0; i < K; i++) {
                    if (walk) {
                        System.out.println(""W"");
                        int nextRoom = sc.nextInt();
                        int numPassages = sc.nextInt();
                        if (passages[nextRoom] == 0) {
                            passages[nextRoom] = numPassages;
                            total += numPassages;
                            roomsVisited++;
                        }
                    } else {
                        System.out.println(""T "" + minUnvisited);
                        int nextRoom = sc.nextInt();
                        passages[nextRoom] = sc.nextInt();
                        total += passages[nextRoom];
                        roomsVisited++;
                    }
                    walk = !walk;
                    while (passages[minUnvisited] != 0) {
                        minUnvisited++;
                    }
                }
                System.",teekaytai
378,"class Code {
    public static Scanner scan;
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int runtime = scan.nextInt();
        int a=1000000000;
        for(int i=0;i<runtime;i++){
            int num=scan.nextInt();
            int [] array=new int[num];
            int [] array2=new int[num];
            Arrays.sort(array);
            System.out.print(""Case #""+"" ""+(i+1)+"":"");
            int t=0;
            for(int d=0;d<array.length;d++) {
                t++;
                if (array[d]<t) {
                    t--;
                }
            }
            System.",ShuoXu
229,"class Solution {
    public static void main(String[] args)
    {
        Scanner s = new Scanner(System.in);
        int t = s.nextInt();
        for(int i = 1; i <= t; i++)
        {
            System.out.println(11111111);
            System.out.flush();
            int comp = s.nextInt();
            while(comp > 0)
            {
                if(comp > 4)
                {
                    System.out.println(11111111);
                    System.out.flush();
                } else if(comp > 2)
                {
                    System.out.println(1111000);
                    System.out.flush();
                } else if(comp == 2)
                {
                    System.out.println(11000000);
                    System.out.flush();
                } else
                {
                    System.out.println(10000000);
                    System.out.flush();
                }
                comp = ",Maarten17581
60,"public class Solution {
	static Scanner sc;
	static StringBuffer s;

  public static void main(String[] args)throws Exception{
	 sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
	 // sc = new Scanner(new BufferedReader(new InputStreamReader(new FileInputStream(new File(""src/input.txt""))))); 
    
     int nbTest = sc.nextInt();
     
	 for(int test = 1;test<=nbTest;test++){ 	   	 	
	 	solve(test);
	 }   
	 
  }
  
  static void solve (int test) {
	  
	  List<Integer> list1 = new ArrayList<Integer>();
	  List<Integer> list2 = new ArrayList<Integer>();
	  List<Integer> list3 = new ArrayList<Integer>();
	  List<Integer> result = new ArrayList<Integer>();
	  int s = 1000000;
	  for (int i = 0; i<4; i++) list1.add(sc.nextInt()); 
	  for (int i = 0; i<4; i++) list2.add(sc.nextInt());
	  for (int i = 0; i<4; i++) list3.add(sc.nextInt());
	  
	  if (somme(list1)<s) {
		  System.out.println(""Case #""+test+"": IMPOSSIBLE"");
		  return;
	  }
	  if (somme(list2)<s) {
		  System.out.println(""Case #""+test+"": IMPOSSIBLE"");
		  return;
	  }
	  if (somme(list3)<s) {
		  System.out.println(""Case #""+test+"": IMPOSSIBLE"");
		  return;
	  }
	  int minC = minimum(list1.get(0), list2.get(0), list3.get(0));
	  int minM = minimum(list1.get(1), list2.get(1), list3.get(1));
	  int minY = minimum(list1.get(2), list2.get(2), list3.get(2));
	  int minK = minimum(list1.get(3), list2.get(3), list3.get(3));
	  
	  if(minC+minM+minY+minK < s) {
		  System.out.println(""Case #""+test+"": IMPOSSIBLE"");
		  return;
	  }
	  
	  
	  if(minC==s) {
		  System.out.println(""Case #""+test+"": ""+minC+""0 0 0"");
		  return;
	  }
	  
	  result.add(minC);
	  
	  if(minC+minM>s) {
		  System.out.println(""Case #""+test+"": ""+minC+"" ""+(s-minM)+"" 0 0"");
		  return;
	  }else {
		  result.add(minM);
	  }
	  
	  if (minC+minM+minY>s) {
		  System.out.println(""Case #""+test+"": ""+minC+"" ""+minM+"" ""+(s-(minC+minM))+"" 0"");
		  return;
	  } else {
		  result.add(minY);
	  }
	  
	  if (s-(minC+minM+minY) <= minK){
		  System.out.println(""Case #""+test+"": ""+minC+"" ""+minM+"" ""+minY+"" ""+
		                                        (s-(minC+minM+minY)));
	  }else {
		  System.out.println(""Case #""+test+"": IMPOSSIBLE"");
	  }


  }
  

  public static int  minimum (int a, int b, int c) {	 
		return Math.min(Math.min(a, b), c);
	}
  public static int somme(List<Integer> list) {
	  int res = 0;
	  for (int i = ",Bil1983
590,"public class Solution {
    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        int T = s.nextInt();
        for (int ii = 1; ii <= T; ii++) {
            int N = s.nextInt();

            int[] f = new int[N];

            int[] p = new int[N];

            HashMap<Integer, ArrayList<Integer>> adjM = new
                    HashMap<>();


            for (int i = 0; i < N; i++) {
                f[i] = s.nextInt();
            }

            for (int i = 0; i < N; i++) {
                p[i] = s.nextInt();
            }

            HashSet<Integer> intermediate = new HashSet<>();
            for (int i = 0; i < N; i++) {
                intermediate.add(p[i]);
                if (p[i] != 0) {
                    if (adjM.get(i + 1) != null) {
                        ArrayList<Integer> ar = adjM.get(i + 1);
                        ar.add(p[i]);
                        adjM.put(i + 1, ar);
                    } else {
                        ArrayList<Integer> ar = new ArrayList<>();
                        ar.add(p[i]);
                        adjM.put(i + 1, ar);
                    }


                }
            }
            Integer[] leaf = new Integer[N - intermediate.size() + 1];
            int j = 0;
            for (int i = 0; i < N; i++) {
                if (!intermediate.contains(i + 1)) {
                    leaf[j] = i + 1;
                    j++;
                }
            }
            boolean[] visited = new boolean[N + 1];
            long ans = 0;
            int n = 0;
            long max = -1;
            List<Integer> permute = Arrays.asList(leaf);

            for(int i=0; i < leaf.length * (leaf.length); i++){
                visited = new boolean[N + 1];
                ans = 0;

                for(Integer i1 : permute){
                    if (!visited[i1]) {
                        // System.out.println(""v="" + leaf[i]);
                        ans = ans + dfs(i1, adjM, visited, f);

                    }
                }
                max = Math.max(max, ans);
                Collections.shuffle(permute);
            }


            System.out.println(""Case #"" + ii + "": "" + max);


        }
    }

    static long dfs(int src,
                    HashMap<Integer, ArrayList<Integer>> adjM,
                    boolean[] visited, int[] f) {
        visited[src] = true;
        long funValue = f[src - 1];

        Stack<Integer> stk = new Stack<Integer>();
        stk.push(src);

        while (!stk.isEmpty()) {
            int u = stk.pop();
            if (adjM.get(u) != null) {
                for (Integer v : adjM.get(u)) {
                    if (!visited[v]) {
                        stk.push(v);
                        funValue = Math.max(funValue, f[v - 1]);
                        visited[v] = true;
                    }
                }
            }
        }

        return funValue;

    }

    public static List<List<Integer>> permute(int[] arr) {
        List<List<Integer>> list = new ArrayList<>();
        permuteHelper(list, new ArrayList<>(), arr);
        return list;
    }

    private static void permuteHelper(List<List<Integer>> list, List<Integer> resultList, int[] arr) {

        // Base case
        if (resultList.size() == arr.length) {
            list.add(new ArrayList<>(resultList));
        } else {
            for (int i = 0; i < arr.length; i++) {

                if (resultList.contains(arr[i])) {
                    // If element already exists in the list then skip
                    continue;
                }
                // Choose element
                resultList.add(arr[i]);
                // Explore
                permuteHelper(list, resultList, arr);
                // Unchoose element
                resultList.",dattap
721,"public class Solution {

    public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        PrintWriter writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));

        int T = in.nextInt();
        for (int casNumero = 1; casNumero <= T; casNumero++) {
            StringBuilder resultat = new StringBuilder();
            resultat.append(""Case #"");
            resultat.append(casNumero);
            resultat.append("": "");

            int n = in.nextInt();
            long[] f = new long[n];
            for (int i = 0; i < n; i++) {
                f[i] = in.nextLong();
            }
            int[] p = new int[n];
            for (int i = 0; i < n; i++) {
                p[i] = in.nextInt();
            }
            long sumFun = 0;
            List<Integer> used = new ArrayList<>();
            Map<Integer, Long> triggers = new HashMap();
            for (int i = 1; i < n+1; i++) {
                int finalI = i;
                if (Arrays.stream(p).parallel().noneMatch(a -> a == finalI)) {
                    if (p[finalI - 1] == 0) {
                        sumFun += f[finalI - 1];
                    }
                    else {
                        triggers.put(finalI, getFun(finalI, f, p, used));
                    }
                }
            }

            while (!triggers.keySet().isEmpty()) {
                long minFun = Collections.min(triggers.values());
                int baseModule = 0;
                for (int i = 1; i < n+1; i++) {
                    if (!used.contains(Integer.valueOf(i)) && f[i - 1] == minFun) {
                        for (Integer trigger : triggers.keySet()) {
                            if (isCommonModule(i, trigger, p)) {
                                baseModule = i;
                                break;
                            }
                        }
                        if (baseModule != 0) {
                            break;
                        }
                    }
                }

                int bestTrigger = 0;
                used.add(baseModule);
                for (Integer trigger : triggers.keySet()) {
                    if (minFun == triggers.get(trigger) && isCommonModule(baseModule, trigger, p)) {
                        triggers.put(trigger, getFun(trigger, f, p, used));
                        if (bestTrigger == 0) {
                            bestTrigger = trigger;
                        }
                        else {
                            if (triggers.get(trigger) < triggers.get(bestTrigger)) {
                                bestTrigger = trigger;
                            }
                        }
                    }
                }
                used.remove(Integer.valueOf(baseModule));
                sumFun += minFun;
                used.addAll(getRelations(bestTrigger, p, used));
                triggers.remove(bestTrigger);

                for (Integer trigger : triggers.keySet()) {
                    if (isCommonModule(baseModule, trigger, p)) {
                        int commonModule = getCommonModule(trigger, bestTrigger, p);
                        if (commonModule != 0 && commonModule != baseModule) {
                            triggers.put(trigger, getFun(trigger, f, p, used));
                        }
                    }
                }
            }
            resultat.append(sumFun);
            writer.print(resultat.toString());
            writer.println();
        }
        in.close();
        writer.close();
    }

    private static int getCommonModule(int index1, int index2, int[] p) {
        int currentIndex1 = p[index1 - 1];
        int currentIndex2 = p[index2 - 1];
        int commonModule = 0;
        while (commonModule == 0 && currentIndex1 != 0 && currentIndex2 != 0) {
            if (currentIndex1 == currentIndex2) {
                commonModule = currentIndex1;
            }
            else if (currentIndex1 > currentIndex2) {
                currentIndex1 = p[currentIndex1 - 1];
            }
            else {
                currentIndex2 = p[currentIndex2 - 1];
            }
        }
        return commonModule;
    }

    private static boolean isCommonModule(int commonModule, int index, int[] p) {
        int relation = index;
        boolean isCommon = relation == commonModule;
        while (!isCommon && relation != 0) {
            relation = p[relation - 1];
            isCommon = relation == commonModule;
        }
        return isCommon;
    }

    private static List<Integer> getRelations(int index, int[] p, List<Integer> used) {
        List<Integer> relations = new ArrayList<>();
        relations.add(index);
        int currentIndex = index;
        while (!used.contains(currentIndex) && p[currentIndex - 1] != 0) {
            currentIndex = p[currentIndex - 1];
            relations.add(currentIndex);
        }
        return relations;
    }

    private static long getFun(int index, long[] f, int[] p, List<Integer> used) {
        long fun = f[index - 1];
        int relation = p[index - 1];
        if (relation != 0 && !used.contains(relation)) {
            long relationFun = getFun(relation, f, p, used);
            if (relationFun > fun) {
                fun = ",gerardmr
660,"public class Solution {
    public static int[] F;
    public static int[][] graph;
    public static void main(String[] args) throws IOException {
        FastScanner input = new FastScanner(false);
        int T = input.nextInt();
        for (int iter = 1; iter<=T; iter++) {
            int N = input.nextInt();
            F = new int[N+1];
            for (int i = 1; i<=N; i++) {
                F[i]=input.nextInt();
            }
            graph = new int[N+1][];
            int[] sizes = new int[N+1];
            int[][] edges = new int[N][2];
            for (int i = 0; i<N; i++) {
                edges[i]=new int[]{input.nextInt(),i+1};
                sizes[edges[i][0]]++;
            }
            for (int i = 0; i<=N; i++) {
                graph[i]=new int[sizes[i]];
            }
            for (int i = 0; i<N; i++) {
                graph[edges[i][0]][--sizes[edges[i][0]]]=edges[i][1];
            }
            System.out.println(""Case #""+iter+"": ""+dfs(0,0));
        }
    }
    public static int dfs(int node, int maxAncestor) {
        int newMaxAncestor = Math.max(F[node],maxAncestor);
        int[] noCurrent = new int[graph[node].length];
        int totalNoCurrent = 0;
        for (int i = 0; i<graph[node].length; i++) {
            noCurrent[i]=dfs(graph[node][i],0);
            totalNoCurrent+=noCurrent[i];
        }
        int res = newMaxAncestor;
        for (int i = 0; i<graph[node].length; i++) {
            int neighbor = graph[node][i];
            res = Math.max(res,totalNoCurrent-noCurrent[i]+dfs(neighbor,newMaxAncestor));
        }
        return res;
    }
    private static class FastScanner {
        final private int BUFFER_SIZE = 1 << 16;
        private DataInputStream din;
        private byte[] buffer;
        private int bufferPointer, bytesRead;
        private FastScanner(boolean usingFile) throws IOException {
            if (usingFile) din=new DataInputStream(new FileInputStream(""C:\\\Users\\\skwek\\\IdeaProjects\\\HelloWorld\\\src\\	esting.in""));
            else din = new DataInputStream(System.in);
            buffer = new byte[BUFFER_SIZE];
            bufferPointer = bytesRead = 0;
        }
        private short nextShort() throws IOException {
            short ret = 0;
            byte c = read();
            while (c <= ' ') c = read();
            boolean neg = (c == '-');
            if (neg) c = read();
            do ret = (short)(ret * 10 + c - '0');
            while ((c = read()) >= '0' && c <= '9');
            if (neg) return (short)-ret;
            return ret;
        }
        private int nextInt() throws IOException {
            int ret = 0;
            byte c = read();
            while (c <= ' ') c = read();
            boolean neg = (c == '-');
            if (neg) c = read();
            do ret = ret * 10 + c - '0';
            while ((c = read()) >= '0' && c <= '9');
            if (neg) return -ret;
            return ret;
        }
        public long nextLong() throws IOException {
            long ret = 0;
            byte c = read();
            while (c <= ' ') c = read();
            boolean neg = (c == '-');
            if (neg) c = read();
            do ret = ret * 10 + c - '0';
            while ((c = read()) >= '0' && c <= '9');
            if (neg) return -ret;
            return ret;
        }
        private char nextChar() throws IOException {
            byte c = read();
            while (c <= ' ') c = read();
            return (char)c;
        }
        private String nextString() throws IOException {
            StringBuilder ret = new StringBuilder();
            byte c = read();
            while (c <=' ') c = read();
            do {
                ret.append((char)c);
            } while ((c = read())>' ');
            return ret.toString();
        }
        private void fillBuffer() throws IOException {
            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);
            if (bytesRead == -1)  buffer[0] = -1;
        }
        private byte read() throws IOException ",ekwek
1280,"public class Solution {

	static boolean verb=true;
	static void log(Object X){if (verb) System.err.println(X);}
	static void log(Object[] X){if (verb) {for (Object U:X) System.err.print(U+"" "");System.err.println("""");}}
	static void log(int[] X){if (verb) {for (int U:X) System.err.print(U+"" "");System.err.println("""");}}
	static void logWln(Object X){if (verb) System.err.print(X);}
	static void info(Object o){	System.out.println(o);}
	static void output(Object o){outputWln(""""+o+""
"");	}
	static void outputWln(Object o){try {out.write(""""+ o);} catch (Exception e) {}}



	static class Composite implements Comparable<Composite>{
		int val;
		int u;
		int v;

		public int compareTo(Composite X) {
			return val-X.val;
		}

		public Composite(int val, int u, int v) {
			this.val = val;
			this.u = u;
			this.v = v;
		}



	}

	// Global vars


	static BufferedWriter out;
	static InputReader reader;


	static int[][] dm= {{0,1},{1,0},{0,-1},{-1,0}};

	static void process() throws Exception {

		out = new BufferedWriter(new OutputStreamWriter(System.out));
		reader=new InputReader(System.in);
		Locale.setDefault(Locale.US);	


		log(""hello"") ;
		
		int n=9999;
		int[] mat=new int[n*n];
		
		int u=0;
		int v=0;
		int e=0;

		int[] x=new int[n*n];
		int[] y=new int[n*n];

		for (int i=0;i<n*n;i++) {
			mat[u*n+v]=i+1;
			x[i]=u;
			y[i]=v;
			
			u+=dm[e][0];
			v+=dm[e][1];
			if (u>=n || u<0 ||v>=n||v<0 || (u>=0 && u<n && v>=0 && v<n && mat[u*n+v]!=0)) {
				u-=dm[e][0];
				v-=dm[e][1];
				e++;
				e%=4;
				u+=dm[e][0];
				v+=dm[e][1];

			}

		}
		log(""generated"");
		
		int[] dst=new int[n*n];
		int[] nxt=new int[n*n];
		log(""testing"");
		for (int val=n*n-1;val>=1;val--) {
			
			u=x[val-1];
			v=y[val-1];
			//log(""processing u:""+u+"" v:""+v+"" ""+X.val);
			boolean found=false;
			dst[u*n+v]=n*n;
			
			
			
			for (int[] tm:dm) {
				int uu=u+tm[0];
				int vv=v+tm[1];
				if (uu>=0 && uu<n && vv>=0 && vv<n) {
					if (mat[uu*n+vv]>mat[u*n+v]) {
						if (dst[uu*n+vv]+1<dst[u*n+v]) {
							dst[u*n+v]=dst[uu*n+vv]+1;
							nxt[u*n+v]=mat[uu*n+vv];
						}
						found=true;
					}
				}
			}
			if (!found) {
				dst[u*n+v]=n*n*2;

			}
		}
		log(""dst created"");
		

		int T=reader.readInt();


		for (int t=1;t<=T;t++) {


			int nn=reader.readInt();
			int k=reader.readInt();

		
			/*
			log(""============"");

			for (int i=0;i<n;i++) {
				log(mat[i]);
			}
			 */
			log(""creating ref"");


			log(""ref created"");
			//Arrays.sort(ref);;
			String ans="""";
			if (k%2==1   ||k<nn-1)
				ans=""IMPOSSIBLE"";
			else {
				log(""n:""+n);
				
				log(""testing done"");
				
				int delta=(n-nn)/2;
				int x0=delta;
				int y0=delta;
				int base=mat[delta*n+delta];
				log(""base:""+base+"" delta:""+delta);
				int val=base;
				int cur=0;
				ans="""";
				//log(""k:""+k);
				int cut=0;
				while (true) {


					u=x[val-1];
					v=y[val-1];
					//log(X.val+"" cur:""+cur+"" dst:""+dst[u*n+v]);
					if (cur+dst[u*n+v]==k) {
						if (nxt[u*n+v]>val+1) {
						cut++;
						ans+=(val-base+1)+"" ""+(nxt[u*n+v]-base+1)+""
"";
						}
						val=nxt[u*n+v];
						

					} else {
						val++;
					}
					cur++;

					if (val==n*n)
						break;
				}
				ans=cut+""
""+ans;



			}



			String ss="""";
			ss+=ans;

			output(""Case #""+t+"": ""+ss);

		}
		//log(""ok"");
		try {
			out.close();
		}
		catch (Exception EX){}

	}








	public static void main(String[] args) throws Exception {
		process();

	}

	static final class InputReader {
		private final InputStream stream;
		private final byte[] buf = new byte[1024];
		private int curChar;
		private int numChars;

		public InputReader(InputStream stream) {
			this.stream = stream;
		}

		private int read() throws IOException {
			if (curChar >= numChars) {
				curChar = 0;
				numChars = stream.read(buf);
				if (numChars <= 0) {
					return -1;
				}
			}
			return buf[curChar++];
		}


		public final String readString() throws IOException {
			int c = read();
			while (isSpaceChar(c)) {
				c = read();
			}
			StringBuilder res=new StringBuilder();
			do {
				res.append((char)c);
				c = read();
			} while (!isSpaceChar(c));
			return res.toString();
		}

		public final int readInt() throws IOException {
			int c = read();
			boolean neg=false;
			while (isSpaceChar(c)) {
				c = read();
			}
			char d=(char)c;
			//log(""d:""+d);
			if (d=='-') {
				neg=true;
				c = read();
			}
			int res = 0;
			do {
				res *= 10;
				res += c - '0';
				c = read();
			} while (!isSpaceChar(c));
			//log(""res:""+res);
			if (neg)
				return -res;
			return res;

		}

		public final long readLong() throws IOException {
			int c = read();
			boolean neg=false;
			while (isSpaceChar(c)) {
				c = read();
			}
			char d=(char)c;
			//lo)g(""d:""+d);
			if (d=='-') {
				neg=true;
				c = read();
			}
			long res = 0;
			do {",vincent
746,"public class Solution {
  static int[] R_OFFSETS = {0, 1, 0, -1};
  static int[] C_OFFSETS = {1, 0, -1, 0};

  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);

    int T = sc.nextInt();
    for (int tc = 1; tc <= T; ++tc) {
      int N = sc.nextInt();
      int K = sc.nextInt();

      System.out.println(String.format(""Case #%d: %s"", tc, solve(N, K)));
    }

    sc.close();
  }

  static String solve(int N, int K) {
    int diff = N * N - 1 - K;

    int[][] grid = new int[N][N];
    int r = 0;
    int c = -1;
    int direction = 0;
    for (int i = 1; i <= N * N; ++i) {
      r += R_OFFSETS[direction];
      c += C_OFFSETS[direction];
      if (!(r >= 0 && r < N && c >= 0 && c < N && grid[r][c] == 0)) {
        r -= R_OFFSETS[direction];
        c -= C_OFFSETS[direction];
        direction = (direction + 1) % R_OFFSETS.length;
        r += R_OFFSETS[direction];
        c += C_OFFSETS[direction];
      }

      grid[r][c] = i;
    }

    // System.err.printf(""%2$s: %1$s
"", diff, ""diff"");

    List<String> result = new ArrayList<>();
    r = 0;
    c = 0;
    while (r != N / 2 || c != N / 2) {
      direction = 0;
      int nextR = r + R_OFFSETS[direction];
      int nextC = c + C_OFFSETS[direction];
      while (!(nextR >= 0
          && nextR < N
          && nextC >= 0
          && nextC < N
          && grid[nextR][nextC] == grid[r][c] + 1)) {
        direction = (direction + 1) % R_OFFSETS.length;
        nextR = r + R_OFFSETS[direction];
        nextC = c + C_OFFSETS[direction];
      }

      // System.err.printf(""%2$s: %1$s
"", r, ""r"");
      // System.err.printf(""%2$s: %1$s
"", c, ""c"");
      // System.err.printf(""%2$s: %1$s
"", nextR, ""nextR"");
      // System.err.printf(""%2$s: %1$s
"", nextC, ""nextC"");

      int shortcutR = r + R_OFFSETS[(direction + 1) % R_OFFSETS.length];
      int shortcutC = c + C_OFFSETS[(direction + 1) % R_OFFSETS.length];

      // System.err.printf(""%2$s: %1$s
"", shortcutR, ""shortcutR"");
      // System.err.printf(""%2$s: %1$s
"", shortcutC, ""shortcutC"");
      if (grid[shortcutR][shortcutC] > grid[nextR][nextC] + 1
          && grid[shortcutR][shortcutC] - grid[nextR][nextC] <= diff) {
        result.add(String.format(""%d %d"", grid[r][c], grid[shortcutR][shortcutC]));
        diff -= grid[shortcutR][shortcutC] - grid[nextR][nextC];
        r = shortcutR;
        c = shortcutC;
        // System.err.printf(""%2$s: %1$s
"", diff, ""diff"");
      } else {
        r += R_OFFSETS[direction];
        c += C_OFFSETS[direction];
      }
    }

    return (diff == 0)
        ? String.format(""%d
%s"", result.size(), String.join(""
"", result))
        : ""IMPOSSIBLE"";
  }
}",goalboy1015
1342,"public class Solution {
    public static void main(String[] args) throws Exception {
        Scanner sc = new Scanner(System.in);
        int tt = sc.nextInt();
        for (int zz = 1; zz <= tt; zz++) {
            runTest(zz, sc);
        }
    }

    public static void runTest(int testCase, Scanner sc) {
        StringBuilder output = new StringBuilder();

        output.append(""Case #"").append(testCase).append("": "");
        //impl here
        String next = sc.next();
        int l = next.length();
        StringBuilder res = new StringBuilder();
        boolean eq = false;
        for(int i=0; i<l-1; i++) {
            res.append(next.charAt(i));
            if ( next.charAt(i)<next.charAt(i+1)) {
                res.append(next.charAt(i));
                if ( eq ) {
                    res.append(next.charAt(i));
                }
            } else if ( next.charAt(i)==next.charAt(i+1)) {
                eq = true;
            } else eq=false;
        }
        res.append(next.charAt(l-1));
        //output here
        output.append(res).append(""
"");",zubaidullo
658,"public class Solution {

    public static void main(String[] args) {
        int x = 1; // Test Case Number (starting from 1)
        int y = ",dtarde
551,"public class Solution {
//public class B2 {
    public static void main(String[] args) throws IOException {
        //BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(""in.txt"")));
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int ttt = Integer.parseInt(br.readLine());
        for (int tt = 1; tt <= ttt; ++tt) {
            String[] cc = br.readLine().split("" "");
            final int n = Integer.parseInt(cc[0]);
            final int p = Integer.parseInt(cc[1]);

            final int[][] all = new int[n][p];
            for (int nn = 0; nn < n; nn++) {
                cc = br.readLine().split("" "");
                for (int pp = 0; pp < p; pp++) {
                    all[nn][pp] = Integer.parseInt(cc[pp]);
                }
            }

            final int[][] q = new int[n][2];
            for (int i = 0; i < n; i++) {
                int min = Integer.MAX_VALUE;
                int max = Integer.MIN_VALUE;
                for (int x : all[i]) {
                    min = Math.min(min, x);
                    max = Math.max(max, x);
                }
                q[i][0] = min;
                q[i][1] = max;
            }

            long answ = 0;
            for (int[] x : q) {
                answ += (long) (x[1] - x[0]);
            }

            //System.out.println(answ);

            int[] elements = new int[n];
            for (int i = 0; i < n; i++) {
                elements[i] = i;
            }

            

            long best = calc(elements, q);

            System.out.println(""Case #"" + tt + "": "" + (answ + best));

        }
    }

    private static long calc(int[] elements, int[][] q) {
        long[][] res = new long[elements.length][2];
        res[0][0] = (long)q[elements[0]][1] * 2L - q[elements[0]][0];
        res[0][1] = q[elements[0]][0];
        for (int i = 1; i < elements.length; i++) {
            final long prevTop = q[elements[i - 1]][1];
            final long prevBottom = q[elements[i - 1]][0];

            final long currTop = q[elements[i]][1];
            final long currBottom = q[elements[i]][0];

            res[i][0] = Math.min(abs(currTop, prevTop) + res[i - 1][1], abs(currTop, prevBottom) + res[i - 1][0]);
            res[i][1] = Math.min(abs(currBottom, prevTop) + res[i - 1][1], abs(currBottom, prevBottom) + res[i - 1][0]);
        }


        return Math.min(res[elements.length - 1][0], res[elements.length - 1][1]);
    }

    private static long abs(long a, long b) ",attila
153,"public class Solution {
  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int T = sc.nextInt();
    for (int i = 0; i < T; i++) {
      int N = sc.nextInt();
      int[] D = new int[N];
      for (int j = 0; j < N; j++) {
        D[j] = sc.nextInt();
      }
      int l = 0;
      int maxDl = D[0];
      for (int j = 0; j < N; j++) {
        int currDl = D[j];
        if(currDl > D[N-1]) {
          currDl = D[N-1];
          N--;
          j--;
        }
        if(currDl >= maxDl) {
          l++;
          maxDl = ",Jai03kh
235,"class Solution {
    public static void main(String[] args)
    {
        Scanner s = new Scanner(System.in);
        int t = s.nextInt();
        for(int i = 1; i <= t; i++)
        {
            System.out.println(11111111);
            System.out.flush();
            int comp = s.nextInt();
            while(comp > 0)
            {
                if(comp == 8)
                {
                    System.out.println(11111111);
                    System.out.flush();
                } else if(comp == 7)
                {
                    System.out.println(11111110);
                    System.out.flush();
                } else if(comp == 6)
                {
                    System.out.println(11100000);
                    System.out.flush();
                } else if(comp == 5)
                {
                    System.out.println(11111000);
                    System.out.flush();
                } else if(comp == 4)
                {
                    System.out.println(10000000);
                    System.out.flush();
                } else if(comp == 3)
                {
                    System.out.println(11111000);
                    System.out.flush();
                } else if(comp == 2)
                {
                    System.out.println(11100000);
                    System.out.flush();
                } else if(comp == 1)
                {
                    System.out.println(11111110);
                    System.out.flush();
                }
                comp = s.nextInt();
            }
            if(comp == -1)
            ",Maarten17581
199,"public class Solution {
    static Integer[] fun;
    static Integer[] attachments;

    public static void main(String[] args) throws FileNotFoundException {
        try (Scanner reader = new Scanner(System.in)){
            if (reader.hasNextLine() && reader.hasNextInt()) {
                // Read the number of test cases
                int T = Integer.parseInt(reader.nextLine()); // testcases
                for (int t = 0; t < T; t++) {
                    int N = Integer.parseInt(reader.nextLine()); // modules
                    fun = new Integer[N];
                    attachments = new Integer[N];
                    for (int n = 0; n < N; n++) {
                        fun[n] = reader.nextInt();
                    }
                    reader.nextLine();
                    for (int n = 0; n < N; n++) {
                        attachments[n] = reader.nextInt();
                    }
                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }
                    List<Integer> initiators = new ArrayList<>();
                    for (int n = 1; n < N + 1; n++) {
                        if (!Arrays.asList(attachments).contains(n)) {
                            initiators.add(n);
                        }
                    }
                    System.out.println(""Case #"" + (t + 1) + "": "" + getMaxFun(initiators, new ArrayList<>(), 0L));
                }
            }
        }
    }

    private static Long getMaxFun(List<Integer> initiators, List<Integer> triggered, Long currentFun) {
        List<Long> possibleFun = new ArrayList<>();
        for (int i = 0; i < initiators.size(); i ++) {
            Long maxFun = 0L;
            int currentModule = initiators.get(i) - 1;
            List<Integer> newTriggered = new ArrayList<>(triggered);
            newTriggered.add(currentModule);
            while (true) {
                if (fun[currentModule] > maxFun) {
                    maxFun = Long.valueOf(fun[currentModule]);
                }
                currentModule = attachments[currentModule] - 1;
                if (newTriggered.contains(currentModule) || currentModule == -1) {
                    break;
                }
                newTriggered.add(currentModule);
            }
            final int initial = initiators.get(i);
            List<Integer> remainingInitiators = initiators.stream().filter(entry -> !Objects.equals(entry, initial)).collect(Collectors.toList());
            if (remainingInitiators.size() > 0) {
                possibleFun.add(getMaxFun(remainingInitiators, newTriggered, currentFun + maxFun));
            }
            else {
                possibleFun.add(currentFun+maxFun);
            }
        }
        return possibleFun.",Larsvr
192,"public class Solution {

	
	public static void main(String[] args) {
		Scanner s = new Scanner(System.in);
		int cases = s.nextInt();
		
		for(int caseIndex=0;caseIndex<cases;caseIndex++) {
			Node.ABYSS=new Node(0,0);
			int nodeCount = s.nextInt();
			Node[] nodes = new Node[nodeCount];
			for(int i=0;i<nodeCount;i++) {
				nodes[i]=new Node(i+1,s.nextInt());
			}
			
			ArrayList<Node> initiators = new ArrayList<>(Arrays.asList(nodes));
			
			for(int i=0;i<nodeCount;i++) {
				int parent = s.nextInt();

				if(parent>0) {
					initiators.remove(nodes[parent-1]);
					nodes[i].parent=nodes[parent-1];
					nodes[parent-1].children.add(nodes[i]);
				}else {
					nodes[i].parent=Node.ABYSS;
					Node.ABYSS.children.add(nodes[i]);
				}
			}
			
			/*ArrayList<Node> results = new ArrayList<>();
			Node.ABYSS.traverse(results);
			int maxValue = 0;
			for(Node initiator : results) {
				maxValue += initiator.validate(0);
				
			}
			System.out.println(results+"":""+maxValue);*/

			
			
			int maxValue = 0;
			List<List<Node>> permutations = permute(initiators.toArray(new Node[] {}));

			for(List<Node> permutation : permutations) {
				for(Node n : nodes) {
					n.parentTaken=false;
				}
				int result = 0;
				for(Node n : permutation) {
					result += n.validate(n.fun);
					//System.out.println(""Validating""+n);
				}
				System.out.println(permutation+"":""+result);
				if(result>maxValue) {
					maxValue=result;
				}
			}
			
			System.out.println(""Case #""+(caseIndex+1)+"": ""+maxValue);
			
			
			
			
		}
		
		s.close();

	}
	
	public static List<List<Node>> permute(Node[] arr) {
        List<List<Node>> list = new ArrayList<>();
        permuteHelper(list, new ArrayList<>(), arr);
        return list;
    }
 
    private static void permuteHelper(List<List<Node>> list, List<Node> resultList, Node[] arr){
 
        // Base case
        if(resultList.size() == arr.length){
            list.add(new ArrayList<>(resultList));
        } 
        else{
            for(int i = 0; i < arr.length; i++){ 
 
                if(resultList.contains(arr[i])) 
                {
                    // If element already exists in the list then skip
                    continue; 
                }
                // Choose element
                resultList.add(arr[i]);
                // Explore
                permuteHelper(list, resultList, arr);
                // Unchoose element
                resultList.remove(resultList.size() - 1);
            }
        }
    } 
	
	public static class Node{
		int fun,id;
		Node parent;
		ArrayList<Node> children = new ArrayList<>();
		public static Node ABYSS = new Node(0,0);
		boolean parentTaken = false;
		
		public Node(int id, int fun) {
			this.id=id;
			this.fun=fun;
		}
		
		
		public void traverse(ArrayList<Node> initiators) {
			
			
			if(children.isEmpty()) {
				initiators.add(this);
				return;
			}
			
			
			HashMap<Node, Integer> order = new HashMap<>();
			for(Node n : children) {
				order.put(n,n.testTraverse());
			}
			
			/*List<Node> sortedNodes = 
				     order.entrySet().stream()
				    .sorted(Entry.<Node,Integer>comparingByValue().reversed())
				    .map(e->e.getKey())
				    .collect(Collectors.toList());
			
			
			for(Object n : sortedNodes) {
				((Node)n).traverse(initiators);
			}*/
			
			Map<Object, Object> sortedMap = 
				     order.entrySet().stream()
				    .sorted(Entry.comparingByValue())
				    .collect(Collectors.toMap(Entry::getKey, Entry::getValue,
				                              (e1, e2) -> e1, LinkedHashMap::new));
			
			
			for(Object n : sortedMap.keySet()) {
				((Node)n).traverse(initiators);
			}
			
			
			
		}
		
		public int testTraverse() {
			if(children.isEmpty()) {
				return fun;
			}
			
			int max=0;
			for(Node n : children) {
				int result = n.testTraverse();
				if(result>max) {
					max=result;
				}
			}
			return max;
		}
		
		public int validate(int maxBefore) {
			if(!parentTaken && this != ABYSS) {
				maxBefore = Math.max(fun, maxBefore);
				int newMax = parent.validate(maxBefore);
				for(Node child: children) {
					child.parentTaken=true;
				}
				return newMax;
			}else {
				return Math.max(fun, maxBefore);
			}
			
		}
		
		@Override
		public String toString() ",KovacsA22
1274,"public class Solution {
    {
        MULTI_TEST = false;
        FILE_NAME = """";
        NEED_FILE_IO = false;
        INF = (long) 1e18;
    } // fields

    int ask(String s) {
        out.println(s);
        out.flush();
        return ri();
    }

    String solve_test() {
        for(int i = 1; i <= 300; i++) {
            int x = ask(Integer.toBinaryString(i));
            if(x == 0) return """";
        }
        return """";
    }


    void solve() {
        int t = ri();
        for(int it = 0; it < t; it++) {
            solve_test();
        }
    }

    public static void main(String[] args) {
        new Solution().run();
    } //main

    @SuppressWarnings(""unused"")
    long gcd(long a, long b) {
        return b == 0 ? a : gcd(b, a % b);
    }

    @SuppressWarnings(""unused"")
    long lcm(long a, long b) {
        return a / gcd(a, b) * b;
    }

    @SuppressWarnings(""unused"")
    int gcd(int a, int b) {
        return (int) gcd((long) a, b);
    }

    @SuppressWarnings(""unused"")
    int lcm(int a, int b) {
        return (int) lcm(a, (long) b);
    }

    @SuppressWarnings(""unused"")
    int sqrtInt(int x) {
        return (int) sqrtLong(x);
    }

    @SuppressWarnings(""unused"")
    long sqrtLong(long x) {
        long root = (long) Math.sqrt(x);
        while (root * root > x) --root;
        while ((root + 1) * (root + 1) <= x) ++root;
        return root;
    }

    @SuppressWarnings(""unused"")
    int cbrtLong(long x) {
        int cbrt = (int) Math.cbrt(x);
        while ((long) cbrt * cbrt >= x) {
            cbrt--;
        }
        while ((long) (cbrt + 1) * (cbrt + 1) <= x) cbrt++;
        return cbrt;
    }

    @SuppressWarnings(""unused"")
    long binpow(long a, long power) {
        return binpow(a, power, Long.MAX_VALUE);
    }

    @SuppressWarnings(""unused"")
    long binpow(long a, long power, long modulo) {
        if (power == 0) return 1 % modulo;
        if (power % 2 == 1) {
            long b = binpow(a, power - 1, modulo) % modulo;
            return ((a % modulo) * b) % modulo;
        } else {
            long b = binpow(a, power / 2, modulo) % modulo;
            return (b * b) % modulo;
        }
    }

    @SuppressWarnings(""unused"")
    long fastMod(String s1, long n2) {
        long num = 0;
        for (int i = 0; i < s1.length() - 1; i++) {
            num += Integer.parseInt(String.valueOf(s1.charAt(i)));
            num *= 10;
            if (num >= n2) {
                num = num % n2;
            }
        }
        return (num + Integer.parseInt(String.valueOf(s1.charAt(s1.length() - 1)))) % n2;
    }

    @SuppressWarnings(""unused"")
    long factorialMod(long n, long p) {
        long res = 1;
        while (n > 1) {
            res = (res * ((n / p) % 2 == 1 ? p - 1 : 1)) % p;
            for (int i = 2; i <= n % p; ++i)
                res = (res * i) % p;
            n /= p;
        }
        return res % p;
    }

    @SuppressWarnings(""unused"")
    boolean isPrime(int number) {
        for (int i = 2; i * i <= number; i++) {
            if (number % i == 0) {
                return false;
            }
        }
        return number > 1;
    }

    @SuppressWarnings(""unused"")
    boolean[] primes(int border) {
        boolean[] isPrimes = new boolean[border + 1];
        Arrays.fill(isPrimes, true);
        isPrimes[0] = false;
        isPrimes[1] = false;
        for (int i = 2; i < border + 1; i++) {
            if (!isPrimes[i]) continue;
            for (int k = i * 2; k < border; k += i) {
                isPrimes[k] = false;
            }
        }
        return isPrimes;
    } //Number theory

    @SuppressWarnings(""unused"")
    void sort(int[] a) {
        int n = a.length;
        Integer[] arr = new Integer[n];
        for (int i = 0; i < n; i++) {
            arr[i] = a[i];
        }
        Arrays.sort(arr);
        for (int i = 0; i < n; i++) {
            a[i] = arr[i];
        }
    }

    @SuppressWarnings(""unused"")
    void sort(long[] a) {
        int n = a.length;
        Long[] arr = new Long[n];
        for (int i = 0; i < n; i++) {
            arr[i] = a[i];
        }
        Arrays.sort(arr);
        for (int i = 0; i < n; i++) {
            a[i] = arr[i];
        }
    }

    @SuppressWarnings(""unused"")
    int max(int[] a) {
        int n = a.length;
        int max = Integer.MIN_VALUE;
        for (int j : a) {
            if (j > max) max = j;
        }
        return max;
    }

    @SuppressWarnings(""unused"")
    long max(long[] a) {
        int n = a.length;
        long max = Long.MIN_VALUE;
        for (long l : a) {
            if (l > max) max = l;
        }
        return max;
    }

    @SuppressWarnings(""unused"")
    int maxIndex(int[] a) {
        int n = a.length;
        int max = Integer.MIN_VALUE;
        int index = 0;
        for (int i = 0; i < n; i++) {
            if (a[i] > max) {
                max = a[i];
                index = i;
            }
        }
        return index;
    }

    @SuppressWarnings(""unused"")
    int maxIndex(long[] a) {
        int n = a.length;
        long max = Long.MIN_VALUE;
        int index = 0;
        for (int i = 0; i < n; i++) {
            if (a[i] > max) {
                max = a[i];
                index = i;
            }
        }
        return index;
    }

    @SuppressWarnings(""unused"")
    int min(int[] a) {
        int n = a.length;
        int min = Integer.MAX_VALUE;
        for (int j : a) {
            if (j < min) min = ",v0s7er
942,"public class Solution {
    ///////////////////////////////////////////
    static boolean[] visited = null;
    static int N = 0;
    static Random random = new Random();
    
    private static void solve() {
        N = in.nextInt();
        int K = in.nextInt();
        visited = new boolean[N];
        Map<Integer, Integer> numEdges = new HashMap<>();

        T2 R_P = request();
        Integer r = (Integer) R_P._1;
        Integer p = (Integer) R_P._2;
        numEdges.put(r, p);

        while (K > 0) {
            //int next = nextUnknown();
            int next = randomUnknown();
            if (next != -1) {
                R_P = teleport(next+1);
                int node = (Integer) R_P._1;
                numEdges.put(node, (Integer) R_P._2);
            } else {
                break;
            }
            K--;
        }


        if (numEdges.size() >= N) {
            long sum = 0L;
            for (Map.Entry<Integer, Integer> entry: numEdges.entrySet()) {
                sum += entry.getValue();
            }
            estimate(sum / 2);

        } else {
            // calculate average
            int count = numEdges.size();
            float sum = 0.0f;
            for (Map.Entry<Integer, Integer> entry : numEdges.entrySet()) {
                sum += entry.getValue();
            }

            float avg = sum / count;
            int diff = N - count;

            sum += diff * avg;

            long response = (long) (sum  / 2.0);

            estimate(response);
        }
    }

//    static int pointer = 0;
//    static int nextUnknown() {
//        while (pointer < N) {
//            if (visited[pointer] == false) {
//                return pointer;
//            }
//            pointer++;
//        }
//        return -1;
//    }

    static int randomUnknown() {
        int steps = 0;
        int pointer = random.nextInt(N);
        while (steps < N) {
            if (visited[pointer % N] == false) {
                return pointer;
            }
            pointer++;
            steps++;
        }
        return -1;
    }

    static T2 request() {
        int R = in.nextInt();
        if (R == -1) {
            throw new IllegalStateException(""Received R -1"");
        }
        visited[R-1] = true;
        int P = in.nextInt();
        if (P == -1) {
            throw new IllegalStateException(""Received P -1"");
        }
        return new T2(R, P);
    }
    static T2 walk() {
        out.println(""W"");
        out.flush();
        return request();
    }
    static T2 teleport (int S) {
        out.println(""T "" + S);
        out.flush();
        return request();
    }
    static void estimate(long P) {
        out.println(""E "" + P);
        out.flush();
    }

    private static Scanner in;
    private static PrintStream out;

    private static void run() throws Exception {
        in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        out = System.out;
        int t = in.nextInt();
        for (int i = 1; i <= t; i++) {
            solve();
        }
        in.close();
        out.close();
        System.exit(0);
    }

    public static void main(String[] args) throws Exception {
        run();
//        if (debug)
//            System.in.read();
    }

    static class T2<X, Y> {
        public final X _1;
        public final Y _2;
        T2(X _1, Y _2) {
            this._1 = _1;
            this._2 = _2;
        }
        @Override
        public String toString() ",levios
886,"public final class Solution
{    
	static PrintWriter out = new PrintWriter(System.out); 
	static StringBuilder ans=new StringBuilder();
	static FastReader in=new FastReader();
	static ArrayList<Integer> g[];
	static long mod=(long)998244353,INF=Long.MAX_VALUE;
	static boolean set[],col[]; 
	static int par[],tot[],partial[];
	static int Days[],P[][];
	static int sum=0,size[];
	static int seg[],vis[][];
	static long dp[][];
	public static void main(String args[])throws IOException
	{		
		/*
		 * star,rope,TPST
		 * BS,LST,MS,MQ
		 */
		int T=i();
		outer:for(int tt=1; tt<=T; tt++)
		{
			int N=i(),P=i();
			long A[][]=new long[N+1][P];
			dp=new long[N+5][P+5];
			for(int i=1; i<=N; i++)A[i]=inputLong(P);
			for(long a[]:dp)Arrays.fill(a, -1);
			cost=Long.MAX_VALUE;
			ans.append(""Case #""+tt+"": ""+f(1,0,A,N,0)+""
"");
		}



		out.println(ans);
		out.close();
	}
	static long cost=Long.MAX_VALUE;
	static long f(int i,int j,long A[][],int N,long p)
	{
//		System.out.println(""comming from ""+j+"" to ""+i+"" with cost "");
		if(i==N+1)
		{
			return 0;
		}
		long min=A[i][0],max=A[i][0];
		int minIndex=0,maxIndex=0;
		int it=0;
		for(long a:A[i])
		{
			min=Math.min(min, a);
			max=Math.max(max, a);
			if(min==a)minIndex=it;
			if(max==a)maxIndex=it;
			it++;		
		}
		if(dp[i][j]==-1)
		{
			if(min<=p && max<=p)
			{
//				System.out.println(1);
				long s=p-min;
				dp[i][j]=s+f(i+1,minIndex,A,N,min);
			}
			else if(min>=p && max>=p)
			{
//				System.out.println(2);
				long s=max-p;
				dp[i][j]=s+f(i+1,maxIndex,A,N,max);
			}
			else
			{
//				System.out.println(""3"");
				long a=p-min,b=max-p;
				long s=(a+b);
				long s1=s;
				s+=a;
				dp[i][j]=s+f(i+1,maxIndex,A,N,max);
				s1+=b;
				dp[i][j]=Math.min(dp[i][j], s1+f(i+1,minIndex,A,N,min));
			}
		}
		return dp[i][j];
	}
	static boolean palin(long n)
	{
		long s=0;
		long N=n;
		while(N!=0)
		{
			long r=N%10;
			s*=10L;
			s+=r;
			N/=10;
		}		
		return s==n;
	}
	static String fdp(char X[],int i,int N)
	{
		String Y="""";
		if(i+1==N)return X[N-1]+"""";




		return Y;
	}
	static long s=0;
	static long dfs(int n,int p,long F[])
	{
		long min=0,sum=0;
		for(int c:g[n])
		{
			if(c!=p)
			{
				long a=dfs(c,n,F);
				sum+=a;
				if(min==0)min=a;
				min=Math.min(a, min);
			}
		}
		//		System.out.println(n+"" ""+min+ "" ""+sum);
		s+=(sum-min);
		return Math.max(F[n-1], min);
	}
	static boolean fSmall(char X[],int i,int N)
	{
		if(i==N)
		{
			//if length of maximum palindrome is >=5
			int max=1;
			for(int l=0; l<N; l++)
			{
				for(int r=l+1; r<N; r++)
				{
					if(isPal(X,l,r))max=Math.max(max, r-l+1);
				}
			}
			return max<5;
		}
		if(X[i]=='?')
		{
			char Y[]=Arrays.copyOf(X,N);
			Y[i]='0';
			X[i]='1';
			return fSmall(X,i+1,N)|fSmall(Y,i+1,N);
		}
		return fSmall(X,i+1,N);
	}
	static boolean isPal(char X[],int l, int r)
	{
		while(l<r)
		{
			if(X[l]!=X[r])return false;
			l++;
			r--;
		}
		return true;
	}


	static boolean f(char X[],char Y[],int N,int M)
	{
		int j=0;
		for(char x:Y)
		{
			if(j<N && x==X[j])j++;
		}
		//	  System.out.println(j+"" ""+N);
		return j==N;
	}
	static int index(int a,ArrayList<Integer> A)
	{
		int l=-1,r=A.size();
		while(r-l>1)
		{
			int m=(l+r)/2;
			int x=A.get(m);
			if(x<=a)l=m;
			else r=m;
		}
		return r;
	}
	static long and(int i,int j)
	{
		System.out.println(""and ""+i+"" ""+j);
		return l();
	}
	static long or(int i,int j)
	{
		System.out.println(""or ""+i+"" ""+j);
		return l();
	}
	static boolean is_Sorted(int A[])
	{
		int N=A.length;
		for(int i=1; i<=N; i++)if(A[i-1]!=i)return false;
		return true;
	}
	static boolean f(StringBuilder sb,String Y,String order)
	{
		StringBuilder res=new StringBuilder(sb.toString());
		HashSet<Character> set=new HashSet<>();
		for(char ch:order.toCharArray())
		{
			set.add(ch);
			for(int i=0; i<sb.length(); i++)
			{
				char x=sb.charAt(i);
				if(set.contains(x))continue;
				res.append(x);
			}
		}

		String str=",kkkkush
307,"public class Solution {

    public static void main(String[] args) throws InterruptedException {
        Scanner in = new Scanner(System.in);
        // Thread.sleep(3000);
        int T = in.nextInt();

        for (int t = 1; t <= T; t++) {
            String s= in.next();
            StringBuilder sb= new StringBuilder();
            HashSet<Character> diff= new HashSet<>();
        for(int i=0; i<s.length()-1; i++){
            diff.add(s.charAt(i));
            sb.append(s.charAt(i));
            char c= s.charAt(i);
            if(s.charAt(i)<s.charAt(i+1))
                sb.append(s.charAt(i));
            else if(s.charAt(i)==s.charAt(i+1)){
                int count=0;
                while(i<s.length()-1 && s.charAt(i)==c){
                    count++;
                    i++;
                }
//                System.out.println(i+"" ""+s.charAt(i)+"" ""+count);

                if(s.charAt(i)>c){
//                    System.out.println(i+"" HHH  ""+s.charAt(i)+"" ""+count);
count=2*count;
                    while(count-->1)
                        sb.append(c);
                }
                else{
                    while(count-->1)
                        sb.append(c);
                }
            }
        }
        sb.append(s.charAt(s.length()-1));
diff.add(s.charAt(s.length()-1));
        if(diff.size()==1)
            System.out.println(""Case #""+t+"": ""+s);
        else
            System.",Rawan321
785,"public class Solution {

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        PrintStream out = System.out;

        try {
//            in = new Scanner(new BufferedReader(new FileReader(""/Users/Shared/Sources/CodingStudy/src/codejam/year2022/round_QA/ChainReactions/sample/sample_ts1-in.txt"")));
//            out = new PrintStream(new FileOutputStream(""/Users/Shared/Sources/CodingStudy/src/codejam/year2022/round_QA/ChainReactions/sample/sample_ts1-out.txt""));

//            in = new Scanner(new BufferedReader(new FileReader(""/Users/Shared/Sources/CodingStudy/src/codejam/year2022/round_QA/ChainReactions/sample/sample_ts2-in.txt"")));
//            out = new PrintStream(new FileOutputStream(""/Users/Shared/Sources/CodingStudy/src/codejam/year2022/round_QA/ChainReactions/sample/sample_ts2-out.txt""));

        } catch (Exception e) {
            e.printStackTrace();
            return;
        }

        int T = in.nextInt();
        for (int t = 1; t <= T; t++) {
            int N = in.nextInt();

            int[] F = new int[N];
            for( int i=0;i<N;i++){
                F[i] = in.nextInt();
            }
            int[] parent = new int[N];
            for( int i=0;i<N;i++){
                parent[i] = in.nextInt();
            }

            long ans = getAnswer(N, F, parent);

            out.printf(""Case #%d: %d
"", t, ans);
        }
        in.close();
    }


    private static long getAnswer(int N, int[] F, int[] parent) {

        Map<Integer, List<Integer>> graph = new HashMap<>();

        Map<Integer,Integer> inDegree = new HashMap<>();
        Map<Integer,Integer> outDegree = new HashMap<>();

        Map<Integer,Boolean> visited = new HashMap<>();

        /* 1. Build graph. */
        for(int i=1;i<=N;i++) {
            graph.put(i, new ArrayList<>());
            inDegree.put(i, 0);
            outDegree.put(i, 0);
            visited.put(i, false);
        }

        for(int i=0;i<N;i++){
            int childNo = i + 1;
            int parentNo = parent[i];

            if( parentNo != 0) {
                graph.get(parentNo).add(childNo);
                inDegree.put(parentNo, inDegree.get(parentNo) + 1);
                outDegree.put(childNo, 1);
            }else{
                outDegree.put(childNo, 0);
            }

        }

        /* 3. Do DFS by maxEst */
        long ans = doDFSByMaxEst(N, F, graph, outDegree, visited);
        return ans;
    }

    private static long doDFSByMaxEst(int N, int[] F, Map<Integer, List<Integer>> graph, Map<Integer, Integer> outDegree, Map<Integer,Boolean> visited) {
        long sum = 0;
        for(Map.Entry<Integer,Integer> entry : outDegree.entrySet()){
            if(entry.getValue() == 0){
                int root = entry.getKey();
                long val = doDFSByMaxEst(N, F, graph, root, visited);
                sum += val;
            }
        }

        return sum;
    }

    private static long doDFSByMaxEst(int N, int[] F, Map<Integer, List<Integer>> graph, int rootNo, Map<Integer,Boolean> visited) {
        visited.put(rootNo, true);

        // Leaf node
        if( graph.get(rootNo).size() == 0){
            return F[rootNo-1];
        }

        // Non-leaf node
        long sum = F[rootNo-1];
        long minVal = sum;
        List<Long> cands = new ArrayList<>();
        cands.add(sum);

        for(int childNo: graph.get(rootNo)){
            if( visited.get(childNo) == false) {
                long val = doDFSByMaxEst(N, F, graph, childNo, visited);
                sum += val;
                minVal = Math.min(minVal, val);

                cands.add(val);
            };
        }
        sum = sum - minVal;

//        System.err.printf(""RootNo: %d Ret: %d Values: %s
"", rootNo, sum, cands);

        return sum;
    }
}",id
543,"public class Solution {
//public class A {
    public static void main(String[] args) throws IOException {
        //BufferedReader br = new BufferedReader(new InputStreamReader(new FileInputStream(""in.txt"")));
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int ttt = Integer.parseInt(br.readLine());
        for (int tt = 1; tt <= ttt; ++tt) {
            final int n = Integer.parseInt(br.readLine());
            final String[] cc = br.readLine().split("" "");
            final int[] r = new int[cc.length];
            for (int i = 0; i < n; i++) {
                r[i] = Integer.parseInt(cc[i]);
            }
            int answ = 0;
            int best = -1;
            int i = 0;
            int j = n - 1;
            while (i <= j) {
                if (r[i] < r[j]) {
                    if (r[i] >= best) {
                        answ++;
                        best = r[i];
                    }
                    i++;
                } else {
                    if (r[j] >= best) {
                        answ++;
                        best = r[j];
                    }
                    j--;
                }
            }


            System.",attila
1260,"public class Solution {
    {
        MULTI_TEST = false;
        FILE_NAME = """";
        NEED_FILE_IO = false;
        INF = (long) 1e18;
    } // fields


    int cLen = 26;
    boolean isValid(String tower) {
        boolean[] usedChar = new boolean[cLen];
        int n = tower.length();
        int l = 0, r = 0;
        while(r < n) {
            while(r + 1 < n && tower.charAt(r + 1) == tower.charAt(r)) r++;

            if(usedChar[tower.charAt(r) - 'A']) return false;
            usedChar[tower.charAt(r) - 'A'] = true;

            r++;l=r;
        }

        return true;
    }

    ArrayList<String> answers = new ArrayList<>();
    void gen(String currS, int curr, int len, boolean[] used, String[] arr) {
        if(curr == len) {
            answers.add(currS);
        } else {
            for(int i = 0; i < len; i++) {
                if(used[i]) continue;
                used[i] = true;
                gen(currS + arr[i], curr+1, len, used, arr);
                used[i] = false;
            }
        }
    }
    String solve_test() {
        answers.clear();
        int n = ri();
        String s[] = new String[n];
        for(int i = 0; i < n; i++) s[i] = rs();
        gen("""", 0, n, new boolean[n], s);
        for(int i = 0; i < answers.size(); i++) {
            if(isValid(answers.get(i))) {
                return answers.get(i);
            }
        }
        return ""IMPOSSIBLE"";
    }
    void solve() {
        int t = ri();
        for(int it = 1; it <= t; it++) {
            out.printf(""Case #%d: %s
"", it, solve_test());
        }
    }

    public static void main(String[] args) {
        new Solution().run();
    } //main

    @SuppressWarnings(""unused"")
    long gcd(long a, long b) {
        return b == 0 ? a : gcd(b, a % b);
    }

    @SuppressWarnings(""unused"")
    long lcm(long a, long b) {
        return a / gcd(a, b) * b;
    }

    @SuppressWarnings(""unused"")
    int gcd(int a, int b) {
        return (int) gcd((long) a, b);
    }

    @SuppressWarnings(""unused"")
    int lcm(int a, int b) {
        return (int) lcm(a, (long) b);
    }

    @SuppressWarnings(""unused"")
    int sqrtInt(int x) {
        return (int) sqrtLong(x);
    }

    @SuppressWarnings(""unused"")
    long sqrtLong(long x) {
        long root = (long) Math.sqrt(x);
        while (root * root > x) --root;
        while ((root + 1) * (root + 1) <= x) ++root;
        return root;
    }

    @SuppressWarnings(""unused"")
    int cbrtLong(long x) {
        int cbrt = (int) Math.cbrt(x);
        while ((long) cbrt * cbrt >= x) {
            cbrt--;
        }
        while ((long) (cbrt + 1) * (cbrt + 1) <= x) cbrt++;
        return cbrt;
    }

    @SuppressWarnings(""unused"")
    long binpow(long a, long power) {
        return binpow(a, power, Long.MAX_VALUE);
    }

    @SuppressWarnings(""unused"")
    long binpow(long a, long power, long modulo) {
        if (power == 0) return 1 % modulo;
        if (power % 2 == 1) {
            long b = binpow(a, power - 1, modulo) % modulo;
            return ((a % modulo) * b) % modulo;
        } else {
            long b = binpow(a, power / 2, modulo) % modulo;
            return (b * b) % modulo;
        }
    }

    @SuppressWarnings(""unused"")
    long fastMod(String s1, long n2) {
        long num = 0;
        for (int i = 0; i < s1.length() - 1; i++) {
            num += Integer.parseInt(String.valueOf(s1.charAt(i)));
            num *= 10;
            if (num >= n2) {
                num = num % n2;
            }
        }
        return (num + Integer.parseInt(String.valueOf(s1.charAt(s1.length() - 1)))) % n2;
    }

    @SuppressWarnings(""unused"")
    long factorialMod(long n, long p) {
        long res = 1;
        while (n > 1) {
            res = (res * ((n / p) % 2 == 1 ? p - 1 : 1)) % p;
            for (int i = 2; i <= n % p; ++i)
                res = (res * i) % p;
            n /= p;
        }
        return res % p;
    }

    @SuppressWarnings(""unused"")
    boolean isPrime(int number) {
        for (int i = 2; i * i <= number; i++) {
            if (number % i == 0) {
                return false;
            }
        }
        return number > 1;
    }

    @SuppressWarnings(""unused"")
    boolean[] primes(int border) {
        boolean[] isPrimes = new boolean[border + 1];
        Arrays.fill(isPrimes, true);
        isPrimes[0] = false;
        isPrimes[1] = false;
        for (int i = 2; i < border + 1; i++) {
            if (!isPrimes[i]) continue;
            for (int k = i * 2; k < border; k += i) {
                isPrimes[k] = false;
            }
        }
        return isPrimes;
    } //Number theory

    @SuppressWarnings(""unused"")
    void sort(int[] a) {
        int n = a.length;
        Integer[] arr = new Integer[n];
        for (int i = 0; i < n; i++) {
            arr[i] = a[i];
        }
        Arrays.sort(arr);
        for (int i = 0; i < n; i++) {
            a[i] = arr[i];
        }
    }

    @SuppressWarnings(""unused"")
    void sort(long[] a) {
        int n = a.length;
        Long[] arr = new Long[n];
        for (int i = 0; i < n; i++) {
            arr[i] = a[i];
        }
        Arrays.sort(arr);
        for (int i = 0; i < n; i++) {
            a[i] = arr[i];
        }
    }

    @SuppressWarnings(""unused"")
    int max(int[] a) {
        int n = a.length;
        int max = Integer.MIN_VALUE;
        for (int j : a) {
            if (j > max) max = j;
        }
        return max;
    }

    @SuppressWarnings(""unused"")
    long max(long[] a) {
        int n = a.length;
        long max = Long.MIN_VALUE;
        for (long l : a) {
            if (l > max) max = l;
        }
        return max;
    }

    @SuppressWarnings(""unused"")
    int maxIndex(int[] a) {
        int n = a.length;
        int max = Integer.MIN_VALUE;
        int index = 0",v0s7er
980,"public class Solution {

	public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        
        int numberOfCases = in.nextInt();
        
        for (int i = 1; i <= numberOfCases; ++i) {
        	int[] result = new int[] {0,0,0,0,0,0,0,0};
        	int N = 10;
        	while(N>0) {
        		if(N == 10) {
        			System.out.println(""00000000"");
        			N = in.nextInt();
        			System.err.println(N);
        		}
        		if(N == 1) {
        			System.out.println(""00000001"");
        			N = in.nextInt();
        			System.err.println(N);
        		}
        		if(N == 2) {
        			System.out.println(""00000011"");
        			N = in.nextInt();
        			System.err.println(N);
        		}
        		if(N == 3) {
        			System.out.println(""00000111"");
        			N = in.nextInt();
        			System.err.println(N);
        		}
        		if(N == 4) {
        			System.out.println(""00001111"");
        			N = in.nextInt();
        			System.err.println(N);
        		}
        		if(N == 5) {
        			System.out.println(""00011111"");
        			N = in.nextInt();
        			System.err.println(N);
        		}
        		if(N == 6) {
        			System.out.println(""00111111"");
        			N = in.nextInt();
        			System.err.println(N);
        		}
        		if(N == 7) {
        			System.out.println(""01111111"");
        			N = in.nextInt();
        			System.err.println(N);
        		}
        		if(N == 8) {
        			System.out.println(""11111111"");
        			N = in.nextInt();
        			System.err.println(N);
        		}
        	}
        	if(N == -1)break;
        	
        }
      }
}",nicolasD
731,"public class Solution {

    public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        PrintWriter writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));

        int T = in.nextInt();
        for (int casNumero = 1; casNumero <= T; casNumero++) {
            StringBuilder resultat = new StringBuilder();
            resultat.append(""Case #"");
            resultat.append(casNumero);
            resultat.append("": "");

            int n = in.nextInt();
            long[] f = new long[n];
            for (int i = 0; i < n; i++) {
                f[i] = in.nextLong();
            }
            int[] p = new int[n];
            for (int i = 0; i < n; i++) {
                p[i] = in.nextInt();
            }
            long sumFun = 0;
            List<Integer> used = new ArrayList<>();
            Map<Integer, Long> triggers = new HashMap();
            for (int i = 1; i < n+1; i++) {
                int finalI = i;
                if (Arrays.stream(p).parallel().noneMatch(a -> a == finalI)) {
                    if (p[finalI - 1] == 0) {
                        sumFun += f[finalI - 1];
                    }
                    else {
                        triggers.put(finalI, getFun(finalI, f, p, used));
                    }
                }
            }

            while (!triggers.keySet().isEmpty()) {
                long minFun = Collections.min(triggers.values());
                int baseModule = 0;
                for (int i = 1; i < n+1; i++) {
                    if (!used.contains(Integer.valueOf(i)) && f[i - 1] == minFun) {
                        baseModule = i;
                        break;
                    }
                }

                int bestTrigger = 0;
                used.add(baseModule);
                for (Integer trigger : triggers.keySet()) {
                    if (minFun == triggers.get(trigger) && isCommonModule(baseModule, trigger, p)) {
                        triggers.put(trigger, getFun(trigger, f, p, used));
                        if (bestTrigger == 0) {
                            bestTrigger = trigger;
                        }
                        else {
                            if (triggers.get(trigger) < triggers.get(bestTrigger)) {
                                bestTrigger = trigger;
                            }
                        }
                    }
                }
                used.remove(Integer.valueOf(baseModule));
                sumFun += minFun;
                used.addAll(getRelations(bestTrigger, p, used));
                triggers.remove(bestTrigger);

                for (Integer trigger : triggers.keySet()) {
                    if (isCommonModule(baseModule, trigger, p)) {
                        int commonModule = getCommonModule(trigger, bestTrigger, p);
                        if (commonModule != 0 && commonModule != baseModule) {
                            triggers.put(trigger, getFun(trigger, f, p, used));
                        }
                    }
                }
            }
            resultat.append(sumFun);
            writer.print(resultat.toString());
            writer.println();
        }
        in.close();
        writer.close();
    }

    private static int getCommonModule(int index1, int index2, int[] p) {
        int currentIndex1 = p[index1 - 1];
        int currentIndex2 = p[index2 - 1];
        int commonModule = 0;
        while (commonModule == 0 && currentIndex1 != 0 && currentIndex2 != 0) {
            if (currentIndex1 == currentIndex2) {
                commonModule = currentIndex1;
            }
            else if (currentIndex1 > currentIndex2) {
                currentIndex1 = p[currentIndex1 - 1];
            }
            else {
                currentIndex2 = p[currentIndex2 - 1];
            }
        }
        return commonModule;
    }

    private static boolean isCommonModule(int commonModule, int index, int[] p) {
        int relation = index;
        boolean isCommon = relation == commonModule;
        while (!isCommon && relation != 0) {
            relation = p[relation - 1];
            isCommon = relation == commonModule;
        }
        return isCommon;
    }

    private static List<Integer> getRelations(int index, int[] p, List<Integer> used) {
        List<Integer> relations = new ArrayList<>();
        relations.add(index);
        int currentIndex = index;
        while (!used.contains(currentIndex) && p[currentIndex - 1] != 0) {
            currentIndex = p[currentIndex - 1];
            relations.add(currentIndex);
        }
        return relations;
    }

    private static long getFun(int index, long[] f, int[] p, List<Integer> used) {
        long fun = f[index - 1];
        int relation = p[index - 1];
        if (relation != 0 && !used.contains(relation)) {
            long relationFun = getFun(relation, f, p, used);
            if (relationFun > fun) {
                fun = ",gerardmr
1284,"public class Solution {

	static boolean verb=true;
	static void log(Object X){if (verb) System.err.println(X);}
	static void log(Object[] X){if (verb) {for (Object U:X) System.err.print(U+"" "");System.err.println("""");}}
	static void log(int[] X){if (verb) {for (int U:X) System.err.print(U+"" "");System.err.println("""");}}
	static void logWln(Object X){if (verb) System.err.print(X);}
	static void info(Object o){	System.out.println(o);}
	static void output(Object o){outputWln(""""+o+""
"");	}
	static void outputWln(Object o){try {out.write(""""+ o);} catch (Exception e) {}}





	// Global vars


	static BufferedWriter out;
	static InputReader reader;



	static int R,P;

	static void ask(int node) throws Exception {
		System.out.println(""T ""+(node+1));
		System.out.flush();
		R=reader.readInt()-1;
		P=reader.readInt();
	}

	static void answer(long x) {
		System.out.println(""E ""+x);
		System.out.flush();

	}

	static void process() throws Exception {

		//out = new BufferedWriter(new OutputStreamWriter(System.out));
		reader=new InputReader(System.in);
		Locale.setDefault(Locale.US);	




		int T=reader.readInt();



		for (int t=1;t<=T;t++) {


			int n=reader.readInt();
			int K=reader.readInt();

			R=reader.readInt()-1;
			P=reader.readInt();
			long tot=0;
			tot+=P;
		
			if (K>=n) {
				for (int i=0;i<n;i++) {
					if (i!=R) {
						ask(i);
						tot+=P;
					}
				}
				answer(tot/2);

			} else {
				// take some randoms
				ArrayList<Integer> list=new ArrayList<Integer>();
				for (int i=0;i<n;i++) {
					if (i!=R) {
						list.add(i);
					}
				}
				tot=0;
				Collections.shuffle(list);
			    //	Collections.shuffle(list);
				for (int i=0;i<K-1;i++) {
					ask(list.get(i));
					tot+=P;
				}
				tot*=n;
				tot/=(K-1);
				answer(tot/2);
				
			}


			//String ss="""";
			

			//output(""Case #""+t+"": ""+ss);
		}
		//log(""ok"");
		/*
		try {
			out.close();
		}
		catch (Exception EX){}
*/
	}








	public static void main(String[] args) throws Exception {
		process();

	}

	static final class InputReader {
		private final InputStream stream;
		private final byte[] buf = new byte[1024];
		private int curChar;
		private int numChars;

		public InputReader(InputStream stream) {
			this.stream = stream;
		}

		private int read() throws IOException {
			if (curChar >= numChars) {
				curChar = 0;
				numChars = stream.read(buf);
				if (numChars <= 0) {
					return -1;
				}
			}
			return buf[curChar++];
		}


		public final String readString() throws IOException {
			int c = read();
			while (isSpaceChar(c)) {
				c = read();
			}
			StringBuilder res=new StringBuilder();
			do {
				res.append((char)c);
				c = read();
			} while (!isSpaceChar(c));
			return res.toString();
		}

		public final int readInt() throws IOException {
			int c = read();
			boolean neg=false;
			while (isSpaceChar(c)) {
				c = read();
			}
			char d=(char)c;
			//log(""d:""+d);
			if (d=='-') {
				neg=true;
				c = read();
			}
			int res = 0;
			do {
				res *= 10;
				res += c - '0';
				c = read();
			} while (!isSpaceChar(c));
			//log(""res:""+res);
			if (neg)
				return -res;
			return res;

		}

		public final long readLong() throws IOException {
			int c = read();
			boolean neg=false;
			while (isSpaceChar(c)) {
				c = read();
			}
			char d=(char)c;
			//lo)g(""d:""+d);
			if (d=='-') {
				neg=true;
				c = read();
			}
			long res = 0;
			do {
				res *= 10;
				res += c - '0';
				c = read();
			} while (!isSpaceChar(c));
			//log(""res:""+res);
			if (neg)
				return -res;
			return res;

		}



",vincent
129,"class Solution {
    static String prev;
    static int prevN;
    static ArrayList<Integer> list;
    static Set<Integer> set1;
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        list = new ArrayList<>();
        for (int i=0; i<8; i++) {
            list.add(i);
        }
        int T = sc.nextInt();
        for(int i = 1; i <= T; i ++){
            prev = ""00000000"";
            System.out.println(prev);
            int res = sc.nextInt();
            while (res != 0) {
                check(res);
                res = sc.nextInt();
            }

        }
        sc.close();
    }

    public static void check(int n){
        if (n > 4) {
            prevN = n;
            prev = ""11111111"";
            System.out.println(prev);
            return;
        }
        
        if (n == 2 && prevN == 2) {
            ArrayList<Integer> tmp = new ArrayList<>(list);
            tmp.removeAll(set1);
            Collections.shuffle(tmp);
            Set<Integer> set = new HashSet<>();
            set.add(tmp.get(0));
            for(Integer i : set1) {
                set.add(i);
                break;
            }
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < 8; i ++) {
                if (!set.contains(i)) {
                    sb.append('1');
                } else {
                    sb.append('0');
                }
            }
            set1 = set;
            prevN = n;
            prev = sb.toString();
            System.out.println(prev);
            return;
        }
        ArrayList<Integer> tmp = new ArrayList<>(list);
        Collections.shuffle(tmp);
        Set<Integer> set = new HashSet<>();
        for (int i = 0; i < n; i ++) {
            set.add(tmp.get(i));
        }
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 8; i ++) {
            if (set.contains(i)) {
                sb.append('1');
            } else {
                sb.append('0');
            }
        }
        set1 = set;
        prevN = n;
        prev = ",Em11
1232,"public class Solution {

  // Template
  public static void main(String[] args) throws Exception {
    final InputReader in = new InputReader(System.in);
    final OutputWriter out = new OutputWriter(System.out);
    Locale.setDefault(Locale.US);
    int T = in.readInt();
    for (int t = 1; t <= T; t++) {
      // read
      int N = in.readInt();
      int[] ns = new int[N];
      for (int i = 0; i < N; i++) {
        ns[i] = in.readInt();
      }
      Arrays.sort(ns);

      // calc sol
      int count = 0;
      for (int i = 0; i < N; i++) {
        if (ns[i] > count) {
          count++;
        }
      }

      // print
      out.printLine(nthcase(t) + "" "" + count);
    }
    out.close();
  }

  static String nthcase(int t) {
    return ""Case #"" + t + "":"";
  }

  static class InputReader {
    private InputStream stream;
    private byte[] buf = new byte[1024];
    private int curChar;
    private int numChars;

    public InputReader(InputStream stream) {
      this.stream = stream;
    }

    public int read() {
      if (numChars == -1) throw new InputMismatchException();
      if (curChar >= numChars) {
        curChar = 0;
        try {
          numChars = stream.read(buf);
        } catch (IOException e) {
          throw new InputMismatchException();
        }
        if (numChars <= 0) return -1;
      }
      return buf[curChar++];
    }

    public char readChar() {
      int c = read();
      while (isSpaceChar(c)) c = read();
      return (char) c;
    }

    public String readLine() {
      int c = read();
      while (isSpaceChar(c)) c = read();
      StringBuilder res = new StringBuilder();
      do {
        res.appendCodePoint(c);
        c = read();
      } while (!isEndOfLine(c));
      return res.toString();
    }

    public String readString() {
      int c = read();
      while (isSpaceChar(c)) c = read();
      StringBuilder res = new StringBuilder();
      do {
        res.appendCodePoint(c);
        c = read();
      } while (!isSpaceChar(c));
      return res.toString();
    }

    public long readLong() {
      int c = read();
      while (isSpaceChar(c)) c = read();
      int sgn = 1;
      if (c == '-') {
        sgn = -1;
        c = read();
      }
      long res = 0;
      do {
        if (c < '0' || c > '9') throw new InputMismatchException();
        res *= 10;
        res += c - '0';
        c = read();
      } while (!isSpaceChar(c));
      return res * sgn;
    }

    public int readInt() {
      int c = read();
      while (isSpaceChar(c)) c = read();
      int sgn = 1;
      if (c == '-') {
        sgn = -1;
        c = read();
      }
      int res = 0;
      do {
        if (c < '0' || c > '9') throw new InputMismatchException();
        res *= 10;
        res += c - '0';
        c = read();
      } while (!isSpaceChar(c));
      return res * sgn;
    }

    public boolean isSpaceChar(int c) {
      return c == ' ' || c == '
' || c == '\r' || c == '	' || c == -1;
    }

    public boolean isEndOfLine(int c) {
      return c == '
' || c == '\r' || c == -1;
    }
  }

  static class OutputWriter {
    private final PrintWriter writer;

    public OutputWriter(OutputStream outputStream) {
      writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
    }

    public OutputWriter(Writer writer) {
      this.writer = new PrintWriter(writer);
    }

    public void print(Object... objects) {
      for (int i = 0; i < objects.length; i++) {
        if (i != 0) writer.print(' ');
        writer.print(objects[i]);
      }
    }

    public void printLine(Object... objects) {
      print(objects);
      writer.println();
    }

    public void flush() {
      writer.flush();
    }
",thesamwiser
64,"public class Solution {
	static Scanner sc;
	static StringBuffer s;

  public static void main(String[] args)throws Exception{
	  sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
	  
     int nbTest = sc.nextInt();
     
	 for(int test = 1;test<=nbTest;test++){ 	   	 	
	 	solve(test);
	 }   
	 
  }
  
  static void solve (int test) {
	  
	  List<Integer> list1 = new ArrayList<Integer>();
	  List<Integer> list2 = new ArrayList<Integer>();
	  List<Integer> list3 = new ArrayList<Integer>();
	  List<Integer> result = new ArrayList<Integer>();
	  int s = 1000000;
	  for (int i = 0; i<4; i++) list1.add(sc.nextInt()); 
	  for (int i = 0; i<4; i++) list2.add(sc.nextInt());
	  for (int i = 0; i<4; i++) list3.add(sc.nextInt());
	  
	  if (somme(list1)<s) {
		  System.out.println(""Case #""+test+"": IMPOSSIBLE"");
		  return;
	  }
	  if (somme(list2)<s) {
		  System.out.println(""Case #""+test+"": IMPOSSIBLE"");
		  return;
	  }
	  if (somme(list3)<s) {
		  System.out.println(""Case #""+test+"": IMPOSSIBLE"");
		  return;
	  }
	  int minC = minimum(list1.get(0), list2.get(0), list3.get(0));
	  int minM = minimum(list1.get(1), list2.get(1), list3.get(1));
	  int minY = minimum(list1.get(2), list2.get(2), list3.get(2));
	  int minK = minimum(list1.get(3), list2.get(3), list3.get(3));
	  
	 
	  
	  
	  result.add(minC);
	  if(minC+minM>s) {
		  System.out.println(""Case #""+test+"": ""+minC+"" ""+(s-minM)+"" ""+0+"" ""+0);
		  return;
	  }else {
		  result.add(minM);
	  }
	  
	  if (minC+minM+minY>s) {
		  System.out.println(""Case #""+test+"": ""+minC+"" ""+minM+"" ""+(s-(minC+minM))+"" ""+0);
		  return;
	  } else {
		  result.add(minY);
	  }
	  
	  
	  System.out.println(""Case #""+test+"": ""+minC+"" ""+minM+"" ""+minY+"" ""+
	                                        (s-(minC+minM+minY)));
	  


  }
  

  public static int  minimum (int a, int b, int c) {	 
		return Math.min(Math.min(a, b), c);
	}
  public static int somme(List<Integer> list) {
	  int res = 0;
	  for (int i = ",Bil1983
1242,"public class Solution {

  // Template
  public static void main(String[] args) throws Exception {
    final InputReader in = new InputReader(System.in);
    final OutputWriter out = new OutputWriter(System.out);
    Locale.setDefault(Locale.US);
    int T = in.readInt();
    for (int t = 1; t <= T; t++) {
      // read
      int R = in.readInt();

      // calc sol
      var filled = drawCircle(R);
      var wrong = drawCircleWrong(R);
      int count = 0;
      for (int i = 0; i < filled.length; i++) {
        for (int j = 0; j < filled[i].length; j++) {
          if (filled[i][j] != wrong[i][j]) {
            count++;
          }
        }
      }
//      draw(filled);
//      draw(wrong);

      // print
      out.printLine(nthcase(t) + "" "" + count);
    }
    out.close();
  }

  private static void draw(boolean[][] mat) {
    for (int x = 0; x < mat.length; x++) {
      for (int y = 0; y < mat[x].length; y++) {
        System.err.print(mat[x][y] ? 'X' : ' ');
      }
      System.err.println();
    }
  }

  private static boolean[][] drawCircle(int R) {
    boolean[][] mat = new boolean[R * 2 + 1][R * 2 + 1];
    for (int x = -R; x <= R; x++) {
      for (int y = -R; y <= R; y++) {
        if (Math.round(Math.sqrt(x * x + y * y)) <= R) {
          set(x, y, R, mat);
        }
      }
    }
    return mat;
  }

  private static void set(int x, int y, int R, boolean[][] mat) {
    mat[x + R][y + R] = true;
  }

  private static boolean[][] drawCircleWrong(int R) {
    boolean[][] mat = new boolean[R * 2 + 1][R * 2 + 1];
    for (int r = 0; r <= R; r++) {
      int R2 = r * r;
      for (int x = -r; x <= r; x++) {
        int y = (int) Math.round(Math.sqrt(R2 - (x * x)));
        set(x, y, R, mat);
        set(x, -y, R, mat);
        set(y, x, R, mat);
        set(-y, x, R, mat);
      }
    }
    return mat;
  }

  static String nthcase(int t) {
    return ""Case #"" + t + "":"";
  }

  static class InputReader {
    private final InputStream stream;
    private final byte[] buf = new byte[1024];
    private int curChar;
    private int numChars;

    public InputReader(InputStream stream) {
      this.stream = stream;
    }

    public int read() {
      if (numChars == -1) throw new InputMismatchException();
      if (curChar >= numChars) {
        curChar = 0;
        try {
          numChars = stream.read(buf);
        } catch (IOException e) {
          throw new InputMismatchException();
        }
        if (numChars <= 0) return -1;
      }
      return buf[curChar++];
    }

    public char readChar() {
      int c = read();
      while (isSpaceChar(c)) c = read();
      return (char) c;
    }

    public String readLine() {
      int c = read();
      while (isSpaceChar(c)) c = read();
      StringBuilder res = new StringBuilder();
      do {
        res.appendCodePoint(c);
        c = read();
      } while (!isEndOfLine(c));
      return res.toString();
    }

    public String readString() {
      int c = read();
      while (isSpaceChar(c)) c = read();
      StringBuilder res = new StringBuilder();
      do {
        res.appendCodePoint(c);
        c = read();
      } while (!isSpaceChar(c));
      return res.toString();
    }

    public long readLong() {
      int c = read();
      while (isSpaceChar(c)) c = read();
      int sgn = 1;
      if (c == '-') {
        sgn = -1;
        c = read();
      }
      long res = 0;
      do {
        if (c < '0' || c > '9') throw new InputMismatchException();
        res *= 10;
        res += c - '0';
        c = read();
      } while (!isSpaceChar(c));
      return res * sgn;
    }

    public int readInt() {
      int c = read();
      while (isSpaceChar(c)) c = read();
      int sgn = 1;
      if (c == '-') {
        sgn = -1;
        c = read();
      }
      int res = 0;
      do {
        if (c < '0' || c > '9') throw new InputMismatchException();
        res *= 10;
        res += c - '0';
        c = read();
      } while (!isSpaceChar(c));
      return res * sgn;
    }

    public boolean isSpaceChar(int c) {
      return c == ' ' || c == '
' || c == '\r' || c == '	' || c == -1;
    }

    public boolean isEndOfLine(int c) {
      return c == '
' || c == '\r' || c == -1;
    }
  }

  static class OutputWriter {
    private final PrintWriter writer;

    public OutputWriter(OutputStream outputStream) {
      this(new BufferedWriter(new OutputStreamWriter(outputStream)));
    }

    public OutputWriter(Writer writer) {
      this.writer = new PrintWriter(writer);
    }

    public void print(Object... objects) {
      for (int i = 0; i < objects.length; i++) {
        if (i != 0) writer.print(' ');
        writer.print(objects[i]);
      }
    }

    public void printLine(Object... objects) {
      print(objects);
      writer.println();
    }

    public void flush() {
      writer.flush();
    }
",thesamwiser
585,"public class Solution{
    public static void main(String[] args){
        Scanner s = new Scanner(System.in);
        int T = s.nextInt();
    forloop:    for(int ii=1; ii <= T; ii++){
            
            int[][] c = new int[3][4];
            
            for(int i=0; i < 3; i++){
                for(int j=0; j <=3; j++){
                    c[i][j] = s.nextInt();
                }
            }
            int rowSum = 0;
            int column = -1;
            int[] min = new int[4];
            Arrays.fill(min,Integer.MAX_VALUE);
            for(int j=0; j <= 3; j++){
               // min = 0;
                for(int i=0; i < 3; i++){
                     min[j] = Math.min(min[j],c[i][j]);
                }
                
                
            }
            
            int target = 1000000;
            int sum = 0;
            int[] ans = new int[4];
            for(int i=0; i < 4; i++){
                sum = sum + min[i];
                
                if (target >= 0){
                    ans[i] = min[i];
                    //continue;
                }
                else{
                    ans[i-1] = min[i-1] + target;
                    target = 0;
                }
                target = target - min[i];
            }
            
            if (target < 0){
                ans[3] = min[3] + target;
            }
            if (sum < 1000000){
                System.out.println(""Case #"" + ii  + "": IMPOSSIBLE"" );
                continue forloop;
            }
            
            System.out.print(""Case #"" + ii  + "": "" );
            
            for(int i=0; i < 4; i++){
                System.out.print(ans[i] + "" "");
            }
            
            
            System.",dattap
365,"class Solution
{
    public static void main(String[] args) {
        Scanner in=new Scanner(System.in);
        int t=in.nextInt();
    
       for(int ca=1;ca<=t;ca++)
        {
            int n=in.nextInt();
            long arr[]=new long[n];
            for(int i=0;i<n;i++)
            {
                arr[i]=in.nextInt();
            }
            solve(arr,ca);
        }
    }

      static void solve( long arr[],int ca) {
           long count=0;
           for(int i=0;i<arr.length;i++)
           {
               if(arr[i]>count)
               {
                   count++;
               }//else{break;}
            

           }
           long max=count;
         count=0;
         for(int i=arr.length-1;i>=0;i--)
         {
             if(arr[i]>count)
             {
                 count++;
             }
         }
         max=",SampathRajaRaghupathi
866,"public class Solution {

	@SuppressWarnings(""unchecked"")
	public static void main(String[] args) throws IOException {
		BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
		int T = Integer.parseInt(in.readLine());
		for (int e = 0; e < T; e++) {
			System.out.print(""Case #"" + (e + 1) + "": "");
			int N = Integer.parseInt(in.readLine());
			String[] strs = new String[N];
			boolean[][] chars = new boolean[N][100];
			char[] lastChar = new char[N];
			char[] firstChar = new char[N];
			TreeSet<Character>[] middleChars = new TreeSet[N];
			TreeSet<Integer>[] corrStrings = new TreeSet[100];
			TreeSet<Integer>[] startStrings = new TreeSet[100];
			TreeSet<Integer>[] endStrings = new TreeSet[100];
			TreeSet<Integer>[] midStrings = new TreeSet[100];
			TreeSet<Integer>[] pureStrings = new TreeSet[100];
			for (int i = 0; i < N; i++) {
				middleChars[i] = new TreeSet<Character>();
			}
			for (int i = 0; i < 100; i++) {
				corrStrings[i] = new TreeSet<Integer>();
				startStrings[i] = new TreeSet<Integer>();
				endStrings[i] = new TreeSet<Integer>();
				midStrings[i] = new TreeSet<Integer>();
				pureStrings[i] = new TreeSet<Integer>();
			}
			StringTokenizer st = new StringTokenizer(in.readLine());
			boolean check = false;
			for (int i = 0; i < N; i++) {
				strs[i] = st.nextToken();
				for (int j = 0; j < strs[i].length(); j++) {
					char c = strs[i].charAt(j);
					if (chars[i][c] && j > 0 && strs[i].charAt(j - 1) != c) {
						check = true;
						break;
					}
					chars[i][c] = true;
				}
				if (check) break;
				lastChar[i] = strs[i].charAt(strs[i].length() - 1);
				firstChar[i] = strs[i].charAt(0);
				startStrings[firstChar[i]].add(i);
				endStrings[lastChar[i]].add(i);
				if (lastChar[i] != firstChar[i]) {
					for (int j = 0; j < strs[i].length(); j++) {
						char c = strs[i].charAt(j);
						corrStrings[c].add(i);
						if (c == lastChar[i] || c == firstChar[i]) continue;
						middleChars[i].add(c);
						midStrings[c].add(i);
					}
				} else {
					pureStrings[firstChar[i]].add(i);
					startStrings[firstChar[i]].remove(i);
					endStrings[lastChar[i]].remove(i);
				}
			}
			if (check) {
				System.out.println(""IMPOSSIBLE"");
				continue;
			}
			TreeSet<Integer> canStart = new TreeSet<>();
			TreeSet<Integer> canEnd = new TreeSet<>();
			TreeSet<Integer> free = new TreeSet<>();
			int index = 0, count = 0, totalCount = 0;
			for (int i = 'A'; i <= 'Z'; i++) {
				//System.out.println((char)i + "" "" + midStrings[i].size() + "" "" + startStrings[i].size() + "" "" + endStrings[i].size() + "" "" + pureStrings[i].size());
				if (midStrings[i].size() > 1) {
					check = true;
					break;
				}
				if (midStrings[i].size() > 0 && startStrings[i].size() + endStrings[i].size() + pureStrings[i].size() > 0) {
					check = true;
					break;
				}
				if (startStrings[i].size() > 1) {
					check = true;
					break;
				}
				if (endStrings[i].size() > 1) {
					check = true;
					break;
				}
				if (startStrings[i].size() + endStrings[i].size() > 0) totalCount++;
				if (startStrings[i].size() == 1 && endStrings[i].size() == 0) {
					canStart.add(i);
				}
				if (endStrings[i].size() == 1 && startStrings[i].size() == 0) {
					canEnd.add(i);
				}
				if (startStrings[i].size() + endStrings[i].size() == 0 && pureStrings[i].size() > 0) {
					free.add(i);
				}
				if (endStrings[i].size() + startStrings[i].size() > 1) {
					index = i;
					count++;
				}
			}
			if (count == totalCount && count != 0) {
				System.out.println(""IMPOSSIBLE"");
				continue;
			}
			if (check) {
				System.out.println(""IMPOSSIBLE"");
				continue;
			}
			ArrayList<Integer> ordering = new ArrayList<>();
			while (ordering.size() < N) {
				if (free.size() > 0) {
					int a = free.first();
					for (int j:pureStrings[a]) {
						ordering.add(j);
					}
					free.remove(a);
					continue;
				}
				int i = canStart.first();
				canStart.remove(i);
				if (pureStrings[i].size() > 0) {
					for (int j:pureStrings[i]) {
						ordering.add(j);
					}
				}
				int strIndex = startStrings[i].first();
				ordering.add(strIndex);
				char currChar = lastChar[strIndex];
				while (!canEnd.contains((int)currChar)) {
					if (pureStrings[currChar].size() > 0) {
						for (int j:pureStrings[currChar]) {
							ordering.add(j);
						}
					}
					strIndex = startStrings[currChar].first();
					ordering.add(strIndex);
					currChar = lastChar[strIndex];
				}
				if (pureStrings[currChar].size() > 0) {
					for (int j:pureStrings[currChar]) {
						ordering.add(j);
					}
				}
			}
			String res = """";
			for (int i:ordering) {
				res += strs[i];
			}
			System.out.println(res);
			if (check) {
				System.out.println(""IMPOSSIBLE"");
				continue;
			}
		}
		in.",kevinz1423
636,"public class Solution {

    private int T;
    private ArrayList<Integer[]> deliciousnessList = new ArrayList<>();

    public static void main(String[] args) {

        Solution solution = new Solution();
        solution.readInput();

        for (int x = 0; x<solution.T; x++) {
            Integer[] deliciousness = solution.deliciousnessList.get(x);
            int customersCounter = solution.solveTestCase(deliciousness);

            System.out.println(String.format(""Case #%d: %d"", x+1, customersCounter));
        }

    }

    private int solveTestCase(Integer[] deliciousness) {

        // Initialise
        int customersCounter = 0;
        int totalMax = Integer.MIN_VALUE;
        int leftIndex = 0;
        int rightIndex=deliciousness.length-1;

        // Variable definitions
        int leftValue;
        int rightValue;
        int currentMax;

        for(int i=0; i<deliciousness.length; i++) {
            leftValue = deliciousness[leftIndex];
            rightValue = deliciousness[rightIndex];
            currentMax = Math.min(leftValue, rightValue);

            if(currentMax<totalMax) {
                if(totalMax<=Math.max(leftValue, rightValue)) {
                    customersCounter++;
                    totalMax = Math.max(leftValue, rightValue);

                    if (leftValue>=rightValue) {
                        leftIndex++;
                    } else {
                        rightIndex--;
                    }
                    continue;
                } else {
                    break;
                }
            }

            customersCounter++;
            totalMax = currentMax;

            if (leftValue<=rightValue) {
                leftIndex++;
            } else {
                rightIndex--;
            }
        }

        return customersCounter;
    }

    private void readInput() {

        Scanner reader = new Scanner(System.in);
        String data;

        if (reader.hasNextLine()) {
            data = reader.nextLine();
            T = Integer.parseInt(data);
        }

        for (int i = 0; i < T; i++) {
            data = reader.nextLine();
            int N = Integer.parseInt(data);

            Integer[] deliciousness = new Integer[N];
            data = reader.nextLine();
            String[] cells = data.split("" "", 0);

            for(int j=0; j<cells.length; j++) {
                deliciousness[j] = Integer.parseInt(cells[j]);
            }

            deliciousnessList.add(deliciousness);
        }

        reader.",dionysis_dt
447,"public class Solution {

    public static void main(String[] args) throws IOException {
        Scanner sc = new Scanner(System.in);
        PrintWriter pw = new PrintWriter(System.out);
        int t = sc.nextInt();
        for (int tc = 1; tc <= t; tc++) {
            int n = sc.nextInt();
            int c = sc.nextInt();
            int[] a = new int[c];
            int[] b = new int[c];
            for (int i = 0; i < c; i++) {
                a[i] = sc.nextInt();
                b[i] = sc.nextInt();
            }
            int[] p = new int[n];
            for (int i = 0; i < n; i++) {
                p[i] = sc.nextInt() - 1;
            }
            int ans = 0;
            for (int i = 0; i < n; i++) {
                int bad = 0;
                int[] cnt = new int[n];
                for (int j = i; (j + 1) % n != i; j = (j + 1) % n) {
//                    System.out.println(p[j]);
                    cnt[p[j]]++;
                    if (cnt[p[j]] == 1)
                        bad++;
                    if (cnt[p[j]] == a[p[j]])
                        bad--;
                    if (cnt[p[j]] == b[p[j]] + 1)
                        bad++;
                    if (bad == 0 && j != i) {
                        ans++;
//                        System.out.println(Arrays.toString(cnt));
                    }
                }
            }
            pw.println(""Case #"" + tc + "" "" + ans);
        }
        pw.close();
    }

    static class Scanner {
        BufferedReader br;
        StringTokenizer st;

        public Scanner(InputStream s) {
            br = new BufferedReader(new InputStreamReader(s));
        }

        public Scanner(FileReader f) {
            br = new BufferedReader(f);
        }

        public String next() throws IOException {
            while (st == null || !st.hasMoreTokens())
                st = new StringTokenizer(br.readLine());
            return st.nextToken();
        }

        public int nextInt() throws IOException {
            return Integer.parseInt(next());
        }

        public long nextLong() throws IOException {
            return Long.parseLong(next());
        }

        public double nextDouble() throws IOException {
            return Double.parseDouble(next());
        }

        public int[] nextIntArr(int n) throws IOException {
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = ",YahiaSherif
1159,"class Solution {

	public static void main ( String [] args ) {
		Scanner s = new Scanner ( System.in);
			
		int T = s.nextInt(); 
		for ( int t=1; t<=T; t++) {
			int h = s.nextInt();  
			int w = s.nextInt();
			
			System.out.println(""Case #""+t+"": ""+t);
			for ( int i=0; i<h; i++) {
				for ( int j=0; j<w; j++) {
					if (i==0&&j==0) {
						System.out.print("".."");
					} else { 
						System.out.print(""+-"");
					}
				} System.out.println(""+"");
				for ( int j=0; j<w; j++) {
					if (i==0&&j==0) {
						System.out.print("".."");
					} else {
						System.out.print(""|."");
					}
				} System.out.print(""|"");
				System.out.println();
				
			}
		

			for ( int j=0; j<w; j++) {
				System.out.print(""+-"");
			} System.",slycer
871,"public class Solution {

    public static void main(String[] args) {
        try (PrintWriter out = new PrintWriter(System.out)) {
            FastScanner in = new FastScanner(System.in);
            solve(in, out);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    private static void solve(FastScanner in, PrintWriter out) throws IOException {
        Random random = new Random(177013);

        int t = in.nextInt();
        for (int q = 1; q <= t; q++) {

            int N = in.nextInt();
            int K = in.nextInt();

            double sum = 0;

            int S = in.nextInt();
            int P = in.nextInt();

            if (N <= K) {
                for (int r = 1; r <= N; r++) {
                    out.println(""T "" + r);
                    out.flush();

                    S = in.nextInt();
                    P = in.nextInt();

                    sum += P;
                }

                sum = sum / 2;

                out.println(""E "" + Math.round(sum));
                out.flush();

                continue;
            }

            HashSet<Integer> st = new HashSet<>();

            for (int i = 0; i < K - 1; i++) {
                int r = random.nextInt(N) + 1;

                while (st.contains(r)) {
                    r = random.nextInt(N) + 1;
                }

                st.add(r);

                out.println(""T "" + r);
                out.flush();

                S = in.nextInt();
                P = in.nextInt();

                sum += P;
            }

            sum = sum * N / (2 * K);

            out.println(""E "" + Math.round(sum));
            out.flush();

        }
    }

    private static class FastScanner {
        private final BufferedReader reader;
        private String[] tokens = null;
        private int cnt = -1;

        public FastScanner(InputStream inputStream) {
            reader = new BufferedReader(new InputStreamReader(inputStream, StandardCharsets.UTF_8));
        }

        public String next() throws IOException {
            if (tokens == null || cnt >= tokens.length) {
                String line = reader.readLine();
                if (line != null) {
                    tokens = line.split(""\\\s"");
                } else {
                    throw new RuntimeException(""not found"");
                }
                cnt = 0;
            }
            return tokens[cnt++];
        }

        public Integer nextInt() throws IOException {
            return Integer.parseInt(next());
        }

        public Long nextLong() throws IOException {
            return Long.parseLong(next());
        }

        public Double nextDouble() throws IOException {
            return Double.parseDouble(next());
        }
    }

    private static class Pair<S, T> {
        public S first;
        public T second;

        public Pair(S first, T second) {
            this.first = first;
            this.second = second;
        }
    }
}",khlyting
862,"public class Solution {
   
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        int T = Integer.parseInt(in.readLine());
        for (int e = 0; e < T; e++) {
            StringTokenizer st = new StringTokenizer(in.readLine());
            int N = Integer.parseInt(st.nextToken()), K = Integer.parseInt(st.nextToken());
            double ans = 0;
            for (int i = 0; i < K; i++) {
                StringTokenizer st2 = new StringTokenizer(in.readLine());
                int R = Integer.parseInt(st2.nextToken()), P = Integer.parseInt(st2.nextToken());
                ans += P;
                System.out.println(""T "" + ((int)(Math.random()*N + 1)));
            }
            StringTokenizer st2 = new StringTokenizer(in.readLine());
            int R = Integer.parseInt(st2.nextToken()), P = Integer.parseInt(st2.nextToken());
            ans += P;
            ans = ans / 2;
            ans = ",kevinz1423
603,"public class Solution {
    public static void main(String[] args) {
        (new Solution()).readInput();
    }

    public void readInput() {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int caseCount = in.nextInt();
        for (int caseId = 1; caseId <= caseCount; ++caseId) {
            play(in);
        }
    }

    private void play(Scanner in){
        Random r = new Random();
        while(true) {
            int i = r.nextInt(256);
            String binaryString = Integer.toBinaryString(i);
            while (binaryString.length() < 0) {
                binaryString = ""0"" + binaryString;
            }
            System.out.print(binaryString);
            int result = ",dboteanu
536,"public class Solution {

    private static final Boolean FROM_FILE = Boolean.FALSE;

    public static void main(String[] args) throws IOException{
        BufferedReader br;
        BufferedWriter bw;

        if(FROM_FILE){
            br = new BufferedReader(new FileReader(""C2022QR1E.in""));
        } else {
            br = new BufferedReader(new InputStreamReader(System.in));
        }

        try {
            if(FROM_FILE) {
                File file = new File(""C2022QR1E.out"");
                if (!file.exists()) {
                    file.createNewFile();
                }
                bw = new BufferedWriter(new FileWriter(file.getAbsoluteFile()));
            } else {
                bw = new BufferedWriter(new OutputStreamWriter(System.out));
            }

            String line = br.readLine();
            String[] q,r;

            int tests = Integer.parseInt(line);//100
            int n,k;
            int maxk = 8000;
            long max;

            // max n is 10000
            // min is n/2 - islands of 2 -> 5 000
            // max is n*(n-1)/2 -> 5000*9999 = 49 995 000

            for(int i = 0; i < tests; i++){
                line = br.readLine();
                q = line.split(""\\\s+"");
                n = Integer.parseInt(q[0]);
                // same k for all tests?
                k = Integer.parseInt(q[1]);

                max = 0L;
                // read first room
                line = br.readLine();
                if(k >= n){
                    // enough tries
                    for(int j = 0; j < n; j++){
                        bw.write(""T""+(j+1)+""
"");
                        bw.flush();

                        line = br.readLine();
                        q = line.split(""\\\s+"");
                        max+= Integer.parseInt(q[1]);
                    }
                    // each was counted twice
                    max /= 2;
                    bw.write(""E""+(max)+""
"");
                    bw.flush();
                    continue;
                }

                // not enough tries, try all k
                // 8000 from 10000 means a 8% random sample
                for(int j = 0; j < k; j++){
                    bw.write(""T""+(ThreadLocalRandom.current().nextInt(1, n + 1))+""
"");
                    bw.flush();

                    line = br.readLine();
                    q = line.split(""\\\s+"");
                    max+= Integer.parseInt(q[1]);
                }

                double average = (double) max / k;

                double uniform = average * n;

                max = Math.round(uniform/2);

                bw.write(""E""+(max)+""
"");
                bw.flush();
            }

            if(FROM_FILE) {
                bw.close();
            }
        } finally {
            if(FROM_FILE) {
                br.close();
            }
        }
    }
}",araver
453,"public class Solution {


    public static void main(String[] args) throws Exception {

        int t=sc.nextInt();
       out: while(t-->0){
            int cnt=8;
            while(true){
                String s="""";
                for(int i=0;i<cnt;i++)s=s+""1"";
                for(int i=0;i<8-cnt;i++)s=s+""0"";

                pw.println(s);
                pw.flush();
                int x=sc.nextInt();
                cnt=x;
                if(x==-1){
                    break out;
                }

                if(x==0){
                    break;
                }
            }
        }

        pw.close();
    }

    static class Scanner {
        StringTokenizer st;
        BufferedReader br;

        public Scanner(InputStream s) {
            br = new BufferedReader(new InputStreamReader(s));
        }

        public Scanner(FileReader r) {
            br = new BufferedReader(r);
        }

        public String next() throws IOException {
            while (st == null || !st.hasMoreTokens())
                st = new StringTokenizer(br.readLine());
            return st.nextToken();
        }

        public int nextInt() throws IOException {
            return Integer.parseInt(next());
        }

        public long nextLong() throws IOException {
            return Long.parseLong(next());
        }

        public String nextLine() throws IOException {
            return br.readLine();
        }

        public double nextDouble() throws IOException {
            String x = next();
            StringBuilder sb = new StringBuilder(""0"");
            double res = 0, f = 1;
            boolean dec = false, neg = false;
            int start = 0;
            if (x.charAt(0) == '-') {
                neg = true;
                start++;
            }
            for (int i = start; i < x.length(); i++)
                if (x.charAt(i) == '.') {
                    res = Long.parseLong(sb.toString());
                    sb = new StringBuilder(""0"");
                    dec = true;
                } else {
                    sb.append(x.charAt(i));
                    if (dec)
                        f *= 10;
                }
            res += Long.parseLong(sb.toString()) / f;
            return res * (neg ? -1 : 1);
        }

        public long[] nextlongArray(int n) throws IOException {
            long[] a = new long[n];
            for (int i = 0; i < n; i++)
                a[i] = nextLong();
            return a;
        }

        public Long[] nextLongArray(int n) throws IOException {
            Long[] a = new Long[n];
            for (int i = 0; i < n; i++)
                a[i] = nextLong();
            return a;
        }

        public int[] nextIntArray(int n) throws IOException {
            int[] a = new int[n];
            for (int i = 0; i < n; i++)
                a[i] = nextInt();
            return a;
        }

        public Integer[] nextIntegerArray(int n) throws IOException {
            Integer[] a = new Integer[n];
            for (int i = 0; i < n; i++)
                a[i] = nextInt();
            return a;
        }

        public boolean ready() throws IOException {
            return br.ready();
        }

    }

    static class pair implements Comparable<pair> {
        long x;
        long y;

        public pair(long x, long y) {
            this.x = x;
            this.y = y;
        }

        public String toString() {
            return x + "" "" + y;
        }

        public boolean equals(Object o) {
            if (o instanceof pair) {
                pair p = (pair) o;
                return p.x == x && p.y == y;
            }
            return false;
        }

        public int hashCode() {
            return new Long(x).hashCode() * 31 + new Long(y).hashCode();
        }

        public int compareTo(pair other) {
            if (this.x == other.x) {
                return Long.compare(this.y, other.y);
            }
            return Long.compare(this.x, other.x);
        }
    }

    static class tuble implements Comparable<tuble> {
        int x;
        int y;
        int z;

        public tuble(int x, int y, int z) {
            this.x = x;
            this.y = y;
            this.z = z;
        }

        public String toString() {
            return x + "" "" + y + "" "" + z;
        }

        public int compareTo(tuble other) {
            if (this.x == other.x) {
                if (this.y == other.y) {
                    return this.z - other.z;
                }
                return this.y - other.y;
            } else {
                return this.x - other.x;
            }
        }
    }

    static long mod = 1000000007;
    static Random rn = new Random();
    static Scanner sc = ",ZerooCool
838,"public class Solution {

    public static void main(String[] args) {

        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.

        int r,c;
        for (int i = 1; i <= t; i++) {
            System.out.print(""Case #"" + i + "":"");
            r = in.nextInt();
            c = in.nextInt();
            getASCII(r,c);
        }

    }

    public static void getASCII(int r, int c){
        int row = r + r + 1;
        int column = c + c + 1;

        for (int i = 0; i< row; i++){
            for (int j = 0; j < column; j++) {

                if((i==0 || i==1) && (j== 0 || j==1) ){
                    System.out.print(""."");
                    continue;
                }

                int jj = 0;
                if(i%2 == 0){
                    while(jj < (column-j)){
                        jj++;
                        if(jj%2 == 0){
                            System.out.print(""-"");
                        }else{
                            System.out.print(""+"");
                        }
                    }
                }else{
                    while(jj < (column-j)){
                        jj++;
                        if(jj%2 == 0){
                            System.out.print(""."");
                        }else{
                            System.out.print(""|"");
                        }
                    }
                }
                System.",jonathan38m
1091,"public class Solution {

    public static void main(String[] args) {
        Scanner sc = null;
        sc = new Scanner(System.in);
       int T = sc.nextInt();
        for (int t = 0; t < T; t++) {
            int N = sc.nextInt();
            int[] F = new int[N];
            int[] P = new int[N];
            for (int i = 0; i < N; i++) {
                F[i] = sc.nextInt();
            }
            for (int i = 0; i < N; i++) {
                P[i] = sc.nextInt();
            }

            Node[] nodes = new Node[N + 1];
            nodes[0] = new Node(0, 0);  //abyss
            nodes[0].out = new Edge(nodes[0], nodes[0]);
            for (int i = 0; i < N; i++) {
                Node n = new Node(i + 1, F[i]);
                nodes[i + 1] = n;
                Edge e1 = new Edge(n, nodes[P[i]]);
                n.out = e1;
                Edge e2 = new Edge(nodes[P[i]], n);
                nodes[P[i]].in.add(e2);
            }

            /*Stack<Node> stack = new Stack<Node>();

            // Mark all the vertices as not visited
            boolean visited[] = new boolean[N + 1];
            for (int i = 0; i < N + 1; i++) {
                visited[i] = false;
            }
            for (int i = 0; i < N + 1; i++)
                if (visited[i] == false)
                    topologicalSortUtil(nodes[i], visited, stack);
*/
            // Print contents of stack
            //make chain
//            Collections.reverse(stack);
            ArrayList<ArrayList<Node>> al = new ArrayList<>();
            for (Node n : nodes) {
//                Node n = stack.pop();
//                if (debug)
                if (n.in.size() == 0) {
                    ArrayList<Node> chain = new ArrayList();
                    Node n1 = n;
                    chain.add(n1);
                    do {
                        n1 = n1.out.to;
                        chain.add(n1);
                    }
                    while (n1.id != 0);
                    al.add((ArrayList<Node>) chain.clone());
                    /*int size = N;
                    int oldSize = chain.size();
                    while (size-- > 0) {
                        ArrayList<Node> cl = (ArrayList<Node>) chain.clone();
                        while (cl.size() > 1 && cl.get(cl.size() - 1).in.size() >= size) {
                            cl.remove(cl.size() - 1);
//                    chain.remove(0);
                        }
                        if (cl.size() != oldSize) {
                            al.add((ArrayList<Node>) cl.clone());
                            oldSize = cl.size();
                        }
                    }*/
                    //find combinations of chains to equal full set
//                    int max=recurs(al);

                }
            }


//            for (ArrayList<Node> chain : al) {
//                int max = Integer.MIN_VALUE;
////                int min = Integer.MAX_VALUE;
//                for (int i = 0; i < chain.size(); i++) {
//                    max = Math.max(chain.get(i).fun, max);
////                    min = Math.min(chain.get(i).fun, min);
//                }
//            }

            //recursion
            //F(x)=max(click it, don't click it)
//            boolean[] vector=new boolean[al.size()];
//            int max=recurs(al,vector);
            maxx = 0;
            recurs(al, new ArrayList<Node>(), N);
            System.out.println(""Case #"" + (t + 1) + "": "" + maxx);
        }

    }

    private static int maxx;

    private static void recurs(ArrayList<ArrayList<Node>> al, ArrayList<Node> nodes, int N) {

        boolean[] visited = new boolean[N + 1];
        int cnt = 0;
        if (nodes.size() == al.size()) {

            for (int i = 0; i < nodes.size(); i++) {
                int max1 = 0;
                Node n54 = nodes.get(i);
                while (n54.id > 0) {
                    //System.out.println(n54.id+"":""+n54.fun+"" ""+max1);
                    if (!visited[n54.id]) {
                        max1 = Math.max(max1, n54.fun);
                        if (n54.id>0)visited[n54.id] = true;

                    } else {
                        
                    }
                    n54 = n54.out.to;
//                    else break;

                }
                //System.out.println(n54.id+"":""+n54.fun+"" ""+max1);
                cnt += max1;
            }
            //System.out.println(cnt+""	""+Arrays.toString(nodes.toArray()));
            maxx=Math.max(maxx,cnt);
        } else {
 /*       if (cnt==N+1){
            return max1;
        }
        max1=Integer.MIN_VALUE;*/
            int mm = 0;
            for (int i = 0; i < al.size(); i++) {
                if (nodes.contains(al.get(i).get(0))) {
                    continue;
                }
//            int mm=0;
                ArrayList<Node> n1 = (ArrayList<Node>) nodes.clone();
//            for (Node n2:al.get(i)){
//                n1.add(n2);
//                mm+=n2.fun;
//            }
                n1.add(al.get(i).get(0));
                recurs(al, n1, N);
            }
//            System.out.println(""*""+mm+""	""+Arrays.toString(nodes.toArray()));
//            if (mm == 0) {
//            return mm;
//            }
//            return 0;
        }
    }


    // A recursive function used by topologicalSort
    static void topologicalSortUtil(Node n, boolean[] visited, Stack<Node> stack) {
        // Mark the current node as visited.
        visited[n.id] = true;
        Edge i;

        // Recur for all the vertices adjacent
        // to thisvertex
        Iterator<Edge> it = n.in.iterator();
        while (it.hasNext()) {
            i = it.next();
            if (!visited[i.to.id])
                topologicalSortUtil(i.to, visited, stack);
        }

        // Push current vertex to stack
        // which stores result
        stack.push(n);
    }


    static class Node {
        Edge out;
        ArrayList<Edge> in = new ArrayList<>();
        int id;
        int fun;

        @Override
        public String toString() {
            return ""Node{"" +
                    ""out="" + out +
                    "", in="" + in.size() +
                    "", id="" + id +
                    "", fun="" + fun +
                    '}';
        }

        Node(int id, int fun) {
            this.id = id;
            this.fun = fun;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Node node = (Node) o;
            return id == node.id;
        }

        @Override
        public int hashCode() {
            return Objects.hash(id);
        }
    }

    static class Edge {
        Node from;
        Node to;

        @Override
        public String toString() {
            return ""Edge{"" +
                    ""from="" + from.id +
                    "", to="" + to.id +
                    '}';
        }

        public Edge(Node from, Node to) {
            this.from = from;
            this.to = ",raver1975
88,"public class Solution 
{
    public static void main(String[] args) 
	{
		Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));//make scanner
		int t = in.nextInt();//number of test cases
		for (int i = 1; i <= t; i++) //iterate through test cases
		{
			int r = in.nextInt();
			int c = in.nextInt();
			
			System.out.println(""Case #"" + i + "":"");
			
			for(int row = 0; row < r; row++)
			{
				int col;
				
				if (row == 0)//top-start
				{
					System.out.print(""..+"");
					col = 1;
				}
				else
				{
					System.out.print(""+"");
					col = 0;
				}
				
				for(; col < c; col++)//top-rest
				{
					System.out.print(""-+"");
				}
				
				System.out.println();
				
				if (row == 0)//body-start
				{
					System.out.print(""..|"");
					col = 1;
				}
				else
				{
					System.out.print(""|"");
					col = 0;
				}
				
				for(; col < c; col++)//body-rest
				{
					System.out.print("".|"");
				}
				
				System.out.println();
			}
			
			System.out.print(""+"");
			
			for(int col = 0; col < c; col++)//top-rest
			{
				System.out.print(""-+"");
			}
			
			System.out.println();

		}

		in.",CoCoCoder
1022,"public class Solution {

    public static void main(String... args) {
        Scanner sc = new Scanner(System.in);
        int count = sc.nextInt();
        for (int i = 0; i < count; i++) {
            int size = sc.nextInt();
            Deque<Integer> pancakes = new LinkedList<>();
            for (int j = 0; j < size; j++) {
                pancakes.add(sc.nextInt());
            }
            System.out.println(""Case #"" + (i + 1) + "": "" + count(pancakes));
        }
    }

    public static int count(Deque<Integer> pancakes) {
        int prev = -1;
        int result = -1;
        while(true) {
            if (pancakes.isEmpty()) {
                break;
            }
            int left = pancakes.getFirst();
            int right = pancakes.getLast();
            boolean leftValid = left >= prev;
            boolean rightValid = right >= prev;
            if (!leftValid && !rightValid) {
                break;
            }
            result++;
            if (leftValid && rightValid) {
                if (left < right) {
                    prev = pancakes.getFirst();
                    pancakes.removeFirst();
                } else {
                    prev = pancakes.getLast();
                    pancakes.removeLast();
                }
            }else if (leftValid) {
                prev = pancakes.getFirst();
                pancakes.removeFirst();
            }else {
                prev = ",petrus
1213,"class Solution{
public static void main(String[] args)
{
    System.out.println(100);
    System.out.println(145);
    Long s=",sriniharika
1322,"public class Solution {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
		int n = scanner.nextInt();
        for (int i = 0; i < n; i++) {
			int R = scanner.nextInt();
			int C = scanner.nextInt();
			System.out.println(""Case #""+(i+1)+"":"");
			System.out.println(get(R,C));
		}
    }

    public static String get(int R, int C) {
        int colTotal = 2*C+1;
        String edge = """";
        String middle = """";
        for(int i=0; i<colTotal; i++) {
            if(i%2==0) {
                edge = edge + ""+"";
                middle = middle + ""|"";
            } else {
                edge = edge + ""-"";
                middle = middle + ""."";
            }
        }

        String firstEdge = "".."" + edge.substring(2,edge.length());
        String firstMiddle = ""."" + middle.substring(1,middle.length());
        String result = firstEdge + ""
"" + firstMiddle + ""
"" + edge;
        for (int i=0; i<R-1; i++) {
            result = result + ""
"" + middle + ""
"" + edge;
        }
        return result;
    }
}",xinyou
652,"public class Solution {

    public static void main(String[] args) {
        
        Scanner scan = new Scanner(System.in); 
        int numOfCases = scan.nextInt();
        
        int x = 1; // Test Case Number (starting from 1)
        
        int r = 0;
        int c = 0;
        
        for (int i = 0; i < numOfCases; i++) {
            r = scan.nextInt();
            c = scan.nextInt();
            
            System.out.print(""Case #"" + x + "": "");
            
            for (int j = 0; j < 2 * r + 1; j++) { 
                System.out.println();
                for (int k = 0; k < 2 * c + 1; k++) {
                    if (j % 2 == 0) {
                        if (k < 2 && j < 2) {
                            System.out.print(""."");
                        }
                        else if (k == 2 * c) {
                            System.out.print(""+"");
                        }
                        else {
                            if (k % 2 == 0) {
                                System.out.print(""+"");
                            }
                            else {
                                System.out.print(""-"");
                            }
                        }
                    }
                    else {
                        if ((k < 2) && (j > 2)) {
                            System.out.print(""."");
                        }
                        else if (k == 2 * c) { 
                            System.out.print(""|"");
                        }
                        else {
                            if (k % 2 == 0) {
                                System.out.print(""|"");
                            }
                            else {
                                System.out.print(""."");
                            }
                        }
                    }
                }
            }
        x++;  
        System.",dtarde
448,"public class Solution {
    public static void main(String[] args) throws IOException {
        Scanner sc = new Scanner(System.in);
        PrintWriter pw = new PrintWriter(System.out);
        int t = sc.nextInt();
        int n = sc.nextInt();
        int k = sc.nextInt();
        for (int tc = 1; tc <= t; tc++) {
            int[] a = new int[n];
            for (int i = 0; i < n; i++) {
                a[i] = sc.nextInt() - 1;
            }
            while (true) {
                int color = 1;
                int[] c = new int[n];
                for (int i = 0; i < n; i++) {
                    if (c[i] != 0)
                        continue;
                    int cur = i;
                    while (c[cur] == 0) {
                        c[cur] = color;
                        cur = a[cur];
                    }
                    color++;
                }
                for (int i = 0; i < n; i++) {
                    pw.print(c[i] + "" "");
                }
                pw.println();
                pw.flush();
                int res = sc.nextInt();
                if (res == -1) {
                    System.exit(0);
                }
                if (res != 0) {
                    break;
                }
                for (int i = 0; i < n; i++) {
                    a[i] = sc.nextInt() - 1;
                }
            }
        }
        pw.close();
    }

    static class Scanner {
        BufferedReader br;
        StringTokenizer st;

        public Scanner(InputStream s) {
            br = new BufferedReader(new InputStreamReader(s));
        }

        public Scanner(FileReader f) {
            br = new BufferedReader(f);
        }

        public String next() throws IOException {
            while (st == null || !st.hasMoreTokens())
                st = new StringTokenizer(br.readLine());
            return st.nextToken();
        }

        public int nextInt() throws IOException {
            return Integer.parseInt(next());
        }

        public long nextLong() throws IOException {
            return Long.parseLong(next());
        }

        public double nextDouble() throws IOException {
            return Double.parseDouble(next());
        }

        public int[] nextIntArr(int n) throws IOException {
            int[] arr = new int[n];
            for (int i = 0; i < n; i++) {
                arr[i] = ",YahiaSherif
148,"public class Solution { //Solution
	static int INF = (int)(1e9);
	static long mod = (long)(1e9)+7;
	static long mod2 = 998244353;
	static long[] segtree;
	static char[] curans;
	static long ans;	
	static String S;
	static ArrayList<Integer>[] graph;
	static boolean[] vis;
	static int[] a;
	static int N;
	static long K;
	static long[] fact;
	static ArrayList<Long> pos;
	static ArrayList<Long> neg;
	static long[] max;
	static int[] dp;
	public static void main(String[] args) {  //Cash out
		/**/
		FastScanner I = new FastScanner(); //Input
		OutPut O = new OutPut(); //Output
		
		int T = I.nextInt();
		
		for (int i = 1; i <= T; i++) {
			int N = I.nextInt();
			
			int[] a = new int[N];
			//int[] dp = new int[1000001];
			
			for (int j = 0; j < N; j++) {
				int x = I.nextInt();
				a[j] = x;
				//dp[x] += 1;
			}
			
			//int ans = 0; 
			// Can never be more than length of the array since there are that many die 
			//in the first place

			/*for (int j = 4; j <= 1000000; j++) { // j = max_cap
				ans += Math.max(0, Math.min(j, dp[j]) - ans);
			}*/
			
			Arrays.sort(a);
			
			int cur_max = 0;
			
			for (int j = 0; j < N; j++) {
				if (a[j] >= cur_max + 1) {
					cur_max += 1;
				}
			}
			
			O.pln(""Case #"" + i + "": "" + cur_max);
		}
		
	}
	
	public static long C(int N, int K) {
		long ans = fact[N];
		ans *= FastExp(fact[K], mod - 2);
		ans %= mod;
		
		ans *= FastExp(fact[N - K], mod - 2);
		ans %= mod;
		
		return ans;
	}
	
	
	public static double[][] matrix_exp(double[][] a, long exp, long mod) {
		int R = a.length;
		int C = a[0].length;
		double[][] ans = new double[R][C];
		
		boolean mult_yet = false;
		
		while (exp > 0) {
			if (exp % 2 == 1) {
				if (!mult_yet) {
					mult_yet = true;
					for (int i = 0; i < R; i++) {
						for (int j = 0; j < C; j++) {
							ans[i][j] = a[i][j]; 
						}
					}
				}else {
					double[][] new_ans = mult(ans, a, mod);
					for (int i = 0; i < R; i++) {
						for (int j = 0; j < C; j++) {
							ans[i][j] = new_ans[i][j]; 
						}
					}
				}
			}
			
			double[][] new_a = mult(a, a, mod); // a = a^2 (binary exponentiation on matrices)
			for (int i = 0; i < R; i++) {
				for (int j = 0; j < C; j++) {
					a[i][j] = new_a[i][j]; 
				}
			}
			exp /= 2;
		}
		
		return ans;
	}
	public static double[][] mult(double[][] a, double[][] b, long mod) {
		int r1 = a.length;
		int c1 = a[0].length;
		int r2 = b.length;
		int c2 = b[0].length;
		//Requires: c1 = r2
		
		double[][] ans = new double[r1][c2];
		for (int r = 0; r < r1; r++) {
			for (int c = 0; c < c2; c++) {
				//Dot product of (a[r])^T and b[c] (as vectors in R^n (n = c1 = r2))
				double[] col_vector = new double[r2];
				double[] row_vector = new double[c1];
				
				for (int i = 0; i < r2; i++) {
					col_vector[i] = b[i][c];
				}
				for (int i = 0; i < c1; i++) {
					row_vector[i] = a[r][i]; 
				}
				
				ans[r][c] = dot_product(row_vector, col_vector, mod);
			}
		}
		return ans;
	}
	
	public static double dot_product(double[] a, double[] b, long mod) {
		double ans = 0;
		int N = a.length; //Requires: a and b are both vectors in R^n
		for (int i = 0; i < N; i++) {
			ans += a[i] * b[i];
		}
		return ans;
	}
	public static double max(double a, double b) {return Math.max(a, b);}
	public static double min(double a, double b) {return Math.min(a, b);}
	public static long min(long a, long b) {return Math.min(a,b);}
	public static long max(long a, long b) {return Math.max(a,b);}
	public static int min(int a, int b) {return Math.min(a,b);}
	public static int max(int a, int b) {return Math.max(a,b);}
	public static long abs(long x) {return Math.abs(x);}
	public static long abs(int x) {return Math.abs(x);}
	public static long ceil(long num, long den) {long ans = num/den; if (num%den!=0) 
	ans++; return ans;}
	public static long GCD(long a, long b) {
		if (a==0||b==0) return max(a,b);
		return GCD(min(a,b),max(a,b)%min(a,b));
	}
	public static long FastExp(long base, long exp) {
		long ans=1;
		while (exp>0) {
			if (exp%2==1) ans*=base;
			exp/=2;
			base*=base;
			base%=mod;
			ans%=mod;
		}
		return ans;
	}
	public static long ModInv(long num,long mod) {return FastExp(num,mod-2);}
	public static int pop(long x) { //Returns number of bits within a number
		int cnt = 0;
		while (x>0) {
			if (x%2==1) cnt++;
			x/=2;
		}
		return cnt;
	}
	static class FastScanner {
		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st=new StringTokenizer("""");
		String next() {
			while (!st.hasMoreTokens())
				try {
					st=new StringTokenizer(br.readLine());
				} catch (IOException e) {
					e.printStackTrace();
				}
			return st.nextToken();
		}
		int nextInt() {return Integer.parseInt(next());}
		long nextLong() {return Long.parseLong(next());};
		double nextDouble() {return Double.parseDouble(next());}
	}
	static class OutPut{
		PrintWriter w = new PrintWriter(System.out);
		void pln(double x) {w.println(x);w.flush();}
		void pln(boolean x) {w.println(x);w.flush();}
		void pln(int x) {w.println(x);w.flush();}
		void pln(long x) {w.println(x);w.flush();}
		void pln(String x) {w.println(x);w.flush();}
		void pln(char x) {w.println(x);w.flush();}
		void pln(StringBuilder x) {w.println(x);w.flush();}
		void pln(BigInteger x) {w.println(x);w.flush();}
		void p(int x) {w.print(x);w.flush();}
		void p(long x) {w.print(x);w.flush();}
		void p(String x) {w.print(x);w.flush();}
		void p(char x) {w.print(x);w.flush();}
		void p(StringBuilder x) {w.print(x);w.flush();}
		void p(BigInteger x) {w.print(x);w.flush();}
		void p(double x) {w.print(x);w.flush();}
		void p(boolean x) {w.",IQEmperor
349,"public class Solution {

    public static void main(String[] args) throws IOException {
        Scanner sc = new Scanner(System.in);
        PrintWriter pw = new PrintWriter(System.out);

        int testCases = sc.nextInt();
        for (int testCase = 1; testCase <= testCases; testCase++) {
            int[] colors = new int[4];
            for (int i = 0; i < 4; i++) {
                colors[i] = sc.nextInt();
            }
            for (int i = 0; i < 2; i++) {
                for (int j = 0; j < 4; j++) {
                    colors[j] = Math.min(colors[j], sc.nextInt());
                }
            }

            int print = 0;
            for (int i = 0; i < colors.length; i++) {
                if (colors[i] > 0) {
                    print++;
                }
            }

            if (print < 3) {
                pw.println(""Case #"" + testCase + "": IMPOSSIBLE"");
                continue;
            } else if (Arrays.stream(colors).sum() > 1_000_000) {
                int remain = Arrays.stream(colors).sum() - 1_000_000;
                for (int i = 0; i < 4 && remain > 0; i++) {
                    if (remain > colors[i]) {
                        remain -= colors[i];
                        colors[i] = 0;
                    } else {
                        colors[i] -= remain;
                        remain = 0;
                    }
                }
            }
            pw.println(""Case #"" + testCase + "": "" + colors[0] + "" "" + colors[1] + "" "" + colors[2] + "" "" + colors[3]);
        }

        pw.close();
        sc.",S
97,"    class Solution {
    	
    	public static int nextInt(Scanner in) {
    		return Integer.parseInt(in.next());
    	}
    	
    	public static void main(String[] args) throws IOException {
    		Scanner in = new Scanner(System.in);
    		int t = in.nextInt();
    		for(int tc = 1; tc <= t; tc ++) {
    			final int N = nextInt(in);
    			int K = nextInt(in);
    			final int MAX_TOUR_SIZE = Math.max(0, (K - 90) / 90);
    			List <Integer> perm = new ArrayList <Integer>();
    			for(int i = 1; i <= N; i ++)
    				perm.add(i);
    			int next = 0;
    			Collections.shuffle(perm);
    			boolean[] done = new boolean[N + 1];
    			long sum = 0;
				int Ri = nextInt(in);
				int Pi = nextInt(in);
				done[Ri] = true;
				sum += Pi;
    			while(K > 0) {
    				for(int i = 0; i < MAX_TOUR_SIZE && K > 0; i ++) {
    					System.out.println(""W"");
    					Ri = nextInt(in);
    					Pi = nextInt(in);
    					K --;
    					if(!done[Ri]) {
    						done[Ri] = true;
    						sum += Pi;
    					} else {
    						break;
    					}
    				}
    				if(K > 0) {
						int S = perm.get(next ++);
						while(done[S] && next < N)
							S = perm.get(next ++);
						if(done[S])
							break;
						System.out.println(""T "" + S);
    					Ri = nextInt(in);
    					Pi = nextInt(in);
    					K --;
    					done[Ri] = true;
						sum += Pi;
					}
    			}
    			int total = 0;
    			for(int i = 1; i <= N; i ++)
    				if(done[i])
    					total ++;
    			long E = ",Deido
399,"class Solution{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        int index = T;
        while(T-- > 0){
            int N = sc.nextInt();
            int[] d = new int[N];
            int ans = 0;
            int l=0;
            for(int i=0;i<N;i++){
                d[i]=sc.nextInt();
            }
            Arrays.sort(d);
            for(int i=0;i<N;i++){
                if(d[i] >= ++l){
                    ans++;
                }
            }
            System.",Sujit_Das
1325,"public class Solution {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
		int n = scanner.nextInt();
        for (int i = 0; i < n; i++) {
            int N = scanner.nextInt();
            List<Node> rootList = new ArrayList<>();
            Node[] arr = new Node[N];
            for(int j=0; j<N; j++) {
                arr[j] = new Node(j+1, scanner.nextLong());
		    }
            for(int j=0; j<N; j++) {
                int p = scanner.nextInt();
                if(p==0) {
                    rootList.add(arr[j]);
                } else {
                    Node node = arr[p-1];
                    node.son.add(arr[j]);
                    arr[p-1] = node;
                }
            }
            long total = 0;
            for (int k=0; k<rootList.size(); k++) {
                total += dfs(rootList.get(k)).sum;
            }
            System.out.print(""Case #""+(i+1)+"": "");
            System.out.println(total);
       }
    }

    public static Data dfs(Node node) {
        // 无孩子
        if(node.son.size()==0) {
            return new Data(node.value, node.value);
        }
        // 多个孩子
        int n = node.son.size();
        long minSon = Long.MAX_VALUE;
        int sum = 0;
        for (int i = 0; i < n; i++) {
            Data sonData = dfs(node.son.get(i));
            minSon = Math.min(sonData.minV, minSon);
            sum += sonData.sum;
        }

        Data result;
        if(node.value > minSon) {
            result = new Data(sum+(node.value-minSon), node.value);
            System.out.println(JSON.toJSONString(result));
            return result;
        } else {
            result = new Data(sum, minSon);
            System.out.println(result);
            return result;
        }
    }

    public static class Data {
        public long sum;
        public long minV;
        public Data(long sum, long minV) {
            this.sum = sum;
            this.minV = minV;
        }
    }

    static class Node {
        public long value;
        public int i;
        public List<Node> son;
        public Node(int i, long value) {
            this.i = i;
            this.value = value;
            son = ",xinyou
1162,"class Solution {

	public static void main ( String [] args ) {
		Scanner s = new Scanner ( System.in);
			
		int T = s.nextInt(); 
		for ( int t=1; t<=T; t++) {  
			int N = s.nextInt(); 
			int k = s.nextInt();
			
			int total=0;
			int seen=0;
			int room = s.nextInt(); 
			int passages = s.nextInt(); 
			total += passages;
			seen+=1;
			
			Random rnd = new Random();
			for ( int i=0; i<k; i++) {
				int next = rnd.nextInt(N-1)+1;
				System.out.println(""T "" + next);
				room = s.nextInt(); 
				passages = s.nextInt(); 
				total += passages;
				seen+=1;
			}
			double avg = total/(double)seen;
			double expected = (N-1)*2;
			
			double estimation = (N*avg)/2;
			System.out.print(""E ""+(int)estimation);
			
			//System.out.print(false)
//			for ( int i=N-1; i<N*N; i++) {
//				double aux = expected/(double)N;
//				expected+=2;
//				if (aux>avg) {
//					System.out.print(""E ""+i);
//					break;
//				}
//			}
			
		}
	}  
	
}",slycer
610,"public class Solution {
    public static void main(String[] args) {
        (new Solution()).readInput();
    }


    public void readInput() {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int caseCount = in.nextInt();
        for (int caseId = 1; caseId <= caseCount; ++caseId) {
            int n = in.nextInt();
            int k = in.nextInt();
            List<Long> numbers = new ArrayList<>();
            for (int i=0;i<n;i++) {
                numbers.add(in.nextLong());
            }
            try {
                System.out.println(""Case #"" + caseId + "": "" + solveMaster(numbers,k));
            } catch (Exception e) {
                System.out.println(""Case #"" + caseId + "": "" + ""IMPOSSIBLE"");
            }
        }
    }

    private String solveMaster(List<Long> numbers,int k) throws Exception{
        List<Long> originalList = new ArrayList<>();
        originalList.addAll(numbers);

        List<Long> copiedNumbers = new ArrayList<>();
        copiedNumbers.addAll(originalList);

        try {
            return solve(copiedNumbers, k);
        } catch (Exception e) {
            //
        }

        if (k>1){
            for (int sign=-1;sign<2;sign+=2){
                for (int i=1;i<1000;i++){
                    copiedNumbers = new ArrayList<>();
                    copiedNumbers.addAll(originalList);


                    long add=(i*sign);
                    copiedNumbers.add(add);

                    try {
                        return add+"" ""+solve(copiedNumbers, k-1);
                    } catch (Exception e) {
                        //
                    }

                }
            }
        }
        return ""IMPOSSIBLE"";
    }

    private String solve(List<Long> numbers,int k) throws Exception{
        if (k==0){
            throw new Exception();
        }

        long a=0;
        long b=0;
        for (long number : numbers){
            a=a+ number*number;
            b=b+number;
        }

        if (a==0){
            return ""0"";
        } else if (b==0){
            return ""IMPOSSIBLE"";
        } else {
            double result = ((a-b*b)/(2.0*b));
            long longResult = Math.round(result);
            if (result==longResult){
                return """"+longResult;
            } else {
                if (longResult == 0) {
                    longResult++;
                }
                numbers.add(longResult);
                return """" + longResult + "" "" + solve(numbers, k - 1);
            }
//
//            long pairSums = 0;
//            for (int i = 0; i < numbers.size() - 1; i++) {
//                for (int j = i + 1; j < numbers.size(); j++) {
//                    pairSums = pairSums + (numbers.get(i) * numbers.get(j));
//                }
//            }
//
//            long sum = 0;
//            for (int i = 0; i < numbers.size(); i++) {
//                sum += numbers.get(i);
//            }
//
//            System.out.println(""P: ""+pairSums+""	""+""S: ""+sum);
//
//            double result = -1 * ((double) pairSums) / sum;
//            long longResult = Math.round(result);
//
//            if (result == longResult) {
//                return """" + longResult;
//            } else {
//                if (longResult == 0) {
//                    longResult++;
//                }
//                numbers.add(longResult);
//                return """" + longResult + "" "" + solve(numbers, k - 1);
//            }

        }

    }
}",dboteanu
21,"public class Solution {


    public void start() throws Exception {
       BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
       
        int t = Integer.parseInt(in.readLine());
        for (int i = 1; i <= t; i++) {
            System.out.print(""Case #"" + i + "": "");
            solve(in);
        }
    }

    private void solve(BufferedReader in) throws Exception {
        int N = Integer.parseInt(in.readLine());
        Node[] nodes = new Node[N + 1];
        Node abyss = new Node();
        abyss.fun = 0;
        abyss.index = 0;
        nodes[0] = abyss;
        String[] args = in.readLine().split("" "");
        for (int i = 1; i <= N; i++) {
            Node n = new Node();
            n.fun = Integer.parseInt(args[i - 1]);
            n.index = i;
            nodes[i] = n;
        }



        args = in.readLine().split("" "");
        for (int i = 1; i <= N; i++) {
            nodes[Integer.parseInt(args[i - 1])].children.add(nodes[i]);
        }
        System.out.println(fun(nodes[0]));

    }

    private int fun(Node n) {
        if (n.children.size() == 0) {
            n.score = n.fun;
            return n.fun;
        }
        int min = Integer.MAX_VALUE;
        int sum = n.fun;
        for (Node c : n.children) {
            int f = fun(c);
            min = Math.min(min, f);
            sum += f;
        }
        n.score = sum - Math.min(min, n.fun);
        n.fun = Math.max(n.fun, min);
        return n.score;
    }


    private class Node {
        List<Node> children = new LinkedList<>();
        int fun;
        int index;
        int score;
    }

    public static void main(String[] args) throws Exception {
        Solution s = ",Abolfazl
150,"public class PancakeDeque {

  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int T = sc.nextInt();
    for (int i = 0; i < T; i++) {
      int N = sc.nextInt();
      int[] D = new int[N];
      for (int j = 0; j < N; j++) {
        D[j] = sc.nextInt();
      }
      int leftDl = D[0];
      int rightDl = D[N - 1];
      int leftl = 1;
      int rightl = 1;
      leftl += pancakeHelper(D, 1, N, leftDl);
      rightl += pancakeHelper(D, 0, N-1, rightDl);
      int l = Math.max(leftl, rightl);
      System.out.println(""Case #"" + (i + 1) + "": "" + l);
    }
  }

  public static int pancakeHelper(int[] D, int j, int N, int max) {
    if (j>=N) {
      return 0;
    }
    int leftDl = D[j];
    int rightDl = D[N - 1];
    int leftl = 0;
    int tmax = max;
    if(leftDl >= max) {
      leftl++;
      tmax = leftDl;
    }
    int rightl = 0;
    if(rightDl >= max) {
      rightl++;
      max = ",Jai03kh
1131,"public class Solution {
    Scanner sc       = new Scanner(System.in);
    static final String FILENAME = ""A-small"";
    static final String IN       = FILENAME + "".in"";
    static final String OUT      = FILENAME + "".out"";
    PrintStream out      = System.out;

    private void run() throws Exception {
        // out = new PrintStream(new FileOutputStream(OUT));
        int T = sc.nextInt();
        for (int t = 1; t <= T; t++) {
            int n = sc.nextInt(); int k = sc.nextInt();
            int [] rooms = new int[n];
            for(int i = 0; i<n; i++)
                rooms[i] = i + 1;

            int stats[] = new int[n];
            Arrays.fill(stats, 0);
            shuffleArray(rooms);;
            int startPos = 0;
            for(int i = 0, j = 0; i<k + 1; i++, j++) {
                int u = sc.nextInt();
                if(i == 0)
                    startPos = u;
                int deg = sc.nextInt();
                stats[deg]++;
                if(rooms[j] == startPos)
                    j++;
                out.println(""T "" + rooms[j]);
                out.flush();
            }
            double p = 0.;
            double totalW = 0.;
            for(int i = 0; i<n; i++) {
                if(stats[i] != 0) {
                    double degP = (i / (n * 1.)) * stats[i];
                    p += degP;
                    totalW += stats[i];
                }
            }
            p = p / totalW;
            double exp = p * n * ( n - 1) / 2.;
            out.println(""E"" + "" "" + (int) Math.ceil(exp));
            out.flush();
        }
        sc.close();
        out.flush();
        out.close();
    }

    // Implementing Fisher–Yates shuffle
    static void shuffleArray(int[] ar)
    {
        // If running on Java 6 or older, use `new Random()` on RHS here
        Random rnd = ThreadLocalRandom.current();
        for (int i = ar.length - 1; i > 0; i--)
        {
            int index = rnd.nextInt(i + 1);
            // Simple swap
            int a = ar[index];
            ar[index] = ar[i];
            ar[i] = a;
        }
    }

    public static void main(String args[]) throws Exception {
        new Solution().",rkamun
933,"public class Solution {
    // TODO: changes this to  >>>  false
    static final boolean debug = false; // false | true
    ///////////////////////////////////////////
    static final String FILENAME = ""src/main/java/google/codejam/y2021/quali5/"";
    static final String IN = FILENAME + ""sample.in"";
    static final String OUT = FILENAME + ""out.out"";
    ///////////////////////////////////////////

    static boolean[] visited = null;
    static int N = 0;
    static Integer newNode = null;
    static Integer oldNode = null;
    static int P;
    private static void solve() {
        N = in.nextInt();
        int K = in.nextInt();
        visited = new boolean[N];
        Map<Integer, Integer> numEdges = new HashMap<>();
        Map<Integer, Set<Integer>> edges = new HashMap<>();
        int response = N-1;

        T2 R_P = request();
        newNode = (Integer) R_P._1;
        Integer p = (Integer) R_P._2;
        visited[newNode-1] = true;
        numEdges.put(newNode, p);
        // was the last operation a WALK ?
        boolean isLastWalk = false;

        estimate(response);
    }

    static int pointer = 0;
    static int nextUnknown() {
        while (pointer < N) {
            if (visited[pointer] == false) {
                return pointer;
            }
            pointer++;
        }
        return -1;
    }

    static T2 request() {
        int R = in.nextInt();
        int P = in.nextInt();
        if (debug) file(R + "" "" + P);
        return new T2(R, P);
    }
    static T2 walk() {
        out.print(""W"");
        out.flush();
        return request();
    }
    static T2 teleport (int S) {
        out.print(""T "" + S);
        //out.println(S);
        out.flush();
        return request();
    }
    static void estimate(int P) {
        out.print(""E"");
        out.flush();
        out.print(P);
        out.flush();
    }
    static void file(Object s) {
        out.println(s); out.flush();
    }

    private static int print(int[] i) {
        String s = Arrays.stream(i).mapToObj(String::valueOf).collect(Collectors.joining("" ""));
        out.println(s); out.flush();
        if (debug) System.out.println(s);
        return in.nextInt();
    }

    private static Scanner in;
    private static PrintStream out;

    private static void run() throws Exception {
        if (debug) {
            //in = new Scanner(new File(IN));
            in = new Scanner(Solution.class.getResourceAsStream(IN));
            out = new PrintStream(new FileOutputStream(OUT));
        } else {
            in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
            out = System.out;
        }
        int t = in.nextInt();
        for (int i = 1; i <= t; i++) {
            solve();
        }
        in.close();
        out.close();
    }

    public static void main(String[] args) throws Exception {
        run();
//        if (debug)
//            System.in.read();
    }

    static class T2<X, Y> {
        public final X _1;
        public final Y _2;
        T2(X _1, Y _2) {
            this._1 = _1;
            this._2 = _2;
        }
        @Override
        public String toString() ",levios
948,"public class Solution {

	public static void main(String[] args) {
		Scanner s = new Scanner(System.in);
		int t, n, i, j, k, l, temp;
		int vet[];
		
		do {
			t = s.nextInt();
		} while(t < 1 || t > 100);
		
		for(i = 1; i <= t; i++) {
			
			do {
				n = s.nextInt();
			} while(n < 1 || n > 100);
			
			vet = new int[n];
			
			for(j = 0; j < n; j++) {
				vet[j] = s.nextInt();
			}
			
			for(k = 0; k < vet.length; k++) {
				for(l = 0; l < vet.length - 1; l++) {
					
					if(vet[l] > vet[l + 1]) {
						temp = vet[l];
						vet[l] = vet[l + 1];
						vet[l + 1] = temp;
					}
				}
			}
			
			temp = vet[0];
			int cont = 0;	
			while(temp > 0) {
				temp--;
				cont++;
			}
				
			System.out.println(""Case #"" + i + "": "" + cont);
			cont = ",marcosph
670,"public class Solution {
    public static int N;
    public static HashSet<Integer> seen;
    public static long total;
    public static void main(String[] args) throws IOException {
        FastScanner input = new FastScanner(false);
        int T = input.nextInt();
        for (int iter = 1; iter<=T; iter++) {
            int N = input.nextInt();
            int K = input.nextInt();
            seen = new HashSet<>();
            System.out.println(""E ""+trial(N,K));
        }
    }
    public static long trial(int N, int K) throws IOException {
        FastScanner input = new FastScanner(false);
        total = 0;
        for (int i = 0; i<K; i++) {
            int R = input.nextInt();
            int P = input.nextInt();
            seen.add(R);
            total+=P;
            if (seen.size()==N) {
                return total/2;
            }
            System.out.println(""T ""+(i+1));
        }
        int R = input.nextInt();
        int P = input.nextInt();
        seen.add(R);
        total+=P;
        return total*N/2/seen.size();
    }
    private static class FastScanner {
        final private int BUFFER_SIZE = 1 << 16;
        private DataInputStream din;
        private byte[] buffer;
        private int bufferPointer, bytesRead;
        private FastScanner(boolean usingFile) throws IOException {
            if (usingFile) din=new DataInputStream(new FileInputStream(""C:\\\Users\\\skwek\\\IdeaProjects\\\HelloWorld\\\src\\	esting.in""));
            else din = new DataInputStream(System.in);
            buffer = new byte[BUFFER_SIZE];
            bufferPointer = bytesRead = 0;
        }
        private short nextShort() throws IOException {
            short ret = 0;
            byte c = read();
            while (c <= ' ') c = read();
            boolean neg = (c == '-');
            if (neg) c = read();
            do ret = (short)(ret * 10 + c - '0');
            while ((c = read()) >= '0' && c <= '9');
            if (neg) return (short)-ret;
            return ret;
        }
        private int nextInt() throws IOException {
            int ret = 0;
            byte c = read();
            while (c <= ' ') c = read();
            boolean neg = (c == '-');
            if (neg) c = read();
            do ret = ret * 10 + c - '0';
            while ((c = read()) >= '0' && c <= '9');
            if (neg) return -ret;
            return ret;
        }
        public long nextLong() throws IOException {
            long ret = 0;
            byte c = read();
            while (c <= ' ') c = read();
            boolean neg = (c == '-');
            if (neg) c = read();
            do ret = ret * 10 + c - '0';
            while ((c = read()) >= '0' && c <= '9');
            if (neg) return -ret;
            return ret;
        }
        private char nextChar() throws IOException {
            byte c = read();
            while (c <= ' ') c = read();
            return (char)c;
        }
        private String nextString() throws IOException {
            StringBuilder ret = new StringBuilder();
            byte c = read();
            while (c <=' ') c = read();
            do {
                ret.append((char)c);
            } while ((c = read())>' ');
            return ret.toString();
        }
        private void fillBuffer() throws IOException {
            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);
            if (bytesRead == -1)  buffer[0] = -1;
        }
        private byte read() throws IOException ",ekwek
1045,"public class Solution {
    InputStream is;
    FastWriter out;
    String INPUT = """";

    public static void main(String[] args) throws Exception
    {
        new Solution().run();// Here run assign I/O calls solve also tell total time invested
    }

    void solve()
    {
        int t=ni(), p=0;
        while(t-->0)
        {
            System.out.print(""Case #""+ ++p +"": "");
            go();
        }
    }
    void go()
    {
        int arr[]=new int[4];
        Arrays.fill(arr, 1000000);
        for(int i=0;i<3;i++)
        {
            arr[0]=Math.min(arr[0],ni());
            arr[1]=Math.min(arr[1],ni());
            arr[2]=Math.min(arr[2],ni());
            arr[3]=Math.min(arr[3],ni());
        }
        if(arr[0]+arr[1]+arr[2]+arr[3]<1000000)
            System.out.println(""IMPOSSIBLE"");
        else
        {
            int sum=1000000;
            for(int a: arr)
            {
                if(sum<=0)
                    System.out.print(0+"" "");
                else
                    System.out.print(Math.min(sum,a)+"" "");
                sum-=a;
            }
            System.out.println();
        }
    }

    static boolean prime[];
    static int count=0;

    void sieve(int n)
    {
        prime=new boolean[n+1];
        Arrays.fill(prime, true);
        for(int i=2;i<=Math.sqrt(n);i++)
            if(prime[i])
                for(int j=i*i;j<=n;j+=i)
                    prime[j]=false;
    }

    boolean isPrime(int n)
    {
        for(int i=2;i<=Math.sqrt(n);i++)
            if(n%i==0)
                return false;
        return true;
    }

    long gcd(long a,long b)
    {
        if(a==0)
            return b;
        return gcd(b%a,a);
    }

    void run() throws Exception
    {
        is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());
        out = new FastWriter(System.out);

        long s = System.currentTimeMillis();
        solve();
        out.flush();
        tr(System.currentTimeMillis()-s+""ms"");
    }

    byte[] inbuf = new byte[1024];
    public int lenbuf = 0, ptrbuf = 0;

    private int readByte()
    {
        if(lenbuf == -1)throw new InputMismatchException();
        if(ptrbuf >= lenbuf){
            ptrbuf = 0;
            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
            if(lenbuf <= 0)return -1;
        }
        return inbuf[ptrbuf++];
    }

    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }

    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }

    private double nd() { return Double.parseDouble(ns()); }

    private char nc() { return (char)skip(); }

    private String ns()
    {
        int b = skip();
        StringBuilder sb = new StringBuilder();
        while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }

    private char[] ns(int n)
    {
        char[] buf = new char[n];
        int b = skip(), p = 0;
        while(p < n && !(isSpaceChar(b))){
            buf[p++] = (char)b;
            b = readByte();
        }
        return n == p ? buf : Arrays.copyOf(buf, p);
    }

    private int[] ni(int n)
    {
        int[] a = new int[n];
        for(int i = 0;i < n;i++)a[i] = ni();
        return a;
    }

    private long[] nl(int n)
    {
        long[] a = new long[n];
        for(int i = 0;i < n;i++)a[i] = nl();
        return a;
    }

    private Long[] nL(int n) {
        Long[] a = new Long[n];
        for (int i = 0; i < n; i++)
            a[i] = nl();
        return a;
    }

    private Integer[] nI(int n) {
        Integer[] a = new Integer[n];
        for (int i = 0; i < n; i++)
            a[i] = ni();
        return a;
    }

    private char[][] ns(int n, int m) {
        char[][] map = new char[n][];
        for(int i = 0;i < n;i++)map[i] = ns(m);
        return map;
    }

    private int[][] ni(int n, int m) {
        int[][] map = new int[n][];
        for(int i = 0;i < n;i++)map[i] = ni(m);
        return map;
    }

    private long[][] nl(int n, int m) {
        long[][] map = new long[n][];
        for(int i = 0;i < n;i++)map[i] = nl(m);
        return map;
    }

    private Integer[][] nI(int n, int m) {
        Integer[][] map = new Integer[n][];
        for(int i = 0;i < n;i++)map[i] = nI(m);
        return map;
    }

    private Long[][] nL(int n, int m) {
        Long[][] map = new Long[n][];
        for(int i = 0;i < n;i++)map[i] = nL(m);
        return map;
    }

    private int ni() { return (int)nl(); }

    private long nl()
    {
        long num = 0;
        int b;
        boolean minus = false;
        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
        if(b == '-'){
            minus = true;
            b = readByte();
        }

        while(true){
            if(b >= '0' && b <= '9'){
                num = num * 10 + (b - '0');
            }else{
                return minus ? -num : num;
            }
            b = readByte();
        }
    }

    public static class FastWriter
    {
        private static final int BUF_SIZE = 1<<13;
        private final byte[] buf = new byte[BUF_SIZE];
        private final OutputStream out;
        private int ptr = 0;

        private FastWriter(){out = null;}

        public FastWriter(OutputStream os)
        {
            this.out = os;
        }

        public FastWriter(String path)
        {
            try {
                this.out = ",pgthebigshot
671,"public class Solution {
    public static void main(String[] args) throws IOException {
        FastScanner input = new FastScanner(false);
        int T = input.nextInt();
        for (int iter = 1; iter<=T; iter++) {
            System.out.println(""Case #""+iter+"":"");
            int R = input.nextInt();
            int C = input.nextInt();
            System.out.print("".."");
            for (int j = 1; j<C; j++) System.out.print(""+-"");
            System.out.println(""+"");
            System.out.print("".."");
            for (int j = 1; j<C; j++) System.out.print(""|."");
            System.out.println(""|"");
            String line1 = """";
            String line2 = """";
            for (int j = 0; j<C; j++) {
                line1+=""+-"";
                line2+=""|."";
            }
            line1+=""+"";
            line2+=""|"";
            for (int i = 1; i<R; i++) {
                System.out.println(line1);
                System.out.println(line2);
            }
            System.out.println(line1);
        }
    }
    private static class FastScanner {
        final private int BUFFER_SIZE = 1 << 16;
        private DataInputStream din;
        private byte[] buffer;
        private int bufferPointer, bytesRead;
        private FastScanner(boolean usingFile) throws IOException {
            if (usingFile) din=new DataInputStream(new FileInputStream(""C:\\\Users\\\skwek\\\IdeaProjects\\\HelloWorld\\\src\\	esting.in""));
            else din = new DataInputStream(System.in);
            buffer = new byte[BUFFER_SIZE];
            bufferPointer = bytesRead = 0;
        }
        private short nextShort() throws IOException {
            short ret = 0;
            byte c = read();
            while (c <= ' ') c = read();
            boolean neg = (c == '-');
            if (neg) c = read();
            do ret = (short)(ret * 10 + c - '0');
            while ((c = read()) >= '0' && c <= '9');
            if (neg) return (short)-ret;
            return ret;
        }
        private int nextInt() throws IOException {
            int ret = 0;
            byte c = read();
            while (c <= ' ') c = read();
            boolean neg = (c == '-');
            if (neg) c = read();
            do ret = ret * 10 + c - '0';
            while ((c = read()) >= '0' && c <= '9');
            if (neg) return -ret;
            return ret;
        }
        public long nextLong() throws IOException {
            long ret = 0;
            byte c = read();
            while (c <= ' ') c = read();
            boolean neg = (c == '-');
            if (neg) c = read();
            do ret = ret * 10 + c - '0';
            while ((c = read()) >= '0' && c <= '9');
            if (neg) return -ret;
            return ret;
        }
        private char nextChar() throws IOException {
            byte c = read();
            while (c <= ' ') c = read();
            return (char)c;
        }
        private String nextString() throws IOException {
            StringBuilder ret = new StringBuilder();
            byte c = read();
            while (c <=' ') c = read();
            do {
                ret.append((char)c);
            } while ((c = read())>' ');
            return ret.toString();
        }
        private void fillBuffer() throws IOException {
            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);
            if (bytesRead == -1)  buffer[0] = -1;
        }
        private byte read() throws IOException ",ekwek
248,"public class Solution{

    public static void main(String[] args){
int r=0;
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int sum=1000000;
        int T = in.nextInt();
        for (int i=1; i<=T; i++){
           
            int [] C=new int[3];
            int [] M=new int[3];
            int [] Y=new int[3];
            int [] B=new int[3];
            int [] R=new int[4];
        int j=0;
            while (j<3)
          {
           C[j]=in.nextInt();
            M[j]=in.nextInt();
            Y[j]=in.nextInt();
            B[j]=in.nextInt();
          j++;
            }
            Arrays.sort(C);
            Arrays.sort(M);
            Arrays.sort(Y);
            Arrays.sort(B);
         if(C[0]+M[0]+Y[0]+B[0]==sum)
         {r=0;
             R[0]=C[0];
         R[1]=M[0];
         R[2]=Y[0];
         R[3]=B[0];
         }
         else  if(C[0]+M[0]+Y[0]+B[0] || C[1]+M[1]+Y[1]+B[1]  || C[2]+M[2]+Y[2]+B[2]    <sum)
         {                    System.out.println(""Case #"" + i + "": "" + ""IMPOSSIBLE"");
r=1;
         }
         else {r=0;
         if(C[0]<sum)
         {
         R[0]=C[0];
         sum=sum-R[0];}
         else if (C[0]>=sum)
         {R[0]=sum;
         R[1]=0;
         R[2]=0;
         R[3]=0;
         sum=0;
         }
         if(M[0]<sum)
         {
         R[1]=M[0];
         sum=sum-R[1];
      
         
         }
         else if(M[0]>=sum)
         {R[1]=sum;
         R[2]=0;
       R[3]=0;
         sum=0;
         }
            if(Y[0]<sum)
         {  R[2]=Y[0];
         sum=sum-R[2];
         }
         else if(Y[0]>=sum)
         {R[2]=sum;
         R[3]=0;
   
         sum=0;
         }
               if(B[0]<sum)
         {  R[3]=B[0];
         sum=sum-R[3];
         }
         else if(B[0]>=sum)
         {R[3]=sum;
         
   
         sum=0;
         }
            
            
             
            }
            
         if(r==0)
         {
             if((R[0]==0 && R[1] ==0 && R[2] ==0 && R[3]==0) ||(R[0]+R[1]+R[2]+R[3])>1000000 ) 
             {            System.out.println(""Case #"" + i + "": "" + ""IMPOSSIBLE"");

             }
             else {
            System.out.println(""Case #"" + i + "": ""+R[0]+"" ""+R[1]+"" ""+R[2]+"" ""+R[3]+"" "");
                     }}
        }     
            
       
        
        in.",Marwan
445,"public class Solution {
    static Scanner sc = new Scanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);

    public static void main(String[] args) throws IOException {
        int t = sc.nextInt();
        for (int tc = 1; tc <= t; tc++) {
            pw.print(""Case #"" + tc + "":"");
            int ans = 1;
            int n = sc.nextInt();
            int[] a = new int[n];
            for (int i = 0; i < n; i++) a[i] = sc.nextInt();
            Arrays.sort(a);
            for (int l = 0, r = 0; l < n; l++) {
                while (r < n && a[r] - (r - l) >= 1) {
                    r++;
                }
//                pw.println(l + "" "" + r);
                ans = Math.max(ans, r - l);
            }
            pw.println(ans);
        }
        pw.close();
    }

    static class Scanner {
        BufferedReader br;
        StringTokenizer st;

        public Scanner(InputStream in) {
            br = new BufferedReader(new InputStreamReader(in));
        }

        public String next() throws IOException {
            while (st == null || !st.hasMoreTokens())
                st = new StringTokenizer(br.readLine());
            return st.nextToken();
        }

        public int nextInt() throws IOException {
            return Integer.",YahiaSherif
950,"public class Solution {

	public static void main(String[] args) {
		Scanner s = new Scanner(System.in);
		int i, j, k, l, t, diferenca, temp;
		int p1[] = new int[4];
		int p2[] = new int[4];
		int p3[] = new int[4];
		int saida1[] = new int[4];
		int saida2[] = new int[4];
 		
		do {
			t = s.nextInt();
		} while(t < 1 || t > 100);
		
		for(i = 1; i <= t; i++) {
			l = 0;
			
				for(k = 0; k < 4; k++) {
					do {
						p1[k] = s.nextInt();
						
					} while(p1[k] < 0 || p1[k] > (int) Math.pow(10, 6));
				}
				
				for(k = 0; k < 4; k++) {
					do {
						p2[k] = s.nextInt();
						
					} while(p2[k] < 0 || p2[k] > (int) Math.pow(10, 6));
				}
				
				for(k = 0; k < 4; k++) {
 					do {
						p3[k] = s.nextInt();
						
					} while(p3[k] < 0 || p3[k] > (int) Math.pow(10, 6));
				}
			
			for(j = 0; j < 4; j++) {
				
				if(p1[j] <= p2[j] & p1[j] <= p3[j]) {
					saida1[l] = p1[j];
				} else if(p2[j] <= p3[j]) {
					saida1[l] = p2[j];
				} else {
					saida1[l] = p3[j];
				}
				
				if(p1[j] == 0)
					if(p2[j] <= p3[j])
						saida1[l] = p2[j];
					else
						saida1[l] = p3[j];
				
				if(p2[j] == 0)
					if(p1[j] <= p3[j])
						saida1[l] = p1[j];
					else
						saida1[l] = p3[j];
				
				if(p3[j] == 0)
					if(p1[j] <= p2[j])
						saida1[l] = p1[j];
					else
						saida1[l] = p2[j];
				
				if(p1[j] == 0 && p2[j] == 0)
					saida1[l] = p3[j];
				
				if(p2[j] == 0 && p3[j] == 0)
					saida1[l] = p1[j];
				
				if(p1[j] == 0 && p3[j] == 0)
					saida1[l] = p2[j];
				
				l++;
			}

			l = 0;
			System.out.print(""Case #"" + i + "": "");
			
			if((saida1[0] + saida1[1] + saida1[2] + saida1[3]) >=  3 * Math.pow(10, 6)) {
				
				for(j = 0; j < 4; j++) {
					saida2[j] = saida1[j];
				}
				
				diferenca = saida1[0] + saida1[1] + saida1[2] + saida1[3] - 3 * 10 * 10 * 10 * 10 * 10 * 10;
				
				while(diferenca > 0 && (saida2[0] + saida2[1] + saida2[2] + saida2[3]) > 10 * 10 * 10 * 10 * 10 * 10) {
					
					while(saida2[l] > 0 && diferenca > 0) {
						saida2[l]--;
						diferenca--;
					}
					
					l++;
				}
				
				System.out.print(saida2[0] + "" "" + saida2[1] + "" "" + saida2[2] + "" "" + saida2[3]);
			} else {
				System.out.print(""IMPOSSIBLE"");
			}
			
			if(i != 1)
				System.",marcosph
16,"public class Solution {


    public void start() throws Exception {
       BufferedReader in = new BufferedReader(new InputStreamReader(System.in));

        int t = Integer.parseInt(in.readLine());
        for (int i = 1; i <= t; i++) {
            System.out.print(""Case #"" + i + "": "");
            solve(in);
        }
    }

    private void solve(BufferedReader in) throws Exception {
        int N = Integer.parseInt(in.readLine());
        Node[] nodes = new Node[N + 1];
        Node abyss = new Node();
        abyss.fun = 0;
        abyss.index = 0;
        nodes[0] = abyss;
        String[] args = in.readLine().split("" "");
        for (int i = 1; i <= N; i++) {
            Node n = new Node();
            n.fun = Integer.parseInt(args[i - 1]);
            n.index = i;
            nodes[i] = n;
        }



        args = in.readLine().split("" "");
        for (int i = 1; i <= N; i++) {
            nodes[Integer.parseInt(args[i - 1])].children.add(nodes[i]);
        }
        //System.out.println(fun(nodes[0]));

        long score = 0;
        for (int i = nodes.length - 1; i > -1; i--) {
            Node n = nodes[i];
            if (n.children.size() == 0) {
                n.score = n.fun;
            } else if (n.children.size() == 1) {
                n.score = Math.max(n.children.get(0).score, n.fun);
            } else {
                long min = n.children.stream().mapToLong(c -> c.score).min().getAsLong();
                long sum = n.children.stream().mapToLong(c -> c.score).sum();
                score += sum - min;
                n.score = Math.max(min, n.fun);
            }
        }
        System.out.println(nodes[0].score + score);
        //System.out.println(fun(nodes[0]));
    }

    private long fun(Node n) {
        if (n.children.size() == 0) {
            return n.fun;
        }
        long min = Integer.MAX_VALUE;
        int sum = 0;
        for (Node c : n.children) {
            long s = fun(c);
            min = Math.min(s, min);
            sum += s;
        }
        if (n.fun < min) {
            return sum;
        }
        return sum + n.fun - min;
    }


    private class Node {
        List<Node> children = new LinkedList<>();
        int fun;
        int index;
        long score;
    }

    public static void main(String[] args) throws Exception {
        Solution s = ",Abolfazl
754,"public class Solution {
     public static  void main(String[] args){
        Scanner myObj = new Scanner(System.in);  
    
        int testcases = myObj.nextInt();
        
        xxas: for(int i = 0; i < testcases; i++) {
            int n = myObj.nextInt();
            int k = myObj.nextInt();
            
            int a = 0;
            int b = 0;
            for(int j = 0; j < n; j++) {
                int nxt = myObj.nextInt();
                a += nxt;
                b += nxt*nxt;
            }
            
            //
            if(k == 1) {
                if(a == 0) {
                    System.out.println(""Case #"" +(i+1)+ "": "" + (b==0 ? 0 : ""IMPOSSIBLE"") );
                }else
                    System.out.println(""Case #"" +(i+1)+ "": "" + ((b-a*(long)a)%(2*a)==0 ? (b-a*(long)a)/(2*a) : ""IMPOSSIBLE"") );
                    continue xxas;
            }
            
            String zeros = """";
            
            for(long x= -800000; x <= 800000; x++) {
                
                a += x;
                b += x*x;
                
                if(a == 0 && b == 0) {
                    System.out.println(""Case #"" +(i+1)+ "": "" + ""0 0"" +  zeros );
                    continue xxas;
                }
                
                if((b-a*(long)a)%(2*a)==0) {
                    System.out.println(""Case #"" +(i+1)+ "": "" + x + "" "" + (b-a*(long)a)/(2*a) + zeros );
                    continue xxas;
                }
                    
                a -= x;
                b -= x*x;
            }
            System.out.println(""Case #"" +(i+1)+ "": "" + ""IMPOSSIBLE"" );

        }
        
    }
    
    static public boolean isValid(String s) {
        boolean[] taken = new boolean[40];
        for(int i = 0; i< s.length();) {
            char c = s.charAt(i);
            if(taken[c-'A'])
            return false;
            taken[c-'A'] = true;
            while(i < s.",gregordr
179,"public class Solution {

    public void solve(Scanner scanner) {
        int n = scanner.nextInt();
        scanner.nextLine();
        List<String> towers = new ArrayList<>(Arrays.asList(scanner.nextLine().split("" "")));

        int i = 0;
        boolean mergeable = true;
        while (mergeable && i <= towers.size()) {
            mergeable = attemptMerge(i, towers, true);
            if (!mergeable) {
                i++;
            }
        }

        i = 0;
        mergeable = true;
        while (mergeable && i <= towers.size()) {
            mergeable = attemptMerge(i, towers, false);
            if (!mergeable) {
                i++;
            }
        }

        String join = join(towers, """");
        HashSet<Character> checkedChars = new HashSet<>();
        for (int j = 0 ; j < join.length(); j++) {
            char currentChar = join.charAt(j);
            if (checkedChars.contains(currentChar)) {
                System.out.println(""IMPOSSIBLE"");
                return;
            }
            while ((j + 1 < join.length() && currentChar == join.charAt(j + 1))) {
                j++;
            }
            checkedChars.add(currentChar);
        }
        System.out.println(join);
    }

    public static String join(Collection var0, String var1) {
        StringBuffer var2 = new StringBuffer();

        for(Iterator var3 = var0.iterator(); var3.hasNext(); var2.append((String)var3.next())) {
            if (var2.length() != 0) {
                var2.append(var1);
            }
        }

        return var2.toString();
    }

    private boolean attemptMerge(int firstIndex, List<String> towers, boolean checkStart) {
        String first = towers.get(firstIndex);
        char firstChar;
        if (checkStart) {
            firstChar = first.charAt(0);
        } else {
            firstChar = first.charAt(first.length() - 1);
        }

        for (int i = 0; i < towers.size(); i++) {
            String second = towers.get(i);
            if (first.equals(second)) {
                continue;
            }
            char secondChar;
            if (checkStart) {
                secondChar = second.charAt(second.length() - 1);
            } else {
                secondChar = second.charAt(0);
            }
            if (firstChar == secondChar) {
                int index = towers.indexOf(first);
                towers.remove(first);
                towers.remove(second);
                String merged;
                if (checkStart) {
                    merged = second + first;
                } else {
                    merged = first + second;
                }
                towers.add(index, merged);
                return true;
            }
        }
        return false;
    }

    public static void main(String[] args) throws Exception {
        Scanner scan = new Scanner(System.in);
        int problems = Integer.parseInt(scan.nextLine());
        for (int count = ",KatieSanderson
843,"class Solution{
    public static void main(String[] args){
        Scanner s = new Scanner(System.in);
        int t = s.nextInt();
        int x = t;
        while(t>0){
            System.out.print(""Case #""+(x-(t-1))+"":"");
            int a1 = s.nextInt();
            int a2 = s.nextInt();
            int a3 = s.nextInt();
            int a4 = s.nextInt();
            int b1 = s.nextInt();
            int b2 = s.nextInt();
            int b3 = s.nextInt();
            int b4 = s.nextInt();
            int c1 = s.nextInt();
            int c2 = s.nextInt();
            int c3 = s.nextInt();
            int c4 = s.nextInt();
            int min1 = Math.min(a1, Math.min(b1, c1));
            int min2 = Math.min(a2, Math.min(b2, c2));
            int min3 = Math.min(a3, Math.min(b3, c3));
            int min4 = Math.min(a4, Math.min(b4, c4));
            int c  = 0;
            int d = 0;
            if(min1+min2+min3+min4 ==1000000){
                c = min3;
                d = min4;
            }
            else if(min1+min2+min3+min4 <1000000){
                System.out.print("" IMPOSSIBLE"");
                System.out.println();
            }
            else{
                int twoSum = min1+min2;
                int rem = 1000000 - twoSum;
                
                if(min3< rem && min4> rem){
                    c = min3;
                    d = 1000000 - (c+twoSum);
                }
                if(min3> rem && min4< rem){
                    d = min3;
                    c = 1000000 - (d+twoSum);
                }
                else if(min3<rem && min4<rem){
                    if(min3+min4 == rem){
                        c = min3;
                        d = min4;
                    }
                    else{
                        c = rem-min3;
                        d = 1000000 -(c+twoSum);
                    }
                    
                }
                else if(min3>rem){
                    c= min3-rem;
                    d = 1000000 -(c+twoSum);
                }
                else if(min4>rem){
                    d = min4-rem;
                    c = 1000000 -(d+twoSum);
                }
                System.out.print("" ""+min1);
                System.out.print("" ""+min2);
                System.out.print("" ""+c);
                System.out.print("" ""+d);
                System.",kaushik_0705
855,"public class Solution {
    
    public static void main(String[] args) throws IOException {
        BufferedReader in=new BufferedReader(new InputStreamReader(System.in));
        int t=Integer.parseInt(in.readLine());
        for (int e=0; e<t; e++) {
            System.out.print(""Case #"" + (e+1)+"":"");
            int[] n =new int[4];
            for (int i=0; i<3; i++) {
                StringTokenizer st=new StringTokenizer(in.readLine());
                for (int j =0; j<4; j++) {
                    int x = Integer.parseInt(st.nextToken());
                    if (i==0) n[j]=x;
                    else n[j] = Math.min(n[j], x);
                }
            }
            int total=0;
            for (int i= 0; i<4; i++) {
                total+=n[i];
            }
            if (total<1000000) {
                System.out.println("" IMPOSSIBLE"");
                continue;
            }
            int diff= 1000000-total;
            int index=0;
            while(diff>0) {
                int sub=Math.min(diff, n[index]);
                n[index]-=sub;
                diff-= sub;
                index++;
            }
            for (int i=",kevinz1423
73,"public class Solution {
	static Scanner sc;
	static StringBuffer s;

  public static void main(String[] args)throws Exception{
	 sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

     int nbTest = sc.nextInt();
     
	 for(int test = 1;test<=nbTest;test++){ 	   	 	
	 	solve(test);
	 }   
	 
  }
  
  static void solve (int test) {
	  
	  List<Integer> list1 = new ArrayList<Integer>();
	  List<Integer> list2 = new ArrayList<Integer>();
	  List<Integer> list3 = new ArrayList<Integer>();
	  List<Integer> result = new ArrayList<Integer>();
	  
	  for (int i = 0; i<4; i++) list1.add(sc.nextInt()); 
	  for (int i = 0; i<4; i++) list2.add(sc.nextInt());
	  for (int i = 0; i<4; i++) list3.add(sc.nextInt());
	  
	  int minC = minimum(list1.get(0), list2.get(0), list3.get(0));
	  int minM = minimum(list1.get(1), list2.get(1), list3.get(1));
	  int minY = minimum(list1.get(2), list2.get(2), list3.get(2));
	  int minK = minimum(list1.get(3), list2.get(3), list3.get(3));
	  int s = 1000000;
	  if(minC+minM+minY+minK < 1000000) {
		  System.out.println(""Case #""+test+"": IMPOSSIBLE"");
		  return;
	  }
	  
	  result.add(minC);
	  if(minC+minM>s) {
		  System.out.println(""Case #""+test+"": ""+minC+"" ""+(s-minM)+"" 0 0"");
		  return;
	  }else {
		  result.add(minM);
	  }
	  
	  if (minC+minM+minY>s) {
		  System.out.println(""Case #""+test+"": ""+minC+"" ""+minM+"" ""+(s-(minC+minM))+"" 0"");
		  return;
	  } else {
		  result.add(minY);
	  }
	  
	  
	  System.out.println(""Case #""+test+"": ""+minC+"" ""+minM+"" ""+minY+"" ""+
	                                        (s-(minC+minM+minY)));
	  


  }
  

  public static int  minimum (int a, int b, int c) {	 
		return Math.",Bil1983
1138,"public class Solution {

    Scanner             sc       = new Scanner(System.in);
    static final String FILENAME = ""A-small"";
    static final String IN       = FILENAME + "".in"";
    static final String OUT      = FILENAME + "".out"";
    PrintStream         out      = System.out;

    private void solve(int n, int p, long[][] products) {
        for(int i = 0; i<n; i++) {
            Arrays.sort(products[i]);
        }
        long pumps = products[0][p  - 1];
        int prevIdx = p - 1;
        Deque<long[]> d = new ArrayDeque<>();
        d.offer(new long[]{pumps, 1, prevIdx});
        long minAns = Long.MAX_VALUE;
        while(!d.isEmpty()) {
            long[] cur = d.poll();
            long sum = cur[0];
            int curIdx = (int) cur[1];
            prevIdx = (int) cur[2];
            if (curIdx == n) {
                minAns = Math.min(minAns, sum);
                continue;
            }
            // topDown
            long topDown = Math.abs(products[curIdx - 1][prevIdx] - products[curIdx][0]);
            d.offer(new long[]{sum + topDown + (products[curIdx][p - 1] - products[curIdx][0]), curIdx + 1, p - 1});
            // bottomUp

            long bottomUp = Math.abs(products[curIdx - 1][prevIdx] - products[curIdx][p - 1]);
            d.offer(new long[]{sum + bottomUp + (products[curIdx][p - 1] - products[curIdx][0]), curIdx + 1, 0});
            // bottomUp
        }
        out.println(minAns);
    }

    private void run() throws Exception {
        // out = new PrintStream(new FileOutputStream(OUT));
        int T = sc.nextInt();
        for (int t = 1; t <= T; t++) {
            out.print(""Case #"" + t + "": "");
            int n = sc.nextInt();
            int p = sc.nextInt();
            long[][] products = new long[n][p];
            for(int i = 0; i<n; i++) {
                for(int j = 0; j<p; j++) {
                    products[i][j] = sc.nextInt();
                }
            }
            solve(n, p, products);
        }
        sc.close();
        out.close();
    }

    public static void main(String args[]) throws Exception {
        new Solution().",rkamun
27,"public class Solution {


    public void start() throws Exception {
       BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        
        int t = Integer.parseInt(in.readLine());
        for (int i = 1; i <= t; i++) {
            System.out.print(""Case #"" + i + "":"");
            solve(in);
        }
    }

    private void solve(BufferedReader in) throws Exception {
        int[] x = new int[4];
        for (int i = 0; i < x.length; i++) {
            x[i] = Integer.MAX_VALUE;
        }
        for (int i = 0; i < 3; i++) {
            String[] args = in.readLine().split("" "");
            for (int j = 0; j < args.length; j++) {
                x[j] = Math.min(x[j], Integer.parseInt(args[j]));
            }
        }
        int sum = 0;
        for (int i = 0; i < x.length; i++) {
            sum += x[i];
        }
        if (sum < 1_000_000) {
            System.out.println("" IMPOSSIBLE"");
        } else {
            sum = 1_000_000;
            for (int i = 0; i < x.length; i++) {
                x[i] = Math.min(x[i], sum);
                sum -= x[i];
            }
            for (int v : x) {
                System.out.print("" "" + v);
            }
            System.out.println();
        }

    }



    public static void main(String[] args) throws Exception {
        Solution s = ",Abolfazl
1101,"public class Solution{
    public static void main(String args[]){
        Scanner sc=new Scanner(System.in);
        int t=sc.nextInt();
        for(int i=1;i<=t;i++){
            int r,c;
            r=sc.nextInt();
            c=sc.nextInt();
            char arr[][]=new char[2*r+1][2*c+1];
            arr[0][0]='.';
            arr[1][0]='.';
            arr[0][1]='.';
            arr[1][1]='.';
            for(int j=0;j<(2*r+1);j++){
                for(int k=0;k<(2*c+1);k++){
                    if((j==0 && k==0) || (j==0 && k==1) || (j==1 && k==0) || (j==1 && k==1))
                        continue;
                    if(j%2==0){
                        if(k%2==0)
                            arr[j][k]='+';
                        else
                            arr[j][k]='-';
                    }
                    else{
                        if(k%2==0)
                            arr[j][k]='|';
                        else
                            arr[j][k]='.';
                    }
                }
            }
            System.out.println(""Case #""+i+"":"");
            for(int j=0;j<(2*r+1);j++){
                for(int k=",rituV
1167,"class Solution {

	public static void main ( String [] args ) {
		Scanner s = new Scanner ( System.in);
			
	
		int T = s.nextInt();  
		for ( int t=1; t<=T; t++) {  
		
			int c = s.nextInt();  
			int p = s.nextInt(); 
			Long [][] presure = new Long[c][p];
			for ( int i=0; i<c; i++) {
				for ( int j=0; j<p; j++) {
					presure[i][j] = s.nextLong(); 
				}
			}
			long [][] dp = new long[c+1][2];
			long [][] last = new long[c+1][2];
			last[0][0] = 0; 
			last[0][1] = 0; 
			for ( int i=1; i<=c; i++) {
				long c1 = dp[i-1][0]+cost(last[i-1][0], presure[i-1], true);;
				long c2 = dp[i-1][1]+cost(last[i-1][1], presure[i-1], true);;
				if ( c1<c2) {
					dp[i][0] = c1;
				} else {
					dp[i][0] = c2; 
				}
				last[i][0] = presure[i-1][p-1]; // ultimul element
				
				long d1 = dp[i-1][0]+cost(last[i-1][0], presure[i-1], false);
				long d2 = dp[i-1][1]+cost(last[i-1][1], presure[i-1], false);
				if ( d1<d2) {
					dp[i][1] = d1; 
				} else {
					dp[i][1] = d2; 
				}
				last[i][1] = presure[i-1][p-1];
			}
			long sol = Math.min(dp[c][0], dp[c][1]);
			System.out.println(""Case #""+t+"": ""+sol);
		}
	}
	
	public static long cost(long current, Long [] data, boolean asc) {
		if ( asc) {
			Arrays.sort(data, new Comparator<Long>() {

				@Override
				public int compare(Long o1, Long o2) {
					return Long.compare(o1, o2);
				}
				
			});
		} else {
			Arrays.sort(data, new Comparator<Long>() {

				@Override
				public int compare(Long o1, Long o2) {
					return -Long.compare(o1, o2);
				}
				
			});
		}
		long cost = 0; 
		for ( int i=0; i<data.length; i++) {
			cost += Math.abs(data[i] - current); 
			current = ",slycer
1011,"public class Solution {
    public static void main(String[] args) {
        Scanner inp = new Scanner(System.in);

        int t = inp.nextInt();

        for (int j = 0; j < t; j++) {
            System.out.printf(""Case #:%d
"",j+1);
            int r = inp.nextInt();
            int c = inp.nextInt();
            inp.nextLine();

            for(int ri = 0; ri < 2*r + 1 ; ri++){
              for(int ci = 0 ; ci < 2*c + 1; ci++ ){
                  if(ri%2==0){
                      if(((ri==0)||(ri==1))&&((ci==0)||(ci==1))) {
                          System.out.print(""."");
                      }
                      else if(ci%2==0){ System.out.print(""+"");}
                      else System.out.print(""-"");

                      if(ci==2*c)
                          System.out.println("""");
                  }
                  if(ri%2==1){
                      if(((ri==0)||(ri==1))&&((ci==0)||(ci==1))) {
                          System.out.print(""."");
                      }
                      else if(ci%2==0){ System.out.print(""|"");}
                      else System.out.print(""."");
                      if(ci==2*c)
                          System.out.println("""");
                  }

              }
            }




        }
    }
}",parthanos
935,"public class Solution {
    // TODO: changes this to  >>>  false
    static final boolean debug = false; // false | true
    ///////////////////////////////////////////
    static final String FILENAME = ""src/main/java/google/codejam/y2022/r1b/a/"";
    static final String IN = FILENAME + ""sample.in"";
    static final String OUT = FILENAME + ""out.out"";
    static final String IMPOSSIBLE = ""IMPOSSIBLE"";
    ///////////////////////////////////////////
    private static void solve() {
        int N = in.nextInt(); //num of p
        int result = 0; // the number of customers who pay for their pancakes
        Deque<Integer> deque = new LinkedList<>();
        for (int i = 0; i < N; i++) {
            int d = in.nextInt();
            deque.addLast(d);
        }

        int max = 0;
        while (!deque.isEmpty()) {
            int f = deque.getFirst();
            int l = deque.getLast();
            int x = Math.min(l,f);
            if (x >= max) {
                result++;
            }
            max = Math.max(max, x);
            // remove smallest
            if (f <= l) {
                deque.removeFirst();
            } else {
                deque.removeLast();
            }
        }

        print(result);
    }

    private static void print(Object s) {
        out.println(s);
        out.flush();
        if (debug)
            System.out.println(s);
    }

    private static Scanner in;
    private static PrintStream out;

    private static void run() throws Exception {
        if (debug) {
            in = new Scanner(new File(IN));
            out = new PrintStream(new FileOutputStream(OUT));
        } else {
            in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
            out = System.out;
        }
        int t = in.nextInt();
        for (int i = 1; i <= t; i++) {
            out.print(""Case #"" + i + "": "");
            solve();
        }
        in.close();
        out.close();
    }

    public static void main(String[] args) throws Exception {
        run();
    }

    static class T2<X, Y> {
        public final X _1;
        public final Y _2;
        T2(X _1, Y _2) {
            this._1 = _1;
            this._2 = _2;
        }
        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            T2<?, ?> t = (T2<?, ?>) o;
            return Objects.equals(_1, t._1) && Objects.equals(_2, t._2);
        }
        @Override
        public int hashCode() {
            return Objects.hash(_1, _2);
        }
        @Override
        public String toString() {
            return _1 + "" "" + _2;
        }
    }

    static class T3<X, Y, Z> {
        public final X _1;
        public final Y _2;
        public final Z _3;
        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            T3<?, ?, ?> t3 = (T3<?, ?, ?>) o;
            return Objects.equals(_1, t3._1) &&
                    Objects.equals(_2, t3._2) &&
                    Objects.equals(_3, t3._3);
        }
        @Override
        public int hashCode() { return Objects.hash(_1, _2, _3); }
        T3(X _1, Y _2, Z _3) {
            this._1 = _1;
            this._2 = _2;
            this._3 = _3;
        }
        @Override
        public String toString() ",levios
1084,"public class Solution {

    public static void main(String[] args) {
        Scanner sc = null;
        sc = new Scanner(System.in);
        int T = sc.nextInt();
        for (int t = 0; t < T; t++) {
            int N = sc.nextInt();
            int[] F = new int[N];
            int[] P = new int[N];
            for (int i = 0; i < N; i++) {
                F[i] = sc.nextInt();
            }
            for (int i = 0; i < N; i++) {
                P[i] = sc.nextInt();
            }

            Node[] nodes = new Node[N + 1];
            nodes[0] = new Node(0, 0);  //abyss
            nodes[0].out = new Edge(nodes[0], nodes[0]);
            for (int i = 0; i < N; i++) {
                Node n = new Node(i + 1, F[i]);
                nodes[i + 1] = n;
                Edge e1 = new Edge(n, nodes[P[i]]);
                n.out = e1;
                Edge e2 = new Edge(nodes[P[i]], n);
                nodes[P[i]].in.add(e2);
            }

            Stack<Node> stack = new Stack<Node>();

            // Mark all the vertices as not visited
            boolean visited[] = new boolean[N + 1];
            for (int i = 0; i < N + 1; i++) {
                visited[i] = false;
            }
            for (int i = 0; i < N + 1; i++)
                if (visited[i] == false)
                    topologicalSortUtil(nodes[i], visited, stack);

            // Print contents of stack
            //make chain
//            Collections.reverse(stack);
            ArrayList<ArrayList<Node>> al = new ArrayList<>();
            while (stack.empty() == false) {
                Node n = stack.pop();
//                if (debug)
                if (n.in.size() == 0) {
                    ArrayList<Node> chain = new ArrayList();
                    Node n1 = n;
                    chain.add(n1);
                    do {
                        n1 = n1.out.to;
                        chain.add(n1);
                    }
                    while (n1.id != 0);
                    al.add((ArrayList<Node>) chain.clone());
                    /*int size = N;
                    int oldSize = chain.size();
                    while (size-- > 0) {
                        ArrayList<Node> cl = (ArrayList<Node>) chain.clone();
                        while (cl.size() > 1 && cl.get(cl.size() - 1).in.size() >= size) {
                            cl.remove(cl.size() - 1);
//                    chain.remove(0);
                        }
                        if (cl.size() != oldSize) {
                            al.add((ArrayList<Node>) cl.clone());
                            oldSize = cl.size();
                        }
                    }*/
                    //find combinations of chains to equal full set
//                    int max=recurs(al);

                }
            }


//            for (ArrayList<Node> chain : al) {
//                int max = Integer.MIN_VALUE;
////                int min = Integer.MAX_VALUE;
//                for (int i = 0; i < chain.size(); i++) {
//                    max = Math.max(chain.get(i).fun, max);
////                    min = Math.min(chain.get(i).fun, min);
//                }
//            }

            //recursion
            //F(x)=max(click it, don't click it)
//            boolean[] vector=new boolean[al.size()];
//            int max=recurs(al,vector);

            int answer=recurs(al,new ArrayList<Node>(),N);
            System.out.println(""Case #""+(t+1)+"": ""+answer);
        }

    }

    private static int recurs(ArrayList<ArrayList<Node>> al,ArrayList<Node> nodes,int N) {
        boolean[] visited=new boolean[N+1];
        int cnt=0;
        if (nodes.size()==al.size()) {

            for (int i = 0; i < nodes.size(); i++) {
                int max1 = 0;
                Node n54 = nodes.get(i);
                while (n54.id > 0) {
                    if (!visited[n54.id]) {
                        max1 = Math.max(max1, n54.fun);
                        visited[n54.id] = true;
                    }
                    n54 = n54.out.to;
                }
                cnt += max1;
            }
            //System.out.println(cnt+""	""+Arrays.toString(nodes.toArray()));
            return cnt;
        }
        else {
 /*       if (cnt==N+1){
            return max1;
        }
        max1=Integer.MIN_VALUE;*/
            int mm = 0;
            for (int i = 0; i < al.size(); i++) {
                if (nodes.contains(al.get(i).get(0))) {
                    continue;
                }
//            int mm=0;
                ArrayList<Node> n1 = (ArrayList<Node>) nodes.clone();
//            for (Node n2:al.get(i)){
//                n1.add(n2);
//                mm+=n2.fun;
//            }
                n1.add(al.get(i).get(0));
                mm = Math.max(recurs(al, n1, N), mm);
            }
//            System.out.println(""*""+mm+""	""+Arrays.toString(nodes.toArray()));

            return mm;
        }
    }


    // A recursive function used by topologicalSort
    static void topologicalSortUtil(Node n, boolean[] visited, Stack<Node> stack) {
        // Mark the current node as visited.
        visited[n.id] = true;
        Edge i;

        // Recur for all the vertices adjacent
        // to thisvertex
        Iterator<Edge> it = n.in.iterator();
        while (it.hasNext()) {
            i = it.next();
            if (!visited[i.to.id])
                topologicalSortUtil(i.to, visited, stack);
        }

        // Push current vertex to stack
        // which stores result
        stack.push(n);
    }


    static class Node {
        Edge out;
        ArrayList<Edge> in = new ArrayList<>();
        int id;
        int fun;

        @Override
        public String toString() {
            return ""Node{"" +
                    ""out="" + out +
                    "", in="" + in.size() +
                    "", id="" + id +
                    "", fun="" + fun +
                    '}';
        }

        Node(int id, int fun) {
            this.id = id;
            this.fun = fun;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Node node = (Node) o;
            return id == node.id;
        }

        @Override
        public int hashCode() {
            return Objects.hash(id);
        }
    }

    static class Edge {
        Node from;
        Node to;

        @Override
        public String toString() {
            return ""Edge{"" +
                    ""from="" + from.id +
                    "", to="" + to.id +
                    '}';
        }

        public Edge(Node from, Node to) {
            this.from = from;
            this.to = ",raver1975
1070,"public class Solution {
    public static Random random = new Random();

    public static String generate(int n){
        n = Math.min(n, 8 - n);
        List<Character> string = new LinkedList<>();
        for(int i = 0; i < 8; i ++){
            string.add('0');
        }
        List<Integer> indices = new LinkedList<>();
        for(int i = 0; i < 8; i ++){
            indices.add(i);
        }
        Collections.shuffle(indices);
        for(int i = 0; i < n; i ++){
            int index = indices.get(i);
            string.set(index, '1');
        }
        StringBuilder sb = new StringBuilder();
        for(Character c : string){
            sb.append(c);
        }
        return sb.toString();
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        boolean flag = true;
        for(int Case = 1; Case <= T; Case ++){
            if(!flag){
                break;
            }
            int startN = random.nextInt(8);
            String string = generate(startN);
            for(int i = 0; i < 300; i ++){
                System.out.println(string);
                int n = sc.nextInt();
                if(n == 0){
                    break;
                }
                else if(n == -1){
//                    System.out.println(""Error"");
                    flag = false;
                    break;
                }
                else{
                    string = ",ql309
443,"public class Solution {
    static Scanner sc = new Scanner(System.in);
    static PrintWriter pw = new PrintWriter(System.out);

    public static void main(String[] args) throws IOException {
        int t = sc.nextInt();
        for (int tc = 1; tc <= t; tc++) {
            pw.print(""Case #"" + tc + "":"");
            int[][] arr = new int[3][4];
            int[] mins = new int[4];
            Arrays.fill(mins, (int) 1e6 + 1);
            for (int i = 0; i < 3; i++) {
                for (int j = 0; j < 4; j++) {
                    arr[i][j] = sc.nextInt();
                    mins[j] = Math.min(mins[j], arr[i][j]);
                }
            }
            int rem = (int) 1e6;
            int[] ans = new int[4];
            for (int i = 0; i < 4; i++) {
                int req = Math.min(rem, mins[i]);
                ans[i] = req;
                rem -= req;
            }
            if (rem != 0) {
                pw.println("" IMPOSSIBLE"");
            } else {
                for (int i = 0; i < 4; i++) {
                    pw.print("" "" + ans[i]);
                }
                pw.println();
            }

        }
        pw.close();
    }

    static class Scanner {
        BufferedReader br;
        StringTokenizer st;

        public Scanner(InputStream in) {
            br = new BufferedReader(new InputStreamReader(in));
        }

        public String next() throws IOException {
            while (st == null || !st.hasMoreTokens())
                st = new StringTokenizer(br.readLine());
            return st.nextToken();
        }

        public int nextInt() throws IOException {
            return Integer.",YahiaSherif
506,"public class Solution {
    public String printDrawPunchCards(int row, int column){
        int start = 0;
        String extra = """";
        String pipe = """";
        StringBuilder output = new StringBuilder();
        int count = 0;

        while(count != row){
            if(start == 0){
                extra = ""..+"" + ""-+"".repeat(column - 1);
                pipe = ""..|"" + "".|"".repeat(column - 1);
            }

            if(start != 0) pipe = ""|"" + "".|"".repeat(column);
            String below = ""+"" + ""-+"".repeat(column);

            if(start == 0) output.append(extra).append(""
"");
            output.append(pipe).append(""
"");
            output.append(below).append(""
"");

            count++;
            start++;",adamson
738,"public class Solution {
  static final int WALK_LENGTH = 100;

  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);

    int T = sc.nextInt();
    for (int tc = 1; tc <= T; ++tc) {
      int N = sc.nextInt();
      int K = sc.nextInt();

      int edgeSum = 0;
      List<Integer> orders = IntStream.rangeClosed(1, N).boxed().collect(Collectors.toList());
      Collections.shuffle(orders);
      int orderIndex = 0;
      int restWalk = WALK_LENGTH;
      Map<Integer, Integer> nodeToEdgeNum = new HashMap<>();
      for (int i = 0; i <= K; ++i) {
        int R = sc.nextInt();
        int P = sc.nextInt();

        if (!nodeToEdgeNum.containsKey(R)) {
          edgeSum += P;
          nodeToEdgeNum.put(R, P);
        }

        if (nodeToEdgeNum.size() == N) {
          break;
        }

        if (i != K) {
          if (restWalk == 0) {
            int next = -1;
            while (true) {
              next = orders.get(orderIndex);
              if (!nodeToEdgeNum.containsKey(next)) {
                break;
              }
              ++orderIndex;
            }

            System.out.println(String.format(""T %d"", next));
            System.out.flush();

            restWalk = WALK_LENGTH;
          } else {
            System.out.println(String.format(""W""));
            System.out.flush();

            --restWalk;
          }
        }
      }

      double avgEdgeNum = computeAvgEdgeNum(nodeToEdgeNum);

      System.out.println(String.format(""E %d"", (long) Math.round(avgEdgeNum * N)));
      System.out.flush();
    }

    sc.close();
  }

  static double computeAvgEdgeNum(Map<Integer, Integer> nodeToEdgeNum) {
    List<Integer> orders =
        nodeToEdgeNum.keySet().stream()
            .sorted(Comparator.comparing(nodeToEdgeNum::get))
            .collect(Collectors.toList());

    double sum = 0;
    for (int i = ",goalboy1015
1097,"public class Solution{
    public static void main(String args[]){
        Scanner sc=new Scanner(System.in);
        int t=sc.nextInt();
        for(int i=1;i<=t;i++){
            long c1=sc.nextLong();
            long m1=sc.nextLong();
            long y1=sc.nextLong();
            long k1=sc.nextLong();
            
            long c2=sc.nextLong();
            long m2=sc.nextLong();
            long y2=sc.nextLong();
            long k2=sc.nextLong();
            
            long c3=sc.nextLong();
            long m3=sc.nextLong();
            long y3=sc.nextLong();
            long k3=sc.nextLong();
            
            long c=Math.min(c1,Math.min(c2,c3));
            long m=Math.min(m1,Math.min(m2,m3));
            long y=Math.min(y1,Math.min(y2,y3));
            long k=Math.min(k1,Math.min(k2,k3));
            
            long r= c+m+y+k;
            if(r<1000000)
                System.out.println(""Case #""+i+"": IMPOSSIBLE"");
            else{
                if(r==1000000)
                    System.out.println(""Case #""+i+"": ""+c+"" ""+m+"" ""+y+"" ""+k);
                    if(c>=r)
                            c-=r;
                            r=0;
                    else{
                            c=0;
                            r-=c;
                    }
                    if(m>=r)
                            m-=r;
                            r=0;
                    else{
                            m=0;
                            r-=m;
                    }
                    if(y>=r)
                            y-=r;
                            r=0;
                    else{
                            y=0;
                            r-=y;
                    }
                    if(k>=r)
                            c-=k;
                            k=0;
                    else{
                            k=0;
                            r-=k;
                    }
                    
                    System.",rituV
1229,"public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        for (int t = 0; t < T; t++) {
            int N = sc.nextInt();
            int K = sc.nextInt();
            int startRoom = sc.nextInt();
            long total = sc.nextInt();
            int k = 0;
            for (int i = 1; i <= N && k < K; i++, k++) {
                if (i == startRoom) {
                    i++;
                    if (i > N) {
                        break;
                    }
                }
                System.out.println(""T "" + i);
                if (sc.nextInt() == -1) {
                    return;
                }
                total += sc.nextInt();
            }
            System.",teekaytai
415,"public class Solution {
    static Scanner sc = new Scanner(System.in);

    public static void main(String[] args) {

        int cases = Integer.parseInt(sc.nextLine());
        for (int i = 0; i < cases; i++) {
            if(runTest() == -1){
                break;
            }
        }


    }



    public static int runTest(){
        StringBuilder sb = new StringBuilder();
        boolean[] bits = new boolean[8];
        for (int i = 0; i < 300; i++) {
            System.out.println(String.format(""%8s"", Integer.toBinaryString((int)(Math.random() * 127))).replaceAll("" "", ""0""));
            int num = ",SurgeM
249,"public class Solution{

    public static void main(String[] args){
int r=0;
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int sum=1000000;
        int T = in.nextInt();
        for (int i=1; i<=T; i++){
           
            int [] C=new int[3];
            int [] M=new int[3];
            int [] Y=new int[3];
            int [] B=new int[3];
            int [] R=new int[4];
        int j=0;
            while (j<3)
          {
           C[j]=in.nextInt();
            M[j]=in.nextInt();
            Y[j]=in.nextInt();
            B[j]=in.nextInt();
          j++;
            }
            Arrays.sort(C);
            Arrays.sort(M);
            Arrays.sort(Y);
            Arrays.sort(B);
         if(C[0]+M[0]+Y[0]+B[0]==sum)
         {r=0;
             R[0]=C[0];
         R[1]=M[0];
         R[2]=Y[0];
         R[3]=B[0];
         }
         else  if((C[0]+M[0]+Y[0]+B[0]) || (C[1]+M[1]+Y[1]+B[1] ) || (C[2]+M[2]+Y[2]+B[2])    <sum)
         {                    System.out.println(""Case #"" + i + "": "" + ""IMPOSSIBLE"");
r=1;
         }
         else {r=0;
         if(C[0]<sum)
         {
         R[0]=C[0];
         sum=sum-R[0];}
         else if (C[0]>=sum)
         {R[0]=sum;
         R[1]=0;
         R[2]=0;
         R[3]=0;
         sum=0;
         }
         if(M[0]<sum)
         {
         R[1]=M[0];
         sum=sum-R[1];
      
         
         }
         else if(M[0]>=sum)
         {R[1]=sum;
         R[2]=0;
       R[3]=0;
         sum=0;
         }
            if(Y[0]<sum)
         {  R[2]=Y[0];
         sum=sum-R[2];
         }
         else if(Y[0]>=sum)
         {R[2]=sum;
         R[3]=0;
   
         sum=0;
         }
               if(B[0]<sum)
         {  R[3]=B[0];
         sum=sum-R[3];
         }
         else if(B[0]>=sum)
         {R[3]=sum;
         
   
         sum=0;
         }
            
            
             
            }
            
         if(r==0)
         {
             if((R[0]==0 && R[1] ==0 && R[2] ==0 && R[3]==0) ||(R[0]+R[1]+R[2]+R[3])>1000000 ) 
             {            System.out.println(""Case #"" + i + "": "" + ""IMPOSSIBLE"");

             }
             else {
            System.out.println(""Case #"" + i + "": ""+R[0]+"" ""+R[1]+"" ""+R[2]+"" ""+R[3]+"" "");
                     }}
        }     
            
       
        
        in.",Marwan
1346,"public class Solution {
    public static void main(String[] args) throws Exception {
        Scanner sc = new Scanner(System.in);
        int tt = sc.nextInt();
        for (int zz = 1; zz <= tt; zz++) {
            runTest(zz, sc);
        }
    }

    public static void runTest(int testCase, Scanner sc) {
        StringBuilder output = new StringBuilder();

        output.append(""Case #"").append(testCase).append("": "");
        //impl here
        int n = sc.nextInt();
        int p = sc.nextInt();
        int[][] arr = new int[n][p];

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < p; j++) {
                arr[i][j] = sc.nextInt();
            }
            Arrays.sort(arr[i]);
        }

        output.append(rec(arr, 0, 0, 0, true));
        //output here
        output.append(""
"");
        System.out.print(output);
    }

    public static long rec(int[][] arr, int i, int point, long sum, boolean left) {
        if ( i == arr.length ) return sum;
        if ( left ) {
            for (int j = 0; j < arr[i].length; j++) {
                sum += Math.abs(arr[i][j] - point);
                point = arr[i][j];
            }
        } else {
            for (int j = arr[i].length - 1; j>=0; j--) {
                sum += M",zubaidullo
120,"class Solution{
    static Set<Integer> set;
    static Set<Integer> set2;
    static Map<Integer, List<Integer>> map;
    static Map<Integer, List<Integer>> map2;
    static int[] arr;
    static int maxFun(int[] arr2, int[] arr1, int n){
        arr = arr2;
        set = new HashSet<>();
        set2 = new HashSet<>();
        for(int i = 0; i < n; i ++){
            set2.add(i);
        }
        map = new HashMap<>();
        map2 = new HashMap<>();
        for(int i = 0; i < n; i ++){
            if(arr1[i] == 0){
                set.add(i);
            }
            else{
                if (!map.containsKey(arr1[i] - 1)){
                    map.put(arr1[i] - 1, new ArrayList<>());
                }
                map.get(arr1[i] - 1).add(i);
                /*if (!map.containsKey(arr1[i] - 1)){
                    map.put(arr1[i] - 1, new ArrayList<>());
                }
                map.get(arr1[i] - 1).add(i);*/
            }
            set2.remove(arr1[i] - 1);
        }
        int max = 0;
        for(int i: set){
            max += findMax(i);
        }
        return max;
    }

    static int findMax(int i){
        if(!map.containsKey(i))
            return arr[i];
        int tmp = arr[i];
        int max = 0;
        List<Integer> tmpList = map.get(i);
        if (tmpList.size() == 1){
            int j = tmpList.get(0);
            arr[j] = Math.max(arr[j], tmp);
            max = findMax(j);
        } else {
            for (int j : tmpList) {
                int cur = findMax(j);
                max += Math.max(cur, tmp);
                tmp = Math.min(cur, tmp);
            }

        }
        return max;
    }

    /*
        1 -> 2 -> 3 -> 4 -> 2

     */

    public static void main(String[] args){


        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int idx = 1;
        while (idx <= n){
            int n1 = sc.nextInt();
            int[] arr = new int[n1];
            int[] arr1 = new int[n1];
            for(int i = 0; i < n1; i ++){
                arr[i] = sc.nextInt();
            }
            for(int i = 0; i < n1; i ++){
                arr1[i] = sc.nextInt();
            }
            System.out.println(""Case #"" + idx + "": "" + maxFun(arr, arr1, n1));
            idx ++;
        }
        sc.",Em11
767,"public class Solution {
    public static void main(String[] argu) throws Exception {
        Reader br = new Reader();
        PrintWriter pw = new PrintWriter(System.out);
        int nt = br.nextInt();
        for (int t = 1; t <= nt; ++t) {
            int N = br.nextInt();
            int[] D = new int[N];
            for (int i = 0; i < N; ++i) D[i] = br.nextInt();
            int i = 0, j = N - 1, res = 0, prev = 0;
            while (i <= j) {
                int cur = D[i] <= D[j] ? D[i++] : D[j--];
                if (prev <= cur) res++;
                prev = Math.max(prev, cur);
            }
            pw.format(""Case #%d: %d"", t, res);
            pw.println();
        }
        pw.close();
        br.close();
    }
    static class Reader
    {
        final private int BUFFER_SIZE = 1 << 16;
        private DataInputStream din;
        private byte[] buffer;
        private int bufferPointer, bytesRead;

        public Reader()
        {
            din = new DataInputStream(System.in);
            buffer = new byte[BUFFER_SIZE];
            bufferPointer = bytesRead = 0;
        }
        private void fillBuffer() throws IOException
        {
            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);
            if (bytesRead == -1)
                buffer[0] = -1;
        }

        private byte read() throws IOException
        {
            if (bufferPointer == bytesRead)
                fillBuffer();
            return buffer[bufferPointer++];
        }

        public void close() throws IOException
        {
            if (din == null)
                return;
            din.close();
        }
        public int nextInt() throws IOException
        {
            int ret = 0;
            byte c = read();
            while (c <= ' ')
                c = read();
            boolean neg = (c == '-');
            if (neg)
                c = read();
            do
            {
                ret = ret * 10 + c - '0';
            }  while ((c = read()) >= '0' && c <= '9');

            if (neg)
                return -ret;
            return ret;
        }
        public String readLine() throws IOException {
            byte[] buf = new byte[200001]; // line length
            int cnt = 0, c = read();
            if (-1 != c && '
' != c) buf[cnt++] = (byte) c;
            while ((c = read()) != -1)
            {
                if (c == '
')
                    break;
                buf[cnt++] = (byte) c;
            }
            return new String(buf, 0, cnt);
        }

    }
}",hdchen
1155,"class Solution {

	public static void main ( String [] args ) {
		Scanner s = new Scanner ( System.in);
		Random rnd = new Random(); 
//		byte v = 1; 
//		for ( int i=0; i<7; i++) {
//			System.out.println(toString((byte)(rr(v,i))));
//		}
	
		int T = s.nextInt();  
		for ( int t=1; t<=T; t++) {  
			System.out.println(""00000001"");
			while (true) { 
				int c = s.nextInt(); 
				//System.err.println(c);
				if ( c>0) {
					
					while(true) {
						byte candidate = (byte)rnd.nextInt(256);
						if (count(candidate)==c) {
							System.out.println(toString(candidate));						
							break; 
						}
					}

				}
				if ( c==0) {
					break; 
				}
				if ( c==-1) {
					break; 
				}
			}
		}
	
		
	} 
	

	public static byte rr(byte a, int k) {
		return (byte) ((a>>k)|(a<<(8-k)));
	}
	
	public static int count(byte a) {
		int ret = 0; 
		for ( int i=7; i>=0; i--) {
			if ( (a &(1<<i)) >0) {
				ret += 1;
			}
		}
		return ret; 
	}
	
	public static String toString(byte a) {
		String ret = """"; 
		for ( int i=7; i>=0; i--) {
			if ( (a &(1<<i)) >0) {
				ret += ""1"";
			} else ",slycer
145,"public class Solution { //Solution
	static int INF = (int)(1e9);
	static long mod = (long)(1e9)+7;
	static long mod2 = 998244353;
	static long[] segtree;
	static char[] curans;
	static long ans;	
	static String S;
	static ArrayList<Integer>[] graph;
	static boolean[] vis;
	static int[] a;
	static int N;
	static long K;
	static long[] fact;
	static ArrayList<Long> pos;
	static ArrayList<Long> neg;
	static long[] max;
	static int[] dp;
	static long mx;
	static long[] fun;
	public static void main(String[] args) {  //Cash out
		/*(Notes)
		 * OPTIMIZE LOCALLY (pick 300 / 8 -> 37 binary strings).
		 * For each of the 37 strings, spam the same string 8 times 
		 * (uniformally get all rotation values r ranging from [0,7].
		 * 
		 * */
		FastScanner I = new FastScanner(); //Input
		OutPut O = new OutPut(); //Output
		
		int T = I.nextInt();
		
		ArrayList<String> S = new ArrayList<String>();
		ArrayList<String>[] g = new ArrayList[9];
		
		for (int i = 0; i <= 8; i++) {
			g[i] = new ArrayList<String>();
		}
		
		for (int i = 0; i < 1 << 8; i++) {
			int cur = i;
			int bit = 0;
			char[] b = new char[8];
			int cnt = 0;
			
			while (bit < 8) {
				if (cur % 2 == 1) {
					b[bit] = '1';
					cnt++;
				}else {
					b[bit] = '0';
				}
				cur /= 2;
				bit++;
			}
			
			S.add(new String(b));
			g[cnt].add(new String(b));
		}
		
		int idx = 0;
		int cnt = 1;
		
		for (int t = 1; t <= T; t++) {
			
			while (true) {
				O.pln(g[cnt].get(idx));
				idx++;
				
				if (idx == g[cnt].size()) {
					cnt++;
					cnt %= 8;
					idx = 0;
				}
				
				int bits = I.nextInt();
				if (bits == 0) {
					break;
				}
			}
			
			//O.pln(""Case #"" + t + "": "" + ans);
		}
		
	}
	
	public static boolean pal(String x) {
		int N = x.length();
		
		for (int i = 0; i < N / 2; i++) {
			if (x.charAt(i) != x.charAt(N - i - 1)) {
				return false;
			}
		}
		
		return true;
	}
	
	public static ArrayList<String> perms(int N, int upper){
		if (N==1) {
			ArrayList<String> ret = new ArrayList<String>();
			for (int i = 1; i<=upper; i++) ret.add(Integer.toString(i)+"" "");
			return ret;
		}
		ArrayList<String> prev = perms(N-1,upper);
		ArrayList<String> ret = new ArrayList<String>();
		for (int i = 0; i < prev.size(); i++) {
			boolean[] vis = new boolean[upper+1];
			String cur = prev.get(i);
			String[] parts = cur.split("" "");
			for (int j = 0; j < parts.length; j++) {
				vis[Integer.parseInt(parts[j])]=true;
			}
			for (int j = 1; j <= upper; j++) {
				if (!vis[j]) {
					String curans = cur;
					curans+=Integer.toString(j)+"" "";
					ret.add(curans);
				}
			}
		}
		return ret;
	}
	
	public static void DFS(int start) {
		if (start == 0) {
			return;
		}
		
		vis[start] = true;
		mx = Math.max(mx, fun[start]);
		int next = graph[start].get(0); // We only ever point to one node at a time
		if (vis[next]) {
			return;
		}
		
		DFS(next);
	}
	
	public static long C(int N, int K) {
		long ans = fact[N];
		ans *= FastExp(fact[K], mod - 2);
		ans %= mod;
		
		ans *= FastExp(fact[N - K], mod - 2);
		ans %= mod;
		
		return ans;
	}
	
	
	public static double[][] matrix_exp(double[][] a, long exp, long mod) {
		int R = a.length;
		int C = a[0].length;
		double[][] ans = new double[R][C];
		
		boolean mult_yet = false;
		
		while (exp > 0) {
			if (exp % 2 == 1) {
				if (!mult_yet) {
					mult_yet = true;
					for (int i = 0; i < R; i++) {
						for (int j = 0; j < C; j++) {
							ans[i][j] = a[i][j]; 
						}
					}
				}else {
					double[][] new_ans = mult(ans, a, mod);
					for (int i = 0; i < R; i++) {
						for (int j = 0; j < C; j++) {
							ans[i][j] = new_ans[i][j]; 
						}
					}
				}
			}
			
			double[][] new_a = mult(a, a, mod); // a = a^2 (binary exponentiation on matrices)
			for (int i = 0; i < R; i++) {
				for (int j = 0; j < C; j++) {
					a[i][j] = new_a[i][j]; 
				}
			}
			exp /= 2;
		}
		
		return ans;
	}
	public static double[][] mult(double[][] a, double[][] b, long mod) {
		int r1 = a.length;
		int c1 = a[0].length;
		int r2 = b.length;
		int c2 = b[0].length;
		//Requires: c1 = r2
		
		double[][] ans = new double[r1][c2];
		for (int r = 0; r < r1; r++) {
			for (int c = 0; c < c2; c++) {
				//Dot product of (a[r])^T and b[c] (as vectors in R^n (n = c1 = r2))
				double[] col_vector = new double[r2];
				double[] row_vector = new double[c1];
				
				for (int i = 0; i < r2; i++) {
					col_vector[i] = b[i][c];
				}
				for (int i = 0; i < c1; i++) {
					row_vector[i] = a[r][i]; 
				}
				
				ans[r][c] = dot_product(row_vector, col_vector, mod);
			}
		}
		return ans;
	}
	
	public static double dot_product(double[] a, double[] b, long mod) {
		double ans = 0;
		int N = a.length; //Requires: a and b are both vectors in R^n
		for (int i = 0; i < N; i++) {
			ans += a[i] * b[i];
		}
		return ans;
	}
	public static double max(double a, double b) {return Math.max(a, b);}
	public static double min(double a, double b) {return Math.min(a, b);}
	public static long min(long a, long b) {return Math.min(a,b);}
	public static long max(long a, long b) {return Math.max(a,b);}
	public static int min(int a, int b) {return Math.min(a,b);}
	public static int max(int a, int b) {return Math.max(a,b);}
	public static long abs(long x) {return Math.abs(x);}
	public static long abs(int x) {return Math.abs(x);}
	public static long ceil(long num, long den) {long ans = num/den; if (num%den!=0) 
	ans++; return ans;}
	public static long GCD(long a, long b) {
		if (a==0||b==0) return max(a,b);
		return GCD(min(a,b),max(a,b)%min(a,b));
	}
	public static long FastExp(long base, long exp) {
		long ans=1;
		while (exp>0) {
			if (exp%2==1) ans*=base;
			exp/=2;
			base*=base;
			base%=mod;
			ans%=mod;
		}
		return ans;
	}
	public static long ModInv(long num,long mod) ",IQEmperor
1336,"public class Solution {
    private static BufferedReader br;
    private static StringTokenizer st;
    private static PrintWriter pw;

    public static void main(String[] args) throws Exception {
        br = new BufferedReader(new InputStreamReader(System.in));
        pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));
        int tt = readInt();
        for (int zz = 1; zz <= tt; zz++) {
            int n = readInt();
            Integer[] arr = new Integer[n * 2];
            int z = 1;
            StringBuilder sb = new StringBuilder();
            long sum = 0;
            for (int i = 0; i < n; i++) {
                arr[i] = z;
                sum += z;
                sb.append(z);
                if (i < n - 1) sb.append("" "");

                if (z == 1) z = 0;
                z += 10;
            }
            System.out.println(sb);
            System.out.flush();
            
            String ret = nextLine();
            String[] arrS = ret.split("" "");
            for (int i = 0; i < n; i++) {
                int next = Integer.parseInt(arrS[i]);
                sum += next;
                arr[n + i] = next;
            }
            //testing TLE
            System.out.println(sb);
            System.out.flush();
            
            ab(arr, 0, 0, new HashSet<>(), sum / 2);
            sb = new StringBuilder();
            for (Integer integer : nextHalf) {
                sb.append(integer).append("" "");
            }
            System.out.println(sb);
            System.out.flush();
        }
        pw.close();

    }

    static boolean found = false;
    static Set<Integer> nextHalf;
    static Set<Long> memo = new HashSet<>();

    public static void ab(Integer[] arr, int idx, long sum, Set<Integer> curr, long target) {
        if (found || idx > arr.length - 1 || memo.contains(sum) || sum > target) return;
        if (sum == target) {
            found = true;
            nextHalf = curr;
            return;
        }

        curr.add(arr[idx]);
        ab(arr, idx + 1, sum + arr[idx], curr, target);
        if (found) return;
        curr.remove(arr[idx]);
        ab(arr, idx + 1, sum, curr, target);
        if (found) return;

        memo.add(sum);

    }

    private static void exitImmediately() {
        pw.close();
        System.exit(0);
    }

    private static long readLong() throws IOException {
        return Long.parseLong(nextToken());
    }

    private static double readDouble() throws IOException {
        return Double.parseDouble(nextToken());
    }

    private static int readInt() throws IOException {
        return Integer.parseInt(nextToken());
    }

    private static String nextLine() throws IOException {
        String s = br.readLine();
        if (s == null) {
            exitImmediately();
        }
        st = null;
        return s;
    }

    private static String nextToken() throws IOException {
        while (st == null || !st.hasMoreTokens()) {
            st = ",zubaidullo
164,"public class Solution {

  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int n = sc.nextInt();
    for (int i = 0; i < n; i++) {
      int N = sc.nextInt();
      int K = sc.nextInt();
      boolean[] visited = new boolean[N];
      long E = 0;
      int visitCt = 0;
      for (int j = 0; j < K; j++) {
        int R = sc.nextInt();
        int P = sc.nextInt();
        if (!visited[R - 1]) {
          E += P;
          visited[R - 1] = true;
          visitCt++;
          System.out.println(""W"");
        } else {
          System.out.println(""W"");
        }
      }
      int R = sc.nextInt();
      int P = sc.nextInt();
      if (!visited[R - 1]) {
        E += P;
        visited[R - 1] = ",Jai03kh
646,"public class Solution {

    public static void main(String[] args) {
        
        Scanner scan = new Scanner(System.in); 
        int numOfCases = scan.nextInt();
        
        int x = 1; // Test Case Number (starting from 1)
        
        int r = 0;
        int c = 0;
        
        for (int i = 0; i < numOfCases; i++) {
            r = scan.nextInt();
            c = scan.nextInt();
            
            System.out.println(""Case #"" + x + "": "");
            
            // First Two Lines
            if (r > 2) {
                System.out.print("".."");
                for (int j = 0; j < r; j++) {
                    System.out.print(""+-"");
                }
                System.out.println(""+"");
                
                System.out.print("".."");
                for (int k = 0; k < r; k++) {
                    System.out.print(""|."");
                }
                System.out.println(""|"");
            }
            else {
                System.out.print("".."");
                for (int j = 1; j < c; j++) {
                    System.out.print(""+-"");
                }
                System.out.println(""+"");
                
                System.out.print("".."");
                for (int k = 1; k < c; k++) {
                    System.out.print(""|."");
                }
                System.out.println(""|"");
            }
            
            // Remaining Lines 
            for (int j = 0; j < r - 1; j++) {
                for (int k = 0; k < c; k++) {
                    System.out.print(""+-"");
                }
                System.out.println(""+"");
                
                for (int l = 0; l < c - 1; l++) {
                    System.out.print(""|."");
                }
                System.out.println(""|.|"");
            }
            
            // Last Lines
            for (int l = 0; l < c; l++) {
                System.out.print(""+-"");
            }
            System.",dtarde
123,"class Solution{
    static Set<Integer> set;
    static Set<Integer> set2;
    static Map<Integer, List<Integer>> map;
    static int[] arr;
    static int localMax;
    static int maxFun(int[] arr2, int[] arr1, int n){
        arr = arr2;
        set = new HashSet<>();
        map = new HashMap<>();
        for(int i = 0; i < n; i ++){
            if(arr1[i] == 0){
                set.add(i);
            }
            else{
                if (!map.containsKey(arr1[i] - 1)){
                    map.put(arr1[i] - 1, new ArrayList<>());
                }
                map.get(arr1[i] - 1).add(i);
                /*if (!map.containsKey(arr1[i] - 1)){
                    map.put(arr1[i] - 1, new ArrayList<>());
                }
                map.get(arr1[i] - 1).add(i);*/
            }
        }
        int max = 0;
        for(int i: set){
            localMax = 0;
            max += findMax(i);
            max += localMax;
        }
        return max;
    }

    static int findMax(int i){
        if(!map.containsKey(i))
            return arr[i];
        List<Integer> tmpList = map.get(i);
        if (tmpList.size() == 1){
            int j = tmpList.get(0);
            arr[j] = Math.max(arr[j], arr[i]);
            return findMax(j);
        } else {
            int tmp = findMax(tmpList.get(0));
            for (int j = 1; j < tmpList.size(); j ++) {
                int cur = findMax(tmpList.get(j));
                localMax += Math.max(cur, tmp);
                tmp = Math.min(cur, tmp);
            }
            return Math.max(tmp, arr[i]);

        }
    }

    /*
        1 -> 2 -> 3 -> 4 -> 2

     */

    public static void main(String[] args){


        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int idx = 1;
        while (idx <= n){
            int n1 = sc.nextInt();
            int[] arr = new int[n1];
            int[] arr1 = new int[n1];
            for(int i = 0; i < n1; i ++){
                arr[i] = sc.nextInt();
            }
            for(int i = 0; i < n1; i ++){
                arr1[i] = sc.nextInt();
            }
            System.out.println(""Case #"" + idx + "": "" + maxFun(arr, arr1, n1));
            idx ++;
        }
        sc.",Em11
674,"public class Solution {
    public static int N;
    public static HashSet<Integer> seen;
    public static long total;
    public static void main(String[] args) throws IOException {
        FastScanner input = new FastScanner(false);
        int T = input.nextInt();
        for (int iter = 1; iter<=T; iter++) {
            int N = input.nextInt();
            if (N==-1) return;
            int K = input.nextInt();
            if (K==-1) return;
            seen = new HashSet<>();
            System.out.println(""E ""+trial(N,K));
        }
    }
    public static long trial(int N, int K) throws IOException {
        FastScanner input = new FastScanner(false);
        total = 0;
        for (int i = 0; i<K; i++) {
            int R = input.nextInt();
            if (R==-1) {
                int a = 1/0;
            }
            int P = input.nextInt();
            if (P==-1) {
                int a = 1/0;
            }
            seen.add(R);
            total+=P;
            if (seen.size()==N) {
                return total/2;
            }
            System.out.println(""T ""+(i+1));
        }
        int R = input.nextInt();
        if (R==-1) {
            int a = 1/0;
        }
        int P = input.nextInt();
        if (P==-1) {
            int a = 1/0;
        }
        seen.add(R);
        total+=P;
        return total*N/2/seen.size();
    }
    private static class FastScanner {
        final private int BUFFER_SIZE = 1 << 16;
        private DataInputStream din;
        private byte[] buffer;
        private int bufferPointer, bytesRead;
        private FastScanner(boolean usingFile) throws IOException {
            if (usingFile) din=new DataInputStream(new FileInputStream(""C:\\\Users\\\skwek\\\IdeaProjects\\\HelloWorld\\\src\\	esting.in""));
            else din = new DataInputStream(System.in);
            buffer = new byte[BUFFER_SIZE];
            bufferPointer = bytesRead = 0;
        }
        private short nextShort() throws IOException {
            short ret = 0;
            byte c = read();
            while (c <= ' ') c = read();
            boolean neg = (c == '-');
            if (neg) c = read();
            do ret = (short)(ret * 10 + c - '0');
            while ((c = read()) >= '0' && c <= '9');
            if (neg) return (short)-ret;
            return ret;
        }
        private int nextInt() throws IOException {
            int ret = 0;
            byte c = read();
            while (c <= ' ') c = read();
            boolean neg = (c == '-');
            if (neg) c = read();
            do ret = ret * 10 + c - '0';
            while ((c = read()) >= '0' && c <= '9');
            if (neg) return -ret;
            return ret;
        }
        public long nextLong() throws IOException {
            long ret = 0;
            byte c = read();
            while (c <= ' ') c = read();
            boolean neg = (c == '-');
            if (neg) c = read();
            do ret = ret * 10 + c - '0';
            while ((c = read()) >= '0' && c <= '9');
            if (neg) return -ret;
            return ret;
        }
        private char nextChar() throws IOException {
            byte c = read();
            while (c <= ' ') c = read();
            return (char)c;
        }
        private String nextString() throws IOException {
            StringBuilder ret = new StringBuilder();
            byte c = read();
            while (c <=' ') c = read();
            do {
                ret.append((char)c);
            } while ((c = read())>' ');
            return ret.toString();
        }
        private void fillBuffer() throws IOException {
            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);
            if (bytesRead == -1)  buffer[0] = -1;
        }
        private byte read() throws IOException ",ekwek
576,"public class Solution {
    private final InputStream in;
    private final PrintWriter out;
    private final Scanner scanner;
    private final int TARGET = 1_000_000;

    public Solution(InputStream in, OutputStream outs) {
        this.in = in;
        this.scanner = new Scanner(in);
        this.out = new PrintWriter(new BufferedOutputStream(outs));
    }

    public static void main(String[] args) throws IOException {
        new Solution(System.in, System.out).solve();
    }

    void solve() throws IOException {
        int T = scanner.nextInt();
        for (int t = 1; t <= T; t++) {
            int[] min = new int[4];
            out.printf(""Case #%d: "", t);
            for (int p = 0; p < 3; p++) {
                for (int c = 0; c < 4; c++) {
                    if(p==0) {
                        min[c] = scanner.nextInt();
                    } else {
                        min[c] = Math.min(min[c], scanner.nextInt());
                    }
                }
            }
            if (min[0] + min[1] + min[2] + min[3] < TARGET) {
                out.println(""IMPOSSIBLE"");
            } else {
                int remain = TARGET;
                for (int c = 0; c < 4; c++) {
                    min[c] = Math.min(remain, min[c]);
                    remain -= min[c];
                    out.print(min[c]);
                    if (c < 3) out.print(' ');
                }
                out.println();
            }
        }
        out.flush();
        out.close();
        in.",bdomokos74
759,"public class Solution {
        public static String toBinary(int n, int len)
    {
        String binary = """";
        for (long i = (1L << len - 1); i > 0; i = i / 2) {
            binary += (n & i) != 0 ? ""1"" : ""0"";
        }
        return binary;
    }
    
     public static  void main(String[] args){
        Scanner myObj = new Scanner(System.in);  
    
        int testcases = myObj.nextInt();
        
        for(int i = 0; i < testcases; i++) {
            
            
            System.out.println(""01010101"");
            
            int ones = myObj.nextInt();
            
            while(ones != 0) {
                if(ones == -1)
                    return;
                
                int randomNum = 0;
                while(bitCnt(randomNum) != ones) randomNum = ThreadLocalRandom.current().nextInt(0, 0b11111111 + 1);
                
                System.out.println(toBinary(randomNum,8));
                ones = myObj.nextInt();
                
            }

        }
        
    }
    
    static int bitCnt(int inp) {
        int cnt = 0;
        while(inp != 0) ",gregordr
801,"class Module {

    public int F;

    public int index;

    private boolean _dirty = true;

    private boolean isFork;

    private boolean isInitiator;

    public boolean isFork() {

        if (_dirty) {
            isFork = parents.size() > 1;
            isInitiator = parents.size() == 0;
            _dirty = false;
        }

        return isFork;
    }

    public boolean isInitiator() {

        if (_dirty) {
            isFork = parents.size() > 1;
            isInitiator = parents.size() == 0;
            _dirty = false;
        }

        return isInitiator;
    }

    public int child;
    public List<Integer> parents;

    public Module() {
        parents = new ArrayList<>();
    }
}

public class Solution {

    public int index;

    public Module[] modules;

    public Module abyss;

    public Solution(int index, int nModules) {

        this.index = index;
        modules = new Module[nModules + 1];

        for (int i = 0; i < nModules; i++) {
            modules[i + 1] = new Module();
        }

        abyss = new Module();
        modules[0] = abyss;
    }

    public void solve() {

        int[] moduleFun = new int[modules.length];

        var forkIds = new ArrayList<Integer>();
        var initiatorIdxs = new ArrayList<Integer>();

        for (var module : modules) {
            if (module.isFork()) {
                forkIds.add(module.index);
            } else if (module.isInitiator()) {
                initiatorIdxs.add(module.index);
            }
        }

        forkIds.stream().sorted(Comparator.reverseOrder());

        int[] forkDetonator = new int[modules.length];

        for (var forkModuleIdx : forkIds) {

            var forkModule = modules[forkModuleIdx];
            int nParents = forkModule.parents.size();

            for (int i = 0; i < nParents; i++) {

                int parentIdx = forkModule.parents.get(i);

                int f = 0;

                if (moduleFun[parentIdx] == 0) {

                    var idx = parentIdx;

                    while (moduleFun[idx] == 0) {

                        if (modules[idx].parents.size() == 0) {
                            break;
                        }

                        idx = modules[idx].parents.get(0);
                    }

                    while (idx >= parentIdx) {
                        f = Math.max(modules[idx].F, f);
                        idx = modules[idx].child;
                    }

                    moduleFun[parentIdx] = f;
                }
            }

            var ordered = forkModule.parents
                    .stream()
                    .sorted(Comparator.comparingInt(m -> moduleFun[m]))
                    .collect(Collectors.toList());

            forkDetonator[forkModuleIdx] = ordered.get(0);
        }

        int score = 0;

        for (var initiatorIdx : initiatorIdxs) {

            int lastIdx = -1;
            var initiatorScore = 0;

            var idx = initiatorIdx;

            while (idx > 0) {

                var mod = modules[idx];
                if (mod.isFork()) {
                    if (forkDetonator[idx] != lastIdx) {
                        break;
                    }
                }

                initiatorScore = Math.max(initiatorScore, mod.F);

                lastIdx = idx;
                idx = mod.child;
            }

            score += initiatorScore;
        }

        System.out.printf(""Case #%d: %d%n"", index, score);
    }

    public static void main(String[] args) {

        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int T = in.nextInt();

        for (int i = 0; i < T; i++) {

            int N = in.nextInt();

            var solution = new Solution(i, N);

            for (int j = 0; j < N; j++) {

                int F = in.nextInt();
                solution.modules[j + 1].F = F;
            }

            for (int j = 0; j < N; j++) {

                int index = j + 1;
                int child = in.nextInt();

                solution.modules[index].index = index;

                solution.modules[index].child = child;
                solution.modules[child].parents.add(index);
            }

            solution.",jaimuepe
323,"public class Solution {
	static int n;
	static int[] p;
	static long[] f;
	static ArrayList<Integer> adj[];
	static PriorityQueue<Long> bestK[];
	static int[] maxSz;
	
	static void addAll(int from, int to) {
//		if(bestK[from].size()>bestK[to].size()) {
//			PriorityQueue<Long> tmp = bestK[from];
//			bestK[from] = bestK[to];
//			bestK[to] = tmp;
//		}
		bestK[to].addAll(bestK[from]);
		bestK[from].clear();
	}
	
	public static void dfs(int i) {
		if(adj[i].isEmpty()) {
			maxSz[i] = 1;
			bestK[i].add(f[i]);
			return;
		}
		for(int j : adj[i]) {
			dfs(j);
			addAll(j, i);
			maxSz[i] += maxSz[j];
		}
		bestK[i].add(f[i]);
		while(bestK[i].size()>maxSz[i]) bestK[i].poll();
	}
	
	public static void solveCase() {
		int n = in.nextInt();
		f = in.nl(n);
		p = in.na(n);
		adj = new ArrayList[n];
		maxSz = new int[n];
		bestK = new PriorityQueue[n];
		ArrayList<Integer> first = new ArrayList<>();
		for(int i = 0; i<n; i++) {
			adj[i] = new ArrayList<>();
			bestK[i] = new PriorityQueue<>();
		}
		for(int i = 0; i<n; i++) {
			if(p[i]==0) {
				first.add(i);
				continue;
			}
			adj[p[i]-1].add(i);
		}
		long ans = 0;
		for(int i : first) {
			dfs(i);
			for(long j : bestK[i]) ans += j;
			bestK[i].clear();
		}
		out.println(ans);
	}
	
	public static void solve() {
		int t = in.nextInt();
		for (int i = 1; i <= t; i++) {
			out.print(""Case #"" + i + "": "");
			solveCase();
		}
	}

	public static void main(String[] args) {
		in = new Reader();
		out = new Writer();
		solve();
		out.exit();
	}

	static Reader in;
	static Writer out;

static class Reader {
	static BufferedReader br;
	static StringTokenizer st;
	
	public Reader() {
		br = new BufferedReader(new InputStreamReader(System.in));
	}
	
	public Reader(String f){
		try {
			br = new BufferedReader(new FileReader(f));
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	public int[] na(int n) {
		int[] a = new int[n];
		for (int i = 0; i < n; i++) a[i] = nextInt();
		return a;
	}

	public double[] nd(int n) {
		double[] a = new double[n];
		for (int i = 0; i < n; i++) a[i] = nextDouble();
		return a;
	}
	
	public long[] nl(int n) {
		long[] a = new long[n];
		for (int i = 0; i < n; i++) a[i] = nextLong();
		return a;
	}

	public char[] nca() {
		return next().toCharArray();
	}

	public String[] ns(int n) {
		String[] a = new String[n];
		for (int i = 0; i < n; i++) a[i] = next();
		return a;
	}

	public int nextInt() {
		ensureNext();
		return Integer.parseInt(st.nextToken());
	}

	public double nextDouble() {
		ensureNext();
		return Double.parseDouble(st.nextToken());
	}

	public Long nextLong() {
		ensureNext();
		return Long.parseLong(st.nextToken());
	}

	public String next() {
		ensureNext();
		return st.nextToken();
	}
	
	public String nextLine() {
		try {
			return br.readLine();
		} catch (Exception e) {
			e.printStackTrace();
			return null;
		}
	}
	
	private void ensureNext() {
		if (st == null || !st.hasMoreTokens()) {
			try {
				st = new StringTokenizer(br.readLine());
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	}
}

static class Util{
		private static Random random = new Random();
		static long[] fact;
		
		public static void initFactorial(int n, long mod) {
			fact = new long[n+1];
			fact[0] = 1;
			for (int i = 1; i < n+1; i++) fact[i] = (fact[i - 1] * i) % mod;
		}
		
		public static long modInverse(long a, long MOD) {
			long[] gcdE = gcdExtended(a, MOD);
			if (gcdE[0] != 1) return -1; // Inverted doesn't exist
			long x = gcdE[1];
			return (x % MOD + MOD) % MOD;
		}
		
		public static long[] gcdExtended(long p, long q) {
			if (q == 0) return new long[] { p, 1, 0 };
			long[] vals = gcdExtended(q, p % q);
			long tmp = vals[2];
			vals[2] = vals[1] - (p / q) * vals[2];
			vals[1] = tmp;
			return vals;
		}
		
		public static long nCr(int n, int r, long MOD) {
			if (r == 0) return 1;
			return (fact[n] * modInverse(fact[r], MOD) % MOD * modInverse(fact[n - r], MOD) % MOD) % MOD;
		}
		
		public static long nCr(int n, int r) {
			return (fact[n]/fact[r])/fact[n-r];
		}
		
		public static long nPr(int n, int r, long MOD) {
			if (r == 0) return 1;
			return (fact[n] * modInverse(fact[n - r], MOD) % MOD) % MOD;
		}
		public static long nPr(int n, int r) {
			return fact[n]/fact[n-r];
		}
		
		public static boolean isPrime(int n) { 
	        if (n <= 1) return false; 
	        if (n <= 3) return true; 
	        if (n % 2 == 0 || n % 3 == 0) return false; 
	        for (int i = 5; i * i <= n; i = i + 6) 
	            if (n % i == 0 || n % (i + 2) == 0) 
	            return false; 
	        return true; 
	    }
		
	    public static boolean[] getSieve(int n) {
	        boolean[] isPrime = new boolean[n+1];
	        for (int i = 2; i <= n; i++) isPrime[i] = true;
	        for (int i = 2; i*i <= n; i++) if (isPrime[i]) 
	                for (int j = i; i*j <= n; j++) isPrime[i*j] = false;
	        return isPrime;
	    }
	    
	    static long pow(long x, long pow, long mod){
	    	long res = 1;
	    	x = x % mod;
	    	if (x == 0) return 0;
	    	while (pow > 0){
	    		if ((pow & 1) != 0) res = (res * x) % mod;
	        	pow >>= 1;
	        	x = ",Restricted
336,"class Solution {
    static boolean found = false;

    public static void findMin(int cMin, int mMin, int yMin, int kMin, int a) {
        if (cMin + mMin + yMin + kMin == 1000000) {
            System.out.println(""Case #"" + (a + 1) + "": "" + cMin + "" "" + mMin + "" "" + yMin + "" "" + kMin);
            return;
        }
        findMin(cMin - 1, mMin, yMin, kMin, a);
        findMin(cMin, mMin - 1, yMin, kMin, a);
        findMin(cMin, mMin, yMin - 1, kMin, a);
        findMin(cMin, mMin, yMin, kMin - 1, a);
    }

    public static void compute3D(ArrayList<ArrayList<Integer>> list, int a) {
        PriorityQueue<Integer> c = new PriorityQueue<>();
        PriorityQueue<Integer> m = new PriorityQueue<>();
        PriorityQueue<Integer> y = new PriorityQueue<>();
        PriorityQueue<Integer> k = new PriorityQueue<>();
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 4; j++) {
                if (j == 0) {
                    c.add(list.get(i).get(j));
                } else if (j == 1) {
                    m.add(list.get(i).get(j));
                } else if (j == 2) {
                    y.add(list.get(i).get(j));
                } else if (j == 3) {
                    k.add(list.get(i).get(j));
                }
            }
        }
        int cMin = c.peek();
        int mMin = m.peek();
        int yMin = y.peek();
        int kMin = k.peek();
        int total = cMin + mMin + yMin + kMin;
        if (total < 1000000) {
            System.out.println(""Case #"" + (a + 1) + "": IMPOSSIBLE"");
        } else if (total == 1000000) {
            System.out.println(""Case #"" + (a + 1) + "": "" + cMin + "" "" + mMin + "" "" + yMin + "" "" + kMin);
        } else {
            findMin(cMin, mMin, yMin, kMin, a);
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int input = sc.nextInt();
        int n = 3;
        ArrayList<ArrayList<ArrayList<Integer>>> printerAll = new ArrayList<>();

        for (int a = 0; a < input; a++) {
            // PriorityQueue<Integer> c = new PriorityQueue<>();
            // PriorityQueue<Integer> m = new PriorityQueue<>();
            // PriorityQueue<Integer> y = new PriorityQueue<>();
            // PriorityQueue<Integer> k = new PriorityQueue<>();
            ArrayList<ArrayList<Integer>> printerCol = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                printerCol.add(new ArrayList<Integer>());
                for (int j = 0; j < 4; j++) {
                    int in = sc.nextInt();
                    printerCol.get(i).add(in);
                    // if (j == 0) {
                    // c.add(in);
                    // } else if (j == 1) {
                    // m.add(in);
                    // } else if (j == 2) {
                    // y.add(in);
                    // } else if (j == 3) {
                    // k.add(in);
                    // }
                }
            }
            // int cMin = c.peek();
            // int mMin = m.peek();
            // int yMin = y.peek();
            // int kMin = k.peek();
            // int total = cMin + mMin + yMin + kMin;
            // if (total < 1000000) {
            // System.out.println(""Case #"" + (a + 1) + "": IMPOSSIBLE"");
            // } else if (total == 1000000) {
            // System.out.println(""Case #"" + (a + 1) + "": "" + cMin + "" "" + mMin + "" "" + yMin
            // + "" "" + kMin);
            // } else {
            // System.out.println(total + "" "" + cMin + "" "" + mMin + "" "" + yMin + "" "" +
            // kMin);
            // }
            printerAll.add(printerCol);
        }
        for (int i = ",Roshan
713,"public class Solution {
    public static void main(String[] args) {
        Scanner input = new Scanner(System.in);
        final int numCases = Integer.parseInt(input.nextLine());
        for (int i = 1; i <= numCases; i++) {
            System.out.print(String.format(""Case #%d: "", i));
            
            final int[][] printer = new int[3][4];
            
            int maxCyan = 1000001;
            int maxMagenta = 1000001;
            int maxYellow = 1000001;
            int maxBlack = 1000001;
            
            for (int j = 0; j < 3; j++) {
                final String line = input.nextLine();
                final String[] parts = line.split(""\\\s"");
            
                printer[j][0] = Integer.parseInt(parts[0]);
                printer[j][1] = Integer.parseInt(parts[1]);
                printer[j][2] = Integer.parseInt(parts[2]);
                printer[j][3] = Integer.parseInt(parts[3]);
                
                if (printer[j][0] < maxCyan) {
                    maxCyan = printer[j][0];
                }
                
                if (printer[j][1] < maxMagenta) {
                    maxMagenta = printer[j][1];
                }
                
                if (printer[j][2] < maxYellow) {
                    maxYellow = printer[j][2];
                }
                
                if (printer[j][3] < maxBlack) {
                    maxBlack = printer[j][3];
                }
            }
            
            String r;
            
            if ((maxCyan + maxMagenta + maxYellow + maxBlack) < 1000000) {
                r = ""IMPOSSIBLE"";
            } else {
                int excess = (maxCyan + maxMagenta + maxYellow + maxBlack) - 1000000;
                int c = maxCyan;
                int m = maxMagenta;
                int y = maxYellow;
                int k = maxBlack;
                
                // remove excess from cyan
                /*if (c < (excess / 4)) {
                    excess -= c;
                    c = 0;
                } else {
                    c -= (excess / 4);
                    excess -= (excess / 4);
                }
                
                // remove excess from magenta
                if (m < (excess / 3)) {
                    excess -= m;
                    m = 0;
                } else {
                    m -= (excess / 3);
                    excess -= (excess / 3);
                }
                
                // remove excess from yellow
                if (y < (excess / 2)) {
                    excess -= y;
                    y = 0;
                } else {
                    y -= (excess / 2);
                    excess -= (excess / 2);
                }
                
                // remove excess from black
                if (k < excess) {
                    k = 0;
                } else {
                    k -= excess;
                }*/
                
                // 0 = cyan, 1 = yellow, 2 = magenta, 3 = black
                int currColor = 0;
                while (excess > 0) {
                    
                    // if there is no cyan left, skip it and move on to the next color
                    if (currColor == 0) {
                        if (c <= 0) {
                            currColor = 1;
                            continue;
                        } else {
                            c -= 1;
                            excess -= 1;
                        }
                    }
                    
                    if (currColor == 1) {
                        if (m <= 0) {
                            currColor = 2;
                            continue;
                        } else {
                            m -= 1;
                            excess -= 1;
                        }
                    }
                    
                    if (currColor == 2) {
                        if (y <= 0) {
                            currColor = 3;
                            continue;
                        } else {
                            y -= 1;
                            excess -= 1;
                        }
                    }
                    
                    if (currColor == 3) {
                        if (k <= 0) {
                            currColor = 0;
                            continue;
                        } else {
                            k -= 1;
                            excess -= 1;
                        }
                    }
                    
                    currColor += 1;
                    currColor = currColor % 4;
                }
                
                
                r = String.format(""%d %d %d %d"", c, m, y, k);
            }
            System.out.println(r);
        }
    }
}",gawallace25
822,"public class Solution {

  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int cases = sc.nextInt();
    for(int a=1; a<=cases; a++){
      ArrayDeque<Integer> deque = new ArrayDeque<>();
      int numPancakes = sc.nextInt();
      for(int i=0; i<numPancakes; i++){
        deque.addLast(sc.nextInt());
      }
      int currentMax = 0;
      int paid = 0;
      while(!deque.isEmpty()){
        //System.out.println(deque.size());
        int d1 = deque.getFirst();
        int d2 = deque.getLast();
        if(d1 < d2){
          deque.removeFirst();
          if(d1 >= currentMax){
            currentMax = d1;
            paid++;
          }

        }
        else{
          deque.removeLast();
          if(d2 >= currentMax){
            currentMax = d2;
            paid++;
          }
        }
      }
      System.",jedya
1,"public class Solution {

  public static void main(String[] args) throws Throwable {
    try (BufferedReader in=new BufferedReader(new InputStreamReader(System.in))) {
      try (PrintStream out=System.out) {
        final int T=Integer.parseInt(in.readLine());
        for (int c=1; c<=T; c++) {
          final int N=Integer.parseInt(in.readLine());
          final int D[]=new int[N];
          final StringTokenizer tokenizer=new StringTokenizer(in.readLine());
          for (int i=0; i<N; i++) {
            D[i]=Integer.parseInt(tokenizer.nextToken());
          }
          final int solution=solveFast(D);
          out.print(""Case #""+c+"": "");
          out.println(solution);
        }
      }
    }
  }

  public static int solveFast(int[] D) {
    int fr=0,to=D.length-1,previous=-1,solution=0;
    while (fr<=to) {
      if (D[fr]<D[to]) {
        if (D[fr]>=previous) {
          previous=D[fr];
          solution++;
        }
        fr++;
      }
      else {
        if (D[to]>=previous) {
          previous=D[to];
          solution++;
        }
        to--;
      }
    }
    return solution;
  }

  private static SortedMap<int[],Integer> mem=new TreeMap<>(Arrays::compare);

  public static int solveSlow(int[] D) {
    mem.clear();
    return solveSlow(D,0,D.length-1,-1);
  }

  private static int solveSlow(int[] D, int fr, int to, int previous) {
    if (fr==to) {
      return D[fr]>=previous?1:0;
    }
    else {
      final int[] key={fr,to,previous};
      Integer result=mem.get(key);
      if (result!=null) return result;
      final int x=solveSlow(D,fr+1,to,Math.max(previous,D[fr]))+(D[fr]>=previous?1:0);
      final int y=solveSlow(D,fr,to-1,Math.max(previous,D[to]))+(D[to]>=previous?1:0);
      result=",ASotelo
1331,"public class Solution {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
		int n = scanner.nextInt();
        for (int i = 0; i < n; i++) {
            int Ci = Integer.MAX_VALUE;
            int Mi = Integer.MAX_VALUE;
            int Yi = Integer.MAX_VALUE;
            int Ki = Integer.MAX_VALUE;
            for(int j=0; j<3; j++) {
                Ci = Math.min(Ci, scanner.nextInt());
                Mi = Math.min(Mi, scanner.nextInt());
                Yi = Math.min(Yi, scanner.nextInt());
                Ki = Math.min(Ki, scanner.nextInt());
            }
			System.out.println(""Case #""+(i+1)+"":"");
			System.out.println(get(Ci, Mi, Yi, Ki));
		}

    }

    public static String get(int Ci, int Mi, int Yi, int Ki) {
        int total = 1000000;
        String result = Math.min(total, Ci)+"" "";
        total -= Math.min(total, Ci);
        result = result + Math.min(total, Mi)+"" "";
        total -= Math.min(total, Mi);
        result = result + Math.min(total, Yi)+"" "";
        total -= Math.min(total, Yi);
        result = ",xinyou
892,"public final class Solution
{    
	static PrintWriter out = new PrintWriter(System.out); 
	static StringBuilder ans=new StringBuilder();
	static FastReader in=new FastReader();
	static ArrayList<Integer> g[];
	static long mod=(long)998244353,INF=Long.MAX_VALUE;
	static boolean set[],col[]; 
	static int par[],tot[],partial[];
	static int Days[],P[][];
	static int sum=0,size[];
	static int seg[],vis[][];
	static long dp[][][];
	public static void main(String args[])throws IOException
	{		
		/*
		 * star,rope,TPST
		 * BS,LST,MS,MQ
		 */
		int T=i();
		outer:for(int tt=1; tt<=T; tt++)
		{
			int N=i(),P=i();
			long A[][]=new long[N][P];
			for(int i=0; i<N; i++)A[i]=inputLong(P);
			cost=Long.MAX_VALUE;
			f(0,A,N,0,0);
			ans.append(""Case #""+tt+"": ""+cost+""
"");
		}



		out.println(ans);
		out.close();
	}
	static long cost=Long.MAX_VALUE;
	static void f(int i,long A[][],int N,long p,long s)
	{
//		System.out.println(s+"" ""+i);
		if(i==N)
		{
			cost=Math.min(cost,s);
			return;
		}
		long min=A[i][0],max=A[i][0];
		for(long a:A[i])
		{
			min=Math.min(min, a);
			max=Math.max(max, a);
		}
		if(min<=p && max<=p)
		{
			s+=p-min;
			f(i+1,A,N,min,s);
		}
		else if(min>=p && max>=p)
		{
			s+=max-p;
			f(i+1,A,N,max,s);
		}
		else
		{
			long a=p-min,b=max-p;
			s+=(a+b);
			if(a<b)
			{
				s+=a;
				f(i+1,A,N,max,s);
			}
			else if(a>b)
			{
				s+=b;
				f(i+1,A,N,min,s);
			}
			else
			{
//				long s1=s;
				s+=a;
				f(i+1,A,N,min,s);
				f(i+1,A,N,max,s);
			}
				
		}
	}
	static boolean palin(long n)
	{
		long s=0;
		long N=n;
		while(N!=0)
		{
			long r=N%10;
			s*=10L;
			s+=r;
			N/=10;
		}		
		return s==n;
	}
	static String fdp(char X[],int i,int N)
	{
		String Y="""";
		if(i+1==N)return X[N-1]+"""";




		return Y;
	}
	static long s=0;
	static long dfs(int n,int p,long F[])
	{
		long min=0,sum=0;
		for(int c:g[n])
		{
			if(c!=p)
			{
				long a=dfs(c,n,F);
				sum+=a;
				if(min==0)min=a;
				min=Math.min(a, min);
			}
		}
		//		System.out.println(n+"" ""+min+ "" ""+sum);
		s+=(sum-min);
		return Math.max(F[n-1], min);
	}
	static boolean fSmall(char X[],int i,int N)
	{
		if(i==N)
		{
			//if length of maximum palindrome is >=5
			int max=1;
			for(int l=0; l<N; l++)
			{
				for(int r=l+1; r<N; r++)
				{
					if(isPal(X,l,r))max=Math.max(max, r-l+1);
				}
			}
			return max<5;
		}
		if(X[i]=='?')
		{
			char Y[]=Arrays.copyOf(X,N);
			Y[i]='0';
			X[i]='1';
			return fSmall(X,i+1,N)|fSmall(Y,i+1,N);
		}
		return fSmall(X,i+1,N);
	}
	static boolean isPal(char X[],int l, int r)
	{
		while(l<r)
		{
			if(X[l]!=X[r])return false;
			l++;
			r--;
		}
		return true;
	}


	static boolean f(char X[],char Y[],int N,int M)
	{
		int j=0;
		for(char x:Y)
		{
			if(j<N && x==X[j])j++;
		}
		//	  System.out.println(j+"" ""+N);
		return j==N;
	}
	static int index(int a,ArrayList<Integer> A)
	{
		int l=-1,r=A.size();
		while(r-l>1)
		{
			int m=(l+r)/2;
			int x=A.get(m);
			if(x<=a)l=m;
			else r=m;
		}
		return r;
	}
	static long and(int i,int j)
	{
		System.out.println(""and ""+i+"" ""+j);
		return l();
	}
	static long or(int i,int j)
	{
		System.out.println(""or ""+i+"" ""+j);
		return l();
	}
	static boolean is_Sorted(int A[])
	{
		int N=A.length;
		for(int i=1; i<=N; i++)if(A[i-1]!=i)return false;
		return true;
	}
	static boolean f(StringBuilder sb,String Y,String order)
	{
		StringBuilder res=new StringBuilder(sb.toString());
		HashSet<Character> set=new HashSet<>();
		for(char ch:order.toCharArray())
		{
			set.add(ch);
			for(int i=0; i<sb.length(); i++)
			{
				char x=sb.charAt(i);
				if(set.contains(x))continue;
				res.append(x);
			}
		}
",kkkkush
1135,"public class Solution {
    Scanner sc       = new Scanner(System.in);
    static final String FILENAME = ""A-small"";
    static final String IN       = FILENAME + "".in"";
    static final String OUT      = FILENAME + "".out"";
    PrintStream out      = System.out;

    private void run() throws Exception {
        // out = new PrintStream(new FileOutputStream(OUT));
        int T = sc.nextInt();
        for (int t = 1; t <= T; t++) {
            int n = sc.nextInt(); int k = sc.nextInt();
            int [] rooms = new int[n];
            for(int i = 0; i<n; i++)
                rooms[i] = i + 1;

            int stats[] = new int[n];
            Arrays.fill(stats, 0);
            shuffleArray(rooms);;
            int startPos = 0;
            for(int i = 0, j = 0; i<k; i++) {
                int u = sc.nextInt();
                int deg = sc.nextInt();
                if(i == 0)
                    startPos = u;
                stats[deg]++;
                if(j < n) {
                    if(deg == 1) {
                        out.println(""W"");
                        out.flush();
                    } else {
                        if(rooms[j] == startPos)
                            j++;
                        out.println(""T "" + rooms[j++]);
                    }
                } else {
                    out.println(""W"");
                    out.flush();
                }

            }
            double p = 0.;
            double totalW = 0.;
            for(int i = 0; i<n; i++) {
                if(stats[i] != 0) {
                    double degP = (i / (n * 1.)) * stats[i];
                    p += degP;
                    totalW += stats[i];
                }
            }
            p = p / totalW;
//            System.out.println(p + "" prob"" );
            double exp1 = p * n * ( n - 1) / 2.;
            double exp2 = (1-p) * n * ( n - 1) / 2.;
            double exp = (exp1 + exp2) / 2;
            out.println(""E"" + "" "" + (int) Math.ceil(exp));
            out.flush();
        }
        sc.close();
        out.flush();
        out.close();
    }

    static void shuffleArray(int[] ar)
    {
        Random rnd = ThreadLocalRandom.current();
        for (int i = ar.length - 1; i > 0; i--)
        {
            int index = rnd.nextInt(i + 1);
            // Simple swap
            int a = ar[index];
            ar[index] = ar[i];
            ar[i] = a;
        }
    }

    public static void main(String args[]) throws Exception {
        new Solution().",rkamun
758,"public class Solution {
     public static  void main(String[] args){
        Scanner myObj = new Scanner(System.in);  
    
        int testcases = myObj.nextInt();
        
        xxas: for(int i = 0; i < testcases; i++) {
            int n = myObj.nextInt();
            int k = myObj.nextInt();
            
            int a = 0;
            int b = 0;
            for(int j = 0; j < n; j++) {
                int nxt = myObj.nextInt();
                a += nxt;
                b += nxt*nxt;
            }
            
            //
            if(k == 1) {
                if(a == 0) {
                    System.out.println(""Case #"" +(i+1)+ "": "" + (b==0 ? 0 : ""IMPOSSIBLE"") );
                }else
                    System.out.println(""Case #"" +(i+1)+ "": "" + ((b-a*(long)a)%(2*a)==0 ? (b-a*(long)a)/(2*a) : ""IMPOSSIBLE"") );
                    continue xxas;
            }
            
            String zeros = """";
            while(k != 2) {
                zeros += "" 0"";
                k--;
            }
            
            for(int x= -100000; x <= 100000; x++) {
                
                a += x;
                b += x*x;
                
                if(a == 0 && b == 0) {
                    System.out.println(""Case #"" +(i+1)+ "": "" + ""0 0"" +  zeros );
                    continue xxas;
                }
                
                if((b-a*(long)a)%(2*a)==0) {
                    System.out.println(""Case #"" +(i+1)+ "": "" + x + "" "" + (b-a*(long)a)/(2*a) + zeros );
                    continue xxas;
                }
                    
                a -= x;
                b -= x*x;
            }
            System.out.println(""Case #"" +(i+1)+ "": "" + ""IMPOSSIBLE"" );

        }
        
    }
    
    static public boolean isValid(String s) {
        boolean[] taken = new boolean[40];
        for(int i = 0; i< s.length();) {
            char c = s.charAt(i);
            if(taken[c-'A'])
            return false;
            taken[c-'A'] = true;
            while(i < s.",gregordr
272,"public static void main(String[] args) {
        Scanner s = new Scanner(System.in) ;
        int n = s.nextInt() ;
        for (int i=1 ;i<=n ;i++) {
            System.out.print(""Case #""+i);
            check() ;
        }
    }

    public static void check() {
        String s = """" ;
        Scanner sc = new Scanner(System.in) ;
        String str = sc.nextLine() ;
        char[] l = str.toCharArray() ;

        boolean test = false ;
        for(int j=0 ; j<l.length-1 ; j++) {
            if(l[j]!=l[j+1]) {
                test = true ;
            }
        }

        if(!test) {
            System.out.println(str);
            return;
        }

        for(int i=0 ; i<l.length-1 ; i++) {
            if(  (int)l[i]<=(int)l[i+1] ) {
                s = ",Mr
1221,"public class Solution {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        for (int t = 0; t < T; t++) {
            int N = sc.nextInt();
            int K = sc.nextInt();
            if (N - 1 <= K) {
                int startRoom = sc.nextInt();
                long total = sc.nextInt();
                for (int i = 1; i <= N; i++) {
                    if (i == startRoom) {
                        continue;
                    }
                    System.out.println(""T "" + i);
                    sc.nextInt();
                    total += sc.nextInt();
                }
                System.out.println(""E "" + total / 2);
            } else {
                int startRoom = sc.nextInt();
                long total = sc.nextInt();
                int k = 0;
                for (int i = 1; i <= N && k < K; i++, k++) {
                    if (i == startRoom) {
                        i++;
                        if (i > N) {
                            break;
                        }
                    }
                    System.out.println(""T "" + i);
                    if (sc.nextInt() == -1) {
                        return;
                    }
                    total += sc.nextInt();
                }
                System.",teekaytai
1031,"public class Solution {
    
    public static void main(String... args) {
        Scanner sc = new Scanner(System.in);
        int count = sc.nextInt();
        for (int i = 0; i < count; i++) {
            int size = sc.nextInt();
            int[] pancakes = new int[size];
            for (int j = 0; j < size; j++) {
                pancakes[j] = sc.nextInt();
            }
            System.out.println(""Case #"" + (i + 1) + "": "" + count(pancakes));
        }
    }

    public static int count(int[] pancakes) {
        int leftIndex = 0;
        int rightIndex = pancakes.length - 1;
        int prev = -1;
        int result = 0;
        while(leftIndex <= rightIndex) {
            int left = pancakes[leftIndex];
            int right = pancakes[rightIndex];
            boolean leftValid = left >= prev;
            boolean rightValid = right >= prev;
            if (!leftValid && !rightValid) {
                break;
            }
            result++;
            if (leftValid && rightValid) {
                if (left <= right) {
                    prev = pancakes[leftIndex++];
                } else {
                    prev = pancakes[rightIndex--];
                }
            }else if (leftValid) {
                prev = pancakes[leftIndex++];
            }else {
                prev = ",petrus
1283,"public class Solution {

	static boolean verb=true;
	static void log(Object X){if (verb) System.err.println(X);}
	static void log(Object[] X){if (verb) {for (Object U:X) System.err.print(U+"" "");System.err.println("""");}}
	static void log(int[] X){if (verb) {for (int U:X) System.err.print(U+"" "");System.err.println("""");}}
	static void logWln(Object X){if (verb) System.err.print(X);}
	static void info(Object o){	System.out.println(o);}
	static void output(Object o){outputWln(""""+o+""
"");	}
	static void outputWln(Object o){try {out.write(""""+ o);} catch (Exception e) {}}





	// Global vars


	static BufferedWriter out;
	static InputReader reader;



	static void process() throws Exception {

		out = new BufferedWriter(new OutputStreamWriter(System.out));
		reader=new InputReader(System.in);
		Locale.setDefault(Locale.US);	

		//test();
		
		String a=""..+-+-+-+-+-+-+-+-+-+-+-+-+-+"";
		String b=""..|.|.|.|.|.|.|.|.|.|.|.|.|.|"";
		String c=""+-+-+-+-+-+-+-+-+-+-+-+-+-+-+"";
		String d=""|.|.|.|.|.|.|.|.|.|.|.|.|.|.|"";
		
		

		int T=reader.readInt();
		
	
		
		for (int t=1;t<=T;t++) {
			
			int R=reader.readInt()-1;
			int C=reader.readInt();
			
			
			
			output(""Case #""+t+"": "");
			int L=2*C+1;
			output(a.substring(0,L));
			output(b.substring(0,L));
			output(c.substring(0,L));
			for (int i=0;i<R;i++) {
				output(d.substring(0,L));
				output(c.substring(0,L));
			}
		}
		//log(""ok"");
		try {
			out.close();
		}
		catch (Exception EX){}

	}








	public static void main(String[] args) throws Exception {
		process();

	}

	static final class InputReader {
		private final InputStream stream;
		private final byte[] buf = new byte[1024];
		private int curChar;
		private int numChars;

		public InputReader(InputStream stream) {
			this.stream = stream;
		}

		private int read() throws IOException {
			if (curChar >= numChars) {
				curChar = 0;
				numChars = stream.read(buf);
				if (numChars <= 0) {
					return -1;
				}
			}
			return buf[curChar++];
		}


		public final String readString() throws IOException {
			int c = read();
			while (isSpaceChar(c)) {
				c = read();
			}
			StringBuilder res=new StringBuilder();
			do {
				res.append((char)c);
				c = read();
			} while (!isSpaceChar(c));
			return res.toString();
		}

		public final int readInt() throws IOException {
			int c = read();
			boolean neg=false;
			while (isSpaceChar(c)) {
				c = read();
			}
			char d=(char)c;
			//log(""d:""+d);
			if (d=='-') {
				neg=true;
				c = read();
			}
			int res = 0;
			do {
				res *= 10;
				res += c - '0';
				c = read();
			} while (!isSpaceChar(c));
			//log(""res:""+res);
			if (neg)
				return -res;
			return res;

		}

		public final long readLong() throws IOException {
			int c = read();
			boolean neg=false;
			while (isSpaceChar(c)) {
				c = read();
			}
			char d=(char)c;
			//lo)g(""d:""+d);
			if (d=='-') {
				neg=true;
				c = read();
			}
			long res = 0;
			do {
				res *= 10;
				res += c - '0';
				c = read();
			} while (!isSpaceChar(c));
			//log(""res:""+res);
			if (neg)
				return -res;
			return res;

		}



",vincent
1035,"public class Solution {
    InputStream is;
    FastWriter out;
    String INPUT = """";

    public static void main(String[] args) throws Exception
    {
        new Solution().run();// Here run assign I/O calls solve also tell total time invested
    }

    void solve()
    {
        int t=ni(), p=0;
        while(t-->0)
        {
            System.out.print(""Case #""+ ++p +"": "");
            go();
        }
    }

    long max=-1; int n;
    int fac[], point[];
    void printDistinctPermutn(String str, String ans)
    {

        // If string is empty
        if (str.length() == 0) {

            // print ans
//            System.out.println(ans);
            boolean vis[]=new boolean[n];
            long sum=0;
            for(int i=0;i<ans.length();i++)
            {
                int val = ans.charAt(i)-'0';
                int m=-1,j=-1;
                if(m<fac[val])
                {
                    j=val;
                    m=fac[val];
                }
                while(point[val]!=0&&val>point[val]-1)
                {
                    val=point[val]-1;
                    if(vis[val])
                        break;
                    if(m<=fac[val])  // if complier gives wc
                    {
                        j=val;
                        m=fac[val];
                    }
                }
                sum+=m;
                vis[j]=true;
            }
            max=Math.max(max, sum);
            return;
        }

        // Make a boolean array of size '26' which
        // stores false by default and make true
        // at the position which alphabet is being
        // used
        boolean alpha[] = new boolean[10];

        for (int i = 0; i < str.length(); i++) {

            // ith character of str
            char ch = str.charAt(i);

            // Rest of the string after excluding
            // the ith character
            String ros = str.substring(0, i) +
                    str.substring(i + 1);

            // If the character has not been used
            // then recursive call will take place.
            // Otherwise, there will be no recursive
            // call
            if (alpha[ch - '0'] == false)
                printDistinctPermutn(ros, ans + ch);
            alpha[ch - '0'] = true;
        }
    }

    void go()
    {
        n=ni();
        fac=ni(n);
        point=ni(n);
        Set<Integer> set=new HashSet<>();
        for(int i=0;i<n;i++)
        {
            if(point[i]==0)
                continue;
            else
                set.add(point[i]-1);
        }
//        System.out.println(set);
        String s="""";
        for(int i=0;i<n;i++)
        {
            if(!set.contains(i))
                s+=i;
        }
        max=-1;
//        System.out.println(s);
        printDistinctPermutn(s,"""");
        System.out.println(max);
    }

    static boolean prime[];
    static int count=0;

    void sieve(int n)
    {
        prime=new boolean[n+1];
        Arrays.fill(prime, true);
        for(int i=2;i<=Math.sqrt(n);i++)
            if(prime[i])
                for(int j=i*i;j<=n;j+=i)
                    prime[j]=false;
    }

    boolean isPrime(int n)
    {
        for(int i=2;i<=Math.sqrt(n);i++)
            if(n%i==0)
                return false;
        return true;
    }

    long gcd(long a,long b)
    {
        if(a==0)
            return b;
        return gcd(b%a,a);
    }

    void run() throws Exception
    {
        is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());
        out = new FastWriter(System.out);

        long s = System.currentTimeMillis();
        solve();
        out.flush();
        tr(System.currentTimeMillis()-s+""ms"");
    }

    byte[] inbuf = new byte[1024];
    public int lenbuf = 0, ptrbuf = 0;

    private int readByte()
    {
        if(lenbuf == -1)throw new InputMismatchException();
        if(ptrbuf >= lenbuf){
            ptrbuf = 0;
            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
            if(lenbuf <= 0)return -1;
        }
        return inbuf[ptrbuf++];
    }

    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }

    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }

    private double nd() { return Double.parseDouble(ns()); }

    private char nc() { return (char)skip(); }

    private String ns()
    {
        int b = skip();
        StringBuilder sb = new StringBuilder();
        while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }

    private char[] ns(int n)
    {
        char[] buf = new char[n];
        int b = skip(), p = 0;
        while(p < n && !(isSpaceChar(b))){
            buf[p++] = (char)b;
            b = readByte();
        }
        return n == p ? buf : Arrays.copyOf(buf, p);
    }

    private int[] ni(int n)
    {
        int[] a = new int[n];
        for(int i = 0;i < n;i++)a[i] = ni();
        return a;
    }

    private long[] nl(int n)
    {
        long[] a = new long[n];
        for(int i = 0;i < n;i++)a[i] = nl();
        return a;
    }

    private Long[] nL(int n) {
        Long[] a = new Long[n];
        for (int i = 0; i < n; i++)
            a[i] = nl();
        return a;
    }

    private Integer[] nI(int n) {
        Integer[] a = new Integer[n];
        for (int i = 0; i < n; i++)
            a[i] = ni();
        return a;
    }

    private char[][] ns(int n, int m) {
        char[][] map = new char[n][];
        for(int i = 0;i < n;i++)map[i] = ns(m);
        return map;
    }

    private int[][] ni(int n, int m) {
        int[][] map = new int[n][];
        for(int i = 0;i < n;i++)map[i] = ni(m);
        return map;
    }

    private long[][] nl(int n, int m) {
        long[][] map = new long[n][];
        for(int i = 0;i < n;i++)map[i] = nl(m);
        return map;
    }

    private Integer[][] nI(int n, int m) {
        Integer[][] map = new Integer[n][];
        for(int i = 0;i < n;i++)map[i] = nI(m);
        return map;
    }

    private Long[][] nL(int n, int m) {
        Long[][] map = new Long[n][];
        for(int i = ",pgthebigshot
778,"public class Solution {
    public static void main(String[] argu) throws Exception {
        Reader br = new Reader();
        PrintWriter pw = new PrintWriter(System.out);
        int T = br.nextInt();
        for (int t = 1; t <= T; ++t) {
            int N = br.nextInt(), res = 0;
            int[] dice = new int[N];
            for (int i = 0; i < N; ++i) dice[i] = br.nextInt();
            Arrays.sort(dice);
            for (int i : dice) if (res < i) res++;
            pw.format(""Case #%d: %d
"", t, res);
        }
        pw.close();
        br.close();
    }
    static class Reader
    {
        final private int BUFFER_SIZE = 1 << 16;
        private DataInputStream din;
        private byte[] buffer;
        private int bufferPointer, bytesRead;

        public Reader()
        {
            din = new DataInputStream(System.in);
            buffer = new byte[BUFFER_SIZE];
            bufferPointer = bytesRead = 0;
        }
        private void fillBuffer() throws IOException
        {
            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);
            if (bytesRead == -1)
                buffer[0] = -1;
        }

        private byte read() throws IOException
        {
            if (bufferPointer == bytesRead)
                fillBuffer();
            return buffer[bufferPointer++];
        }

        public void close() throws IOException
        {
            if (din == null)
                return;
            din.close();
        }
        public int nextInt() throws IOException
        {
            int ret = 0;
            byte c = read();
            while (c <= ' ')
                c = read();
            boolean neg = (c == '-');
            if (neg)
                c = read();
            do
            {
                ret = ret * 10 + c - '0';
            }  while ((c = read()) >= '0' && c <= '9');

            if (neg)
                return -ret;
            return ret;
        }
        public long nextLong() throws IOException
        {
            long ret = 0;
            byte c = read();
            while (c <= ' ')
                c = read();
            boolean neg = (c == '-');
            if (neg)
                c = read();
            do
            {
                ret = ret * 10 + c - '0';
            }  while ((c = read()) >= '0' && c <= '9');

            if (neg)
                return -ret;
            return ret;
        }

        public String readLine() throws IOException {
            byte[] buf = new byte[200001]; // line length
            int cnt = 0, c = read();
            if (-1 != c && '
' != c) buf[cnt++] = (byte) c;
            while ((c = read()) != -1)
            {
                if (c == '
')
                    break;
                buf[cnt++] = (byte) c;
            }
            return new String(buf, 0, cnt);
        }

    }
}",hdchen
1285,"public class Solution {

	static boolean verb=true;
	static void log(Object X){if (verb) System.err.println(X);}
	static void log(Object[] X){if (verb) {for (Object U:X) System.err.print(U+"" "");System.err.println("""");}}
	static void log(int[] X){if (verb) {for (int U:X) System.err.print(U+"" "");System.err.println("""");}}
	static void logWln(Object X){if (verb) System.err.print(X);}
	static void info(Object o){	System.out.println(o);}
	static void output(Object o){outputWln(""""+o+""
"");	}
	static void outputWln(Object o){try {out.write(""""+ o);} catch (Exception e) {}}





	// Global vars


	static BufferedWriter out;
	static InputReader reader;



	static int R,P;

	static void ask(int node) throws Exception {
		System.out.println(""T ""+(node+1));
		System.out.flush();
		R=reader.readInt()-1;
		P=reader.readInt();
	}

	static void answer(long x) {
		System.out.println(""E ""+x);
		System.out.flush();

	}

	static void process() throws Exception {

		//out = new BufferedWriter(new OutputStreamWriter(System.out));
		reader=new InputReader(System.in);
		Locale.setDefault(Locale.US);	




		int T=reader.readInt();



		for (int t=1;t<=T;t++) {


			int n=reader.readInt();
			int K=reader.readInt();

			R=reader.readInt()-1;
			P=reader.readInt();
			long tot=0;
			tot+=P;
		
			if (K>=n) {
				for (int i=0;i<n;i++) {
					if (i!=R) {
						ask(i);
						tot+=P;
					}
				}
				answer(tot/2);

			} else {
				// take some randoms
				ArrayList<Integer> list=new ArrayList<Integer>();
				for (int i=0;i<n;i++) {
					if (i!=R) {
						list.add(i);
					}
				}
				//Collections.shuffle(list);
				for (int i=0;i<K-1;i++) {
					ask(list.get(i));
					tot+=P;
				}
				tot*=n;
				tot/=K;
				tot/=2;
				long max=n;
				max*=n-1;
				max/=3;
				
				long min=(2*n)/3;
				if (tot<min)
					tot=min;
				if (tot>max)
					tot=max;
				
				answer(tot);
				
			}


			//String ss="""";
			

			//output(""Case #""+t+"": ""+ss);
		}
		//log(""ok"");
		/*
		try {
			out.close();
		}
		catch (Exception EX){}
*/
	}








	public static void main(String[] args) throws Exception {
		process();

	}

	static final class InputReader {
		private final InputStream stream;
		private final byte[] buf = new byte[1024];
		private int curChar;
		private int numChars;

		public InputReader(InputStream stream) {
			this.stream = stream;
		}

		private int read() throws IOException {
			if (curChar >= numChars) {
				curChar = 0;
				numChars = stream.read(buf);
				if (numChars <= 0) {
					return -1;
				}
			}
			return buf[curChar++];
		}


		public final String readString() throws IOException {
			int c = read();
			while (isSpaceChar(c)) {
				c = read();
			}
			StringBuilder res=new StringBuilder();
			do {
				res.append((char)c);
				c = read();
			} while (!isSpaceChar(c));
			return res.toString();
		}

		public final int readInt() throws IOException {
			int c = read();
			boolean neg=false;
			while (isSpaceChar(c)) {
				c = read();
			}
			char d=(char)c;
			//log(""d:""+d);
			if (d=='-') {
				neg=true;
				c = read();
			}
			int res = 0;
			do {
				res *= 10;
				res += c - '0';
				c = read();
			} while (!isSpaceChar(c));
			//log(""res:""+res);
			if (neg)
				return -res;
			return res;

		}

		public final long readLong() throws IOException {
			int c = read();
			boolean neg=false;
			while (isSpaceChar(c)) {
				c = read();
			}
			char d=(char)c;
			//lo)g(""d:""+d);
			if (d=='-') {
				neg=true;
				c = read();
			}
			long res = 0;
			do {
				res *= 10;
				res += c - '0';
				c = read();
			} while (!isSpaceChar(c));
			//log(""res:""+res);
			if (neg)
				return -res;
			return res;

		}



",vincent
837,"public class Solution {

    public static void main(String[] args) {

        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int t = Integer.parseInt(in.nextLine()); // Scanner has functions to read ints, longs, strings, chars, etc.

        String s;
        for (int i = 1; i <= t; i++) {
            s = in.nextLine();
            System.out.print(""Case #"" + i + "": "");

            char[] stringChar = s.toCharArray();
            Arrays.sort(stringChar);

            StringBuilder result, stringAux;



            stringAux = new StringBuilder(s);
            List<Integer> positionExc = new ArrayList<>();

            for (char c : stringChar) {

                result = new StringBuilder();
                for (int l = 0; l < stringAux.length(); l++) {
                    if (c == stringAux.charAt(l) && !positionExc.contains(l)) {

                        for (int j = 0; j < positionExc.size(); j++) {
                            if(l<positionExc.get(j)){
                                positionExc.set(j, positionExc.get(j)+1);
                            }
                        }

                        result.append(stringAux.charAt(l));
                        result.append(stringAux.charAt(l));
                        result.append(stringAux.substring(l + 1, stringAux.length()));
                        positionExc.add(l);
                        positionExc.add(l + 1);
                        break;
                    } else {
                        result.append(stringAux.charAt(l));
                    }

                }

                if (result.compareTo(stringAux) < 0) {
                    stringAux = result;
                }
            }



            System.",jonathan38m
1265,"public class Solution {
    {
        MULTI_TEST = false;
        FILE_NAME = """";
        NEED_FILE_IO = false;
        INF = (long) 1e18;
    } // fields

    int ask(String s) {
        out.println(s);
        out.flush();
        return ri();
    }

    String getForm(int x) {
        char[] form = new char[8];
        Arrays.fill(form, '0');
        int cnt = 0;
        while(x > 0) {
            int bit = x % 2;
            x/=2;
            form[8 - cnt - 1] = (char) ('0' + bit);
            cnt++;
        }

        return new String(form);
    }
    String solve_test() {
        for(int i = 1; i <= 255; i++) {
            int x = ask(getForm(i));
            if(x == 0) return """";
        }
        return """";
    }


    void solve() {
        int t = ri();
        for(int it = 0; it < t; it++) {
            solve_test();
        }
    }

    public static void main(String[] args) {
        new Solution().run();
    } //main

    @SuppressWarnings(""unused"")
    long gcd(long a, long b) {
        return b == 0 ? a : gcd(b, a % b);
    }

    @SuppressWarnings(""unused"")
    long lcm(long a, long b) {
        return a / gcd(a, b) * b;
    }

    @SuppressWarnings(""unused"")
    int gcd(int a, int b) {
        return (int) gcd((long) a, b);
    }

    @SuppressWarnings(""unused"")
    int lcm(int a, int b) {
        return (int) lcm(a, (long) b);
    }

    @SuppressWarnings(""unused"")
    int sqrtInt(int x) {
        return (int) sqrtLong(x);
    }

    @SuppressWarnings(""unused"")
    long sqrtLong(long x) {
        long root = (long) Math.sqrt(x);
        while (root * root > x) --root;
        while ((root + 1) * (root + 1) <= x) ++root;
        return root;
    }

    @SuppressWarnings(""unused"")
    int cbrtLong(long x) {
        int cbrt = (int) Math.cbrt(x);
        while ((long) cbrt * cbrt >= x) {
            cbrt--;
        }
        while ((long) (cbrt + 1) * (cbrt + 1) <= x) cbrt++;
        return cbrt;
    }

    @SuppressWarnings(""unused"")
    long binpow(long a, long power) {
        return binpow(a, power, Long.MAX_VALUE);
    }

    @SuppressWarnings(""unused"")
    long binpow(long a, long power, long modulo) {
        if (power == 0) return 1 % modulo;
        if (power % 2 == 1) {
            long b = binpow(a, power - 1, modulo) % modulo;
            return ((a % modulo) * b) % modulo;
        } else {
            long b = binpow(a, power / 2, modulo) % modulo;
            return (b * b) % modulo;
        }
    }

    @SuppressWarnings(""unused"")
    long fastMod(String s1, long n2) {
        long num = 0;
        for (int i = 0; i < s1.length() - 1; i++) {
            num += Integer.parseInt(String.valueOf(s1.charAt(i)));
            num *= 10;
            if (num >= n2) {
                num = num % n2;
            }
        }
        return (num + Integer.parseInt(String.valueOf(s1.charAt(s1.length() - 1)))) % n2;
    }

    @SuppressWarnings(""unused"")
    long factorialMod(long n, long p) {
        long res = 1;
        while (n > 1) {
            res = (res * ((n / p) % 2 == 1 ? p - 1 : 1)) % p;
            for (int i = 2; i <= n % p; ++i)
                res = (res * i) % p;
            n /= p;
        }
        return res % p;
    }

    @SuppressWarnings(""unused"")
    boolean isPrime(int number) {
        for (int i = 2; i * i <= number; i++) {
            if (number % i == 0) {
                return false;
            }
        }
        return number > 1;
    }

    @SuppressWarnings(""unused"")
    boolean[] primes(int border) {
        boolean[] isPrimes = new boolean[border + 1];
        Arrays.fill(isPrimes, true);
        isPrimes[0] = false;
        isPrimes[1] = false;
        for (int i = 2; i < border + 1; i++) {
            if (!isPrimes[i]) continue;
            for (int k = i * 2; k < border; k += i) {
                isPrimes[k] = false;
            }
        }
        return isPrimes;
    } //Number theory

    @SuppressWarnings(""unused"")
    void sort(int[] a) {
        int n = a.length;
        Integer[] arr = new Integer[n];
        for (int i = 0; i < n; i++) {
            arr[i] = a[i];
        }
        Arrays.sort(arr);
        for (int i = 0; i < n; i++) {
            a[i] = arr[i];
        }
    }

    @SuppressWarnings(""unused"")
    void sort(long[] a) {
        int n = a.length;
        Long[] arr = new Long[n];
        for (int i = 0; i < n; i++) {
            arr[i] = a[i];
        }
        Arrays.sort(arr);
        for (int i = 0; i < n; i++) {
            a[i] = arr[i];
        }
    }

    @SuppressWarnings(""unused"")
    int max(int[] a) {
        int n = a.length;
        int max = Integer.MIN_VALUE;
        for (int j : a) {
            if (j > max) max = j;
        }
        return max;
    }

    @SuppressWarnings(""unused"")
    long max(long[] a) {
        int n = a.length;
        long max = Long.MIN_VALUE;
        for (long l : a) {
            if (l > max) max = l;
        }
        return max;
    }

    @SuppressWarnings(""unused"")
    int maxIndex(int[] a) {
        int n = a.length;
        int max = Integer.MIN_VALUE;
        int index = 0;
        for (int i = 0; i < n; i++) {
            if (a[i] > max) {
                max = a[i];
                index = i;
            }
        }
        return index;
    }

    @SuppressWarnings(""unused"")
    int maxIndex(long[] a) {
        int n = a.length;
        long max = Long.MIN_VALUE;
        int index = 0;
        for (int i = 0; i < n; i++) {
            if (a[i] > max) {
                max = a[i];
                index = ",v0s7er
330,"class Solution {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[][] input = new int[n][2];
        for (int i = 0; i < n; i++) {
            input[i][0] = sc.nextInt();
            input[i][1] = sc.nextInt();
        }
        for (int i = 0; i < n; i++) {
            System.out.println(""Case #"" + (i + 1) + "":"");
            printOutput(input[i]);
        }
    }

    public static void printOutput(int[] input) {
        int numOfRows = input[0] + input[0] + 1;
        for (int i = 0; i < numOfRows; i++) {
            if (i == 0) {
                System.out.print("".."");
                for (int j = 0; j < input[1] - 1; j++) {
                    System.out.print(""+-"");
                }
                System.out.print(""+"");
                System.out.println();
            } else if (i == 1) {
                System.out.print("".."");
                for (int j = 0; j < input[1] - 1; j++) {
                    System.out.print(""|."");
                }
                System.out.print(""|"");
                System.out.println();
            } else if (i % 2 == 0) {
                for (int j = 0; j < input[1]; j++) {
                    System.out.print(""+-"");
                }
                System.out.print(""+"");
                System.out.println();
            } else {
                for (int j = 0; j < input[1]; j++) {
                    System.out.print(""|."");
                }
                System.out.print(""|"");
                System.",Roshan
316,"public class Solution {
	static int n;
	static int[] p;
	static long[] f;
	static ArrayList<Integer> adj[];
	static PriorityQueue<Long> bestK[];
	static int[] maxSz;
	
	static void addAll(int from, int to) {
		if(bestK[from].size()>bestK[to].size()) {
			PriorityQueue<Long> tmp = bestK[from];
			bestK[from] = bestK[to];
			bestK[to] = tmp;
		}
		bestK[to].addAll(bestK[from]);
		bestK[from].clear();
	}
	
	public static void dfs(int i) {
		if(adj[i].isEmpty()) {
			maxSz[i] = 1;
			bestK[i].add(f[i]);
			return;
		}
		for(int j : adj[i]) {
			dfs(j);
			bestK[i].addAll(bestK[j]);
			//addAll(j, i);
			maxSz[i] += maxSz[j];
		}
		bestK[i].add(f[i]);
		while(bestK[i].size()>maxSz[i]) bestK[i].poll();
	}
	
	public static void solveCase() {
		int n = in.nextInt();
		f = in.nl(n);
		p = in.na(n);
		adj = new ArrayList[n];
		maxSz = new int[n];
		bestK = new PriorityQueue[n];
		ArrayList<Integer> first = new ArrayList<>();
		for(int i = 0; i<n; i++) {
			adj[i] = new ArrayList<>();
			bestK[i] = new PriorityQueue<>();
		}
		for(int i = 0; i<n; i++) {
			if(p[i]==0) {
				first.add(i);
				continue;
			}
			adj[p[i]-1].add(i);
		}
		long ans = 0;
		for(int f : first) {
			dfs(f);
			while(bestK[f].size()>maxSz[f]) bestK[f].poll();
			for(long j : bestK[f]) ans += j;
		}
		out.println(ans);
	}
	
	public static void solve() {
		int t = in.nextInt();
		for (int i = 1; i <= t; i++) {
			out.print(""Case #"" + i + "": "");
			solveCase();
		}
	}

	public static void main(String[] args) {
		in = new Reader();
		out = new Writer();
		solve();
		out.exit();
	}

	static Reader in;
	static Writer out;

static class Reader {
	static BufferedReader br;
	static StringTokenizer st;
	
	public Reader() {
		br = new BufferedReader(new InputStreamReader(System.in));
	}
	
	public Reader(String f){
		try {
			br = new BufferedReader(new FileReader(f));
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
	
	public int[] na(int n) {
		int[] a = new int[n];
		for (int i = 0; i < n; i++) a[i] = nextInt();
		return a;
	}

	public double[] nd(int n) {
		double[] a = new double[n];
		for (int i = 0; i < n; i++) a[i] = nextDouble();
		return a;
	}
	
	public long[] nl(int n) {
		long[] a = new long[n];
		for (int i = 0; i < n; i++) a[i] = nextLong();
		return a;
	}

	public char[] nca() {
		return next().toCharArray();
	}

	public String[] ns(int n) {
		String[] a = new String[n];
		for (int i = 0; i < n; i++) a[i] = next();
		return a;
	}

	public int nextInt() {
		ensureNext();
		return Integer.parseInt(st.nextToken());
	}

	public double nextDouble() {
		ensureNext();
		return Double.parseDouble(st.nextToken());
	}

	public Long nextLong() {
		ensureNext();
		return Long.parseLong(st.nextToken());
	}

	public String next() {
		ensureNext();
		return st.nextToken();
	}
	
	public String nextLine() {
		try {
			return br.readLine();
		} catch (Exception e) {
			e.printStackTrace();
			return null;
		}
	}
	
	private void ensureNext() {
		if (st == null || !st.hasMoreTokens()) {
			try {
				st = new StringTokenizer(br.readLine());
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	}
}

static class Util{
		private static Random random = new Random();
		static long[] fact;
		
		public static void initFactorial(int n, long mod) {
			fact = new long[n+1];
			fact[0] = 1;
			for (int i = 1; i < n+1; i++) fact[i] = (fact[i - 1] * i) % mod;
		}
		
		public static long modInverse(long a, long MOD) {
			long[] gcdE = gcdExtended(a, MOD);
			if (gcdE[0] != 1) return -1; // Inverted doesn't exist
			long x = gcdE[1];
			return (x % MOD + MOD) % MOD;
		}
		
		public static long[] gcdExtended(long p, long q) {
			if (q == 0) return new long[] { p, 1, 0 };
			long[] vals = gcdExtended(q, p % q);
			long tmp = vals[2];
			vals[2] = vals[1] - (p / q) * vals[2];
			vals[1] = tmp;
			return vals;
		}
		
		public static long nCr(int n, int r, long MOD) {
			if (r == 0) return 1;
			return (fact[n] * modInverse(fact[r], MOD) % MOD * modInverse(fact[n - r], MOD) % MOD) % MOD;
		}
		
		public static long nCr(int n, int r) {
			return (fact[n]/fact[r])/fact[n-r];
		}
		
		public static long nPr(int n, int r, long MOD) {
			if (r == 0) return 1;
			return (fact[n] * modInverse(fact[n - r], MOD) % MOD) % MOD;
		}
		public static long nPr(int n, int r) {
			return fact[n]/fact[n-r];
		}
		
		public static boolean isPrime(int n) { 
	        if (n <= 1) return false; 
	        if (n <= 3) return true; 
	        if (n % 2 == 0 || n % 3 == 0) return false; 
	        for (int i = 5; i * i <= n; i = i + 6) 
	            if (n % i == 0 || n % (i + 2) == 0) 
	            return false; 
	        return true; 
	    }
		
	    public static boolean[] getSieve(int n) {
	        boolean[] isPrime = new boolean[n+1];
	        for (int i = 2; i <= n; i++) isPrime[i] = true;
	        for (int i = 2; i*i <= n; i++) if (isPrime[i]) 
	                for (int j = i; i*j <= n; j++) isPrime[i*j] = false;
	        return isPrime;
	    }
	    
	    static long pow(long x, long pow, long mod){
	    	long res = 1;
	    	x = x % mod;
	    	if (x == 0) return 0;
	    	while (pow > 0){
	    		if ((pow & 1) != 0) res = ",Restricted
198,"public class Solution {
    static Map<Integer, Map<Integer, List<Integer>>> evolutions; // endpoint -> start, gain
    static Integer[] fun;
    static Map<Integer, List<Integer>> attachments;
    static List<Integer> attachedTo;

    public static void main(String[] args) throws FileNotFoundException {
        try (Scanner reader = new Scanner(System.in)){
            if (reader.hasNextLine() && reader.hasNextInt()) {
                // Read the number of test cases
                int T = Integer.parseInt(reader.nextLine()); // testcases
                for (int t = 0; t < T; t++) {
                    int N = Integer.parseInt(reader.nextLine()); // modules
                    fun = new Integer[N];
                    attachments = new HashMap<>();
                    attachedTo = new ArrayList<>();
                    evolutions = new HashMap<>();
                    for (int n = 0; n < N; n++) {
                        fun[n] = reader.nextInt();
                    }
                    reader.nextLine();
                    for (int n = 0; n < N; n++) {
                        int attachedNode = reader.nextInt() - 1;
                        if (!attachments.containsKey(attachedNode)){
                            attachments.put(attachedNode, new ArrayList<>());
                        }
                        attachments.get(attachedNode).add(n);
                        attachedTo.add(attachedNode);
                    }
                    if (reader.hasNextLine()) {
                        reader.nextLine();
                    }
                    List<Integer> initiators = new ArrayList<>();
                    List<Integer> innerPoints = new ArrayList<>();
                    for (int n = 0; n < N; n++) {
                        if (!attachments.containsKey(n)) {
                            initiators.add(n);
                        } else {
                            innerPoints.add(n);
                        }
                    }
                    innerPoints.sort(Collections.reverseOrder());
                    Map<Integer, State> states = new HashMap<>();
                    for (int innerPoint: innerPoints) {
                        State newState = new State(attachments.get(innerPoint).get(0), fun[innerPoint]);
                        states.put(innerPoint, newState);
                        int maxDif = -999999999;
                        for (int prevPoint: attachments.get(innerPoint)) {
                            int newDif;
                            if (states.containsKey(prevPoint)) {
                                newDif = newState.currentValue - states.get(prevPoint).currentValue;
                            } else {
                                newDif = newState.currentValue - fun[prevPoint];
                            }
                            if (newDif > maxDif) {
                                maxDif = newDif;
                                if (states.containsKey(prevPoint)) {
                                    newState.initiatorNode = states.get(prevPoint).initiatorNode;
                                }
                                else {
                                    newState.initiatorNode = prevPoint;
                                }
                            }
                        }
                        if (maxDif < 0) {
                            newState.currentValue -= maxDif;
                        }
                    }

                    Collections.sort(innerPoints);
                    List<Integer> initiatorOrder = new ArrayList<>();
                    for(int innerPoint: innerPoints) {
                        if (!initiatorOrder.contains(states.get(innerPoint).initiatorNode)) {
                            initiatorOrder.add(states.get(innerPoint).initiatorNode);
                        }
                    }
                    for (int initiator: initiators) {
                        if (!initiatorOrder.contains(initiator)) {
                            initiatorOrder.add(initiator);
                        }
                    }
                    System.out.println(""Case #"" + (t + 1) + "": "" + getMaxFun(initiatorOrder));
                }
            }
        }
    }

    private static class State {
        public int initiatorNode;
        public int currentValue;

        State(int init, int val) {
            initiatorNode = init;
            currentValue = val;
        }
    }

    private static Long getMaxFun(List<Integer> initiators) {
        long totalFun = 0L;
        List<Integer> triggered = new ArrayList<>();
        for (int initiator : initiators) {
            Long maxFun = 0L;
            int currentModule = initiator;
            triggered.add(currentModule);
            while (true) {
                if (fun[currentModule] > maxFun) {
                    maxFun = Long.valueOf(fun[currentModule]);
                }
                currentModule = attachedTo.get(currentModule);
                if (triggered.contains(currentModule) || currentModule == -1) {
                    break;
                }
                triggered.",Larsvr
293,"public class Solution {

  public static void main(String[] args) {
  /*  String aaa = ""3
"" +
        ""5
"" +
        ""100 80 100 90 70
"" +
        ""0 1 1 2 2
"" +
        ""5
"" +
        ""3 2 1 4 5
"" +
        ""0 1 1 1 0
"" +
        ""8
"" +
        ""100 100 100 90 80 100 90 100
"" +
        ""0 1 2 1 2 3 1 3"";
    final Stream<String> lines = Arrays.stream(aaa.split(""
"")); */
    
    final BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
    final Stream<String> lines = reader.lines();

    int T = 0;
    int cs = 1;
    int start = 1;
    int end = 3;
    int N = 0;
    long[] F = null;
    int[] idx = null;
/*

    final String UPPER = ""ABCDEFGHIJKLMNOPQRSTUVWXYZ"";
    final String LOWER = ""abcdefghijklmnopqrstuvwxyz"";
    final char [] upper = UPPER.toCharArray();
    final char [] lower = LOWER.toCharArray();
    String line="""";
    List<Long> l = Arrays.stream(line.split("" "")).map(Long::valueOf).collect(Collectors.toList());

*/

    final Iterator<String> iterator = lines.iterator();
    int i = 0;
    String[] temp;

    while (iterator.hasNext()) {
      final String line = iterator.next();
      if (i == 0) {
        T = Integer.valueOf(line);
      } else {
        if (i == start) {
          N = Integer.valueOf(line);
          end = start + 2;
        } else if (i == start + 1) {
          temp = line.split("" "");
          F = new long[N];
          for (int j = 0; j < N; j++) {
            F[j] = Long.valueOf(temp[j]);
          }
        }
        if (i == end) {
          start += 3;
          temp = line.split("" "");
          idx = new int[N];
          for (int j = 0; j < N; j++) {
            idx[j] = Integer.valueOf(temp[j]);
          }

          if (cs <= T) {
            Test t = new Test(N, F, idx);
            System.out.println(""Case #"" + cs + "": "" + t.print());
            cs++;
            if (cs > T) {
              break;
            }
          }
        }
      }
      i++;
    }

  }

  public static class Test {
    int N = 0;
    long[] F;
    int[] idx;

    public Test(int n, long[] f, int[] idx) {
      this.N = n;
      this.F = f;
      this.idx = idx;
    }

    public Long print() {
      Module[] ms = new Module[N];
      for (int i = 0; i < N; i++) {
        ms[i] = new Module(idx[i], F[i]);
        if (idx[i] > 0) {
          ms[idx[i] - 1].s.add(i + 1);
        }
      }

      AtomicLong sum = new AtomicLong(0);
      Set<Module> initiators = new HashSet<>();
      for (int i = 0; i < N; i++) {
        if (ms[i].s.size() == 0) {
          initiators.add(ms[i]);
        }
      }

      traverse(initiators, ms, sum);

      return sum.get();
    }

    private void traverse(Set<Module> initiators, Module[] ms, AtomicLong sum) {
      final HashSet initiators_copy = new HashSet(initiators);
      final Iterator<Module> iter = initiators.iterator();

      while (iter.hasNext()) {
        final Module i = iter.next();
        if (i.t == 0) {
          sum.addAndGet(i.F);
          initiators_copy.remove(i);
        }
      }

      initiators = new HashSet<>(initiators_copy);

      final Module[] inits = initiators.toArray(Module[]::new);
      for (int i = 0; i < initiators.size(); i++) {
        Module target = ms[inits[i].t - 1];
        while (target.s.size() == 1 && target.t != 0) {
          target.F = Math.max(inits[i].F, target.F);
          inits[i].visited = true;
          inits[i] = target;
          target = ms[inits[i].t - 1];
        }
      }

      final HashSet initiators_copy1 = new HashSet(Arrays.asList(inits));

      for (int i = 0; i < inits.length; i++) {
        if (inits[i].visited) {
          continue;
        }
        Module target = ms[inits[i].t - 1];
        if (target.s.stream().allMatch(e -> initiators_copy1.contains(ms[e - 1]))) {
          target.calculate_inits(ms);
          target.s.forEach(e -> initiators_copy1.remove(ms[e - 1]));
          target.s = new ArrayList<>();
          initiators_copy1.add(target);
        }
      }

      if (initiators_copy1.size() == 0) {
        return;
      }

      traverse(initiators_copy1, ms, sum);

    }

    public class Module {
      public int t;
      public List<Integer> s = new ArrayList();
      public long F;
      public int max;
      public boolean visited = false;

      public Module(int idx, long i) {
        t = idx;
        F = i;
      }

      public void calculate_inits(Module[] ms) {
        long sum = 0;
        long[] FS = new long[s.size()];
        for (int i = 0; i < s.size(); i++) {
          FS[i] = ms[s.get(i) - 1].F;
          ms[s.get(i) - 1].visited = true;
        }
        Arrays.sort(FS);
        for (int i = 0; i < FS.length; i++) {
          if (i == 0) {
            if (FS[0] < F) {
              sum += F;
            } else {
              sum += FS[0];
            }
          } else {
            sum += FS[i];
          }
        }

        F = ",Obchelli
839,"public class Solution {

    public static void main(String[] args) {

        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.

        String s;
        s = in.nextLine();
        for (int i = 1; i <= t; i++) {
            s = in.nextLine();
            System.out.print(""Case #"" + i + "": "");

            char[] stringChar = s.toCharArray();
            Arrays.sort(stringChar);

            StringBuilder result, stringAux;



            stringAux = new StringBuilder(s);
            List<Integer> positionExc = new ArrayList<>();

            for (char c : stringChar) {

                result = new StringBuilder();
                for (int l = 0; l < stringAux.length(); l++) {
                    if (c == stringAux.charAt(l) && !positionExc.contains(l)) {

                        for (int j = 0; j < positionExc.size(); j++) {
                            if(l<positionExc.get(j)){
                                positionExc.set(j, positionExc.get(j)+1);
                            }
                        }

                        result.append(stringAux.charAt(l));
                        result.append(stringAux.charAt(l));
                        result.append(stringAux.substring(l + 1, stringAux.length()));
                        positionExc.add(l);
                        positionExc.add(l + 1);
                        break;
                    } else {
                        result.append(stringAux.charAt(l));
                    }

                }

                if (result.compareTo(stringAux) < 0) {
                    stringAux = result;
                }
            }



            System.",jonathan38m
234,"class Solution {
    public static void main(String[] args)
    {
        Scanner s = new Scanner(System.in);
        int t = s.nextInt();
        for(int i = 1; i <= t; i++)
        {
            int n = s.nextInt();
            int[] d = new int[n];
            for(int j = 0; j < n; j++)
            {
                d[j] = s.nextInt();
            }
            int top = 0;
            int x = 0;
            int y = n-1;
            int out = 0;
            while(x != y)
            {
                if(d[x] <= d[y])
                {
                    if(d[x] >= top)
                    {
                        out++;
                        top = d[x];
                    }
                    x++;
                } else
                {
                    if(d[y] >= top)
                    {
                        out++;
                        top = d[y];
                    }
                    y--;
                }
            }
            if(d[x] >= top)
            {
                out++;
                top = ",Maarten17581
989,"public class Solution {

	public static void main(String[] args) {
		Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

		int numberOfCases = in.nextInt();

		for (int i = 1; i <= numberOfCases; ++i) {
			int N = 10;
			while (N > 0) {
				if (N == 11) {
					System.out.println(""01010101"");
					N = in.nextInt();
					System.err.println(N);
				}else 
				if (N == 10) {
					System.out.println(""00000000"");
					N = in.nextInt();
					System.err.println(N);
					N = 11;
				}else 
				 if (N <= 2) {
					int x = (int) (Math.random() * 7);
					String test = """";
					for (int j = 0; j < 7; j++) {
						if (j == x)
							test += ""1"";
						else
							test += ""0"";
					}
					System.out.println(test+""1"");
					N = in.nextInt();
				}else if (N == 3) {
					int x = (int) (Math.random() * 3);
					int y = (int) (Math.random() * 4);
					String test = """";
					for (int j = 0; j < 3; j++) {
						if (j == x)
							test += ""1"";
						else
							test += ""0"";
					}
					for (int j = 0; j < 4; j++) {
						if (j == y)
							test += ""1"";
						else
							test += ""0"";
					}
					System.out.println(test+""1"");
					N = in.nextInt();
				}else if (N == 4) {
					int x = (int) (Math.random() * 2);
					int y = (int) (Math.random() * 2);
					int z = (int) (Math.random() * 3);
					String test = """";
					for (int j = 0; j < 2; j++) {
						if (j == x)
							test += ""1"";
						else
							test += ""0"";
					}
					for (int j = 0; j < 2; j++) {
						if (j == y)
							test += ""1"";
						else
							test += ""0"";
					}
					for (int j = 0; j < 3; j++) {
						if (j == z)
							test += ""1"";
						else
							test += ""0"";
					}
					System.out.println(test+""1"");
					N = in.nextInt();
				}else if (N >4) {
					System.out.println(""11111111"");
					N = in.nextInt();
				}
			}
			if (N == -1)
				break;

		}
	}
}",nicolasD
342,"class Second {
    static boolean found = false;

    public static void findMin(int cMin, int mMin, int yMin, int kMin, int a) {
        // if (found == true)
        // return;
        // if (cMin + mMin + yMin + kMin == 1000000) {
        // System.out.println(""Case #"" + (a + 1) + "": "" + cMin + "" "" + mMin + "" "" + yMin
        // + "" "" + kMin);
        // found = true;
        // return;
        // }
        // findMin(cMin - 1, mMin, yMin, kMin, a);
        // findMin(cMin, mMin - 1, yMin, kMin, a);
        // findMin(cMin, mMin, yMin - 1, kMin, a);
        // findMin(cMin, mMin, yMin, kMin - 1, a);
        int out = (1000000) / 4;
        if (cMin >= out && yMin >= out && kMin >= out && mMin >= out) {
            System.out.println(""Case #"" + (a + 1) + "": "" + out + "" "" + out + "" "" + out + "" "" + out);
            return;
        } else if (cMin >= out && yMin >= out && kMin >= out && mMin >= out) {
            System.out.println(""Case #"" + (a + 1) + "": "" + out + "" "" + out + "" "" + out + "" "" + out);
            return;
        }

        else {
            for (int i = 10000; i <= cMin; i+=1000) {
                for (int j = 10000; j <= mMin; j+=1000) {
                    for (int k = 10000; k <= yMin; k+=1000) {
                        for (int l = 10000; l <= kMin; l+=1000) {
                            if (i + j + k + l == 1000000) {
                                System.out.println(""Case #"" + (a + 1) + "": "" + i + "" "" + j + "" "" + k + "" "" + l);
                                return;
                            }
                        }
                    }
                }
            }
        }

    }

    public static void compute3D(ArrayList<ArrayList<Integer>> list, int a) {
        PriorityQueue<Integer> c = new PriorityQueue<>();
        PriorityQueue<Integer> m = new PriorityQueue<>();
        PriorityQueue<Integer> y = new PriorityQueue<>();
        PriorityQueue<Integer> k = new PriorityQueue<>();
        for (int i = 0; i < 3; i++) {
            for (int j = 0; j < 4; j++) {
                if (j == 0) {
                    c.add(list.get(i).get(j));
                } else if (j == 1) {
                    m.add(list.get(i).get(j));
                } else if (j == 2) {
                    y.add(list.get(i).get(j));
                } else if (j == 3) {
                    k.add(list.get(i).get(j));
                }
            }
        }
        int cMin = c.peek();
        int mMin = m.peek();
        int yMin = y.peek();
        int kMin = k.peek();
        int total = cMin + mMin + yMin + kMin;
        if (total < 1000000) {
            System.out.println(""Case #"" + (a + 1) + "": IMPOSSIBLE"");
        } else if (total == 1000000) {
            System.out.println(""Case #"" + (a + 1) + "": "" + cMin + "" "" + mMin + "" "" + yMin + "" "" + kMin);
        } else {
            findMin(cMin, mMin, yMin, kMin, a);
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int input = sc.nextInt();
        int n = 3;
        ArrayList<ArrayList<ArrayList<Integer>>> printerAll = new ArrayList<>();

        for (int a = 0; a < input; a++) {
            // PriorityQueue<Integer> c = new PriorityQueue<>();
            // PriorityQueue<Integer> m = new PriorityQueue<>();
            // PriorityQueue<Integer> y = new PriorityQueue<>();
            // PriorityQueue<Integer> k = new PriorityQueue<>();
            ArrayList<ArrayList<Integer>> printerCol = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                printerCol.add(new ArrayList<Integer>());
                for (int j = 0; j < 4; j++) {
                    int in = sc.nextInt();
                    printerCol.get(i).add(in);
                    // if (j == 0) {
                    // c.add(in);
                    // } else if (j == 1) {
                    // m.add(in);
                    // } else if (j == 2) {
                    // y.add(in);
                    // } else if (j == 3) {
                    // k.add(in);
                    // }
                }
            }
            // int cMin = c.peek();
            // int mMin = m.peek();
            // int yMin = y.peek();
            // int kMin = k.peek();
            // int total = cMin + mMin + yMin + kMin;
            // if (total < 1000000) {
            // System.out.println(""Case #"" + (a + 1) + "": IMPOSSIBLE"");
            // } else if (total == 1000000) {
            // System.out.println(""Case #"" + (a + 1) + "": "" + cMin + "" "" + mMin + "" "" + yMin
            // + "" "" + kMin);
            // } else {
            // System.out.println(total + "" "" + cMin + "" "" + mMin + "" "" + yMin + "" "" +
            // kMin);
            // }
            printerAll.add(printerCol);
        }
        for (int i = ",Roshan
246,"public class Solution{

    public static void main(String[] args){
int r=0;
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int sum=1000000;
        int T = in.nextInt();
        for (int i=1; i<=T; i++){
           
            int [] C=new int[3];
            int [] M=new int[3];
            int [] Y=new int[3];
            int [] B=new int[3];
            int [] R=new int[4];
        int j=0;
            while (j<3)
          {
           C[j]=in.nextInt();
            M[j]=in.nextInt();
            Y[j]=in.nextInt();
            B[j]=in.nextInt();
          j++;
            }
            Arrays.sort(C);
            Arrays.sort(M);
            Arrays.sort(Y);
            Arrays.sort(B);
         if(C[0]+M[0]+Y[0]+B[0]==sum)
         {R[0]=C[0];
         R[1]=M[0];
         R[2]=Y[0];
         R[3]=B[0];
         }
         else  if(C[0]+M[0]+Y[0]+B[0]<sum)
         {                    System.out.println(""Case #"" + i + "": "" + ""IMPOSSIBLE"");
r=1;
         }
         else {r=0;
         R[0]=C[0];
         sum=sum-R[0];
         if(M[0]<sum)
         {
         R[1]=M[0];
         sum=sum-R[1];
      
         
         }
         else if(M[0]>=sum)
         {R[1]=sum;
         R[2]=0;
       R[3]=0;
         sum=0;
         }
            if(Y[0]<sum)
         {  R[2]=Y[0];
         sum=sum-R[2];
         }
         else if(Y[0]>=sum)
         {R[2]=sum;
         R[3]=0;
   
         sum=0;
         }
               if(B[0]<sum)
         {  R[3]=Y[0];
         sum=sum-R[3];
         }
         else if(B[0]>=sum)
         {R[3]=sum;
         
   
         sum=0;
         }
            
            
             
            }
            
         if(r==0)
         {
            System.out.println(""Case #"" + i + "": ""+R[0]+"" ""+R[1]+"" ""+R[2]+"" ""+R[3]+"" "");}
        }     
            
       
        
        in.",Marwan
472,"public class Solution {

    public static void main(String[] args) {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        try {
            int T = Integer.parseInt(br.readLine());
            for (int ti = 1; ti <= T; ti++) {
                String[] temp = br.readLine().split("" "");
                int N = Integer.parseInt(temp[0]);
                int K = Integer.parseInt(temp[1]);

                temp = br.readLine().split("" "");
                int R = Integer.parseInt(temp[0]);
                int P = Integer.parseInt(temp[1]);

                List<Integer> roomNumbers = new ArrayList<>();
                for (int i = 1; i <= N; i++) {
                    if (R != i) {
                        roomNumbers.add(i);
                    }
                }

                int sumP = P;
                int k = 0;
                HashMap<Integer, Integer> pMap = new HashMap<>();
                boolean[] visited = new boolean[N + 1];
                for (int i = 0; i < K && i < N; i++) {
                    if (roomNumbers.size() == 0) {
                        break;
                    }
                    int roomIndex = (int) (Math.random() * roomNumbers.size());
                    System.out.println(""T "" + roomNumbers.remove(roomIndex));

                    temp = br.readLine().split("" "");
                    R = Integer.parseInt(temp[0]);
                    P = Integer.parseInt(temp[1]);
                    Integer pCount = pMap.get(P);
                    if (pCount == null) {
                        pCount = 1;
                    } else {
                        pCount++;
                    }
                    pMap.put(P, pCount);

                    sumP += P;
                    k++;
                }

                int remainRoomCount = N - k - 1;
                double predictSum = sumP;
                // 남은 p에 대해 추정치 : 남은 카운트를 비율로 나눠서 p로 곱함, 비율 = p카운트/k+1카운트
                for (Map.Entry<Integer, Integer> entry : pMap.entrySet()) {
                    Integer pNumber = entry.getKey();
                    Integer pCount = entry.getValue();
                    predictSum += pNumber * (remainRoomCount * (pCount / (k + 1.0)));
                }
                predictSum /= 2.0;

                double predict = N;
                if (k != 0) {
                    double dv = (sumP) / (k + 1.0);
                    predict *= dv;
                    predict /= 2.0;
                }

                System.out.println(""E "" + Math.round(predictSum));
            }
        } catch (IOException e) {
            e.",absee
618,"public class Solution {

	private static CodeJamIO io = new CodeJamIO();

	/**
	 * @param args
	 */
	public static void main(String[] args) {

		try {
			init();

			int numCases = Integer.parseInt(io.readNextLine()[0]);
			for (int i=1; i <= numCases; i++) {
				io.debug(""Solving Case #"" + i + ""..."");
				solveCase(i);
				io.debug(""Case #"" + i + "" solved!"");
			}
			
		} catch (Exception e) {
			e.printStackTrace();
		}

	}

	/**
	 * Performs initial computations
	 */
	private static void init() {
		
	}

	/**
	 * Solves a Test Case
	 *
	 * @param caseNum
	 * @throws IOException
	 */
	private static void solveCase(int caseNum) throws IOException {
		// Read input
		String[] tokens = io.readNextLine();
		int r = Integer.parseInt(tokens[0]);
		int c = Integer.parseInt(tokens[1]);

		// Do the work

		// Print results
		io.printCase(caseNum).println();
		printTopBorder(c);
		printCellsNoTopBorder(true, c);
		for (int i=1; i<r; i++) {
		    printCellsNoTopBorder(false, c);
		}
	}
	
	private static void printTopBorder(int c) {
	    io.print(""..+"");
	    for (int j=1; j<c; j++) {
	        io.print(""-+"");
	    }
	    io.println();
	}
	
	private static void printCellsNoTopBorder(boolean open, int c) {
	    io.print(open ? ""."" : ""|"");
	    for (int j=0; j<c; j++) {
	        io.print("".|"");
	    }
	    io.println();
	    io.print(""+"");
	    for (int j=0; j<c; j++) {
	        io.print(""-+"");
	    }
	    io.println();
	}

	/**
	 * Input and Output CodeJam style
	 *
	 */
	private static class CodeJamIO {
		private static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
		private static PrintWriter out = new PrintWriter(System.out, true);
		private static PrintWriter err = new PrintWriter(System.err, true);

		public String[] readNextLine() throws IOException {
			String line = in.readLine();
			String[] tokens = line.split(""\\\s+"");
			return tokens;
		}

		public CodeJamIO printCase(int caseNum) { return print(""Case #"" + caseNum + "": "" ); }
		
		public CodeJamIO print(Object o) { out.print(o); return this; }

		public CodeJamIO print(Object o[]) { return print(concat(o)); }

		public CodeJamIO print(Object o[][]) { return print(concat(o)); }

		public CodeJamIO println() { out.println(); return this; }

		public CodeJamIO printlnCase(int caseNum) { return printCase(caseNum).println(); }
		
		public CodeJamIO println(Object o) { return print(o).println(); }

		public CodeJamIO println(Object o[]) { return print(o).println(); }

		public CodeJamIO println(Object o[][]) { return print(concat(o)).println(); }

		public CodeJamIO println(List<Integer[]> l) { return print(concat(l)).println(); }

		
		private String concat(Object[] o) {
			StringBuffer buf = new StringBuffer(10*o.length);
			
			String delim = """";
			for (int i=0; i < o.length; i++) {
				buf.append(delim).append(o[i]);
				delim = "" "";
			}
			return buf.toString();
		}
		
		private String concat(Object[][] o) {
			StringBuffer buf = new StringBuffer(100*o.length);
			for (int i=0; i < o.length; i++) {
				buf.append(concat(o[i])).append(""
"");
			}
			return buf.toString();
		}

		private String concat(List<Integer[]> list) {
			StringBuffer buf = new StringBuffer();
			String delim = """";
			for (Object[] elm : list) {
				buf.append(delim).append(concat(elm)).append(""
"");
			}
			return buf.toString();
		}

		public void debug(String message) {
			err.println(Calendar.getInstance().getTime() + "": "" + message);
		}

		public void debug(String message, Object[] o) {
			err.println(Calendar.getInstance().getTime() + "": "" + message);
			err.println(""	"" + concat(o));
		}

		public void debug(String message, Object[][] o) {
			err.println(Calendar.getInstance().getTime() + "": "" + message);
			String values = concat(o);
			err.println(""	"" + values.replaceAll(""
"", ""
	""));
		}

		public void debug(String message, List<Integer[]> list) {
			err.println(Calendar.getInstance().getTime() + "": "" + message);
			String values = concat(list);
			err.println(""	"" + values.replaceAll(""
"", ""
	""));
		}

		public void flush() {
			out.flush();
			err.flush();
		}

	}
",ddimi
797,"public class Solution {

    public int index;
    public int[] dices;

    public Solution(int index, int nDices) {
        this.index = index;
        dices = new int[nDices];
    }

    public void solve() {

        Arrays.sort(dices);

        int count = 0;

        for (int i = 0; i < dices.length; i++) {

            int x = i + 1;

            if (dices[i] < x) {
                continue;
            }

            count++;
        }

        System.out.printf(""Case #%d: %d%n"", index + 1, count);
    }

    public static void main(String[] args) {

        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int T = in.nextInt();

        for (int i = 0; i < T; i++) {

            int N = in.nextInt();

            var solution = new Solution(i, N);

            for (int j = 0; j < N; j++) {
                int S = in.nextInt();
                solution.dices[j] = ",jaimuepe
623,"public class Solution {

    private static CodeJamIO io = new CodeJamIO();

    /**
     * @param args
     */
    public static void main(String[] args) {

        try {
            init();

            int numCases = Integer.parseInt(io.readNextLine()[0]);
            for (int i=1; i <= numCases; i++) {
                io.debug(""Solving Case #"" + i + ""..."");
                solveCase(i);
                io.debug(""Case #"" + i + "" solved!"");
            }

        } catch (Exception e) {
            e.printStackTrace();
        }

    }

    /**
     * Performs initial computations
     */
    private static void init() {

    }

    /**
     * Solves a Test Case
     *
     * @param caseNum
     * @throws IOException
     */
    private static void solveCase(int caseNum) throws IOException {
        // Read input
        int[][] ink = new int[4][3];
        for (int i=0; i<3; i++) {
            String[] tokens = io.readNextLine();
            for (int j=0; j<4; j++) {
                ink[j][i] = Integer.parseInt(tokens[j]);
            }
        }

        // Do the work
        int[] minink = new int[4];
        for (int j=0; j<4; j++) {
            minink[j] = Arrays.stream(ink[j]).min().getAsInt();
        }
        
        Arrays.sort(minink);
        
        int[] results = new int[4];
        int remaining = 1000000;
        for (int j=0; j<3; j++) {
            results[j] = remaining <= minink[j] ? remaining : minink[j];
            remaining -= results[j];
        }
        boolean impossible = remaining > minink[3];
        results[3] = remaining;

        // Print results
        io.printCase(caseNum).println();
        String space = """";
        if (impossible) {
            io.println(""IMPOSSIBLE"");
        } else {
            for (int j=0; j<4; j++) {
                io.print(space).print(results[j]);
                space = "" "";
            }
            io.println();
        }
    }

    /**
     * Input and Output CodeJam style
     *
     */
    private static class CodeJamIO {
        private static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        private static PrintWriter out = new PrintWriter(System.out, true);
        private static PrintWriter err = new PrintWriter(System.err, true);

        public String[] readNextLine() throws IOException {
            String line = in.readLine();
            String[] tokens = line.split(""\\\s+"");
            return tokens;
        }

        public CodeJamIO printCase(int caseNum) { return print(""Case #"" + caseNum + "": "" ); }

        public CodeJamIO print(Object o) { out.print(o); return this; }

        public CodeJamIO print(Object o[]) { return print(concat(o)); }

        public CodeJamIO print(Object o[][]) { return print(concat(o)); }

        public CodeJamIO println() { out.println(); return this; }

        public CodeJamIO printlnCase(int caseNum) { return printCase(caseNum).println(); }

        public CodeJamIO println(Object o) { return print(o).println(); }

        public CodeJamIO println(Object o[]) { return print(o).println(); }

        public CodeJamIO println(Object o[][]) { return print(concat(o)).println(); }

        public CodeJamIO println(List<Integer[]> l) { return print(concat(l)).println(); }


        private String concat(Object[] o) {
            StringBuffer buf = new StringBuffer(10*o.length);

            String delim = """";
            for (int i=0; i < o.length; i++) {
                buf.append(delim).append(o[i]);
                delim = "" "";
            }
            return buf.toString();
        }

        private String concat(Object[][] o) {
            StringBuffer buf = new StringBuffer(100*o.length);
            for (int i=0; i < o.length; i++) {
                buf.append(concat(o[i])).append(""
"");
            }
            return buf.toString();
        }

        private String concat(List<Integer[]> list) {
            StringBuffer buf = new StringBuffer();
            String delim = """";
            for (Object[] elm : list) {
                buf.append(delim).append(concat(elm)).append(""
"");
            }
            return buf.toString();
        }

        public void debug(String message) {
            err.println(Calendar.getInstance().getTime() + "": "" + message);
        }

        public void debug(String message, Object[] o) {
            err.println(Calendar.getInstance().getTime() + "": "" + message);
            err.println(""	"" + concat(o));
        }

        public void debug(String message, Object[][] o) {
            err.println(Calendar.getInstance().getTime() + "": "" + message);
            String values = concat(o);
            err.println(""	"" + values.replaceAll(""
"", ""
	""));
        }

        public void debug(String message, List<Integer[]> list) {
            err.println(Calendar.getInstance().getTime() + "": "" + message);
            String values = concat(list);
            err.println(""	"" + values.replaceAll(""
"", ""
	""));
        }

        public void flush() {
            out.flush();
            err.flush();
        }

    }
",ddimi
870,"public class Solution {

    public static void main(String[] args) {
        try (PrintWriter out = new PrintWriter(System.out)) {
            FastScanner in = new FastScanner(System.in);
            solve(in, out);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    private static void solve(FastScanner in, PrintWriter out) throws IOException {
        Random random = new Random();

        int t = in.nextInt();
        for (int q = 1; q <= t; q++) {

            int N = in.nextInt();
            int K = in.nextInt();

            double sum = 0;

            int S = in.nextInt();
            int P = in.nextInt();

            for (int i = 0; i < K; i++) {
                int r = random.nextInt(N) + 1;
                out.println(""T "" + r);
                out.flush();

                S = in.nextInt();
                P = in.nextInt();

                sum += P;
            }

            sum = sum * N / (2 * K);

            sum = sum * 4 / 3;

            out.println(""E "" + Math.round(sum));
            out.flush();

        }
    }

    private static class FastScanner {
        private final BufferedReader reader;
        private String[] tokens = null;
        private int cnt = -1;

        public FastScanner(InputStream inputStream) {
            reader = new BufferedReader(new InputStreamReader(inputStream, StandardCharsets.UTF_8));
        }

        public String next() throws IOException {
            if (tokens == null || cnt >= tokens.length) {
                String line = reader.readLine();
                if (line != null) {
                    tokens = line.split(""\\\s"");
                } else {
                    throw new RuntimeException(""not found"");
                }
                cnt = 0;
            }
            return tokens[cnt++];
        }

        public Integer nextInt() throws IOException {
            return Integer.parseInt(next());
        }

        public Long nextLong() throws IOException {
            return Long.parseLong(next());
        }

        public Double nextDouble() throws IOException {
            return Double.parseDouble(next());
        }
    }

    private static class Pair<S, T> {
        public S first;
        public T second;

        public Pair(S first, T second) {
            this.first = first;
            this.second = second;
        }
    }
}",khlyting
1273,"public class Solution {
    {
        MULTI_TEST = false;
        FILE_NAME = """";
        NEED_FILE_IO = false;
        INF = (long) 1e18;
    } // fields


    String solve_test() {
        int n = ri();
        int[] a = ria(n);

        int l = 0, r = n - 1;
        int ans = 0;
        int pref = Integer.MIN_VALUE;
        while (l <= r) {
            if (a[l] < a[r]) {
                if (a[l] >= pref) {
                    ans++;
                }
                pref = Math.max(a[l], pref);
                l++;
            } else {
                if (a[r] >= pref) {
                    ans++;
                }
                pref = Math.max(a[r], pref);
                r--;
            }
        }
        return """" + ans;
    }

    void solve() {
        int t = ri();
        for (int it = 1; it <= t; it++) {
            out.printf(""Case #%d: %s
"", it, solve_test());
        }
    }

    public static void main(String[] args) {
        new Solution().run();
    } //main

    @SuppressWarnings(""unused"")
    long gcd(long a, long b) {
        return b == 0 ? a : gcd(b, a % b);
    }

    @SuppressWarnings(""unused"")
    long lcm(long a, long b) {
        return a / gcd(a, b) * b;
    }

    @SuppressWarnings(""unused"")
    int gcd(int a, int b) {
        return (int) gcd((long) a, b);
    }

    @SuppressWarnings(""unused"")
    int lcm(int a, int b) {
        return (int) lcm(a, (long) b);
    }

    @SuppressWarnings(""unused"")
    int sqrtInt(int x) {
        return (int) sqrtLong(x);
    }

    @SuppressWarnings(""unused"")
    long sqrtLong(long x) {
        long root = (long) Math.sqrt(x);
        while (root * root > x) --root;
        while ((root + 1) * (root + 1) <= x) ++root;
        return root;
    }

    @SuppressWarnings(""unused"")
    int cbrtLong(long x) {
        int cbrt = (int) Math.cbrt(x);
        while ((long) cbrt * cbrt >= x) {
            cbrt--;
        }
        while ((long) (cbrt + 1) * (cbrt + 1) <= x) cbrt++;
        return cbrt;
    }

    @SuppressWarnings(""unused"")
    long binpow(long a, long power) {
        return binpow(a, power, Long.MAX_VALUE);
    }

    @SuppressWarnings(""unused"")
    long binpow(long a, long power, long modulo) {
        if (power == 0) return 1 % modulo;
        if (power % 2 == 1) {
            long b = binpow(a, power - 1, modulo) % modulo;
            return ((a % modulo) * b) % modulo;
        } else {
            long b = binpow(a, power / 2, modulo) % modulo;
            return (b * b) % modulo;
        }
    }

    @SuppressWarnings(""unused"")
    long fastMod(String s1, long n2) {
        long num = 0;
        for (int i = 0; i < s1.length() - 1; i++) {
            num += Integer.parseInt(String.valueOf(s1.charAt(i)));
            num *= 10;
            if (num >= n2) {
                num = num % n2;
            }
        }
        return (num + Integer.parseInt(String.valueOf(s1.charAt(s1.length() - 1)))) % n2;
    }

    @SuppressWarnings(""unused"")
    long factorialMod(long n, long p) {
        long res = 1;
        while (n > 1) {
            res = (res * ((n / p) % 2 == 1 ? p - 1 : 1)) % p;
            for (int i = 2; i <= n % p; ++i)
                res = (res * i) % p;
            n /= p;
        }
        return res % p;
    }

    @SuppressWarnings(""unused"")
    boolean isPrime(int number) {
        for (int i = 2; i * i <= number; i++) {
            if (number % i == 0) {
                return false;
            }
        }
        return number > 1;
    }

    @SuppressWarnings(""unused"")
    boolean[] primes(int border) {
        boolean[] isPrimes = new boolean[border + 1];
        Arrays.fill(isPrimes, true);
        isPrimes[0] = false;
        isPrimes[1] = false;
        for (int i = 2; i < border + 1; i++) {
            if (!isPrimes[i]) continue;
            for (int k = i * 2; k < border; k += i) {
                isPrimes[k] = false;
            }
        }
        return isPrimes;
    } //Number theory

    @SuppressWarnings(""unused"")
    void sort(int[] a) {
        int n = a.length;
        Integer[] arr = new Integer[n];
        for (int i = 0; i < n; i++) {
            arr[i] = a[i];
        }
        Arrays.sort(arr);
        for (int i = 0; i < n; i++) {
            a[i] = arr[i];
        }
    }

    @SuppressWarnings(""unused"")
    void sort(long[] a) {
        int n = a.length;
        Long[] arr = new Long[n];
        for (int i = 0; i < n; i++) {
            arr[i] = a[i];
        }
        Arrays.sort(arr);
        for (int i = 0; i < n; i++) {
            a[i] = arr[i];
        }
    }

    @SuppressWarnings(""unused"")
    int max(int[] a) {
        int n = a.length;
        int max = Integer.MIN_VALUE;
        for (int j : a) {
            if (j > max) max = j;
        }
        return max;
    }

    @SuppressWarnings(""unused"")
    long max(long[] a) {
        int n = a.length;
        long max = Long.MIN_VALUE;
        for (long l : a) {
            if (l > max) max = l;
        }
        return max;
    }

    @SuppressWarnings(""unused"")
    int maxIndex(int[] a) {
        int n = a.length;
        int max = Integer.MIN_VALUE;
        int index = 0;
        for (int i = 0; i < n; i++) {
            if (a[i] > max) {
                max = a[i];
                index = i;
            }
        }
        return index;
    }

    @SuppressWarnings(""unused"")
    int maxIndex(long[] a) {
        int n = a.length;
        long max = Long.MIN_VALUE;
        int index = 0;
        for (int i = 0; i < n; i++) {
            if (a[i] > max) {
                max = a[",v0s7er
488,"public class Solution {
    static int[] dx = {0, 1, 0, -1};
    static int[] dy = {1, 0, -1, 0};
    static int mod = (1 << 31) - 1;
    static List<Integer>[] graph;

    static char[][] grid;

    static int MAX = 1000001;

    public static void main(String[] args){
        InputStream is;
        try {
            is = new FileInputStream("".\\\src\\\input\\\in.txt"");
        } catch (FileNotFoundException e) {
            is = System.in;
        }
        InputReader in = new InputReader(is);
//        PrintWriter out = new PrintWriter(System.out);
        PrintStream out = System.out;

        int t = in.nextInt();
        for (int tt=1;tt<=t;tt++){
            int n = in.nextInt();
            int k = in.nextInt();

            int fr = in.nextInt();
            int fp = in.nextInt();

            if (n <= k) {
                int total = fp;
                for (int i=1;i<=n;i++) {
                    if (i == fr) continue;
                    out.println(""T ""+ i);
                    out.flush();
                    int r = in.nextInt();
                    int p = in.nextInt();
                    total += p;
                }
                out.println(""E ""+ total/2);
            }
            else{
                long total = fp;
                int currentP = fp;
                int currentR = fr;

                HashSet<Integer> visited = new HashSet<>();
                visited.add(currentR);
                for (int i=0;i<k;i++) {
                    int operation = (int) ((Math.random() * (2 - 1)) + 1);
                    if (operation == 1) {
                        out.println(""W"");
                        out.flush();
                        currentR = in.nextInt();
                        currentP = in.nextInt();

                    }
                    else{
                        int x = currentR;
                        while (visited.contains(x)) {
                            x = (int) ((Math.random() * (n - 1)) + 1);
                        }
                        out.println(""T "" + x);
                        out.flush();
                        currentR = in.nextInt();
                        currentP = in.nextInt();
                    }
                    visited.add(currentR);
                    total += currentP;
                }
                out.println(""E "" + (total/2) * (n/k));
            }
        }
        out.close();
    }


    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }
        public long nextLong() {
            return Long.parseLong(next());
        }
        public double nextDouble() {return Double.",ac23
725,"public class Solution {

    public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        PrintWriter writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));

        int T = in.nextInt();
        for (int casNumero = 1; casNumero <= T; casNumero++) {
            StringBuilder resultat = new StringBuilder();
            resultat.append(""Case #"");
            resultat.append(casNumero);
            resultat.append("": "");

            int n = in.nextInt();
            long[] f = new long[n];
            for (int i = 0; i < n; i++) {
                f[i] = in.nextLong();
            }
            int[] p = new int[n];
            for (int i = 0; i < n; i++) {
                p[i] = in.nextInt();
            }
            long sumFun = 0;
            List<Integer> used = new ArrayList<>();
            Map<Integer, Long> triggers = new HashMap();
            for (int i = 1; i < n+1; i++) {
                int finalI = i;
                if (Arrays.stream(p).parallel().noneMatch(a -> a == finalI)) {
                    if (p[finalI - 1] == 0) {
                        sumFun += f[finalI - 1];
                    }
                    else {
                        triggers.put(finalI, getFun(finalI, f, p, used));
                    }
                }
            }

            while (!triggers.keySet().isEmpty()) {
                long minFun = Collections.min(triggers.values());
                int commonModule = 0;
                for (int i = 1; i < n+1; i++) {
                    if (!used.contains(Integer.valueOf(i)) && f[i - 1] == minFun) {
                        commonModule = i;
                        break;
                    }
                }

                int bestTrigger = 0;
                used.add(commonModule);
                for (Integer trigger : triggers.keySet()) {
                    if (minFun == triggers.get(trigger) && isCommonModule(commonModule, trigger, p)) {
                        if (bestTrigger == 0) {
                            bestTrigger = trigger;
                            triggers.put(trigger, getFun(trigger, f, p, used));
                        }
                        else {
                            triggers.put(trigger, getFun(trigger, f, p, used));
                            if (triggers.get(trigger) < triggers.get(bestTrigger)) {
                                bestTrigger = trigger;
                            }
                        }
                    }
                }
                used.remove(Integer.valueOf(commonModule));
                sumFun += minFun;
                used.addAll(getRelations(bestTrigger, p, used));
                triggers.remove(bestTrigger);
            }
            resultat.append(sumFun);
            writer.print(resultat.toString());
            writer.println();
        }
        in.close();
        writer.close();
    }

    private static boolean isCommonModule(int commonModule, int index, int[] p) {
        int relation = index;
        boolean isCommon = relation == commonModule;
        while (!isCommon && relation != 0) {
            relation = p[relation - 1];
            isCommon = relation == commonModule;
        }
        return isCommon;
    }

    private static List<Integer> getRelations(int index, int[] p, List<Integer> used) {
        List<Integer> relations = new ArrayList<>();
        relations.add(index);
        int currentIndex = index;
        while (!used.contains(currentIndex) && p[currentIndex - 1] != 0) {
            currentIndex = p[currentIndex - 1];
            relations.add(currentIndex);
        }
        return relations;
    }

    private static long getFun(int index, long[] f, int[] p, List<Integer> used) {
        long fun = f[index - 1];
        int relation = p[index - 1];
        if (relation != 0 && !used.contains(relation)) {
            long relationFun = getFun(relation, f, p, used);
            if (relationFun > fun) {
                fun = ",gerardmr
1132,"public class Solution {

    Scanner             sc       = new Scanner(System.in);
    static final String FILENAME = ""A-small"";
    static final String IN       = FILENAME + "".in"";
    static final String OUT      = FILENAME + "".out"";
    PrintStream         out      = System.out;

    Map<String, Integer> dp;
    private void solve(int n, int [] d) {
        dp = new HashMap<>();

        out.println(solve(n, d, 0, n-1, -1));
    }

    private int solve(int n, int[] d, int l, int r, int maxSoFar) {
        String key= l + "","" + r;
        if(dp.get(key) != null) {
            return dp.get(key);
        }
        if(l == r) {
            if(d[l] >= maxSoFar) {
                return 1;
            }
            return 0;
        }
//        System.out.println(l + "" "" + r);
        // case l < r
//        int bestResult = -1;

        if(d[l] <= d[r]) {
            // good
            int bestResult = -1;

            if(maxSoFar <= d[l]) {
                dp.put(key, Math.max(dp.getOrDefault(key, -1), 1 + solve(n, d, l + 1, r, d[l])));
            } else {
                dp.put(key, Math.max(dp.getOrDefault(key, -1), solve(n, d, l + 1, r, maxSoFar)));
            }
        } else {
            if(maxSoFar <= d[r]) {
                dp.put(key, Math.max(dp.getOrDefault(key, -1), 1 + solve(n, d, l, r - 1, d[r])));
            } else {
                dp.put(key, Math.max(dp.getOrDefault(key, -1), solve(n, d, l, r - 1, maxSoFar)));
            }
        }
        return dp.get(key);
    }

    private void run() throws Exception {
        // out = new PrintStream(new FileOutputStream(OUT));
        int T = sc.nextInt();
        for (int t = 1; t <= T; t++) {
            out.print(""Case #"" + t + "": "");
            int n = sc.nextInt();
            int[] d = new int[n];
            for(int i = 0; i<n; i++) {
                d[i] = sc.nextInt();
            }
            solve(n, d);
        }
        sc.close();
        out.close();
    }

    public static void main(String args[]) throws Exception {
        new Solution().",rkamun
650,"public class Solution {

    public static void main(String[] args) {
        
        Scanner scan = new Scanner(System.in); 
        int numOfCases = scan.nextInt();
        
        int x = 1; // Test Case Number (starting from 1)
        
        int r = 0;
        int c = 0;
        
        for (int i = 0; i < numOfCases; i++) {
            r = scan.nextInt();
            c = scan.nextInt();
            
            System.out.print(""Case #"" + x + "":"");
            
            for (int j = 0; j < 2 * r + 1; j++) { 
                System.out.println();
                for (int k = 0; k < 2 * c + 1; k++) {
                    if (j % 2 == 0) {
                        if ((k < 2) && (j < 2)) {
                            System.out.print(""."");
                        }
                        else if (k == 2 * c) {
                            System.out.print(""+"");
                        }
                        else {
                            if (k % 2 == 0) {
                                System.out.print(""+"");
                            }
                            else {
                                System.out.print(""-"");
                            }
                        }
                    }
                    else {
                        if ((k < 2) && (j > 2)) {
                            System.out.print(""."");
                        }
                        else if (k == 2 * c) { 
                            System.out.print(""|"");
                        }
                        else {
                            if (k % 2 == 0) {
                                System.out.print(""|"");
                            }
                            else {
                                System.out.print(""."");
                            }
                        }
                    }
                }
            }
        x++;  
        System.",dtarde
282,"public class Solution {
    
    public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int T = in.nextInt();
        for (int i = 1; i <= T; i++) {
          int R = in.nextInt();
          int C = in.nextInt();
          System.out.println(""Case #"" + i + "":"");
          print(R, C);
        }
	}
    
    public static void print(int R, int C) {
		for (int i = 0; i < R * 2 + 1; i++) {
			for (int j = 0; j < C * 2 + 1; j++) {
				if (i <= 1 && j <= 1)
					System.out.print(""."");
				else {
					if (i % 2 == 0 && j % 2 == 0)
						System.out.print(""+"");
					else if (i % 2 == 0 && j % 2 == 1)
						System.out.print(""-"");
					else if (i % 2 == 1 && j % 2 == 0)
						System.out.print(""|"");
					else
						System.out.print(""."");
				}
			}
			System.",Mr
1103,"public class Solution{
    public static void main(String args[]){
        Scanner sc=new Scanner(System.in);
        int t=sc.nextInt();
        for(int i=1;i<=t;i++){
            int r,c;
            c=sc.nextInt();
            r=sc.nextInt();
            char arr[][]=new char[2*r+1][2*c+1];
            arr[0][0]='.';
            arr[1][0]='.';
            arr[0][1]='.';
            arr[1][1]='.';
            for(int j=0;j<(2*r+1);j++){
                for(int k=0;k<(2*c+1);k++){
                    if((j==0 && k==0) || (j==0 && k==1) || (j==1 && k==0) || (j==1 && k==1))
                        continue;
                    if(j%2==0){
                        if(k%2==0)
                            arr[j][k]='+';
                        else
                            arr[j][k]='-';
                    }
                    else{
                        if(k%2==0)
                            arr[j][k]='|';
                        else
                            arr[j][k]='.';
                    }
                }
            }
            System.out.println(""Case #""+i+"":"");
            for(int j=0;j<(2*r+1);j++){
                for(int k=",rituV
1125,"public class Solution {
//    Scanner sc       = new Scanner(getClass().getResourceAsStream(IN));
    Scanner sc       = new Scanner(System.in);
    static final String FILENAME = ""A-small"";
    static final String IN       = FILENAME + "".in"";
    static final String OUT      = FILENAME + "".out"";
    PrintStream out      = System.out;

    private void solve() {
        int ans = 0;

        out.println(ans);
    }

    int MAX_VALUE = 1000000;
    private void run() throws Exception {
        // out = new PrintStream(new FileOutputStream(OUT));
        int T = sc.nextInt();
        for (int t = 1; t <= T; t++) {
            out.print(""Case #"" + t + "": "");
            int[]c = new int[4];
            int[]m = new int[4];
            int []y = new int[4];
            int []k = new int[4];
            int minC = MAX_VALUE, minM = MAX_VALUE, minY = MAX_VALUE, minK = MAX_VALUE;
            for(int i =0; i<3; i++) {
                c[i] = sc.nextInt();
                minC = Math.min(minC, c[i]);
                m[i] = sc.nextInt();
                minM = Math.min(minM, m[i]);
                y[i] = sc.nextInt();
                minY = Math.min(minY, y[i]);
                k[i] = sc.nextInt();
                minK = Math.min(minK, k[i]);
            }
            if(minM + minC + minY + minK < MAX_VALUE || minM == 0 || minC == 0 || minY == 0 || minK == 0) {
                out.print(""IMPOSSIBLE"");
                out.println();
                continue;
            }

            int[] arr = new int[]{minC, minM, minY, minK};
            int sum = minC + minM + minY + minK;
            if(sum > MAX_VALUE) {
                int diff = sum - MAX_VALUE;
                for(int i = 0; i<4; i++) {
                    int newI = arr[i] - Math.min(arr[i] - 1, diff);
                    diff -= (arr[i] - newI);
                    arr[i] = newI;
                    if(diff == 0)
                        break;
                }
            }
            out.print(arr[0] + "" "" + arr[1] + "" "" + arr[2] + "" ""+ arr[3]);
            out.println();

        }
        sc.close();
        out.close();
    }

    public static void main(String args[]) throws Exception {
        new Solution().",rkamun
924,"public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        int cases = Integer.parseInt(in.readLine());
        for (int i = 1; i <= cases; i++) {
            System.out.println(""00000000"");
            boolean done = false;
            while (!done) {
                switch(Integer.parseInt(in.readLine())) {
                    case 0:
                        done = true;
                        break;
                    case 1:
                        System.out.println(""10000000"");
                        break;
                    case 2:
                        System.out.println(""11000000"");
                        break;
                    case 3:
                        System.out.println(""11100000"");
                        break;
                    case 4:
                        System.out.println(""11110000"");
                        break;
                    case 5:
                        System.out.println(""11111000"");
                        break;
                    case 6:
                        System.out.println(""11111100"");
                        break;
                    case 7:
                        System.out.println(""11111110"");
                        break;
                    case 8:
                        System.",lavikj
662,"public class Solution {
    public static void main(String[] args) throws IOException {
        FastScanner input = new FastScanner(false);
        int T = input.nextInt();
        for (int iter = 1; iter<=T; iter++) {
            int N = input.nextInt();
            boolean[][] filled = circleFilled(N);
            boolean[][] wrong = circleWrong(N);
            int res = 0;
            for (int i = 0; i<=2*N; i++) {
                for (int j = 0; j<=2*N; j++) {
                    if (filled[i][j]^wrong[i][j]) {
                        res+=1;
                    }
                }
            }
            System.out.println(""Case #""+iter+"": ""+res);
        }
    }
    private static void circlePerimeter(int R, boolean[][] A) {
        for (int i = A.length/2-R; i<=A.length/2+R; i++) {
            int y = (int)Math.round(Math.sqrt(R*R-(i-A.length/2)*(i-A.length/2)));
            A[i][y+A.length/2]=true;
            A[i][-y+A.length/2]=true;
            A[y+A.length/2][i]=true;
            A[-y+A.length/2][i]=true;
        }
    }
    private static boolean[][] circleFilled(int R) {
        boolean[][] res = new boolean[2*R+1][2*R+1];
        for (int x = -R; x<=R; x++) {
            for (int y = -R; y<=R; y++) {
                if (Math.round(Math.sqrt(x*x+y*y))<=R) {
                    res[x+R][y+R]=true;
                }
            }
        }
        return res;
    }
    private static boolean[][] circleWrong(int R) {
        boolean[][] res = new boolean[2*R+1][2*R+1];
        for (int r = 0; r<=R; r++) {
            circlePerimeter(r,res);
        }
        return res;
    }
    private static class FastScanner {
        final private int BUFFER_SIZE = 1 << 16;
        private DataInputStream din;
        private byte[] buffer;
        private int bufferPointer, bytesRead;
        private FastScanner(boolean usingFile) throws IOException {
            if (usingFile) din=new DataInputStream(new FileInputStream(""C:\\\Users\\\skwek\\\IdeaProjects\\\HelloWorld\\\src\\	esting.in""));
            else din = new DataInputStream(System.in);
            buffer = new byte[BUFFER_SIZE];
            bufferPointer = bytesRead = 0;
        }
        private short nextShort() throws IOException {
            short ret = 0;
            byte c = read();
            while (c <= ' ') c = read();
            boolean neg = (c == '-');
            if (neg) c = read();
            do ret = (short)(ret * 10 + c - '0');
            while ((c = read()) >= '0' && c <= '9');
            if (neg) return (short)-ret;
            return ret;
        }
        private int nextInt() throws IOException {
            int ret = 0;
            byte c = read();
            while (c <= ' ') c = read();
            boolean neg = (c == '-');
            if (neg) c = read();
            do ret = ret * 10 + c - '0';
            while ((c = read()) >= '0' && c <= '9');
            if (neg) return -ret;
            return ret;
        }
        public long nextLong() throws IOException {
            long ret = 0;
            byte c = read();
            while (c <= ' ') c = read();
            boolean neg = (c == '-');
            if (neg) c = read();
            do ret = ret * 10 + c - '0';
            while ((c = read()) >= '0' && c <= '9');
            if (neg) return -ret;
            return ret;
        }
        private char nextChar() throws IOException {
            byte c = read();
            while (c <= ' ') c = read();
            return (char)c;
        }
        private String nextString() throws IOException {
            StringBuilder ret = new StringBuilder();
            byte c = read();
            while (c <=' ') c = read();
            do {
                ret.append((char)c);
            } while ((c = read())>' ');
            return ret.toString();
        }
        private void fillBuffer() throws IOException {
            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);
            if (bytesRead == -1)  buffer[0] = -1;
        }
        private byte read() throws IOException ",ekwek
1049,"public class Solution {
    InputStream is;
    FastWriter out;
    String INPUT = """";

    public static void main(String[] args) throws Exception
    {
        new Solution().run();// Here run assign I/O calls solve also tell total time invested
    }

    void solve()
    {
        int t=ni(), p=0;
        while(t-->0)
        {
            System.out.println(""Case #""+ ++p +"":"");
            go();
        }
    }
    void go()
    {
        int r=ni(),c=ni();
        StringBuilder ans=new StringBuilder();
        StringBuilder bod=new StringBuilder();
        StringBuilder pat=new StringBuilder();
        for(int i=0;i<c-1;i++)
        {
            bod.append(""+-"");
            pat.append(""|."");
        }
        bod.append(""+"");
        pat.append(""|"");
        ans.append("".."");
        ans.append(bod);
        ans.append(""
"");
        ans.append("".."");
        ans.append(pat);
        ans.append(""
"");
        bod.append(""-+
"");
        pat.append("".|
"");
        for(int i=0;i<r-1;i++)
        {
            ans.append(bod);
            ans.append(pat);
        }
        ans.append(bod);
        System.out.println(ans);
    }

    static boolean prime[];
    static int count=0;

    void sieve(int n)
    {
        prime=new boolean[n+1];
        Arrays.fill(prime, true);
        for(int i=2;i<=Math.sqrt(n);i++)
            if(prime[i])
                for(int j=i*i;j<=n;j+=i)
                    prime[j]=false;
    }

    boolean isPrime(int n)
    {
        for(int i=2;i<=Math.sqrt(n);i++)
            if(n%i==0)
                return false;
        return true;
    }

    long gcd(long a,long b)
    {
        if(a==0)
            return b;
        return gcd(b%a,a);
    }

    void run() throws Exception
    {
        is = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());
        out = new FastWriter(System.out);

        long s = System.currentTimeMillis();
        solve();
        out.flush();
        tr(System.currentTimeMillis()-s+""ms"");
    }

    byte[] inbuf = new byte[1024];
    public int lenbuf = 0, ptrbuf = 0;

    private int readByte()
    {
        if(lenbuf == -1)throw new InputMismatchException();
        if(ptrbuf >= lenbuf){
            ptrbuf = 0;
            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }
            if(lenbuf <= 0)return -1;
        }
        return inbuf[ptrbuf++];
    }

    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }

    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }

    private double nd() { return Double.parseDouble(ns()); }

    private char nc() { return (char)skip(); }

    private String ns()
    {
        int b = skip();
        StringBuilder sb = new StringBuilder();
        while(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')
            sb.appendCodePoint(b);
            b = readByte();
        }
        return sb.toString();
    }

    private char[] ns(int n)
    {
        char[] buf = new char[n];
        int b = skip(), p = 0;
        while(p < n && !(isSpaceChar(b))){
            buf[p++] = (char)b;
            b = readByte();
        }
        return n == p ? buf : Arrays.copyOf(buf, p);
    }

    private int[] ni(int n)
    {
        int[] a = new int[n];
        for(int i = 0;i < n;i++)a[i] = ni();
        return a;
    }

    private long[] nl(int n)
    {
        long[] a = new long[n];
        for(int i = 0;i < n;i++)a[i] = nl();
        return a;
    }

    private Long[] nL(int n) {
        Long[] a = new Long[n];
        for (int i = 0; i < n; i++)
            a[i] = nl();
        return a;
    }

    private Integer[] nI(int n) {
        Integer[] a = new Integer[n];
        for (int i = 0; i < n; i++)
            a[i] = ni();
        return a;
    }

    private char[][] ns(int n, int m) {
        char[][] map = new char[n][];
        for(int i = 0;i < n;i++)map[i] = ns(m);
        return map;
    }

    private int[][] ni(int n, int m) {
        int[][] map = new int[n][];
        for(int i = 0;i < n;i++)map[i] = ni(m);
        return map;
    }

    private long[][] nl(int n, int m) {
        long[][] map = new long[n][];
        for(int i = 0;i < n;i++)map[i] = nl(m);
        return map;
    }

    private Integer[][] nI(int n, int m) {
        Integer[][] map = new Integer[n][];
        for(int i = 0;i < n;i++)map[i] = nI(m);
        return map;
    }

    private Long[][] nL(int n, int m) {
        Long[][] map = new Long[n][];
        for(int i = 0;i < n;i++)map[i] = nL(m);
        return map;
    }

    private int ni() { return (int)nl(); }

    private long nl()
    {
        long num = 0;
        int b;
        boolean minus = false;
        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));
        if(b == '-'){
            minus = true;
            b = readByte();
        }

        while(true){
            if(b >= '0' && b <= '9'){
                num = num * 10 + (b - '0');
            }else{
                return minus ? -num : num;
            }
            b = readByte();
        }
    }

    public static class FastWriter
    {
        private static final int BUF_SIZE = 1<<13;
        private final byte[] buf = new byte[BUF_SIZE];
        private final OutputStream out;
        private int ptr = 0;

        private FastWriter(){out = null;}

        public FastWriter(OutputStream os)
        {
            this.out = os;
        }
",pgthebigshot
1282,"public class Solution {

	static boolean verb=true;
	static void log(Object X){if (verb) System.err.println(X);}
	static void log(Object[] X){if (verb) {for (Object U:X) System.err.print(U+"" "");System.err.println("""");}}
	static void log(int[] X){if (verb) {for (int U:X) System.err.print(U+"" "");System.err.println("""");}}
	static void logWln(Object X){if (verb) System.err.print(X);}
	static void info(Object o){	System.out.println(o);}
	static void output(Object o){outputWln(""""+o+""
"");	}
	static void outputWln(Object o){try {out.write(""""+ o);} catch (Exception e) {}}





	// Global vars


	static BufferedWriter out;
	static InputReader reader;


	static class Composite implements Comparable<Composite>{
		int value;
		int idx;

		public int compareTo(Composite X) {
			if (value!=X.value)
				return value-X.value;
			return idx-X.idx;


		}

		public Composite(int value, int idx) {
			this.value = value;
			this.idx = idx;
		}
	}




	static void process() throws Exception {

		out = new BufferedWriter(new OutputStreamWriter(System.out));
		reader=new InputReader(System.in);
		Locale.setDefault(Locale.US);	




		int T=reader.readInt();



		for (int t=1;t<=T;t++) {


			int n=reader.readInt();
			int[] anc=new int[n];
			int[] nb=new int[n];
			int[] fun=new int[n];
			for (int i=0;i<n;i++)
				fun[i]=reader.readInt();
			for (int i=0;i<n;i++) {
				anc[i]=reader.readInt()-1;
				if (anc[i]>=0) {
					nb[anc[i]]++;
				}
			}

			PriorityQueue<Composite> pq=new PriorityQueue<Composite>();
			for (int u=0;u<n;u++) {
				if (nb[u]==0) {
					pq.add(new Composite(fun[u],u));
				}
			}
			long tot=0;
			while (pq.size()>0) {
				Composite X=pq.poll();
	
				int u=X.idx;
				int v=anc[u];
				
				if (v>=0 && fun[v]>=0) {
					//log(""visiting v:""+(v+1));
					if (X.value<fun[v]) {
						X.value=fun[v];
					
						//log(""----------using v:""+(v+1));
					}
					fun[v]=-1;
					//id[anc[u]]=root(anc[v]);
					X.idx=v;
					pq.add(X);
					//log(""adding to PQ:""+(v+1));

				} else
					tot+=X.value;

			}

			String ss="""";
			ss+=tot;


			output(""Case #""+t+"": ""+ss);
		}
		//log(""ok"");
		try {
			out.close();
		}
		catch (Exception EX){}

	}








	public static void main(String[] args) throws Exception {
		process();

	}

	static final class InputReader {
		private final InputStream stream;
		private final byte[] buf = new byte[1024];
		private int curChar;
		private int numChars;

		public InputReader(InputStream stream) {
			this.stream = stream;
		}

		private int read() throws IOException {
			if (curChar >= numChars) {
				curChar = 0;
				numChars = stream.read(buf);
				if (numChars <= 0) {
					return -1;
				}
			}
			return buf[curChar++];
		}


		public final String readString() throws IOException {
			int c = read();
			while (isSpaceChar(c)) {
				c = read();
			}
			StringBuilder res=new StringBuilder();
			do {
				res.append((char)c);
				c = read();
			} while (!isSpaceChar(c));
			return res.toString();
		}

		public final int readInt() throws IOException {
			int c = read();
			boolean neg=false;
			while (isSpaceChar(c)) {
				c = read();
			}
			char d=(char)c;
			//log(""d:""+d);
			if (d=='-') {
				neg=true;
				c = read();
			}
			int res = 0;
			do {
				res *= 10;
				res += c - '0';
				c = read();
			} while (!isSpaceChar(c));
			//log(""res:""+res);
			if (neg)
				return -res;
			return res;

		}

		public final long readLong() throws IOException {
			int c = read();
			boolean neg=false;
			while (isSpaceChar(c)) {
				c = read();
			}
			char d=(char)c;
			//lo)g(""d:""+d);
			if (d=='-') {
				neg=true;
				c = read();
			}
			long res = 0;
			do {
				res *= 10;
				res += c - '0';
				c = read();
			} while (!isSpaceChar(c));
			//log(""res:""+res);
			if (neg)
				return -res;
			return res;

		}



",vincent
511,"public class Solution{

    static long MOD = 1_000_000_007L;
    //static long MOD = 998_244_353L;
    //static long MOD = 1_000_000_033L;
    static long inv2 = (MOD + 1) / 2;
    static long [] fac;
    static long [] pow;
    static long [] inv;
    static long [] invFac;
    static int[][] dir = new int[][]{{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
    static long lMax = 0x3f3f3f3f3f3f3f3fL;
    static int iMax = 0x3f3f3f3f;
    static HashMap <Long, Long> memo = new HashMap();
    static MyScanner sc = new MyScanner();
    //static ArrayList <Integer> primes;

    static long[] pow2;
    static int[] base;
    static int[] numOfDiv;
    static ArrayList <Integer> primes;
    //-----------PrintWriter for faster output---------------------------------
    public static PrintWriter out;
    public static void main(String[] args) {
        out = new PrintWriter(new BufferedOutputStream(System.out));
        // Start writing your solution here. -------------------------------------

        int nn = 300000;

        /*fac = new long[nn + 1];
        fac[1] = 1;
        for(int i = 2; i <= nn; i++)
            fac[i] = fac[i - 1] * 1L * i % MOD;*/

        /*pow = new long[nn + 1];
        pow[0] = 1L;
        for(int i = 1; i <= nn; i++)
            pow[i] = pow[i - 1] * 2L % MOD;
        pow[1] = 3L;*/

        /*
        pow2 = new long[nn + 1];
        pow2[0] = 1L;
        for(int i = 1; i <= nn; i++)
            pow2[i] = pow2[i - 1] * 2L;*/

        /*inv = new long[nn + 1];
        inv[1] = 1;
        for (int i = 2; i <= nn; ++i)
            inv[i] = (MOD - MOD / i) * inv[(int)(MOD % i)] % MOD;

        invFac = new long[nn + 1];
        invFac[1] = 1;
        for(int i = 2; i <= nn; i++)
            invFac[i] = invFac[i - 1] * inv[i] % MOD;*/

        //primes = sieveOfEratosthenes(100001);


        /*for(int i = 2; i <= 20000000; i++)
            if(numOfDiv[i] == 0)
                for(int j = i; j <= 20000000; j += i)
                    numOfDiv[j] ++;*/

        int t = 1, tt = 0;
        t = sc.ni();
        while(tt++ < t) {
            //long res = solve();
            //out.print(""Case #"" + tt + "": "");
            solve();
            //out.println(res);
        }
        out.close();
    }
    static void solve() {
        int N = sc.ni();
        long sum = 0, curSum = 0;
        int[] A = new int[N];
        ArrayList <Integer> list = new ArrayList();
        int thres = Math.min(N, 30);
        for(int i = 0; i < thres; i++) A[i] = 1 << (thres - i - 1);
        for(int i = thres; i < N; i++) {
            A[i] = 500 + i;
            list.add(A[i]);
        }
        for(int i = 0; i < N; i++) System.out.print(A[i] + "" "");
        System.out.println();
        System.out.flush();
        int[] B = sc.na(N);
        for(int i = 0; i < N; i++) list.add(B[i]);
        for(int i : A) sum += i;
        for(int i : B) sum += i;
        HashSet <Integer> AA = new HashSet(), BB = new HashSet();
        for(int i : list) {
            if(curSum + i <= sum / 2) {
                AA.add(i);
                curSum += i;
            } else BB.add(i);
        }
        for(int i = 0; i < thres; i++) {
            if(curSum + A[i] <= sum / 2) {
                AA.add(A[i]);
                curSum += A[i];
            } else BB.add(A[i]);
        }
        for(int i : AA) System.out.print(i + "" "");
        System.out.println();
        System.out.flush();
    }

    static long c(int a, int b) {
        if(a <= 0 || b <= 0 || a <= b) return 1L;
        return fac[a] * invFac[b] % MOD * invFac[a - b] % MOD;
    }

    // SegmentTree range min/max query From uwi
    public static class SegmentTreeRMQ {
        public int M, H, N;
        public long[] st;

        public SegmentTreeRMQ(int n)
        {
            N = n;
            M = Integer.highestOneBit(Math.max(N-1, 1))<<2;
            H = M>>>1;
            st = new long[M];
            Arrays.fill(st, 0, M, Integer.MAX_VALUE);
        }

        public SegmentTreeRMQ(long[] a)
        {
            N = a.length;
            M = Integer.highestOneBit(Math.max(N-1, 1))<<2;
            H = M>>>1;
            st = new long[M];
            for(int i = 0;i < N;i++){
                st[H+i] = a[i];
            }
            Arrays.fill(st, H+N, M, Integer.MAX_VALUE);
            for(int i = H-1;i >= 1;i--)propagate(i);
        }

        public void update(int pos, int x)
        {
            st[H+pos] = x;
            for(int i = (H+pos)>>>1;i >= 1;i >>>= 1)propagate(i);
        }

        private void propagate(int i)
        {
            st[i] = Math.min(st[2*i], st[2*i+1]);
        }

        public long minx(int l, int r){
            long min = Long.MAX_VALUE;
            if(l >= r) return min;
            while(l != 0){
                int f = l&-l;
                if(l+f > r)break;
                long v = st[(H+l)/f];
                if(v < min)min = v;
                l += f;
            }

            while(l < r){
                int f = r&-r;
                long v = st[(H+r)/f-1];
                if(v < min) min = v;
                r -= f;
            }
            return min;
        }

        public long min(int l, int r){ return l >= r ? 0 : min(l, r, 0, H, 1);}

        private long min(int l, int r, int cl, int cr, int cur)
        {
            if(l <= cl && cr <= r){
                return st[cur];
            }else{
                int mid = cl+cr>>>1;
                long ret = Long.MAX_VALUE;
                if(cl < r && l < mid){
                    ret = Math.min(ret, min(l, r, cl, mid, 2*cur));
                }
                if(mid < r && l < cr){
                    ret = Math.min(ret, min(l, r, mid, cr, 2*cur+1));
                }
                return ret;
            }
        }
    }

    public static char[] rev(char[] a){char[] b = new char[a.length];for(int i = 0;i < a.length;i++)b[a.length-1-i] = a[i];return b;}
    public static int[] rev(int[] a, int start, int end){int[] b = a.clone();for(int i = start;i <= end;i++) b[start + end - i] = a[i];return b;}
    public static int[] rev(int[] a){return rev(a, 0, a.length - 1);}

    public static double dist(double a, double b){
        return Math.sqrt(a * a + b * b);
    }
    public static double dist(int[] A, int[] B){
        return dist(1.0 * A[0] - B[0], 1.0 * A[1] - B[1]);
    }

    public static long inv(long a){
        return quickPOW(a, MOD - 2);
    }

    public class Interval {
        int start;
        int end;
        public Interval(int start, int end) {
            this.start = start;
            this.end = end;
        }
    }

    public static ArrayList<Integer> sieveOfEratosthenes(int n) {
        boolean prime[] = new boolean[n + 1];
        Arrays.fill(prime, true);
        for (int p = 2; p * p <= n; p++) {
            if (prime[p]) {
                for (int i = p * 2; i <= n; i += p) {
                    prime[i] = false;
                }
            }
        }
        ArrayList<Integer> primeNumbers = new ArrayList<>();
        for (int i = 2; i <= n; i++) {
            if (prime[i]) {
                primeNumbers.add(i);
            }
        }
        return primeNumbers;
    }


    public static int lowerBound(int[] a, int v){ return lowerBound(a, 0, a.length, v); }
    public static int lowerBound(int[] a, int l, int r, int v)
    {
        if(l > r || l < 0 || r > a.length)throw new IllegalArgumentException();
        int low = l-1, high = r;
        while(high-low > 1){
            int h = high+low>>>1;
            if(a[h] >= v){
                high = h;
            }else{
                low = h;
            }
        }
        return high;
    }
    public static int rlowerBound(int[] a, int v){ return lowerBound(a, 0, a.length, v); }
    public static int rlowerBound(int[] a, int l, int r, int v)
    {
        if(l > r || l < 0 || r > a.length)throw new IllegalArgumentException();
        int low = l-1, high = r;
        while(high-low > 1){
            int h = high+low>>>1;
            if(a[h] <= v){
                high = h;
            }else{
                low = ",anhpp123
20,"public class Solution {


    public void start() throws Exception {
       BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        
        int t = Integer.parseInt(in.readLine());
        for (int i = 1; i <= t; i++) {
            System.out.print(""Case #"" + i + "": "");
            solve(in);
        }
    }

    private void solve(BufferedReader in) throws Exception {
        int N = Integer.parseInt(in.readLine());
        Node[] nodes = new Node[N + 1];
        Node abyss = new Node();
        abyss.fun = 0;
        abyss.index = 0;
        nodes[0] = abyss;
        String[] args = in.readLine().split("" "");
        for (int i = 1; i <= N; i++) {
            Node n = new Node();
            n.fun = Integer.parseInt(args[i - 1]);
            n.index = i;
            nodes[i] = n;
        }



        args = in.readLine().split("" "");
        for (int i = 1; i <= N; i++) {
            nodes[Integer.parseInt(args[i - 1])].children.add(nodes[i]);
        }
        System.out.println(fun(nodes[0]));

    }

    private int fun(Node n) {
        if (n.children.size() == 0) {
            n.score = n.fun;
            return n.fun;
        }
        Node min = n.children.get(0);
        int sum = 0;
        for (Node c : n.children) {
            int s = fun(c);
            if (s < min.score) {
                min = c;
            }
            sum += s;
        }
        n.score = sum;
        if (n.fun < min.fun) {
            n.fun = min.fun;
        } else {
            n.score += n.fun - min.fun;
        }
        return n.score;
    }


    private class Node {
        List<Node> children = new LinkedList<>();
        int fun;
        int index;
        int score;
    }

    public static void main(String[] args) throws Exception {
        Solution s = ",Abolfazl
538,"public class Solution {

    private static final Boolean FROM_FILE = Boolean.FALSE;
    private static final int MAX = 1000000001;

    public static void main(String[] args) throws IOException{
        BufferedReader br;
        BufferedWriter bw;

        if(FROM_FILE){
            br = new BufferedReader(new FileReader(""C2022QR1D.in""));
        } else {
            br = new BufferedReader(new InputStreamReader(System.in));
        }

        try {
            if(FROM_FILE) {
                File file = new File(""C2022QR1D.out"");
                if (!file.exists()) {
                    file.createNewFile();
                }
                bw = new BufferedWriter(new FileWriter(file.getAbsoluteFile()));
            } else {
                bw = new BufferedWriter(new OutputStreamWriter(System.out));
            }

            String line = br.readLine();
            String[] q,r;

            int tests = Integer.parseInt(line);//100
            int n;
            int[] f;
            int[] p;
            int[] height;
            int[] firstChild;
            int[] noChildren;
            int[] hasBrothers;

            int i,k,l,u, min, found, m, biggestHeight, leafWithBiggestHeight;
            long max;

            for(i = 0; i < tests; i++){
                line = br.readLine();
                n = Integer.parseInt(line);

                f = new int[n];
                p = new int[n];
                height = new int[n];

                line = br.readLine();
                q = line.split(""\\\s+"");

                line = br.readLine();
                r = line.split(""\\\s+"");

                firstChild = new int[n];
                Arrays.fill(firstChild,-1);
                hasBrothers = new int[n];
                Arrays.fill(hasBrothers,-1);
                noChildren = new int[n];
                Arrays.fill(noChildren,0);

                // input and abyss detection
                for(int j = 0;j<n; j++){
                    f[j] = Integer.parseInt(q[j]);
                    // 0 <= Pi <= i-1, for all i.
                    // XXX: why less than i. Oh, these are ordered!
                    p[j] = Integer.parseInt(r[j])-1;

                    // abyss
                    if(-1 == p[j]){
                        height[j] = 0; // root
                    } else {
                        // p[j] has children
                        // upstream.get(p[j]).add(j);
                        if(0 == noChildren[p[j]]){
                            noChildren[p[j]] = 1;
                            firstChild[p[j]] = j;
                            // hasBrothers[j] = -1;
                        } else {
                            noChildren[p[j]]++;

                            // insert child as last brother
                            m = firstChild[p[j]];

                            while(-1 != hasBrothers[m]){
                                m = hasBrothers[m];
                            }

                            hasBrothers[m] = j;
                        }

                        // because of XXX ordering his parent's height was already counted
                        height[j] = height[p[j]]+1;
                    }
                }

                max = 0L;

                // XXX: Pk cannot be triggered by Pk+1...Pn, so walk backwards to fold trees
                for(k = n-1; k >= 0; k--){
                    // #0 skip nodes with no fun
                    if(f[k] == 0) {
                        continue;
                    }

                    // #00 count roots
                    if(p[k] == -1){
                        max += f[k];
                        //f[k] = 0;
                        continue;
                    }

                    // #1 optimize - reduce leafs that are only childs
                    // is not a root && is a leaf && only child
                    if(noChildren[k] == 0 &&
                            noChildren[p[k]] == 1){
                        // reduce fun of parent as max of leaf and parent, they get triggered at once anyways!
                        f[p[k]] = Math.max(f[k], f[p[k]]);
                        f[k] = 0;
                        // parent becomes a leaf after reduce
                        noChildren[p[k]] = 0;

                        // skip anything this turn
                        continue;
                    }

                    // #2A detect leaf with greatest height
                    biggestHeight = -1;
                    leafWithBiggestHeight = -1;

                    for(l = k; l >= 0; l--){
                        // leaf detection (backwards because of XXX order, first big height is resolved first!)
                        // only consider nodes with fun left
                        if(f[l] > 0 && noChildren[l] == 0){
                            if(height[l] > biggestHeight){
                                biggestHeight = height[l];
                                leafWithBiggestHeight = l;
                            }
                        }
                    }
                    // #2B reduce leafWithBiggestHeight
                    // parent, not visited yet because of XXX ordering
                    m = p[leafWithBiggestHeight];

                    // only child, again simple
                    if(noChildren[m] == 1){
                        // reduce fun of parent as max of leaf and parent, they get triggered at once anyways!
                        f[m] = Math.max(f[leafWithBiggestHeight], f[m]);
                        // parent becomes a leaf after reduce
                        noChildren[m] = 0;
                        // make leaf no fun, it has been reduced
                        f[leafWithBiggestHeight] = 0;
                    } else {
                        // parent has at least 2 children.
                        // find the minimal fun child and merge with parent
                        min = MAX;
                        found = -1;
                        u = firstChild[m];

                        while(-1 != hasBrothers[u]){
                            if(f[u] < min){
                                min = f[u];
                                found = u;
                            }
                            u = hasBrothers[u];
                        }
                        // last child
                        if(f[u] < min){
                            min = f[u];
                            found = u;
                        }

                        // minimal fun gets reduced into parent
                        // reduce fun of parent as max of leaf and parent, they get triggered at once anyways!
                        f[m] = Math.max(f[found], f[m]);
                        // make leaf no fun, it has been reduced
                        f[found] = 0;

                        // count the fun of the other children (they are leaves because of XXX sorting after height step)
                        /* for(u = 0; u < noChildren[m]; u++){
                            max += f[upstream.get(m).get(u)];
                            f[upstream.get(m).get(u)] = 0;
                        }*/

                        u = firstChild[m];
                        while(-1 != hasBrothers[u]){
                            max += f[u];
                            f[u]= 0;
                            u = hasBrothers[u];
                        }
                        max+=f[u];

                        // parent becomes a leaf after reduce
                        noChildren[m] = 0;
                    }
                }

                bw.write(""Case #""+(i+1)+"": "" + max + ""
"");

                bw.flush();

                f = null;
                p = null;
                q = null;
                r = null;
                height = null;

                firstChild = null;
                noChildren = null;
                hasBrothers = null;
            }

            if(FROM_FILE) {
                bw.close();
            }
        } finally {
            if(FROM_FILE) {
                br.close();
            }
        }
    }
}",araver
1111,"public class Solution {

  public static void main(String[] args) {
    Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
    int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
    for (int i = 1; i <= t; ++i) {
      int n = in.nextInt();

      var map = new TreeMap<Integer, Integer>();
      for (int j = 1; j <= n; j++) {
        int key = in.nextInt();
        int val = map.getOrDefault(key, 0);
        map.put(key, val + 1);
      }

      int result = solve(map);
      System.out.println(""Case #"" + i + "": "" + result);
    }
  }

  static int solve(TreeMap<Integer, Integer> map) {
    int position = 0;
    for (var key : map.navigableKeySet()) {
      var value = map.get(key);
      var diff = ",rk13
375,"public class Solution {
    public static Scanner scan;
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int runtime = scan.nextInt();
        for(int i=0;i<runtime;i++){
            int row=scan.nextInt();
            int col=scan.nextInt();
            String[][] cell=new String[row*2+1][col*2+1];
            for(int j=0;j<=row*2;j++){
                for(int k=0;k<=col*2;k++){
                    if(j%2==0) {
                        if(k%2==0) {
                            cell[j][k]=""+"";
                        }
                        else cell[j][k]=""-"";
                    }
                    if(j%2==1){
                        if(k%2==0){
                            cell[j][k]=""|"";
                        }
                        else cell[j][k]=""."";
                    }
                    if(k<2&&j<2){
                        cell[j][k]=""."";
                    }
                    //System.out.print(cell[j][k]);
                }
                //System.out.println();
            }
        }
    }
}
",ShuoXu
1021,"public class Solution {

    public static void main(String... args) {
        Scanner sc = new Scanner(System.in);
        int count = sc.nextInt();
        for (int i = 0; i < count; i++) {
            int size = sc.nextInt();
            Deque<Integer> pancakes = new LinkedList<>();
            for (int j = 0; j < size; j++) {
                pancakes.add(sc.nextInt());
            }
            System.out.println(""Case #"" + (i + 1) + "": "" + count(pancakes));
        }
    }

    public static int count(Deque<Integer> pancakes) {
        int prev = -1;
        int result = 0;
        throw new IllegalArgumentException(pancakes);
        while(true) {
            if (pancakes.isEmpty()) {
                break;
            }
            int left = pancakes.getFirst();
            int right = pancakes.getLast();
            boolean leftValid = left >= prev;
            boolean rightValid = right >= prev;
            boolean takeLeft = left <= right;
            if (!leftValid && !rightValid) {
                break;
            }
            result++;
            int current = -1;
            if (leftValid && rightValid) {
                if (left < right) {
                    current = pancakes.getFirst();
                    pancakes.removeFirst();
                } else {
                    current = pancakes.getLast();
                    pancakes.removeLast();
                }
            }else if (leftValid) {
                current = pancakes.getFirst();
                pancakes.removeFirst();
            }else {
                current = pancakes.getLast();
                pancakes.removeLast();
            }
            
            prev = ",petrus
569,"public class Solution {
    static final int REL = 1;
    static final int NOLOG = 2;
    static final int TEST = 3;
    static int mode = NOLOG;
    static PrintWriter pw;

    private static int max(int a, int b) {
        if(a >= b) { return a;} else {return b;}
    }

    private static int minIndex(int a, int b, int c) {
        if(a <= b && a <= c) {
            return 0;
        } else if(b <= a && b <= c) {
            return 1;
        } else {
            return 2;
        }
    }

    private static int min(int a, int b, int c) {
        if(a <= b && a <= c) {
            return a;
        } else if(b <= a && b <= c) {
            return b;
        } else {
            return c;
        }
    }

    public static boolean nextPermutation(List<Node> arr) {
        int len = arr.size();
        int left = len - 2;
        while (left >= 0 && arr.get(left).val >= arr.get(left+1).val) left--;
        if (left < 0) return false;
        int right = len - 1;
        while (arr.get(left).val >= arr.get(right).val) right--;
        {Node t = arr.get(left); arr.set(left, arr.get(right)); arr.set(right, t); }
        left++;
        right = len - 1;
        while (left < right) {
            { Node t = arr.get(left); arr.set(left, arr.get(right)); arr.set(right, t); }
          left++;
          right--;
        }
        return true;
      }

    private static class Node {
        int val;
        Node next = null;
        List<Node> pref = new ArrayList<>();
        boolean used = false;
        boolean triggered = false;
        Node(int val) {
            this.val = val;
        }
    }

    static int factCalculator(int n){
        if( n == 0 || n ==1){
            return 1;
        }
        else{
            return n * factCalculator(n-1); 
        }
    }

    private static void initList(List<Node> list) {
        for(Node node : list) {
            node.used = false;
            node.triggered = false;
        }
    }

    public static void main(String[] args) {
        Scanner in = getScanner();
        if(in == null) {
            log(""get scanner fail"");
            return;
        }
        long start = System.currentTimeMillis();
        
        try {
            int t = in.nextInt();
            log(""t:"" + t);
            for (int i = 1; i <= t; ++i) {
                int N = in.nextInt();
                List<Integer> F = new ArrayList<>();
                List<Integer> P = new ArrayList<>();
                for(int j = 0; j < N; ++j) {
                    F.add(in.nextInt());
                }
                for(int j = 0; j < N; ++j) {
                    P.add(in.nextInt());
                }
                log(""F:"", F);
                log(""P:"", P);
                List<Node> list = new ArrayList<>();
                for(int j = 0; j < N; ++j) {
                    list.add(new Node(F.get(j)));
                }
                for(int j = 0; j < N; ++j) {
                    int nextIndex = P.get(j);
                    if(nextIndex > 0 && nextIndex < N) {
                        list.get(j).next = list.get(nextIndex - 1);
                        list.get(nextIndex - 1).pref.add(list.get(j));
                    }
                }
                F.clear(); F = null; P.clear(); P = null;
                
                // initiators
                List<Node> initiators = new ArrayList<>();
                for(Node node : list) {
                    if(node.pref.size() == 0) {
                        initiators.add(node);
//                        log(""initiator:"" + node.val);
                    }
                }

                int score = 0;
                do{
                    log(""***"");
                    int curScore = 0;
                    for(Node node : initiators) {
                        Node cur = node;
                        Node maxNode = cur;
                        int maxScore = 0;
                        while(cur != null) {
                            if(!cur.used && cur.val >= maxScore) {
                                maxScore = cur.val;
                                maxNode = cur;
                            }
                            if(cur.triggered) {
                                break;
                            }
                            cur.triggered = true;
                            cur = cur.next;
                        }
                        maxNode.used = true;
                        curScore += maxNode.val;
                        log(""initiator:"" + node.val + "" score:"" + maxNode.val);
                    }
                    log(""score:"" + curScore);
                    if(curScore > score) {
                        score = curScore;
                        log(""update"");
                    }
                    initList(list);
                }while(nextPermutation(initiators));

                System.out.println(""Case #"" + i + "": "" + score);
            }
            in.close();
        }catch(Exception e) {
            log(e + "" "" + e.getMessage());
        }

        if(mode != REL) {
            log(""time:"" + (System.currentTimeMillis() - start));
            pw.close();
            test();
        }
    }

    private static void test() {
    }

    private static void log(String msg) {
        if(mode == TEST) {
            System.out.print(""[log]"");
            System.out.println(msg);
            pw.println(msg);
        }
    }
    private static void log(List<Integer> list) {
        log("""", list);
    }
    private static void log(String msg, List<Integer> list) {
        if(mode == TEST) {
            System.out.print(""[log]"" + msg);
            for(Integer a : list) {
                System.out.print(a + "" "");
            }
            System.out.println("""");
        }
    }

    private static Scanner getScanner() {
        BufferedReader br;
        if(mode == REL) {
            br = new BufferedReader(new InputStreamReader(System.in));
        } else {
            try {
                br = new BufferedReader(
                    new InputStreamReader(new FileInputStream(""C:\\\\\Users\\	akafumi\\\Desktop\\\Java\\\codejam2022\\	est.txt""), ""UTF-8""));
                    FileWriter file = new FileWriter(""C:\\\\\Users\\	akafumi\\\Desktop\\\Java\\\codejam2022\\\out.txt"", false);
                    pw = new PrintWriter(new BufferedWriter(file));
           } catch(Exception e) ",azzurri992
734,"public class Solution {

    public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        PrintWriter writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));

        int T = in.nextInt();
        for (int casNumero = 1; casNumero <= T; casNumero++) {
            StringBuilder resultat = new StringBuilder();
            resultat.append(""Case #"");
            resultat.append(casNumero);
            resultat.append("": "");

            int n = in.nextInt();
            int p = in.nextInt();

            long[] x = new long[p];
            for (int z = 0; z < p; z++) {
                x[z] = in.nextInt();
            }
            Arrays.sort(x);
            long y = 0;
            long lastValue = 0;

            for (int i = 0; i < n - 1; i++) {
                long[] next = new long[p];
                for (int z = 0; z < p; z++) {
                    next[z] = in.nextInt();
                }
                Arrays.sort(next);

                long difNextFrontFront = Math.abs(x[0] - next[0]);
                long difNextFrontBack = Math.abs(x[0] - next[next.length - 1]);
                long difNextBackFront = Math.abs(x[x.length - 1] - next[0]);
                long difNextBackBack = Math.abs(x[x.length - 1] - next[next.length - 1]);

                long difFront = Math.abs(x[0] - lastValue) + Math.min(difNextBackFront, difNextBackBack);
                long difBack = Math.abs(x[x.length - 1] - lastValue) + Math.min(difNextFrontFront, difNextFrontBack);

                if (difFront < difBack) {
                    y += Math.abs(x[0] - lastValue);
                    lastValue = x[x.length - 1];
                }
                else {
                    y += Math.abs(x[x.length - 1] - lastValue);
                    lastValue = x[0];
                }
                y += x[x.length - 1] - x[0];
                x = next;
            }

            if (Math.abs(x[0] - lastValue) < Math.abs(x[x.length - 1] - lastValue)) {
                y += Math.abs(x[0] - lastValue);
            }
            else {
                y += Math.abs(x[x.length - 1] - lastValue);
            }
            y += x[x.length - 1] - x[0];

            resultat.append(y);

            writer.print(resultat.toString());
            writer.println();
        }
        in.close();
        writer.",gerardmr
245,"public class Solution{

    public static void main(String[] args){

        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));

        int T = in.nextInt();
        for (int i=1; i<=T; i++){
            int count=0;
            int z=in.nextInt();
            int [] array=new int[z];
            for (int j=0;j<z;j++)
            {array[j]=in.nextInt();
            }
            Arrays.sort(array);
            if(array[z-1]>z)
            { count=z;}
            else {
               for (int o=1;o<z;o++)
               { if(i<=array[0])
               {count++;}
               }
            
            
            }
           
                    System.out.println(""Case #"" + T + "": "" + count);
            }
        
        in.",Marwan
593,"public class Solution{
    public static void main(String[] args){
        Scanner s = new Scanner(System.in);
        int T = s.nextInt();
        for(int ii=1; ii <= T; ii++){
            int N = s.nextInt();

            int[] f = new int[N];

            int[] p = new int[N];

            HashMap<Integer,ArrayList<Integer>> adjM = new
                    HashMap<>();


            for(int i=0; i < N; i++){
                f[i] = s.nextInt();
            }

            for(int i=0; i < N; i++){
                p[i] = s.nextInt();
            }

            HashSet<Integer> intermediate = new HashSet<>();
            for(int i=0; i < N; i++){
                intermediate.add(p[i]);
                if (p[i] != 0){
                    if (adjM.get(i+1) != null){
                        ArrayList<Integer> ar = adjM.get(i+1);
                        ar.add(p[i]);
                        adjM.put(i+1,ar);
                    }
                    else{
                        ArrayList<Integer> ar = new ArrayList<>();
                        ar.add(p[i]);
                        adjM.put(i+1,ar);
                    }


                }
            }
            int[] leaf = new int[N- intermediate.size() + 1];
            int j = 0;
            for(int i=0; i < N; i++){
                if (!intermediate.contains(i+1)){
                    leaf[j] = i+1;
                    j++;
                }
            }
            boolean[] visited = new boolean[N+1];
            long ans = 0;
            int n= 0;
            long max = -1;
            while( n < leaf.length) {
                int j1 = 0;
                visited = new boolean[N+1];
                ans = 0;
                int i=0;
                for ( i = 0; i < leaf.length; i++) {
                    //if (!intermediate.contains(i+1)){
                    if (!visited[leaf[i]]){
                       // System.out.println(""v="" + leaf[i]);
                        ans = ans + dfs(leaf[i], adjM, visited, f);

                    }
                    //System.out.println(""v = "" + leaf[i] + "" ans = "" + ans);
                }
                max = Math.max(max,ans);
                int temp = leaf[leaf.length-1];
                for(j1 = leaf.length - 1; j1 >= 1; j1--) {
                    leaf[j1] = leaf[j1-1];
                }
                leaf[0] = temp;
                n++;
            }

            System.out.println(""Case #"" + ii  + "": "" + max );



        }
    }
    static long dfs(int src,
                    HashMap<Integer,ArrayList<Integer>> adjM,
                    boolean[] visited,int[] f){
        visited[src] = true;
        long funValue = f[src-1];

        Stack<Integer> stk = new Stack<Integer>();
        stk.push(src);

        while(!stk.isEmpty()){
            int u = stk.pop();
           if (adjM.get(u) != null) {
               for (Integer v : adjM.get(u)) {
                   if (!visited[v]) {
                       stk.push(v);
                       funValue = Math.max(funValue, f[v - 1]);
                       visited[v] = true;
                   }
               }
           }
        }

        return funValue;

    }
",dattap
218,"public class Solution {
    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        int c=s.nextInt();
        int wj = s.nextInt();
        ArrayList<Integer> wjj=new ArrayList<>();
        for (int t = 0; t < c; t++) 
        {
            for(int z=0;z<wj;z++)
            { wjj.add(s.nextInt());}
    
            System.out.print(""Case #"" + (t + 1)+"":"");
            int min=wjj.get(0);
            int o=0;
            int f=0;
         int[] l=new int[wjj.size()];
            for(int w=0;w<wjj.length;w++)
            {
              for(int k=0;k<wjj.length;k++) 
              {
                  if((int)wjj.get(k)<=min)
                  {min=(int)wjj.get(k);
                  o=k;}
              }
              if(f>wjj.get(o))
              break;
              l[w]=f;
              f++;
              wjj.remove(o);
              w--;
            }
            System.",LeonardWang
412,"public class Solution {


    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);

        int testCases = sc.nextInt();

        for (int caseNum = 0; caseNum < testCases; caseNum++) {

            int[][] printers = new int[3][4];

            for (int i = 0; i < 12; i++) {
                printers[i/4][i%4] = sc.nextInt();
            }


            Integer     a = Math.min(Math.min(printers[0][0],printers[1][0]),printers[2][0]),
                    b = Math.min(Math.min(printers[0][1],printers[1][1]),printers[2][1]),
                    c = Math.min(Math.min(printers[0][2],printers[1][2]),printers[2][2]),
                    d = Math.min(Math.min(printers[0][3],printers[1][3]),printers[2][3]);



            int sum = a + b + c + d;

            if(sum == 1e6){
                System.out.print(""Case #"" + (caseNum + 1) + "":"");
                System.out.println(a + "" "" + b + "" "" + c + "" "" +d);
            }else if(sum > 1e6){
                int diff = sum - (int)1e6;
                
                a -= diff;
                if(a < 0){
                    a = 0;
                    
                    sum = a + b + c + d;
                    diff = sum - (int)1e6;

                    b -= diff;
                    if(b < 0){
                        b = 0;
                        sum = a + b + c + d;
                        diff = sum - (int)1e6;

                        c -= diff;
                        if(c < 0){
                            c = 0;
                            sum = a + b + c + d;
                            diff = sum - (int)1e6;

                            d -= diff;
                        }
                    }
                }
                

                System.out.print(""Case #"" + (caseNum + 1) + "":"");
                System.out.println(a + "" "" + b + "" "" + c + "" "" +d);
            }else{
                System.",SurgeM
1124,"public class Solution {

  static Scanner in;

  public static void main(String[] args) {
    in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
    int t = in.nextInt(); // Scanner has functions to read ints, longs, strings, chars, etc.
    for (int i = 1; i <= t; i++) {
      int n = in.nextInt();
      int k = in.nextInt();
      solve(n, k);
    }
  }

  static void solve(int n, int k) {
    var rng = new Random();
    long sum = 0;
    var set = new HashSet<Integer>();
    set.add(in.nextInt());
    sum += in.nextInt();

    for (int i = 0; i < k; i++) {
      int t = rng.nextInt(n) + 1;
      int tries = 1000;
      while (set.contains(t) && tries > 0) {
        t = rng.nextInt(n) + 1;
        tries--;
      }
      System.out.println(""T "" + t);

      set.add(in.nextInt());
      sum += in.nextInt();
    }
    long r = ",rk13
1007,"public class Solution {
    public static void main(String[] args) {
        Scanner inp = new Scanner(System.in);

        int t = inp.nextInt();

        for (int j = 0; j < t; j++) {
            System.out.printf(""Case #%d: "",j+1);
            int c = inp.nextInt();
            int m = inp.nextInt();
            int y = inp.nextInt();
            int k = inp.nextInt();
            for (int i = 0; i <2 ; i++){
                int c1 = inp.nextInt();
                int m1 = inp.nextInt();
                int y1 = inp.nextInt();
                int k1 = inp.nextInt();

                c = (c1<c) ? c1 : c ;
                m = (m1<m) ? m1 : m ;
                y = (y1<y) ? y1 : y ;
                k = (k1<k) ? k1 : k ;

            }
            if(c>1000000)
                System.out.println(1000000 + "" 0 0 0"");
            else if(c>1000000)
                System.out.println(1000000 + "" 0 0 0"");
            else if(c>1000000)
                System.out.println(1000000 + "" 0 0 0"");
            else if(c>1000000)
                System.out.println(1000000 + "" 0 0 0"");

            else if((c+m+y+k)<1000000)
                System.out.println(""IMPOSSIBLE"");
            else if(c + m + k < 1000000)
                System.out.printf(""%d %d %d %d
"",c,m,1000000-c-m-k,k);
            else if(c + k + y < 1000000)
                System.out.printf(""%d %d %d %d
"",c,1000000-c-k-y,y,k);
            else if(k + m + y < 1000000)
                System.out.printf(""%d %d %d %d
"",1000000-k-m-y,m,y,k);
            else if(c + m + y < 1000000)
                System.out.printf(""%d %d %d %d
"",c,m,y,1000000-c-m-y);
            else if(c + m > 1000000 )
                System.out.printf(""%d %d %d %d
"",c,1000000-c,0,0);
            else if(c + y > 1000000 )
                System.out.printf(""%d %d %d %d
"",c,0,1000000-c,0);
            else if(c + k > 1000000 )
                System.out.printf(""%d %d %d %d
"",c,0,0,1000000-c);
            else if(m + k > 1000000 )
                System.out.printf(""%d %d %d %d
"",0,1000000-k,0,k);
            else if(m + y > 1000000 )
                System.out.printf(""%d %d %d %d
"",0,1000000-y,y,0);
            else if(y + k > 1000000 )
                System.out.printf(""%d %d %d %d
"",0,0,1000000-k,k);
                
            

            








        }
    }
}",parthanos
31,"    public class Solution {
    
    public static void main(String[] args) {
           Scanner keyboard = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
    int a;
    int[][]array1;
int c=0;
int m=0;
int y=0;
int k=0;
    
    a = keyboard.nextInt();
    array1 = new int[a][12];

    
for (int b = 0; b<a; b++)
{
    for (int z = 0; z < 12; z++)
    {
  array1[b][z]=keyboard.nextInt();
    }
}
for (int d = 0; d < a; d++)
{
    int counter = 0;
   if ((array1[d][0]<=array1[d][4])&&(array1[d][0]<=array1[d][8]))
           {
               c = array1[d][0];
           }
   else if (array1[d][4]<=array1[d][8])
   {        
               c = array1[d][4];
   }
   else
               c = array1[d][8];

   if ((array1[d][1]<=array1[d][5])&&(array1[d][1]<=array1[d][9]))
           {
               m = array1[d][1];
           }
   else if (array1[d][5]<=array1[d][9])
   {        
               m = array1[d][5];
   }
   else
               m = array1[d][9];

   if ((array1[d][2]<=array1[d][6])&&(array1[d][2]<=array1[d][10]))
           {
               y = array1[d][2];
           }
   else if (array1[d][6]<=array1[d][10])
   {        
               y = array1[d][5];
   }
   else
               y = array1[d][10];
   
      if ((array1[d][3]<=array1[d][7])&&(array1[d][3]<=array1[d][11]))
           {
               k = array1[d][3];
           }
   else if (array1[d][7]<=array1[d][11])
   {        
               k = array1[d][7];
   }
   else
               k = array1[d][11];


if (counter==0)
      for (int col1 = c; col1 >=0; col1--)
      {
          
          if (counter==0)
          for (int col2 = m ; col2>=0; col2--)
          {if (counter==0)
              for (int col3 = y; col3 >=0; col3--)
              {if (counter==0)
                  for (int col4 = k; col4 >=0; col4-- )
                  {
                      if (col1+col2+col3+col4==1000000)
                      {
                          System.out.println(""Case #""+(d+1)+"": ""+col1+"" ""+col2+"" ""+col3+"" ""+col4);
                          counter++;
                          break;
                                                }
                  }
              }
          }
      }
if (counter==0)
{
    System.out.println(""Case #""+(d+1)+"" IMPOSSIBLE"");
}



}
    }
}",Ak9
188,"public class Solution {
	
	long countedPassages=0;
	int visitedRoomCount=0, currentRoom=1;
	Scanner s;
	
	public static void main(String[] args) {
		new Solution().start();
	}
	
	
	public void start() {
		
		s = new Scanner(System.in);
		int cases = s.nextInt();
		for(int caseIndex=0;caseIndex<cases;caseIndex++) {
			int roomCount = s.nextInt();
			int maximumTries = s.nextInt();
			countedPassages=0;
			visitedRoomCount=0;
			
			sync();
			
			TreeSet<Integer> untouchedRooms = new TreeSet<>();
			for(int i=0;i<roomCount;i++) {
				untouchedRooms.add(i+1);
			}
			boolean teleportNext=false;
			for(int step=0;step<maximumTries;step++) {
				untouchedRooms.remove(currentRoom);
				
				if(teleportNext) {
					teleport(untouchedRooms.first());
				}else {
					walk();
				}
				teleportNext=!untouchedRooms.contains(currentRoom);
				
			}
			
			long estimation = (long)(1f*countedPassages*roomCount/visitedRoomCount);
			
			System.out.println(""E ""+estimation);
		}
		
		s.close();

	}
	
	private void teleport(int room) {
		System.out.println(""T ""+room);
		sync();
	}
	
	private void walk() {
		System.out.println(""W"");
		sync();
	}
	
	private void sync() {
		currentRoom = s.nextInt();
		long passageCount = ",KovacsA22
101,"    class Solution {
    	
    	public static int nextInt(Scanner in) {
    		return Integer.parseInt(in.next());
    	}
    	
    	public static void main(String[] args) throws IOException {
    		Scanner in = new Scanner(System.in);
    		int t = in.nextInt();
    		for(int tc = 1; tc <= t; tc ++) {
    			final int N = nextInt(in);
    			int K = nextInt(in);
    			final int MAX_TOUR_SIZE = Math.max(0, (K - 90) / 90);
    			TreeSet<Integer> missing = new TreeSet<> ();
    			for(int i = 1; i <= N; i ++)
    				missing.add(i);
    			boolean[] done = new boolean[N + 1];
    			long sum = 0;
				int Ri = nextInt(in);
				int Pi = nextInt(in);
				done[Ri] = true;
				sum += Pi;
    			missing.remove(Ri);
    			while(K > 0 && !missing.isEmpty()) {
    				for(int i = 0; i < MAX_TOUR_SIZE && K > 0 && !missing.isEmpty(); i ++) {
    					System.out.println(""W"");
    					Ri = nextInt(in);
    					Pi = nextInt(in);
    					K --;
    					if(!done[Ri]) {
    						done[Ri] = true;
    						sum += Pi;
    						missing.remove(Ri);
    					} else {
    						break;
    					}
    				}
    				if(K > 0 && !missing.isEmpty()) {
						List<Integer> list = new ArrayList<> (missing);
						Collections.shuffle(list);
						int S = list.get(0);
						System.out.println(""T "" + S);
    					Ri = nextInt(in);
    					Pi = nextInt(in);
    					K --;
    					done[Ri] = true;
						sum += Pi;
						missing.remove(Ri);
					}
    			}
    			int total = 0;
    			for(int i = 1; i <= N; i ++)
    				if(done[i])
    					total ++;
    			long E = ",Deido
617,"public class Solution {

    private static CodeJamIO io = new CodeJamIO();

    /**
     * @param args
     */
    public static void main(String[] args) {

        try {
            init();

            int numCases = Integer.parseInt(io.readNextLine()[0]);
            for (int i=1; i <= numCases; i++) {
                io.debug(""Solving Case #"" + i + ""..."");
                solveCase(i);
                io.debug(""Case #"" + i + "" solved!"");
            }

        } catch (Exception e) {
            e.printStackTrace();
        }

    }

    /**
     * Performs initial computations
     */
    private static void init() {

    }

    /**
     * Solves a Test Case
     *
     * @param caseNum
     * @throws IOException
     */
    private static void solveCase(int caseNum) throws IOException {
        // Read input
        Ink[][] ink = new Ink[4][3];
        for (int i=0; i<3; i++) {
            String[] tokens = io.readNextLine();
            for (int j=0; j<4; j++) {
                ink[j][i] = new Ink(Integer.parseInt(tokens[j]), j);
            }
        }

        // Do the work
        Ink[] minink = new Ink[4];
        for (int j=0; j<4; j++) {
            minink[j] = Arrays.stream(ink[j]).min(new QuantityComparator()).get();
        }

        Arrays.sort(minink, new QuantityComparator());

        Ink[] results = new Ink[4];
        int remaining = 1000000;
        for (int j=0; j<3; j++) {
            results[j] = new Ink(remaining <= minink[j].quantity ? remaining : minink[j].quantity, minink[j].color);
            remaining -= results[j].quantity;
        }
        boolean impossible = remaining > minink[3].quantity;
        results[3] = new Ink(remaining, minink[3].color);

        Arrays.sort(results, new ColorComparator());

        // Print results
        io.printCase(caseNum);
        String space = """";
        if (impossible) {
            io.println(""IMPOSSIBLE"");
        } else {
            for (int j=0; j<4; j++) {
                io.print(space).print(results[j].quantity);
                space = "" "";
            }
            io.println();
        }
    }

    private static class Ink {
        private int quantity;
        private int color;

        private Ink(int quantity, int color) {
            this.quantity = quantity;
            this.color = color;
        }
    }

    private static class QuantityComparator implements Comparator<Ink> {
        public int compare(Ink one, Ink two) {
            return (new Integer(one.quantity)).compareTo(two.quantity);
        }
    }

    private static class ColorComparator implements Comparator<Ink> {
        public int compare(Ink one, Ink two) {
            return (new Integer(one.color)).compareTo(two.color);
        }
    }

    /**
     * Input and Output CodeJam style
     *
     */
    private static class CodeJamIO {
        private static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        private static PrintWriter out = new PrintWriter(System.out, true);
        private static PrintWriter err = new PrintWriter(System.err, true);

        public String[] readNextLine() throws IOException {
            String line = in.readLine();
            String[] tokens = line.split(""\\\s+"");
            return tokens;
        }

        public CodeJamIO printCase(int caseNum) { return print(""Case #"" + caseNum + "": "" ); }

        public CodeJamIO print(Object o) { out.print(o); return this; }

        public CodeJamIO print(Object o[]) { return print(concat(o)); }

        public CodeJamIO print(Object o[][]) { return print(concat(o)); }

        public CodeJamIO println() { out.println(); return this; }

        public CodeJamIO printlnCase(int caseNum) { return printCase(caseNum).println(); }

        public CodeJamIO println(Object o) { return print(o).println(); }

        public CodeJamIO println(Object o[]) { return print(o).println(); }

        public CodeJamIO println(Object o[][]) { return print(concat(o)).println(); }

        public CodeJamIO println(List<Integer[]> l) { return print(concat(l)).println(); }


        private String concat(Object[] o) {
            StringBuffer buf = new StringBuffer(10*o.length);

            String delim = """";
            for (int i=0; i < o.length; i++) {
                buf.append(delim).append(o[i]);
                delim = "" "";
            }
            return buf.toString();
        }

        private String concat(Object[][] o) {
            StringBuffer buf = new StringBuffer(100*o.length);
            for (int i=0; i < o.length; i++) {
                buf.append(concat(o[i])).append(""
"");
            }
            return buf.toString();
        }

        private String concat(List<Integer[]> list) {
            StringBuffer buf = new StringBuffer();
            String delim = """";
            for (Object[] elm : list) {
                buf.append(delim).append(concat(elm)).append(""
"");
            }
            return buf.toString();
        }

        public void debug(String message) {
            err.println(Calendar.getInstance().getTime() + "": "" + message);
        }

        public void debug(String message, Object[] o) {
            err.println(Calendar.getInstance().getTime() + "": "" + message);
            err.println(""	"" + concat(o));
        }

        public void debug(String message, Object[][] o) {
            err.println(Calendar.getInstance().getTime() + "": "" + message);
            String values = concat(o);
            err.println(""	"" + values.replaceAll(""
"", ""
	""));
        }

        public void debug(String message, List<Integer[]> list) {
            err.println(Calendar.getInstance().getTime() + "": "" + message);
            String values = concat(list);
            err.println(""	"" + values.replaceAll(""
"", ""
	""));
        }

        public void flush() {
            out.flush();
            err.flush();
        }

    }
",ddimi
781,"public class Solution {

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        PrintStream out = System.out;

//        try {
//            in = new Scanner(new BufferedReader(new FileReader(""/Users/Shared/Sources/CodingStudy/src/codejam/year2022/round_QA/D1000000/sample/sample_ts1-in.txt"")));
//            out = new PrintStream(new FileOutputStream(""/Users/Shared/Sources/CodingStudy/src/codejam/year2022/round_QA/D1000000/sample/sample_ts1-out.txt""));
//        } catch (Exception e) {
//            e.printStackTrace();
//            return;
//        }

        int T = in.nextInt();
        for (int t = 1; t <= T; t++) {
            int N = in.nextInt();
            int[] S = new int[N];
            for (int i = 0; i < N; i++) {
                S[i] = in.nextInt();
            }
            int max = getAnswerV2(S);

            out.printf(""Case #%d: %d
"", t, max);
        }
        in.close();
    }

    private static int getAnswerV2(int[] S) {
        int[] array = Arrays.copyOf(S, S.length);
        Arrays.sort(array);

        int maxLen = 0;
        int left = 0;
        int right = 0;
        int leftVal = 1;
        int rightVal = 1;

        /* Sliding window */
        while (right < array.length) {

            if (rightVal <= array[right]) {
                maxLen = Math.max(maxLen, right - left + 1);

                right++;
                rightVal++;
            } else {
                if( left < array.length - 1 && leftVal <= array[left+1]){
                    left++;

                    rightVal--;
                }else{
                    throw new IllegalStateException();
                }
            }

//            System.err.printf(""Left %d Right %d
"", left, right);

//            if( right < left){
//                break;
////                throw new IllegalStateException();
//            }


        }

//        System.err.printf(""Left %d Right %d Max: %d
"", left, right, maxLen);

        return maxLen;
    }

    private static int getAnswerV1(int[] S) {
        int[] copyS = Arrays.copyOf(S, S.length);
        Arrays.sort(copyS);

        int maxLen = Integer.MIN_VALUE;
        for (int left = 0; left < S.length; left++) {
            for (int right = left; right < S.length; right++) {
                if (isAcceptable(copyS, left, right)) {
                    maxLen = Math.max(maxLen, right - left + 1);
                }
            }
        }

        return maxLen;
    }

    private static boolean isAcceptable(int[] copyS, int left, int right) {
        int val = 1;
        for (int i = left; i <= right; i++) {
            if (val <= copyS[i]) {
                val++;
            } else {
                return false;
            }
        }

        return true;
    }

}",id
1170,"public class Solution {
    public static void main(String[] args) throws IOException {
        Scanner scanner = new Scanner(System.in);
        int t = scanner.nextInt();
        for(int i = 1; i <= t; ++i){
            int n = scanner.nextInt();
            BigInteger values[] = new BigInteger[n];
            int links[] = new int[n];
            for(int j = 0; j < n; ++ j){
                values[j] = scanner.nextBigInteger();
            }
            for(int j = 0; j < n; ++ j){
                links[j] = scanner.nextInt() - 1;
            }
            System.out.println(String.format(""Case #%d: %s"",i,solve(values,links,n).toString()));
        }
    }

    public static BigInteger solve(BigInteger[] values, int[] links, int n){
        Node[] nodes = new Node[n];
        Node abyss = new Node(BigInteger.ZERO);
        for(int i = 0; i < n; ++i){
            nodes[i] = new Node(values[i]);
        }
        for(int i = 0; i < n; ++i){
            if(links[i] == -1){
                abyss.initiators.add(nodes[i]);
                nodes[i].next = abyss;
            }else{
                nodes[links[i]].initiators.add(nodes[i]);
                nodes[i].next = nodes[links[i]];
            }
        }
        return abyss.maxFactor();
//        return Arrays.stream(nodes)
//                .filter(q -> q.next == null)
//                .map(Node::maxFactor)
//                .reduce(BigInteger::add)
//                .orElse(BigInteger.ZERO)
//                .add(abyss.maxFactor());
    }

    public static class Node{
        public BigInteger val;
        public List<Node> initiators;
        public Node next;

        public Node(BigInteger v){
            val = v;
            initiators = new ArrayList<>();
        }

        BigInteger maxFactor(){
            if(initiators.isEmpty()){
                return val;
            }
            List<BigInteger> si =  initiators.stream().map(Node::maxFactor).sorted().collect(Collectors.toList());
            Iterator<BigInteger> itr = si.iterator();
            BigInteger fun = itr.next().max(val);
            while(itr.hasNext()){
                fun = ",smartelf
28,"public class Solution {

    static BufferedReader in;
    int N;
    int K;
    Node[] nodes;
    int count;
    public void start() throws Exception {
        in = new BufferedReader(new InputStreamReader(System.in));
        int t = Integer.parseInt(in.readLine());
        for (int i = 1; i <= t; i++) {
            String[] args = in.readLine().split("" "");
            N = Integer.parseInt(args[0]);
            K = Integer.parseInt(args[1]);
            nodes = new Node[N + 1];
            solve(in);
        }
    }

    private void solve(BufferedReader in) throws Exception {

        int index = walkResp(-1);
        while (count < N && K > 0) {
            if (index <= 0) {
                for (int i = 1; i < nodes.length; i++) {
                    if (nodes[i] == null) {
                        System.out.println(""T "" + i);
                        K--;
                        index = walkResp(-1);
                        break;
                    }
                }
            } else {
                Node node = nodes[index];
                if (node.edges.size() < node.edgeCnt / 3) {
                    System.out.println(""W"");
                    K--;
                    index = walkResp(index);
                } else {
                    index = -1;
                }
            }

        }

        long s = 0;
        for (Node node : nodes) {
            if(node != null) {
                s += node.edgeCnt;
            }
        }

        if (count < N) {
            s = Math.round(N * 1d * s / (count * 2d));
        } else {
            s = s / 2;
        }

        System.out.println(""E "" + s);
    }

    private int walkResp(int currentNode)throws Exception {

        String[] args = in.readLine().split("" "");
        int index = Integer.parseInt(args[0]);
        int edgeCount = Integer.parseInt(args[1]);

        if (nodes[index] == null) {
            Node node = new Node();
            node.index = index;
            node.edgeCnt = edgeCount;
            nodes[index] = node;
            count++;
        }
        if (currentNode > 0) {
            if (nodes[currentNode].edges.contains(index)) {
                return -1;
            }
            nodes[currentNode].edges.add(index);
            nodes[index].edges.add(currentNode);
        }
        return index;
    }

    class Node {
        int index;
        Set<Integer> edges = new HashSet<>();
        int edgeCnt;
    }


    public static void main(String[] args) throws Exception {
        Solution s = ",Abolfazl
1033,"public class Solution {

    public static void main(String... args) {
        Scanner sc = new Scanner(System.in);
        int count = sc.nextInt();
        for (int i = 0; i < count; i++) {
            int size = sc.nextInt();
            Deque<Integer> pancakes = new LinkedList<>();
            for (int j = 0; j < size; j++) {
                pancakes.add(sc.nextInt());
            }
            System.out.println(""Case #"" + (i + 1) + "": "" + count(pancakes));
        }
    }

    public static int count(Deque<Integer> pancakes) {
        int prev = -1;
        int result = 0;
        while(true) {
            if (pancakes.isEmpty()) {
                break;
            }
            int left = pancakes.getFirst();
            int right = pancakes.getLast();
            boolean leftValid = left >= prev;
            boolean rightValid = right >= prev;
            boolean takeLeft = left <= right;
            if (!leftValid && !rightValid) {
                break;
            }
            result++;
            int current = -1;
            if (leftValid && rightValid) {
                if (left <= right) {
                    current = pancakes.getFirst();
                    pancakes.removeFirst();
                } else {
                    current = pancakes.getLast();
                    pancakes.removeLast();
                }
            }else if (leftValid) {
                current = pancakes.getFirst();
                pancakes.removeFirst();
            }else {
                current = pancakes.getLast();
                pancakes.removeLast();
            }
            prev = ",petrus
927,"public class Solution {
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        int cases = Integer.parseInt(in.readLine());
        for (int i = 1; i <= cases; i++) {
            System.out.println(""11111100"");
            boolean done = false;
            while (!done) {
                switch(Integer.parseInt(in.readLine())) {
                    case 0:
                        done = true;
                        break;
                    case 1:
                        System.out.println(""10000000"");
                        break;
                    case 2:
                        System.out.println(""11000000"");
                        break;
                    case 3:
                        System.out.println(""11100000"");
                        break;
                    case 4:
                        System.out.println(""11110000"");
                        break;
                    case 5:
                        System.out.println(""11111000"");
                        break;
                    case 6:
                        System.out.println(""11111100"");
                        break;
                    case 7:
                        System.out.println(""11111110"");
                        break;
                    case 8:
                        System.",lavikj
672,"public class Solution {
    public static int N;
    public static HashSet<Integer> seen;
    public static long total;
    public static void main(String[] args) throws IOException {
        Scanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int T = input.nextInt();
        for (int iter = 1; iter<=T; iter++) {
            int N = input.nextInt();
            if (N==-1) return;
            int K = input.nextInt();
            if (K==-1) return;
            seen = new HashSet<>();
            System.out.println(""E ""+trial(N,K,input));
        }
    }
    public static long trial(int N, int K, Scanner input) throws IOException {
        total = 0;
        for (int i = 0; i<K; i++) {
            int R = input.nextInt();
            if (R==-1) {
                int a = 1/0;
            }
            int P = input.nextInt();
            if (P==-1) {
                int a = 1/0;
            }
            seen.add(R);
            total+=P;
            if (seen.size()==N) {
                return total/2;
            }
            System.out.println(""T ""+(i+1));
        }
        int R = input.nextInt();
        if (R==-1) {
            int a = 1/0;
        }
        int P = input.nextInt();
        if (P==-1) {
            int a = ",ekwek
1230,"public class Solution {

  // Template
  public static void main(String[] args) throws Exception {
    final InputReader in = new InputReader(System.in);
    final OutputWriter out = new OutputWriter(System.out);
    Locale.setDefault(Locale.US);
    int T = in.readInt();
    for (int t = 1; t <= T; t++) {
      // read
      int N = in.readInt();
      int[] cost = new int[N + 1];
      for (int i = 1; i <= N; i++) {
        cost[i] = in.readInt();
      }
      int[] parent = new int[N + 1];
      parent[0] = -1;
      int[] childCount = new int[N + 1];
      for (int i = 1; i <= N; i++) {
        parent[i] = in.readInt();
        childCount[parent[i]]++;
      }
      int[][] graph = new int[N + 1][];
      var leafs = new LinkedList<Integer>();
      for (int i = 0; i <= N; i++) {
        if (i > 0 && childCount[i] == 0) {
          leafs.add(i);
        }
        graph[i] = new int[childCount[i]];
      }
      for (int i = 1; i <= N; i++) {
        graph[parent[i]][--childCount[parent[i]]] = i;
      }
      // calc sol
      var todo = new LinkedList<>(leafs);
      int[] min = new int[N + 1];
      int[] min2 = new int[N + 1];
      for (int i = 0; i <= N; i++) {
        min[i] = min2[i] = i;
      }

      while (!todo.isEmpty()) {
        var cur = todo.pollFirst();
        var par = parent[cur];
        if (par == -1) {
          break;
        }
        if (min[par] == parent[cur] || cost[min[par]] > cost[min[cur]]) {
          min2[par] = min[par];
          min[par] = min[cur];
        } else if (min2[par] == parent[cur] || cost[min2[par]] > cost[min[cur]]) {
          min2[par] = min[cur];
        }
        if (++childCount[par] == graph[par].length) {
          todo.add(par);
          if (cost[par] > cost[min[par]]) {
            cost[min[par]] = cost[par];
            if (min2[par] != -1 && cost[min[par]] > cost[min2[par]]) {
              min[par] = min2[par];
            }
          }
        }
      }

      int res = leafs.stream().mapToInt(i -> cost[i]).sum();

      // print
      out.printLine(nthcase(t) + "" "" + res);
    }
    out.close();
  }

  static String nthcase(int t) {
    return ""Case #"" + t + "":"";
  }

  static class InputReader {
    private InputStream stream;
    private byte[] buf = new byte[1024];
    private int curChar;
    private int numChars;

    public InputReader(InputStream stream) {
      this.stream = stream;
    }

    public int read() {
      if (numChars == -1) throw new InputMismatchException();
      if (curChar >= numChars) {
        curChar = 0;
        try {
          numChars = stream.read(buf);
        } catch (IOException e) {
          throw new InputMismatchException();
        }
        if (numChars <= 0) return -1;
      }
      return buf[curChar++];
    }

    public char readChar() {
      int c = read();
      while (isSpaceChar(c)) c = read();
      return (char) c;
    }

    public String readLine() {
      int c = read();
      while (isSpaceChar(c)) c = read();
      StringBuilder res = new StringBuilder();
      do {
        res.appendCodePoint(c);
        c = read();
      } while (!isEndOfLine(c));
      return res.toString();
    }

    public String readString() {
      int c = read();
      while (isSpaceChar(c)) c = read();
      StringBuilder res = new StringBuilder();
      do {
        res.appendCodePoint(c);
        c = read();
      } while (!isSpaceChar(c));
      return res.toString();
    }

    public long readLong() {
      int c = read();
      while (isSpaceChar(c)) c = read();
      int sgn = 1;
      if (c == '-') {
        sgn = -1;
        c = read();
      }
      long res = 0;
      do {
        if (c < '0' || c > '9') throw new InputMismatchException();
        res *= 10;
        res += c - '0';
        c = read();
      } while (!isSpaceChar(c));
      return res * sgn;
    }

    public int readInt() {
      int c = read();
      while (isSpaceChar(c)) c = read();
      int sgn = 1;
      if (c == '-') {
        sgn = -1;
        c = read();
      }
      int res = 0;
      do {
        if (c < '0' || c > '9') throw new InputMismatchException();
        res *= 10;
        res += c - '0';
        c = read();
      } while (!isSpaceChar(c));
      return res * sgn;
    }

    public boolean isSpaceChar(int c) {
      return c == ' ' || c == '
' || c == '\r' || c == '	' || c == -1;
    }

    public boolean isEndOfLine(int c) {
      return c == '
' || c == '\r' || c == -1;
    }
  }

  static class OutputWriter {
    private final PrintWriter writer;

    public OutputWriter(OutputStream outputStream) {
      writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));
    }

    public OutputWriter(Writer writer) {
      this.writer = new PrintWriter(writer);
    }

    public void print(Object... objects) {
      for (int i = 0; i < objects.length; i++) {
        if (i != 0) writer.print(' ');
        writer.print(objects[i]);
      }
    }

    public void printLine(Object... objects) {
      print(objects);
      writer.println();
    }

    public void flush() {
      writer.flush();
    }
",thesamwiser
26,"public class Solution {


    public void start() throws Exception {
       BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        int t = Integer.parseInt(in.readLine());
        for (int i = 1; i <= t; i++) {
            //System.out.print(""Case #"" + i + "": "");
            solve(in);
        }
    }

    private void solve(BufferedReader in) throws Exception {
        String[] args = in.readLine().split("" "");
        int N = Integer.parseInt(args[0]);
        int K = Integer.parseInt(args[1]);

        int s = 0;

        args = in.readLine().split("" "");
        int O = Integer.parseInt(args[0]);
        s += Integer.parseInt(args[1]);

        int n = 0;
        int i = 0;
        while (n < N && i < K) {
            n++;
            if (n == O) {
                continue;
            }
            System.out.println(""T "" + n);
            i++;
            s += Integer.parseInt(in.readLine().split("" "")[1]);
        }
        if (n < N) {
            s = (int) Math.round(N * 1.d * s / n);
        }
        System.out.println(""E "" + (s / 2));
    }



    public static void main(String[] args) throws Exception {
        Solution s = ",Abolfazl
1012,"class Solution {
    public static void main(String[] args) {
        Scanner inp = new Scanner(System.in);

        int t = inp.nextInt();

        for (int j = 0; j < t; j++) {
            System.out.printf(""Case #%d: "",j+1);
            int n = inp.nextInt();
            int[] arr = new int[n];

            for(int i = 0 ; i < n ; i++){
                arr[i] = inp.nextInt();
            }

            Arrays.sort(arr);

            int ar = 0;
            int check = 1;

            for(int i = 0 ; i < n ; i++){
                if(arr[i] >= check) {
                    check++;
                    ar++;
                }
            }

            System.",parthanos
66,"public class Solution {
	static Scanner sc;
	static StringBuffer s;

  public static void main(String[] args)throws Exception{
	  sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
	  
     int nbTest = sc.nextInt();
     
	 for(int test = 1;test<=nbTest;test++){ 	   	 	
	 	solve(test);
	 }   
	 
  }
  
  static void solve (int test) {
	  
	  List<Integer> list1 = new ArrayList<Integer>();
	  List<Integer> list2 = new ArrayList<Integer>();
	  List<Integer> list3 = new ArrayList<Integer>();
	  List<Integer> result = new ArrayList<Integer>();
	  int s = 1000000;
	  for (int i = 0; i<4; i++) list1.add(sc.nextInt()); 
	  for (int i = 0; i<4; i++) list2.add(sc.nextInt());
	  for (int i = 0; i<4; i++) list3.add(sc.nextInt());
	  
	  if (somme(list1)<s) {
		  System.out.println(""Case #""+test+"": IMPOSSIBLE"");
		  return;
	  }
	  if (somme(list2)<s) {
		  System.out.println(""Case #""+test+"": IMPOSSIBLE"");
		  return;
	  }
	  if (somme(list3)<s) {
		  System.out.println(""Case #""+test+"": IMPOSSIBLE"");
		  return;
	  }
	  int minC = minimum(list1.get(0), list2.get(0), list3.get(0));
	  int minM = minimum(list1.get(1), list2.get(1), list3.get(1));
	  int minY = minimum(list1.get(2), list2.get(2), list3.get(2));
	  int minK = minimum(list1.get(3), list2.get(3), list3.get(3));
	  
	  if(minC+minM+minY+minK < s) {
		  System.out.println(""Case #""+test+"": IMPOSSIBLE"");
		  return;
	  }
	  
	  
	  result.add(minC);
	  if(minC+minM>s) {
		  System.out.println(""Case #""+test+"": ""+minC+"" ""+(s-minM)+"" ""+0+"" ""+0);
		  return;
	  }else {
		  result.add(minM);
	  }
	  
	  if (minC+minM+minY>s) {
		  System.out.println(""Case #""+test+"": ""+minC+"" ""+minM+"" ""+(s-(minC+minM))+"" ""+0);
		  return;
	  } else {
		  result.add(minY);
	  }
	  
	  
	  System.out.println(""Case #""+test+"": ""+minC+"" ""+minM+"" ""+minY+"" ""+
	                                        (s-(minC+minM+minY)));
	  


  }
  

  public static int  minimum (int a, int b, int c) {	 
		return Math.min(Math.min(a, b), c);
	}
  public static int somme(List<Integer> list) {
	  int res = 0;
	  for (int i = ",Bil1983
13,"public class Solution {

  public static void main(String[] args) throws Throwable {
    try (BufferedReader in=new BufferedReader(new InputStreamReader(System.in))) {
      try (PrintStream out=System.out) {
        final int T=Integer.parseInt(in.readLine());
        for (int c=1; c<=T; c++) {
          final int N=Integer.parseInt(in.readLine());
          final StringBuilder sL=new StringBuilder();
          final List<Long> L=new ArrayList<>();
          for (long value=1; value<=N; value++) {
            L.add(value);
            if (value>1) sL.append("" "");
            sL.append(value);
          }
          out.println(sL);
          final StringTokenizer tokenizer=new StringTokenizer(in.readLine());
          while (tokenizer.hasMoreTokens()) {
            final long value=Long.parseLong(tokenizer.nextToken());
            L.add(value); 
          }
          Collections.sort(L);
          long halfSum=0L;
          for (long value:L) {
            halfSum+=value;
          }
          if (halfSum%2!=0) throw new IllegalStateException();
          halfSum/=2;
          TreeSet<Long> set=new TreeSet<>();
          set.add(0L);
          final long maxSums[]=new long[L.size()];
          for (int i=0; i<L.size(); i++) {
            final long value=L.get(i);
            final TreeSet<Long> newSet=new TreeSet<>(set);
            for (long x:set) {
              if (value+x<=halfSum) newSet.add(value+x);
            }
            set=newSet;
            maxSums[i]=set.last();
          }
          final Long array[]=set.toArray(new Long[0]);
          final int Z=array.length,Y=L.size();
          if (array[Z-1]!=halfSum) throw new IllegalStateException();
          boolean mat[][]=new boolean[Y+1][Z];
          mat[0][0]=true;
          for (int k=1; k<=Y; k++) {
            long value=L.get(k-1);
            for (int v=0; v<Z; v++) {
              final long sum=array[v];
              if (mat[k-1][v]) {
                mat[k][v]=true;
              }
              else if (sum>=value&&sum<=maxSums[k-1]) {
                final long sum2=sum-value;
                final int v2=Arrays.binarySearch(array,sum2);
                if (v2<0) throw new IllegalStateException();
                if (mat[k-1][v2]) {
                  mat[k][v]=true;
                }
              }
            }
          }
          int k=Y,v=Z-1;
          if (!mat[k][v]) throw new IllegalStateException();
          final Set<Long> result=new TreeSet<>();
          while (k>=1) {
            if (mat[k-1][v]) {
              k--;
            }
            else {
              final long value=L.get(k-1);
              result.add(value);
              k--;
              v=Arrays.binarySearch(array,array[v]-value);
              if (v<0||!mat[k][v]) throw new IllegalStateException();
            }
          }
          StringBuilder sResult=new StringBuilder();
          for (long value:result) {
            if (!sResult.isEmpty()) sResult.append("" "");
            sResult.append(value);
          }
          System.",ASotelo
732,"public class Solution {

    public static void main(String[] args) {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        PrintWriter writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));

        int T = in.nextInt();
        for (int casNumero = 1; casNumero <= T; casNumero++) {
            StringBuilder resultat = new StringBuilder();
            resultat.append(""Case #"");
            resultat.append(casNumero);
            resultat.append("": "");

            int n = in.nextInt();
            long[] f = new long[n];
            for (int i = 0; i < n; i++) {
                f[i] = in.nextLong();
            }
            int[] p = new int[n];
            for (int i = 0; i < n; i++) {
                p[i] = in.nextInt();
            }

            List<Integer> used = new ArrayList<>();
            Map<Integer, Long> triggers = new HashMap();
            for (int i = 1; i < n+1; i++) {
                int finalI = i;
                if (Arrays.stream(p).noneMatch(a -> a == finalI)) {
                    triggers.put(finalI, getFun(finalI, f, p, used));
                }
            }

            Map<Integer, Long> finalSortedTriggers1 = new LinkedHashMap<>();
            triggers.entrySet().stream()
                    .sorted(Map.Entry.comparingByValue())
                    .forEachOrdered(x -> finalSortedTriggers1.put(x.getKey(), x.getValue()));
            Map<Integer, Long> sortedTriggers = finalSortedTriggers1;
            long sumFun = 0;
            while (!sortedTriggers.keySet().isEmpty()) {
                long minFun = 0;
                int bestTrigger = 0;

                for (Integer trigger : sortedTriggers.keySet()) {
                    long fun = sortedTriggers.get(trigger);
                    if (minFun == 0 || minFun > fun) {
                        minFun = fun;
                        bestTrigger = trigger.intValue();
                    }
                    else if (minFun < fun) {
                        break;
                    }
                    else if (minFun == fun) {
                        int commonModule = getCommonModule(bestTrigger, trigger, p);
                        if (commonModule == 0 && f[trigger - 1] < f[bestTrigger - 1]) {
                            minFun = fun;
                            bestTrigger = trigger.intValue();
                        }
                        else if (commonModule != 0) {
                            used.add(commonModule);
                            if (getFun(trigger.intValue(), f, p, used) < getFun(bestTrigger, f, p, used)) {
                                minFun = fun;
                                bestTrigger = trigger.intValue();
                            }
                            used.remove(Integer.valueOf(commonModule));
                        }
                    }
                }
                sumFun += minFun;
                used.addAll(getRelations(bestTrigger, p, used));
                triggers.remove(bestTrigger);
                for (Integer trigger : triggers.keySet()) {
                    int commonModule = getCommonModule(bestTrigger, trigger, p);
                    if (commonModule != 0 && triggers.get(trigger) == minFun) {
                        triggers.put(trigger, getFun(trigger, f, p, used));
                    }
                }
                Map<Integer, Long> finalSortedTriggers = new LinkedHashMap<>();
                triggers.entrySet().stream()
                        .sorted(Map.Entry.comparingByValue())
                        .forEachOrdered(x -> finalSortedTriggers.put(x.getKey(), x.getValue()));

                sortedTriggers = finalSortedTriggers;
            }
            resultat.append(sumFun);
            writer.print(resultat.toString());
            writer.println();
        }
        in.close();
        writer.close();
    }

    private static int getCommonModule(int index1, int index2, int[] p) {
        int currentIndex1 = p[index1 - 1];
        int currentIndex2 = p[index2 - 1];
        int commonModule = 0;
        while (commonModule == 0 && currentIndex1 != 0 && currentIndex2 != 0) {
            if (currentIndex1 == currentIndex2) {
                commonModule = currentIndex1;
            }
            else if (currentIndex1 > currentIndex2) {
                currentIndex1 = p[currentIndex1 - 1];
            }
            else {
                currentIndex2 = p[currentIndex2 - 1];
            }
        }
        return commonModule;
    }

    private static List<Integer> getRelations(int index, int[] p, List<Integer> used) {
        List<Integer> relations = new ArrayList<>();
        relations.add(index);
        int currentIndex = index;
        while (!used.contains(currentIndex) && p[currentIndex - 1] != 0) {
            currentIndex = p[currentIndex - 1];
            relations.add(currentIndex);
        }
        return relations;
    }

    private static long getFun(int index, long[] f, int[] p, List<Integer> used) {
        long fun = f[index - 1];
        int relation = p[index - 1];
        if (relation != 0 && !used.contains(relation)) {
            long relationFun = getFun(relation, f, p, used);
            if (relationFun > fun) {
                fun = ",gerardmr
350,"public class Solution {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        PrintWriter pw = new PrintWriter(System.out);

        int testCases = sc.nextInt();
        for (int testCase = 1; testCase <= testCases; testCase++) {
            Map<Integer, Set<Integer>> map = new HashMap<>();
            List<Long> resList = new ArrayList<>();
            Set<Integer> children = new HashSet<>();

            map.putIfAbsent(0, new HashSet<>());

            int N = sc.nextInt();
            long[] F = new long[N + 1];
            int[] P = new int[N + 1];

            for (int i = 1; i <= N; i++) F[i] = sc.nextInt();
            for (int i = 1; i <= N; i++) P[i] = sc.nextInt();


            for (int i = 1; i <= N; i++) {
                int parent = (P[i] >= i) ? 0 : P[i];
                map.putIfAbsent(parent, new HashSet<>());
                map.get(parent).add(i);

                if (P[i] < i) children.add(i);
            }

            for (int idx : map.keySet())
                if (!children.contains(idx) && idx != 0)
                    map.get(0).add(idx);

            Long res = helper(map, F, 0, resList);
            res += resList.stream().reduce(0L, Long::sum);
            pw.println(""Case #"" + testCase + "": "" + res);
        }

        pw.close();
        sc.close();
    }

    private static long helper(Map<Integer, Set<Integer>> map, long[] F, int idx, List<Long> resList) {
        if (!map.containsKey(idx)) {
            return F[idx];
        }

        long sum = 0L, min = Long.MAX_VALUE;
        for (int childIdx : map.get(idx)) {
            long cur = helper(map, F, childIdx, resList);
            min = Math.min(min, cur);
            sum += cur;
        }

        if (sum - min > 0) resList.add(sum - min);

        return Math.",S
999,"public class Solution
{
    String output = """";
    int iter = 1;
    public void calculate(int n, int[] arr)
    {
        int first = 0, last = n-1;
        int max = 0;
        int answer = 0;
        for(int i=0; i<n; i++)
        {
            if(arr[first] < arr[last])
            {
                if(arr[first]>=max)
                {
                    max = arr[first];
                    answer++;
                }
                first++;
            }
            else
            {
                if(arr[last]>=max)
                {
                    max = arr[last];
                    answer++;
                }
                last--;
            }
        }
        output += ""Case #""+(iter++)+"": ""+answer+""
"";
    }
    public static void main(String[] args) throws IOException
    {
        Solution obj = new Solution();
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int t = Integer.parseInt(st.nextToken());
        for(int i=0; i<t; i++)
        {
            st = new StringTokenizer(br.readLine());
            int n = Integer.parseInt(st.nextToken());
            st = new StringTokenizer(br.readLine());
            int[] arr = new int[n];
            for(int j=0; j<n; j++)
            {
                arr[j] = Integer.parseInt(st.nextToken());
            }
            obj.calculate(n, arr);
        }",nocturnalspider
161,"public class Solution {

  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int n = sc.nextInt();
    for (int i = 0; i < n; i++) {
      int N = sc.nextInt();
      int K = sc.nextInt();
      boolean[] visited = new boolean[N];
      long E = 0;
      int visitCt = 0;
      for (int j = 0; j < K; j++) {
        int R = sc.nextInt();
        int P = sc.nextInt();
        if (!visited[R - 1]) {
          E += P;
          visited[R - 1] = true;
          visitCt++;
          System.out.println(""W"");
        } else {
          int T = N - R;
          while(visited[T]) {
            T++;
          }
          System.out.println(""T ""+ T);
        }
      }
      int R = sc.nextInt();
      int P = sc.nextInt();
      if (!visited[R - 1]) {
        E += P;
        visited[R - 1] = ",Jai03kh
1251,"public class Solution {
	public static void input() {
		Scanner sc = new Scanner(System.in);
		int testCase = sc.nextInt();
		int countTest = 1;
		int[] dices;
		while (testCase > 0) {
			int numDices = sc.nextInt();
			dices = new int[numDices];
			for (int i = 0; i < numDices; i++) {
				dices[i] = sc.nextInt();
			}
			System.out.println(""Case #"" + countTest + "": "" + output(dices));
			countTest++;
			testCase--;
		}
	}

	public static int output(int[] arr) {
		int len = arr.length;
		if (len == 1) {
			return 1;
		}

		// Determine whether the array has all repeat element
		int countRepeat = 1;
		int first = arr[0];
		for (int i = 1; i < len; i++) {
			if(arr[i] == first) {
				countRepeat++;
			}
			if(i == len-1) {
				if(countRepeat == len-1) {
					return 1;
				}
			}
		}
		
		Arrays.sort(arr);
		
		int countForward = 1;
		if(len == 10) {
			int mockCheck = arr[0];
			for(int i = 2; i < len; i++) {
			    if(arr[i] <= countForward){
			        return countForward;
			    }else{
					countForward++;
					mockCheck = arr[i];
				}
			}
			return countForward;
		}else {
			int mockCheck = arr[0];
			for(int i = 1; i < len; i++) {
			    if(arr[i] <= countForward){
			        return countForward;
			    }else{
					countForward++;
					mockCheck = arr[i];
				}
			}
			return countForward;
		}
	}

	public static void main(String[] args) ",tonybuidn
238,"class Solution {
    public static void main(String[] args)
    {
        Scanner s = new Scanner(System.in);
        int t = s.nextInt();
        for(int i = 1; i <= t; i++)
        {
            System.out.println(11111111);
            System.out.flush();
            int comp = s.nextInt();
            while(comp > 0)
            {
                if(comp > 4)
                {
                    System.out.println(11111111);
                    System.out.flush();
                } else if(comp > 2)
                {
                    System.out.println(10101010);
                    System.out.flush();
                } else if(comp == 2)
                {
                    System.out.println(10001000);
                    System.out.flush();
                } else
                {
                    System.out.println(10000000);
                    System.out.flush();
                }
                comp = ",Maarten17581
1143,"public class Solution {

    public static void main(String[] args) {

        try {
            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
            int numTests = Integer.parseInt(br.readLine());
            int cnt = 1;
            while (cnt <= numTests) {
                String first = br.readLine();
                String[] intsOne = first.split("" "");

                String second = br.readLine();
                String[] intsTwo = second.split("" "");

                String third = br.readLine();
                String[] intsThree = third.split("" "");

                int[] printer1 = new int[4];
                int[] printer2 = new int[4];
                int[] printer3 = new int[4];
                for (int i = 0; i < 4; i++) {
                    printer1[i] = Integer.parseInt(intsOne[i]);
                    printer2[i] = Integer.parseInt(intsTwo[i]);
                    printer3[i] = Integer.parseInt(intsThree[i]);
                }


                String output = task2(printer1, printer2, printer3);
                System.out.println(""Case #"" + cnt + "": "" + output);
                cnt++;
            }
        } catch (Exception ex) {

        }
    }

    private static String task2(int[] printer1, int[] printer2, int[] printer3) {

        int sum = 0;
        int[] col = new int[4];
        for (int i = 0; i < 4; i++) {
            int color = Math.min(printer3[i], Math.min(printer1[i], printer2[i]));
            sum += color;
            if (sum >= 1_000_000) {
                color -= sum - 1_000_000;
                col[i] = color;
                break;
            }
            col[i] = color;
        }

        if (sum < 1_000_000) {
            return ""IMPOSSIBLE"";
        }

        return Arrays.",skyfugl
35,"public class Solution {

    /**
     * @param args the command line arguments
     */
    
 
    
    public static void main(String[] args) {
          Scanner keyboard = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
    int a;
    int[][]array1;
int c=0;
int m=0;
int y=0;
int k=0;
    
    a = keyboard.nextInt();
    array1 = new int[a][12];

    
for (int b = 0; b<a; b++)
{
    for (int z = 0; z < 12; z++)
    {
  array1[b][z]=keyboard.nextInt();
    }
}
for (int d = 0; d < a; d++)
{

   if ((array1[d][0]<=array1[d][4])&&(array1[d][0]<=array1[d][8]))
           {
               c = array1[d][0];
           }
   else if (array1[d][4]<=array1[d][8])
   {        
               c = array1[d][4];
   }
   else
               c = array1[d][8];

   if ((array1[d][1]<=array1[d][5])&&(array1[d][1]<=array1[d][9]))
           {
               m = array1[d][1];
           }
   else if (array1[d][5]<=array1[d][9])
   {        
               m = array1[d][5];
   }
   else
               m = array1[d][9];

   if ((array1[d][2]<=array1[d][6])&&(array1[d][2]<=array1[d][10]))
           {
               y = array1[d][2];
           }
   else if (array1[d][6]<=array1[d][10])
   {        
               y = array1[d][5];
   }
   else
               y = array1[d][10];
   
      if ((array1[d][3]<=array1[d][7])&&(array1[d][3]<=array1[d][11]))
           {
               k = array1[d][3];
           }
   else if (array1[d][7]<=array1[d][11])
   {        
               k = array1[d][7];
   }
   else
               k = array1[d][11];



        if ((c+m+y+k)<1000000)
{
    System.out.println(""Case #""+(d+1)+"": IMPOSSIBLE"");
}
         
        else if (c+m+y+k>=1000000)
        {
            if (c==1000000)
            {
                y = 0;
                m = 0; 
                k = 0;
            }
            
            else if (m==1000000)
            {
                y = 0;
                c = 0; 
                k = 0;
            }
            else if (y==1000000)
            {
                c = 0;
                m = 0; 
                k = 0;
            }
            else if (k==1000000)
            {
                y = 0;
                m = 0; 
                c = 0;
            }
        
            else if (c+m>1000000)
        {
               if (c+m>1000000)
               {
                   m = (1000000 - (c));
                   y=0;
                   k = 0;
               }
               else
               {
                   y = 0;
                   k = 0;
               }
        }
         else if (c+y>1000000)
        {
               if (c+y>1000000)
               {
                   y = (1000000 - (c));
                   m=0;
                   k = 0;
               }
               else
               {
                   m = 0;
                   k = 0;
               }
        }   
         else if (c+k>1000000)
        {
               if (c+k>1000000)
               {
                   k = (1000000 - (c));
                   m=0;
                   y = 0;
               }
               else
               {
                   m = 0;
                   y = 0;
               }
        }   
         else if (m+y>1000000)
        {
               if (m+y>1000000)
               {
                   m = (1000000 - (k));
                   c=0;
                   y = 0;
               }
               else
               {
                   c = 0;
                   y = 0;
               }
        }
         
         else if (m+k>1000000)
        {
               if (m+k>1000000)
               {
                   k = (1000000 - (m));
                   c=0;
                   y = 0;
               }
               else
               {
                   c = 0;
                   y = 0;
               }
        }
         
         else if (y+k>1000000)
        {
               if (y+k>1000000)
               {
                   k = (1000000 - (y));
                   m=0;
                   c = 0;
               }
               else
               {
                   m = 0;
                   c = 0;
               }
        }       
            
            
            
            
            else if (c+m+y>1000000)
        {
               if (c+m>1000000)
               {
                   y = (1000000 - (c+m));
                   k = 0;
               }
               else 
                   k=0;
        }
            
        else if (c+m+k>1000000)
        {
               if (c+m>1000000)
               {
                   k = (1000000 - (c+m));
                   y = 0;
               }
               else 
                   y = 0;
        }    
            
                else if (y+m+k>1000000)
        {
               if (y+k>1000000)
               {
                   m = ",Ak9
624,"public class Solution {

    private static CodeJamIO io = new CodeJamIO();

    /**
     * @param args
     */
    public static void main(String[] args) {

        try {
            init();

            int numCases = Integer.parseInt(io.readNextLine()[0]);
            for (int i=1; i <= numCases; i++) {
                io.debug(""Solving Case #"" + i + ""..."");
                solveCase(i);
                io.debug(""Case #"" + i + "" solved!"");
            }

        } catch (Exception e) {
            e.printStackTrace();
        }

    }

    /**
     * Performs initial computations
     */
    private static void init() {

    }

    /**
     * Solves a Test Case
     *
     * @param caseNum
     * @throws IOException
     */
    private static void solveCase(int caseNum) throws IOException {
        // Read input
        String[] tokens = io.readNextLine();
        int n = Integer.parseInt(tokens[0]);
        int k = Integer.parseInt(tokens[1]);
        if (k > n) {
            k = n;
        }

        // Interact
        double[] p = new double[k];
        double e = 0;
        Set<Integer> rooms = new HashSet<>();

        tokens = io.readNextLine();
        rooms.add(Integer.parseInt(tokens[0]));
        int passages = Integer.parseInt(tokens[1]);
        p[0] = passages;
        e += p[0];
        double sum = 0;

        for (int i=0; i<k; i++) {
            if (p[i] > i) {
                io.println(""W"");
            } else {
                io.println(""T "" + String.valueOf(pickRoom(rooms)));
            }
            tokens = io.readNextLine();
            rooms.add(Integer.parseInt(tokens[0]));
            passages = Integer.parseInt(tokens[1]);
            passages -= sum / (n-1);
            if (p[i] > i) { // this will always be true for i==0
                p[i+1] = passages - 1;
            } else {
                p[i+1] = passages - p[i-1] / (n-1);
            }
            e += p[i+1];
            sum += p[i];
        }

        // Print results
        io.println(""E "" + String.valueOf(Math.round(e)));
    }

    /**
     * Input and Output CodeJam style
     *
     */
    private static class CodeJamIO {
        private static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        private static PrintWriter out = new PrintWriter(System.out, true);
        private static PrintWriter err = new PrintWriter(System.err, true);

        public String[] readNextLine() throws IOException {
            String line = in.readLine();
            String[] tokens = line.split(""\\\s+"");
            return tokens;
        }

        public CodeJamIO printCase(int caseNum) { return print(""Case #"" + caseNum + "": "" ); }

        public CodeJamIO print(Object o) { out.print(o); return this; }

        public CodeJamIO print(Object o[]) { return print(concat(o)); }

        public CodeJamIO print(Object o[][]) { return print(concat(o)); }

        public CodeJamIO println() { out.println(); return this; }

        public CodeJamIO printlnCase(int caseNum) { return printCase(caseNum).println(); }

        public CodeJamIO println(Object o) { return print(o).println(); }

        public CodeJamIO println(Object o[]) { return print(o).println(); }

        public CodeJamIO println(Object o[][]) { return print(concat(o)).println(); }

        public CodeJamIO println(List<Integer[]> l) { return print(concat(l)).println(); }


        private String concat(Object[] o) {
            StringBuffer buf = new StringBuffer(10*o.length);

            String delim = """";
            for (int i=0; i < o.length; i++) {
                buf.append(delim).append(o[i]);
                delim = "" "";
            }
            return buf.toString();
        }

        private String concat(Object[][] o) {
            StringBuffer buf = new StringBuffer(100*o.length);
            for (int i=0; i < o.length; i++) {
                buf.append(concat(o[i])).append(""
"");
            }
            return buf.toString();
        }

        private String concat(List<Integer[]> list) {
            StringBuffer buf = new StringBuffer();
            String delim = """";
            for (Object[] elm : list) {
                buf.append(delim).append(concat(elm)).append(""
"");
            }
            return buf.toString();
        }

        public void debug(String message) {
            err.println(Calendar.getInstance().getTime() + "": "" + message);
        }

        public void debug(String message, Object[] o) {
            err.println(Calendar.getInstance().getTime() + "": "" + message);
            err.println(""	"" + concat(o));
        }

        public void debug(String message, Object[][] o) {
            err.println(Calendar.getInstance().getTime() + "": "" + message);
            String values = concat(o);
            err.println(""	"" + values.replaceAll(""
"", ""
	""));
        }

        public void debug(String message, List<Integer[]> list) {
            err.println(Calendar.getInstance().getTime() + "": "" + message);
            String values = concat(list);
            err.println(""	"" + values.replaceAll(""
"", ""
	""));
        }

        public void flush() {
            out.flush();
            err.flush();
        }

    }
",ddimi
1080,"public class Solution {

    public static void main(String[] args) {
//        PrintWriter pw = new PrintWriter(""out.txt"");
        boolean debug = false;
        Scanner sc = null;
//        try {
//            sc = new Scanner(new FileInputStream(""in.txt""));
//        } catch (FileNotFoundException e) {
//            e.printStackTrace();
       // }
        if (!debug) sc = new Scanner(System.in);
        int T = sc.nextInt();
        for (int t = 0; t < T; t++) {
            int N = sc.nextInt();
            int[] arr = new int[N];
            for (int i = 0; i < N; i++) {
                arr[i] = sc.nextInt();
            }
            Arrays.sort(arr);
            if (debug) {
                System.out.println(""N="" + N);
                System.out.println(Arrays.toString(arr));
            }

            HashMap<String,Integer> hm=new HashMap<>();
            System.out.println(""Case #""+(t+1)+"": ""+findsubSeq(hm,arr, 0, arr.length));
            //F(x)=


        }
    }

    private static int findsubSeq(HashMap<String,Integer> hm,int[] arr, int left, int right) {
        if (left + 1 == right) {
            return 1;
        }
        if (hm.get(left+"":""+right)!=null){
            return hm.get(left+"":""+right);
        }
        for (int i = left; i < right; i++) {
//            System.out.println(arr[i]+"":""+(i-left+1)+"" ""+left+"" ""+right);
            if (arr[i] < i-left+1) {
                int a = Integer.MAX_VALUE;
                int b = Integer.MAX_VALUE;
                if (left + 1 < right) {
                    a = findsubSeq(hm,arr, left + 1, right);
                }
                if (left < right - 1) {
                    b = findsubSeq(hm,arr, left, right - 1);
                }
                int c=Math.max(a,b);
                hm.put(left+"":""+right,c);
                return c;
            }
        }
//        System.out.println();

hm.",raver1975
491,"public class Solution {
    static int[] dx = {0, 1, 0, -1};
    static int[] dy = {1, 0, -1, 0};
    static int mod = (1 << 31) - 1;
    static List<Integer>[] graph;

    static char[][] grid;

    static int MAX = 1000001;

    public static void main(String[] args){
        InputStream is;
        try {
            is = new FileInputStream("".\\\src\\\input\\\in.txt"");
        } catch (FileNotFoundException e) {
            is = System.in;
        }
        InputReader in = new InputReader(is);
//        PrintWriter out = new PrintWriter(System.out);
        PrintStream out = System.out;

        int t = in.nextInt();
        for (int tt=1;tt<=t;tt++){
            int n = in.nextInt();
            int k = in.nextInt();

            int fr = in.nextInt();
            int fp = in.nextInt();

            if (n <= k) {
                int total = fp;
                for (int i=1;i<=n;i++) {
                    if (i == fr) continue;
                    out.println(""T ""+ i);
                    out.flush();
                    int r = in.nextInt();
                    int p = in.nextInt();
                    total += p;
                }
                out.println(""E ""+ total/2);
            }
            else{
                out.println(""E "" + (n - 1 + fp));
                out.flush();
            }
        }
//        out.close();
    }


    static class InputReader {
        public BufferedReader reader;
        public StringTokenizer tokenizer;

        public InputReader(InputStream stream) {
            reader = new BufferedReader(new InputStreamReader(stream), 32768);
            tokenizer = null;
        }

        public String next() {
            while (tokenizer == null || !tokenizer.hasMoreTokens()) {
                try {
                    tokenizer = new StringTokenizer(reader.readLine());
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            }
            return tokenizer.nextToken();
        }

        public int nextInt() {
            return Integer.parseInt(next());
        }
        public long nextLong() {
            return Long.parseLong(next());
        }
        public double nextDouble() {return Double.",ac23
1015,"class Solution {
    public static void main(String[] args) {
        Scanner inp = new Scanner(System.in);

        int t = inp.nextInt();

        for (int j = 0; j < t; j++) {
            System.out.printf(""Case #%d: "",j+1);
            int c = inp.nextInt();
            int m = inp.nextInt();
            int y = inp.nextInt();
            int k = inp.nextInt();
            for (int i = 0; i <2 ; i++){
                int c1 = inp.nextInt();
                int m1 = inp.nextInt();
                int y1 = inp.nextInt();
                int k1 = inp.nextInt();

                c = (c1<c) ? c1 : c ;
                m = (m1<m) ? m1 : m ;
                y = (y1<y) ? y1 : y ;
                k = (k1<k) ? k1 : k ;

            }
            
            int[] arr = {c,m,y,k};
            
            int sum = 0;
            
            for(int i = 0; i<4;i++){
                sum += arr[i];
                if (sum >= 1000000){
                    arr[i] =1000000-sum+arr[i];
                    for(int l = i+1 ; l<4 ; l++){
                        arr[t]=0;
                    }
                    System.out.printf(""%d %d %d %d
"",arr[0],arr[1],arr[2],arr[3]);
                    i=5;
                }
                
                if(i==3)
                    System.out.println(""IMPOSSIBLE"");
                
            }


            
        }
    }
}",parthanos
736,"public class Solution {
  static final int WALK_LENGTH = 400;

  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);

    int T = sc.nextInt();
    for (int tc = 1; tc <= T; ++tc) {
      int N = sc.nextInt();
      int K = sc.nextInt();

      List<Integer> orders = IntStream.rangeClosed(1, N).boxed().collect(Collectors.toList());
      Collections.shuffle(orders);
      int orderIndex = 0;
      int restWalk = WALK_LENGTH;
      Map<Integer, Integer> nodeToEdgeNum = new HashMap<>();
      for (int i = 0; i <= K; ++i) {
        int R = sc.nextInt();
        int P = sc.nextInt();

        if (!nodeToEdgeNum.containsKey(R)) {
          nodeToEdgeNum.put(R, P);
        }

        if (nodeToEdgeNum.size() == N) {
          break;
        }

        if (i != K) {
          if (restWalk == 0) {
            int next = -1;
            while (true) {
              next = orders.get(orderIndex);
              if (!nodeToEdgeNum.containsKey(next)) {
                break;
              }
              ++orderIndex;
            }

            System.out.println(String.format(""T %d"", next));
            System.out.flush();

            restWalk = WALK_LENGTH;
          } else {
            System.out.println(String.format(""W""));
            System.out.flush();

            --restWalk;
          }
        }
      }

      double avgEdgeNum = computeAvgEdgeNum(N, nodeToEdgeNum);

      System.out.println(String.format(""E %d"", (long) Math.round(avgEdgeNum * N)));
      System.out.flush();
    }

    sc.close();
  }

  static double computeAvgEdgeNum(int N, Map<Integer, Integer> nodeToEdgeNum) {
    List<Integer> orders =
        nodeToEdgeNum.keySet().stream()
            .sorted(Comparator.comparing(nodeToEdgeNum::get))
            .collect(Collectors.toList());

    double sum = 0;
    for (int i = 0; i < orders.size(); ++i) {
      sum +=
          nodeToEdgeNum.get(orders.get(i))
              * (((double) nodeToEdgeNum.size() / N < 0.5 && i >= orders.size() - 2) ? 1 : 0.5);
    }

    return sum / nodeToEdgeNum.",goalboy1015
1231,"public class Solution {

  static InputReader in;
  static Map<Integer, Long> map;

  // interactive
  public static void main(String[] args) throws Exception {
    in = new InputReader(System.in);
    Locale.setDefault(Locale.US);
    int T = in.readInt();
    for (int t = 1; t <= T; t++) {
      // read
      int N = in.readInt(), K = in.readInt();
      map = new HashMap<>();
      int[] rooms = new int[N];
      for (int i = 0; i < N; i++) {
        rooms[i] = i + 1;
      }
      shuffleArray(rooms);

      // calc sol
      int lastRoom = readRooms();
      for (int i = 0; i < N; i++) {
        if (map.containsKey(rooms[i])) {
          continue;
        }
        System.out.println(""T "" + rooms[i]);
        lastRoom = readRooms();
        if (--K <= 0) {
          break;
        }
        if (map.get(lastRoom) == 1L) {
          System.out.println(""W"");
          readRooms();
        }
        if (--K <= 0) {
          break;
        }
      }

      // print
      long res = N * map.values().stream().mapToLong(l -> l).sum() / (map.size() * 2);
      System.out.println(""E "" + res);
    }
    System.out.close();
  }

  static void shuffleArray(int[] ar) {
    Random rnd = ThreadLocalRandom.current();
    for (int i = ar.length - 1; i > 0; i--) {
      int index = rnd.nextInt(i + 1);
      // Simple swap
      int a = ar[index];
      ar[index] = ar[i];
      ar[i] = a;
    }
  }

  static int readRooms() {
    int R = in.readInt();
    long C = in.readInt();
    map.put(R, C);
    return R;
  }

  static class InputReader {
    private InputStream stream;
    private byte[] buf = new byte[1024];
    private int curChar;
    private int numChars;

    public InputReader(InputStream stream) {
      this.stream = stream;
    }

    public int read() {
      if (numChars == -1) throw new InputMismatchException();
      if (curChar >= numChars) {
        curChar = 0;
        try {
          numChars = stream.read(buf);
        } catch (IOException e) {
          throw new InputMismatchException();
        }
        if (numChars <= 0) return -1;
      }
      return buf[curChar++];
    }

    public char readChar() {
      int c = read();
      while (isSpaceChar(c)) c = read();
      return (char) c;
    }

    public String readLine() {
      int c = read();
      while (isSpaceChar(c)) c = read();
      StringBuilder res = new StringBuilder();
      do {
        res.appendCodePoint(c);
        c = read();
      } while (!isEndOfLine(c));
      return res.toString();
    }

    public String readString() {
      int c = read();
      while (isSpaceChar(c)) c = read();
      StringBuilder res = new StringBuilder();
      do {
        res.appendCodePoint(c);
        c = read();
      } while (!isSpaceChar(c));
      return res.toString();
    }

    public long readLong() {
      int c = read();
      while (isSpaceChar(c)) c = read();
      int sgn = 1;
      if (c == '-') {
        sgn = -1;
        c = read();
      }
      long res = 0;
      do {
        if (c < '0' || c > '9') throw new InputMismatchException();
        res *= 10;
        res += c - '0';
        c = read();
      } while (!isSpaceChar(c));
      return res * sgn;
    }

    public int readInt() {
      int c = read();
      while (isSpaceChar(c)) c = read();
      int sgn = 1;
      if (c == '-') {
        sgn = -1;
        c = read();
      }
      int res = 0;
      do {
        if (c < '0' || c > '9') throw new InputMismatchException();
        res *= 10;
        res += c - '0';
        c = read();
      } while (!isSpaceChar(c));
      return res * sgn;
    }

    public boolean isSpaceChar(int c) {
      return c == ' ' || c == '
' || c == '\r' || c == '	' || c == -1;
    }
",thesamwiser
1079,"public class Solution {
    public static void drawFirstRow(int C){
        System.out.print(""..+"");
        for(int j = 0; j < C - 1; j ++){
            System.out.print(""-+"");
        }
        System.out.println();
    }

    public static void drawSecondRow(int C){
        System.out.print(""..|"");
        for(int j = 0; j < C - 1; j ++){
            System.out.print("".|"");
        }
        System.out.println();
    }

    public static void drawBoundary(int C){
        System.out.print(""+"");
        for(int j = 0; j < C; j ++){
            System.out.print(""-+"");
        }
        System.out.println();
    }

    public static void drawRow(int C){
        System.out.print(""|"");
        for(int j = 0; j < C; j ++){
            System.out.print("".|"");
        }
        System.out.println();
    }


    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        for(int Case = 1; Case <= T; Case ++){
            int R = sc.nextInt();
            int C = sc.nextInt();
            System.out.println(""Case #"" + Case + "":"");
            drawFirstRow(C);
            drawSecondRow(C);
            drawBoundary(C);
            for(int i = ",ql309
655,"public class Solution {

    public static void main(String[] args) {
        
        Scanner scan = new Scanner(System.in); 
        int numOfCases = ",dtarde
383,"class Solution {
    public static Scanner scan;
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int runtime = scan.nextInt();
        for(int i=0;i<runtime;i++){
            int num=scan.nextInt();
            int [] array=new int[num];
            for(int j=0;j<num;j++) array[j]=scan.nextInt();
            Arrays.sort(array);
            System.out.print(""Case #""+"" ""+(i+1)+"": "");
            int t=0;
            for(int d=0;d<array.length;d++) {
                if (array[d]>t) {
                    t++;
                }
            }
            System.",ShuoXu
1234,"public class Solution {

  static InputReader in;
  static Map<Integer, Long> map;

  // interactive
  public static void main(String[] args) throws Exception {
    in = new InputReader(System.in);
    Locale.setDefault(Locale.US);
    int T = in.readInt();
    for (int t = 1; t <= T; t++) {
      // read
      int N = in.readInt(), K = in.readInt();
      map = new HashMap<>();
      int[] rooms = new int[N];
      for (int i = 0; i < N; i++) {
        rooms[i] = i + 1;
      }
      shuffleArray(rooms);

      // calc sol
      readRooms();
      for (int i = 0; i < N; i++) {
        if (map.containsKey(rooms[i])) {
          continue;
        }
        System.out.println(""T "" + rooms[i]);
        readRooms();
        if (--K <= 0) {
          break;
        }
      }

      // print
      long res = N * map.values().stream().mapToLong(l -> l).sum() / (map.size() * 2);
      System.out.println(""E "" + res);
    }
    System.out.close();
  }

  static void shuffleArray(int[] ar) {
    Random rnd = ThreadLocalRandom.current();
    for (int i = ar.length - 1; i > 0; i--) {
      int index = rnd.nextInt(i + 1);
      // Simple swap
      int a = ar[index];
      ar[index] = ar[i];
      ar[i] = a;
    }
  }

  static int readRooms() {
    int R = in.readInt();
    long C = in.readInt();
    map.put(R, C);
    return R;
  }

  static class InputReader {
    private InputStream stream;
    private byte[] buf = new byte[1024];
    private int curChar;
    private int numChars;

    public InputReader(InputStream stream) {
      this.stream = stream;
    }

    public int read() {
      if (numChars == -1) throw new InputMismatchException();
      if (curChar >= numChars) {
        curChar = 0;
        try {
          numChars = stream.read(buf);
        } catch (IOException e) {
          throw new InputMismatchException();
        }
        if (numChars <= 0) return -1;
      }
      return buf[curChar++];
    }

    public char readChar() {
      int c = read();
      while (isSpaceChar(c)) c = read();
      return (char) c;
    }

    public String readLine() {
      int c = read();
      while (isSpaceChar(c)) c = read();
      StringBuilder res = new StringBuilder();
      do {
        res.appendCodePoint(c);
        c = read();
      } while (!isEndOfLine(c));
      return res.toString();
    }

    public String readString() {
      int c = read();
      while (isSpaceChar(c)) c = read();
      StringBuilder res = new StringBuilder();
      do {
        res.appendCodePoint(c);
        c = read();
      } while (!isSpaceChar(c));
      return res.toString();
    }

    public long readLong() {
      int c = read();
      while (isSpaceChar(c)) c = read();
      int sgn = 1;
      if (c == '-') {
        sgn = -1;
        c = read();
      }
      long res = 0;
      do {
        if (c < '0' || c > '9') throw new InputMismatchException();
        res *= 10;
        res += c - '0';
        c = read();
      } while (!isSpaceChar(c));
      return res * sgn;
    }

    public int readInt() {
      int c = read();
      while (isSpaceChar(c)) c = read();
      int sgn = 1;
      if (c == '-') {
        sgn = -1;
        c = read();
      }
      int res = 0;
      do {
        if (c < '0' || c > '9') throw new InputMismatchException();
        res *= 10;
        res += c - '0';
        c = read();
      } while (!isSpaceChar(c));
      return res * sgn;
    }

    public boolean isSpaceChar(int c) {
      return c == ' ' || c == '
' || c == '\r' || c == '	' || c == -1;
    }
",thesamwiser
9,"public class Solution {

  public static void main(String[] args) throws Throwable {
    try (BufferedReader in=new BufferedReader(new InputStreamReader(System.in))) {
      try (PrintStream out=System.out) {
        final int T=Integer.parseInt(in.readLine());
        for (int c=1; c<=T; c++) {
          final int N=Integer.parseInt(in.readLine());
          final char S[][]=new char[N][];
          final StringTokenizer tokenizer=new StringTokenizer(in.readLine());
          for (int i=0; i<N; i++) {
            S[i]=tokenizer.nextToken().toCharArray();
          }
          char[] solution=solve(S);
          if (solution==null) solution=""IMPOSSIBLE"".toCharArray();
          out.print(""Case #""+c+"": "");
          out.println(new String(solution));
        }
      }
    }
  }

  public static char[] solve(char[][] S) {
    for (char[] s:S) if (!isGood(s)) return null;
    for (int i=0; i<S.length; i++) {
      final Stack<Integer> stack=new Stack<>();
      stack.push(i);
      final Set<Integer> remaining=new TreeSet<>();
      for (int j=0; j<S.length; j++) if (j!=i) remaining.add(j);
      final char[] solution=solve(S,remaining,stack);
      if (solution!=null) return solution;
    }
    return null;
  }

  public static char[] solve(char[][] S, Set<Integer> remaining, Stack<Integer> stack) {
    if (remaining.isEmpty()) {
      final StringBuilder builder=new StringBuilder();
      for (int i:stack) builder.append(new String(S[i]));
      final char string[]=builder.toString().toCharArray();
      if (!isGood(string)) return null;
      return string;
    }
    else {
      final int lastIndex=stack.peek();
      final char[] lastString=S[lastIndex];
      final char lastLetter=lastString[lastString.length-1];
      for (int i:remaining.toArray(new Integer[0])) {
        if (S[i][0]==S[i][S[i].length-1]&&S[i][0]==lastLetter) {
          remaining.remove(i);
          stack.push(i);
          final char[] solution=solve(S,remaining,stack);
          if (solution!=null) return solution;
          stack.pop();
          remaining.add(i);
          return solution;
        }
      }
      for (int i:remaining.toArray(new Integer[0])) {
        if (S[i][0]==lastLetter) {
          remaining.remove(i);
          stack.push(i);
          final char[] solution=solve(S,remaining,stack);
          if (solution!=null) return solution;
          stack.pop();
          remaining.add(i);
          return solution;
        }
      }
      for (int i:remaining.toArray(new Integer[0])) {
        remaining.remove(i);
        stack.push(i);
        final char[] solution=solve(S,remaining,stack);
        if (solution!=null) return solution;
        stack.pop();
        remaining.add(i);
      }
      return null;
    }
  }

  public static boolean isGood(char[] s) {
    for (int i=0; i<s.length; i++) for (int j=i+2; j<s.length; j++) if (s[i]==s[j]) {
      for (int k=",ASotelo
1105,"public class Solution{
    public static void main(String args[]){
        Scanner sc=new Scanner(System.in);
        int t=sc.nextInt();
        for(int i=1;i<=t;i++){
            long c1=sc.nextLong();
            long m1=sc.nextLong();
            long y1=sc.nextLong();
            long k1=sc.nextLong();
            
            long c2=sc.nextLong();
            long m2=sc.nextLong();
            long y2=sc.nextLong();
            long k2=sc.nextLong();
            
            long c3=sc.nextLong();
            long m3=sc.nextLong();
            long y3=sc.nextLong();
            long k3=sc.nextLong();
            
            long c=Math.min(c1,Math.min(c2,c3));
            long m=Math.min(m1,Math.min(m2,m3));
            long y=Math.min(y1,Math.min(y2,y3));
            long k=Math.min(k1,Math.min(k2,k3));
            
            long r= c+m+y+k;
            if(r<1000000)
                System.out.println(""Case #""+i+"": IMPOSSIBLE"");
            else{
                if(r==1000000)
                    System.out.println(""Case #""+i+"": ""+c+"" ""+m+"" ""+y+"" ""+k);
                else{
                    r-=1000000;
                    int max=Math.max(c,Math.max(m,Math.max(y,k)));
                    if(max==c)
                        c-=r;
                    else if(max==m)
                        m-=r;
                    else if(max==y)
                        y-=r;
                    else
                        k-=r;
                    System.",rituV
77,"public class Solution 
{
	private class Module
	{
		int fun;
		int to = 0;
		LinkedList<Integer> pointers = new LinkedList<Integer>();
		
		public int getChain(Module[] modules)
		{
			if(pointers.size() == 0)//no pointers
			{
				return fun;
			}
			else if(pointers.size() == 1)//down the chain
			{
				return Math.max(fun, modules[pointers.get(0)].getChain(modules));
			}
			else
			{
				int min = Integer.MAX_VALUE;
				int index = -1;
				for(int i: pointers)//find smallest branch
				{
					int result = modules[i].getChain(modules);
					if(result < min)
					{
						min = result;
						index = i;
					}
				}
				
				for(int i: pointers)//prunes all other branches
				{
					if(i != index)
					{
						modules[i].to = -1;
					}
				}
				//return fun;
				return Math.max(fun, min);
			}
		}
	}
	
    public static void main(String[] args) 
	{
		Solution sol = new Solution();
		sol.solve();
	}
    
    public void solve()
    {
    	Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));//make scanner
		int t = in.nextInt();//number of test cases
		for (int i = 1; i <= t; i++) //iterate through test cases
		{
			int n = in.nextInt();
			Module[] modules = new Module[n];
			for(int rep = 0; rep < n; rep++)
			{
				modules[rep] = new Module();
				modules[rep].fun = in.nextInt();
			}
			
			for(int rep = 0; rep < n; rep++)
			{
				int pointed = in.nextInt()-1;
				if(pointed == -1)
				{
					modules[rep].to = pointed;
				}
				else
				{
					modules[rep].to = pointed;
					modules[pointed].pointers.add(rep);	
				}
			}
			//int total = 0;
			long total = 0;
			for(int rep = 0; rep < n; rep++)
			{
				if(modules[rep].to == -1)
				{
					total += modules[rep].getChain(modules);
				}
			}


			System.out.println(""Case #"" + i + "": "" + total);
		}

		in.",CoCoCoder
815,"public class Solution {

  public static void main(String[] args) {
    Scanner sc = new Scanner(System.in);
    int cases = sc.nextInt();
    for(int a=1; a<=cases; a++){
      while (true){
        //give 1, ... n
        int n = sc.nextInt();
        ArrayList<Integer> myInts = new ArrayList<>();
        for(int i=1; i<=n; i++){
          myInts.add(i);
          if(i!=n){
            System.out.print(i + "" "");
          }
          else{
            System.out.println(i);
          }
        }
        System.out.flush();

        ArrayList<Integer> ret = new ArrayList<Integer>();


        //scan in the next N numbers
        for(int i=0; i<n; i++){
          myInts.add(sc.nextInt());
        }


        Collections.sort(myInts);

        long sum = 0;
        for(int i=0; i<2*n; i++){
          sum += myInts.get(i);
        }
        long target = sum / 2;


        int index = n*2 - 1;
        long current = myInts.get(index);
        ret.add(myInts.get(index));
        index--;

        //scan the given n integers
        while(index >= n){
          if(current >= target){
            continue;
          }
          if(current + myInts.get(index) <= target){
            current+= myInts.get(index);
            ret.add(myInts.get(index));
          }
          index--;

        }


        //pick the remaining integers from 1, 2, ... n
        while(index >=0){
          if(current == target){
            break;
          }
          if(current + myInts.get(index) <= target){
            current += myInts.get(index);
            ret.add(myInts.get(index));
          }
          index--;

        }


        if(target != current){
          int asdf = 0/0;
        }


        for(int i=0; i<ret.size(); i++){
          if(i != ret.size()-1){
            System.out.print(ret.get(i) + "" "");
          }
          else{
            System.out.println(ret.get(i));
          }
        }

        System.",jedya
784,"public class Solution {

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        PrintStream out = System.out;

//        try {
//            in = new Scanner(new BufferedReader(new FileReader(""/Users/Shared/Sources/CodingStudy/src/codejam/year2022/round_QA/D1000000/sample/sample_ts1-in.txt"")));
//            out = new PrintStream(new FileOutputStream(""/Users/Shared/Sources/CodingStudy/src/codejam/year2022/round_QA/D1000000/sample/sample_ts1-out.txt""));
//        } catch (Exception e) {
//            e.printStackTrace();
//            return;
//        }

        int T = in.nextInt();
        for (int t = 1; t <= T; t++) {
            int N = in.nextInt();
            int[] S = new int[N];
            for (int i = 0; i < N; i++) {
                S[i] = in.nextInt();
            }
            int max = getAnswer(S);

            out.printf(""Case #%d: %d
"", t, max);
        }
        in.close();
    }

    private static int getAnswer(int[] S) {
        /*Sliding windows*/
        int[] copyS = Arrays.copyOf(S, S.length);
        Arrays.sort(copyS);

        int maxLen = Integer.MIN_VALUE;
        for (int left = 0; left < S.length; left++) {
            for (int right = left; right < S.length; right++) {
                if (isAcceptable(copyS, left, right)) {
                    maxLen = Math.max(maxLen, right - left + 1);
                }
            }
        }

        return maxLen;
    }

    private static boolean isAcceptable(int[] copyS, int left, int right) {
        int val = 1;
        for(int i=left;i<=right;i++){
            if( val <= copyS[i]){
                val++;
            }else{
                return false;
            }
        }

        return true;
    }

}",id
612,"public class Solution {
    public static void main(String[] args) {
        (new Solution()).readInput();
    }


    public void readInput() {
        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        int caseCount = in.nextInt();
        for (int caseId = 1; caseId <= caseCount; ++caseId) {
            int n = in.nextInt();
            int k = in.nextInt();
            List<Long> numbers = new ArrayList<>();
            for (int i=0;i<n;i++) {
                numbers.add(in.nextLong());
            }
            try {
                System.out.println(""Case #"" + caseId + "": "" + solveMaster(numbers,k));
            } catch (Exception e) {
                System.out.println(""Case #"" + caseId + "": "" + ""IMPOSSIBLE"");
            }
        }
    }

    private String solveMaster(List<Long> numbers,int k) throws Exception{
        List<Long> originalList = new ArrayList<>();
        originalList.addAll(numbers);

        List<Long> copiedNumbers = new ArrayList<>();
        copiedNumbers.addAll(originalList);

        try {
            return solve(copiedNumbers, k);
        } catch (Exception e) {
            //
        }

        if (k>1){
            for (int sign=-1;sign<2;sign+=2){
                for (int i=1;i<100;i++){
                    copiedNumbers = new ArrayList<>();
                    copiedNumbers.addAll(originalList);


                    long add=(i*sign);
                    copiedNumbers.add(add);

                    try {
                        return add+"" ""+solve(copiedNumbers, k-1);
                    } catch (Exception e) {
                        //
                    }

                }
            }
        }
        return ""IMPOSSIBLE"";
    }

    private String solve(List<Long> numbers,int k) throws Exception{
        if (k==0){
            throw new Exception();
        }

        long a=0;
        long b=0;
        for (long number : numbers){
            a=a+ number*number;
            b=b+number;
        }

        if (a==0){
            return ""0"";
        } else if (b==0){
            return ""IMPOSSIBLE"";
        } else {
            double result = ((a-b*b)/(2.0*b));
            long longResult = Math.round(result);
            if (result==longResult){
                return """"+longResult;
            } else {
                if (longResult == 0) {
                    longResult++;
                }
                numbers.add(longResult);
                return """" + longResult + "" "" + solve(numbers, k - 1);
            }
//
//            long pairSums = 0;
//            for (int i = 0; i < numbers.size() - 1; i++) {
//                for (int j = i + 1; j < numbers.size(); j++) {
//                    pairSums = pairSums + (numbers.get(i) * numbers.get(j));
//                }
//            }
//
//            long sum = 0;
//            for (int i = 0; i < numbers.size(); i++) {
//                sum += numbers.get(i);
//            }
//
//            System.out.println(""P: ""+pairSums+""	""+""S: ""+sum);
//
//            double result = -1 * ((double) pairSums) / sum;
//            long longResult = Math.round(result);
//
//            if (result == longResult) {
//                return """" + longResult;
//            } else {
//                if (longResult == 0) {
//                    longResult++;
//                }
//                numbers.add(longResult);
//                return """" + longResult + "" "" + solve(numbers, k - 1);
//            }

        }

    }
}",dboteanu
524,"public class Solution{

    static long MOD = 1_000_000_007L;
    //static long MOD = 998_244_353L;
    //static long MOD = 1_000_000_033L;
    static long inv2 = (MOD + 1) / 2;
    static long [] fac;
    static long [] pow;
    static long [] inv;
    static long [] invFac;
    static int[][] dir = new int[][]{{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
    static long lMax = 0x3f3f3f3f3f3f3f3fL;
    static int iMax = 0x3f3f3f3f;
    static HashMap <Long, Long> memo = new HashMap();
    static MyScanner sc = new MyScanner();
    //static ArrayList <Integer> primes;

    static long[] pow2;
    static int[] base;
    static int[] numOfDiv;
    static ArrayList <Integer> primes;
    //-----------PrintWriter for faster output---------------------------------
    public static PrintWriter out;
    public static void main(String[] args) {
        out = new PrintWriter(new BufferedOutputStream(System.out));
        // Start writing your solution here. -------------------------------------

        int nn = 300000;

        /*fac = new long[nn + 1];
        fac[1] = 1;
        for(int i = 2; i <= nn; i++)
            fac[i] = fac[i - 1] * 1L * i % MOD;*/

        /*pow = new long[nn + 1];
        pow[0] = 1L;
        for(int i = 1; i <= nn; i++)
            pow[i] = pow[i - 1] * 2L % MOD;
        pow[1] = 3L;*/

        /*
        pow2 = new long[nn + 1];
        pow2[0] = 1L;
        for(int i = 1; i <= nn; i++)
            pow2[i] = pow2[i - 1] * 2L;*/

        /*inv = new long[nn + 1];
        inv[1] = 1;
        for (int i = 2; i <= nn; ++i)
            inv[i] = (MOD - MOD / i) * inv[(int)(MOD % i)] % MOD;

        invFac = new long[nn + 1];
        invFac[1] = 1;
        for(int i = 2; i <= nn; i++)
            invFac[i] = invFac[i - 1] * inv[i] % MOD;*/

        //primes = sieveOfEratosthenes(100001);


        /*for(int i = 2; i <= 20000000; i++)
            if(numOfDiv[i] == 0)
                for(int j = i; j <= 20000000; j += i)
                    numOfDiv[j] ++;*/

        int t = 1, tt = 0;
        t = sc.ni();
        while(tt++ < t) {
            //long res = solve();
            //out.print(""Case #"" + tt + "": "");
            solve();
            //out.println(res);
        }
        out.close();
    }
    static void solve() {
        int N = sc.ni();
        long sum = 0, curSum = 0;
        int[] A = new int[N];
        ArrayList <Integer> list = new ArrayList();
        int thres = Math.min(N, 31);
        for(int i = 0; i < thres; i++) A[i] = 1 << (thres - i - 1);
        for(int i = thres; i < N; i++) {
            A[i] = 500 + i;
            list.add(A[i]);
        }
        for(int i = 0; i < N; i++) System.out.print(A[i] + "" "");
        System.out.println();
        System.out.flush();
        int[] B = sc.na(N);
        for(int i = 0; i < N; i++) list.add(B[i]);
        for(int i : A) sum += i;
        for(int i : B) sum += i;
        HashSet <Integer> AA = new HashSet(), BB = new HashSet();
        for(int i : list) {
            if(curSum + i <= sum / 2) {
                AA.add(i);
                curSum += i;
            } else BB.add(i);
        }
        for(int i = 0; i < thres; i++) {
            if(curSum + A[i] <= sum / 2) {
                AA.add(A[i]);
                curSum += A[i];
            } else BB.add(A[i]);
        }
        for(int i : AA) System.out.print(i + "" "");
        System.out.println();
    }

    static long c(int a, int b) {
        if(a <= 0 || b <= 0 || a <= b) return 1L;
        return fac[a] * invFac[b] % MOD * invFac[a - b] % MOD;
    }

    // SegmentTree range min/max query From uwi
    public static class SegmentTreeRMQ {
        public int M, H, N;
        public long[] st;

        public SegmentTreeRMQ(int n)
        {
            N = n;
            M = Integer.highestOneBit(Math.max(N-1, 1))<<2;
            H = M>>>1;
            st = new long[M];
            Arrays.fill(st, 0, M, Integer.MAX_VALUE);
        }

        public SegmentTreeRMQ(long[] a)
        {
            N = a.length;
            M = Integer.highestOneBit(Math.max(N-1, 1))<<2;
            H = M>>>1;
            st = new long[M];
            for(int i = 0;i < N;i++){
                st[H+i] = a[i];
            }
            Arrays.fill(st, H+N, M, Integer.MAX_VALUE);
            for(int i = H-1;i >= 1;i--)propagate(i);
        }

        public void update(int pos, int x)
        {
            st[H+pos] = x;
            for(int i = (H+pos)>>>1;i >= 1;i >>>= 1)propagate(i);
        }

        private void propagate(int i)
        {
            st[i] = Math.min(st[2*i], st[2*i+1]);
        }

        public long minx(int l, int r){
            long min = Long.MAX_VALUE;
            if(l >= r) return min;
            while(l != 0){
                int f = l&-l;
                if(l+f > r)break;
                long v = st[(H+l)/f];
                if(v < min)min = v;
                l += f;
            }

            while(l < r){
                int f = r&-r;
                long v = st[(H+r)/f-1];
                if(v < min) min = v;
                r -= f;
            }
            return min;
        }

        public long min(int l, int r){ return l >= r ? 0 : min(l, r, 0, H, 1);}

        private long min(int l, int r, int cl, int cr, int cur)
        {
            if(l <= cl && cr <= r){
                return st[cur];
            }else{
                int mid = cl+cr>>>1;
                long ret = Long.MAX_VALUE;
                if(cl < r && l < mid){
                    ret = Math.min(ret, min(l, r, cl, mid, 2*cur));
                }
                if(mid < r && l < cr){
                    ret = Math.min(ret, min(l, r, mid, cr, 2*cur+1));
                }
                return ret;
            }
        }
    }

    public static char[] rev(char[] a){char[] b = new char[a.length];for(int i = 0;i < a.length;i++)b[a.length-1-i] = a[i];return b;}
    public static int[] rev(int[] a, int start, int end){int[] b = a.clone();for(int i = start;i <= end;i++) b[start + end - i] = a[i];return b;}
    public static int[] rev(int[] a){return rev(a, 0, a.length - 1);}

    public static double dist(double a, double b){
        return Math.sqrt(a * a + b * b);
    }
    public static double dist(int[] A, int[] B){
        return dist(1.0 * A[0] - B[0], 1.0 * A[1] - B[1]);
    }

    public static long inv(long a){
        return quickPOW(a, MOD - 2);
    }

    public class Interval {
        int start;
        int end;
        public Interval(int start, int end) {
            this.start = start;
            this.end = end;
        }
    }

    public static ArrayList<Integer> sieveOfEratosthenes(int n) {
        boolean prime[] = new boolean[n + 1];
        Arrays.fill(prime, true);
        for (int p = 2; p * p <= n; p++) {
            if (prime[p]) {
                for (int i = p * 2; i <= n; i += p) {
                    prime[i] = false;
                }
            }
        }
        ArrayList<Integer> primeNumbers = new ArrayList<>();
        for (int i = 2; i <= n; i++) {
            if (prime[i]) {
                primeNumbers.add(i);
            }
        }
        return primeNumbers;
    }


    public static int lowerBound(int[] a, int v){ return lowerBound(a, 0, a.length, v); }
    public static int lowerBound(int[] a, int l, int r, int v)
    {
        if(l > r || l < 0 || r > a.length)throw new IllegalArgumentException();
        int low = l-1, high = r;
        while(high-low > 1){
            int h = high+low>>>1;
            if(a[h] >= v){
                high = h;
            }else{
                low = h;
            }
        }
        return high;
    }
    public static int rlowerBound(int[] a, int v){ return lowerBound(a, 0, a.length, v); }
    public static int rlowerBound(int[] a, int l, int r, int v)
    {
        if(l > r || l < 0 || r > a.length)throw new IllegalArgumentException();
        int low = l-1, high = r;
        while(high-low > 1){
            int h = high+low>>>1;
            if(a[h] <= v){
                high = h;
            }else{
                low = ",anhpp123
478,"public class Solution {

    public static void main(String[] args) {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        try {
            int T = Integer.parseInt(br.readLine());
            for (int ti = 1; ti <= T; ti++) {
                String[] temp = br.readLine().split("" "");
                int N = Integer.parseInt(temp[0]);
                int K = Integer.parseInt(temp[1]);

                temp = br.readLine().split("" "");
                int R = Integer.parseInt(temp[0]);
                int P = Integer.parseInt(temp[1]);

                List<Integer> roomNumbers = new ArrayList<>();
                for (int i = 1; i <= N; i++) {
                    if (R != i) {
                        roomNumbers.add(i);
                    }
                }
                long sumP = P;
                int k = 0;
                int flag = 1;
                HashMap<Integer, Integer> pMap = new HashMap<>();
                for (int i = 0; i < K && i < N; i++) {
                    if (roomNumbers.size() == 0) {
                        break;
                    }
                    if (flag == 0) {
                        int roomIndex = (int) (Math.random() * roomNumbers.size());
                        System.out.println(""T "" + roomNumbers.get(roomIndex));
                    } else {
                        System.out.println(""W"");
                    }
                    flag = (flag + 1) % 4;
                    
                    temp = br.readLine().split("" "");
                    R = Integer.parseInt(temp[0]);
                    int idx = Collections.binarySearch(roomNumbers, R);

                    if (idx >= 0) {
                        roomNumbers.remove(idx);
                        P = Integer.parseInt(temp[1]);
                        Integer pCount = pMap.get(P);
                        if (pCount == null) {
                            pCount = 1;
                        } else {
                            pCount++;
                        }
                        pMap.put(P, pCount);

                        sumP += P;
                        k++;
                    }
                }

                int remainRoomCount = N - k - 1;
                double predictSum = sumP;
                if (remainRoomCount > 0) {
                    for (Map.Entry<Integer, Integer> entry : pMap.entrySet()) {
                        Integer pNumber = entry.getKey();
                        Integer pCount = entry.getValue();
                        predictSum += pNumber * (remainRoomCount * (pCount / (k + 1.0)));
                    }
                    predictSum /= 2.0;
                }
                System.out.println(""E "" + Math.round(predictSum));
            }
        } catch (IOException e) {
            e.",absee
1106,"public class Solution{
    public static void main(String args[]){
        Scanner sc=new Scanner(System.in);
        int t=sc.nextInt();
        for(int i=1;i<=t;i++){
            long c1=sc.nextLong();
            long m1=sc.nextLong();
            long y1=sc.nextLong();
            long k1=sc.nextLong();
            
            long c2=sc.nextLong();
            long m2=sc.nextLong();
            long y2=sc.nextLong();
            long k2=sc.nextLong();
            
            long c3=sc.nextLong();
            long m3=sc.nextLong();
            long y3=sc.nextLong();
            long k3=sc.nextLong();
            
            long c=Math.min(c1,Math.min(c2,c3));
            long m=Math.min(m1,Math.min(m2,m3));
            long y=Math.min(y1,Math.min(y2,y3));
            long k=Math.min(k1,Math.min(k2,k3));
            
            long r= c+m+y+k;
            if(r<1000000)
                System.out.println(""Case #""+i+"": IMPOSSIBLE"");
            else{
                if(r==1000000)
                    System.out.println(""Case #""+i+"": ""+c+"" ""+m+"" ""+y+"" ""+k);
                else{
                    r/=4;
                    c-=r;
                    m-=r;
                    y-=r;
                    k-=r;
                    System.",rituV
599,"public class Solution {
    public static void main(String[] args) {
        Scanner s = new Scanner(System.in);
        int T = s.nextInt();
        for (int ii = 1; ii <= T; ii++) {
            int N = s.nextInt();

            int[] f = new int[N];

            int[] p = new int[N];

            HashMap<Integer, ArrayList<Integer>> adjM = new
                    HashMap<>();


            for (int i = 0; i < N; i++) {
                f[i] = s.nextInt();
            }

            for (int i = 0; i < N; i++) {
                p[i] = s.nextInt();
            }

            HashSet<Integer> intermediate = new HashSet<>();
            for (int i = 0; i < N; i++) {
                intermediate.add(p[i]);
                if (p[i] != 0) {
                    if (adjM.get(i + 1) != null) {
                        ArrayList<Integer> ar = adjM.get(i + 1);
                        ar.add(p[i]);
                        adjM.put(i + 1, ar);
                    } else {
                        ArrayList<Integer> ar = new ArrayList<>();
                        ar.add(p[i]);
                        adjM.put(i + 1, ar);
                    }


                }
            }
            int[] leaf = new int[N - intermediate.size() + 1];
            int j = 0;
            for (int i = 0; i < N; i++) {
                if (!intermediate.contains(i + 1)) {
                    leaf[j] = i + 1;
                    j++;
                }
            }
            boolean[] visited = new boolean[N + 1];
            long ans = 0;
            int n = 0;
            long max = -1;
            List<List<Integer>> permute = permute(leaf);

            for(List<Integer> list : permute){
                visited = new boolean[N + 1];
                ans = 0;

                for(Integer i1 : list){
                    if (!visited[i1]) {
                        // System.out.println(""v="" + leaf[i]);
                        ans = ans + dfs(i1, adjM, visited, f);

                    }
                }
                max = Math.max(max, ans);
            }


            System.out.println(""Case #"" + ii + "": "" + max);


        }
    }

    static long dfs(int src,
                    HashMap<Integer, ArrayList<Integer>> adjM,
                    boolean[] visited, int[] f) {
        visited[src] = true;
        long funValue = f[src - 1];

        Stack<Integer> stk = new Stack<Integer>();
        stk.push(src);

        while (!stk.isEmpty()) {
            int u = stk.pop();
            if (adjM.get(u) != null) {
                for (Integer v : adjM.get(u)) {
                    if (!visited[v]) {
                        stk.push(v);
                        funValue = Math.max(funValue, f[v - 1]);
                        visited[v] = true;
                    }
                }
            }
        }

        return funValue;

    }

    public static List<List<Integer>> permute(int[] arr) {
        List<List<Integer>> list = new ArrayList<>();
        permuteHelper(list, new ArrayList<>(), arr);
        return list;
    }

    private static void permuteHelper(List<List<Integer>> list, List<Integer> resultList, int[] arr) {

        // Base case
        if (resultList.size() == arr.length) {
            list.add(new ArrayList<>(resultList));
        } else {
            for (int i = 0; i < arr.length; i++) {

                if (resultList.contains(arr[i])) {
                    // If element already exists in the list then skip
                    continue;
                }
                // Choose element
                resultList.add(arr[i]);
                // Explore
                permuteHelper(list, resultList, arr);
                // Unchoose element
                resultList.",dattap
476,"public class Solution {

    public static void main(String[] args) {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        try {
            int T = Integer.parseInt(br.readLine());
            for (int ti = 1; ti <= T; ti++) {
                String[] temp = br.readLine().split("" "");
                int r = Integer.parseInt(temp[0]);
                int c = Integer.parseInt(temp[1]);
                System.out.println(""Case #"" + ti + "": 
"" + solve(r, c));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    public static String solve(int r, int c) {

        StringBuilder sb = new StringBuilder();

        for (int row = 0; row < r; row++) {
            // top line
            for (int col = 0; col < c; col++) {
                if (row == 0 && col == 0) {
                    sb.append(leftTopCell());
                } else {
                    sb.append(cellTop());
                }
            }
            sb.append(rightEndCellTop());

            // middle line
            for (int col = 0; col < c; col++) {
                if (row == 0 && col == 0) {
                    sb.append(leftTopCell());
                } else {
                    sb.append(cellMiddle());
                }
            }
            sb.append(rightEndCellMiddle());

            // bottom line
            if (row == r - 1) {
                for (int col = 0; col < c; col++) {
                    sb.append(cellBottom());
                }
                sb.append(rightEndCellBottom());
            }

        }
        return sb.toString();
    }

    public static String leftTopCell() {
        return "".."";
    }

    public static String cellTop() {
        return ""+-"";
    }

    public static String cellMiddle() {
        return ""|."";
    }

    public static String cellBottom() {
        return ""+-"";
    }

    public static String rightEndCellTop() {
        return ""+
"";
    }

    public static String rightEndCellMiddle() {
        return ""|
"";
    }

    public static String rightEndCellBottom() {
        return ""+
"";
    }

",absee
905,"class Solution
{
	public static void main (String[] args) throws java.lang.Exception
	{
		// your code goes here
	    	int i, j, k, dices;
		Scanner reader = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		
		long cases, max, res;
		long[] setup;
		String anotherLine = """";
		
		Map<Long, Long> assoc;

		cases = Long.parseLong(reader.nextLine());
		
		for(i = 0; i < cases; i++) {
		    dices = Integer.parseInt(reader.nextLine());
		    
		    try {
		        setup = getLine(reader, dices);
		    } catch (Exception e) {
		        return;
		    }
		   
		    Arrays.sort(setup);

		    assoc = new HashMap<Long, Long>();
		    for(j = 0, max = setup[0]; j < dices; j++) {
		        if(setup[j] > max) max = setup[j];
		        if(assoc.containsKey(setup[j])) { res = assoc.get(setup[j]); assoc.put(setup[j], res + 1l); }
		        else assoc.put(setup[j], 1l);
		    }
		    
		    for(j = 0, res = 0; j < max; j++) {
		        for(k = 0; k < dices; k++) {
		            if(setup[k] >= (long)(j + 1) && assoc.get(setup[k]) > 0) { 
				    assoc.put(setup[k], assoc.get(setup[k]) - 1l);
				    res += 1l;
				    break;
			    }
		        }
		    }
		    
		    System.out.println(""Case #"" + (i + 1) + "": "" + res);
		}
		return;
	}
	
	public static long[] getLine(Scanner pipe, int num) throws java.lang.Exception
	{
	    int i = 0;
	    long[] result = null;
	    String anotherLine = """";
	    try {
	        anotherLine = pipe.nextLine();
	    } catch (Exception e) {
	        System.out.println(""Out of format"");
	        return result;
	    }
	    
	    StringTokenizer st = new StringTokenizer(anotherLine, "" "");
		if (st.countTokens() != num) {
		    System.out.println(""Out of format."");
		    return result;
		}
		
		result = new long[num];
		while (st.hasMoreTokens()) {
		    result[i++] = ",krizor
147,"public class Solution { //Solution
	static int INF = (int)(1e9);
	static long mod = (long)(1e9)+7;
	static long mod2 = 998244353;
	static long[] segtree;
	static char[] curans;
	static long ans;	
	static String S;
	static ArrayList<Integer>[] graph;
	static boolean[] vis;
	static int[] a;
	static int N;
	static long K;
	static long[] fact;
	static ArrayList<Long> pos;
	static ArrayList<Long> neg;
	static long[] max;
	static int[] dp;
	static long mx;
	static long[] fun;
	public static void main(String[] args) {  //Cash out
		/*(Notes)
		 * 
		 * 
		 * */
		FastScanner I = new FastScanner(); //Input
		OutPut O = new OutPut(); //Output
		
		int T = I.nextInt();
		for (int t = 1; t <= T; t++) {
			
			int N = I.nextInt();
			int P = I.nextInt();
			
			long[][] a = new long[N + 1][P + 1];
			
			for (int i = 1; i <= N; i++) {
				for (int j = 1; j <= P; j++) {
					a[i][j] = I.nextLong();
				}
			}
			
			long[][] dp = new long[N + 1][P + 1];
			long[] max = new long[N + 1];
			long[] min = new long[N + 1];
			
			Arrays.fill(max, Long.MIN_VALUE);
			Arrays.fill(min, Long.MAX_VALUE);
			
			for (int i = 1; i <= N; i++) {
				for (int j = 1; j <= P; j++) {
					dp[i][j] = Long.MAX_VALUE;
				}
			}
			
			for (int i = 1; i <= N; i++) {
				for (int j = 1; j <= P; j++) {
					max[i] = Math.max(max[i], a[i][j]);
					min[i] = Math.min(min[i], a[i][j]);
				}
			}
			
			for (int j = 1; j <= P; j++) {
				dp[1][j] = max[1] + Math.abs(max[1] - a[1][j]);
				//Pump starts at 0
			}
			
			for (int i = 2; i <= N; i++) {
				for (int j = 1; j <= P; j++) {
					for (int k = 1; k <= P; k++) {
						long best1 = Math.abs(a[i - 1][k] - max[i]);
						best1 += Math.abs(max[i] - min[i]);
						best1 += Math.abs(a[i][j] - min[i]);
						best1 += dp[i - 1][k];
						
						long best2 = Math.abs(a[i - 1][k] - min[i]);
						best2 += Math.abs(max[i] - min[i]);
						best2 += Math.abs(a[i][j] - max[i]);
						best2 += dp[i - 1][k];
						
						dp[i][j] = Math.min(dp[i][j], best1);
						dp[i][j] = Math.min(dp[i][j], best2);
					}
				}
			}
			
			long ans = Long.MAX_VALUE;
			
			for (int j = 1; j <= P; j++) {
				ans = Math.min(ans, dp[N][j]);
			}
			
			O.pln(""Case #"" + t + "": "" + ans);
		}
		
	}
	
	public static boolean pal(String x) {
		int N = x.length();
		
		for (int i = 0; i < N / 2; i++) {
			if (x.charAt(i) != x.charAt(N - i - 1)) {
				return false;
			}
		}
		
		return true;
	}
	
	public static ArrayList<String> perms(int N, int upper){
		if (N==1) {
			ArrayList<String> ret = new ArrayList<String>();
			for (int i = 1; i<=upper; i++) ret.add(Integer.toString(i)+"" "");
			return ret;
		}
		ArrayList<String> prev = perms(N-1,upper);
		ArrayList<String> ret = new ArrayList<String>();
		for (int i = 0; i < prev.size(); i++) {
			boolean[] vis = new boolean[upper+1];
			String cur = prev.get(i);
			String[] parts = cur.split("" "");
			for (int j = 0; j < parts.length; j++) {
				vis[Integer.parseInt(parts[j])]=true;
			}
			for (int j = 1; j <= upper; j++) {
				if (!vis[j]) {
					String curans = cur;
					curans+=Integer.toString(j)+"" "";
					ret.add(curans);
				}
			}
		}
		return ret;
	}
	
	public static void DFS(int start) {
		if (start == 0) {
			return;
		}
		
		vis[start] = true;
		mx = Math.max(mx, fun[start]);
		int next = graph[start].get(0); // We only ever point to one node at a time
		if (vis[next]) {
			return;
		}
		
		DFS(next);
	}
	
	public static long C(int N, int K) {
		long ans = fact[N];
		ans *= FastExp(fact[K], mod - 2);
		ans %= mod;
		
		ans *= FastExp(fact[N - K], mod - 2);
		ans %= mod;
		
		return ans;
	}
	
	
	public static double[][] matrix_exp(double[][] a, long exp, long mod) {
		int R = a.length;
		int C = a[0].length;
		double[][] ans = new double[R][C];
		
		boolean mult_yet = false;
		
		while (exp > 0) {
			if (exp % 2 == 1) {
				if (!mult_yet) {
					mult_yet = true;
					for (int i = 0; i < R; i++) {
						for (int j = 0; j < C; j++) {
							ans[i][j] = a[i][j]; 
						}
					}
				}else {
					double[][] new_ans = mult(ans, a, mod);
					for (int i = 0; i < R; i++) {
						for (int j = 0; j < C; j++) {
							ans[i][j] = new_ans[i][j]; 
						}
					}
				}
			}
			
			double[][] new_a = mult(a, a, mod); // a = a^2 (binary exponentiation on matrices)
			for (int i = 0; i < R; i++) {
				for (int j = 0; j < C; j++) {
					a[i][j] = new_a[i][j]; 
				}
			}
			exp /= 2;
		}
		
		return ans;
	}
	public static double[][] mult(double[][] a, double[][] b, long mod) {
		int r1 = a.length;
		int c1 = a[0].length;
		int r2 = b.length;
		int c2 = b[0].length;
		//Requires: c1 = r2
		
		double[][] ans = new double[r1][c2];
		for (int r = 0; r < r1; r++) {
			for (int c = 0; c < c2; c++) {
				//Dot product of (a[r])^T and b[c] (as vectors in R^n (n = c1 = r2))
				double[] col_vector = new double[r2];
				double[] row_vector = new double[c1];
				
				for (int i = 0; i < r2; i++) {
					col_vector[i] = b[i][c];
				}
				for (int i = 0; i < c1; i++) {
					row_vector[i] = a[r][i]; 
				}
				
				ans[r][c] = dot_product(row_vector, col_vector, mod);
			}
		}
		return ans;
	}
	
	public static double dot_product(double[] a, double[] b, long mod) {
		double ans = 0;
		int N = a.length; //Requires: a and b are both vectors in R^n
		for (int i = 0; i < N; i++) {
			ans += a[i] * b[i];
		}
		return ans;
	}
	public static double max(double a, double b) {return Math.max(a, b);}
	public static double min(double a, double b) {return Math.min(a, b);}
	public static long min(long a, long b) {return Math.min(a,b);}
	public static long max(long a, long b) {return Math.max(a,b);}
	public static int min(int a, int b) {return Math.min(a,b);}
	public static int max(int a, int b) {return Math.max(a,b);}
	public static long abs(long x) {return Math.abs(x);}
	public static long abs(int x) {return Math.abs(x);}
	public static long ceil(long num, long den) {long ans = num/den; if (num%den!=0) 
	ans++; return ans;}
	public static long GCD(long a, long b) {
		if (a==0||b==0) return max(a,b);
		return GCD(min(a,b),max(a,b)%min(a,b));
	}
	public static long FastExp(long base, long exp) {
		long ans=",IQEmperor
853,"class Solution{
    public static void main(String[] args){
        Scanner s = new Scanner(System.in);
        int t = s.nextInt();
        int x = t;
        while(t>0){
            System.out.print(""Case #""+(x-(t-1))+"":"");
            int a1 = s.nextInt();
            int a2 = s.nextInt();
            int a3 = s.nextInt();
            int a4 = s.nextInt();
            int b1 = s.nextInt();
            int b2 = s.nextInt();
            int b3 = s.nextInt();
            int b4 = s.nextInt();
            int c1 = s.nextInt();
            int c2 = s.nextInt();
            int c3 = s.nextInt();
            int c4 = s.nextInt();
            int min1 = Math.min(a1, Math.min(b1, c1));
            int min2 = Math.min(a2, Math.min(b2, c2));
            int min3 = Math.min(a3, Math.min(b3, c3));
            int min4 = Math.min(a4, Math.min(b4, c4));
            int c  = 0;
            int d = 0;
            if(min1+min2+min3+min4 ==1000000){
                System.out.print("" ""+min1);
                System.out.print("" ""+min2);
                System.out.print("" ""+min3);
                System.out.print("" ""+min4);
                System.out.println();
            }
            else if(min1+min2+min3+min4 <1000000){
                System.out.print("" IMPOSSIBLE"");
                System.out.println();
            }
            else{
                int twoSum = min1+min2;
                int rem = 1000000 - twoSum;
                
                if(min3< rem && min4> rem){
                    c = min3;
                    d = 1000000 - (c+twoSum);
                }
                if(min3> rem && min4< rem){
                    d = min3;
                    c = 1000000 - (d+twoSum);
                }
                else if(min3<rem && min4<rem){
                    if(min3+min4 == rem){
                        c = min3;
                        d = min4;
                    }
                    else{
                        c = rem-min3;
                        d = 1000000 -(c+twoSum);
                    }
                    
                }
                else if(min3>rem){
                    c= min3-rem;
                    d = 1000000 -(c+twoSum);
                }
                else if(min4>rem){
                    d = min4-rem;
                    c = 1000000 -(d+twoSum);
                }
                System.out.print("" ""+min1);
                System.out.print("" ""+min2);
                System.out.print("" ""+c);
                System.out.print("" ""+d);
                System.",kaushik_0705
380,"public class Solution {
    public static Scanner scan;
    public static void main(String[] args) {
        Scanner scan = new Scanner(System.in);
        int runtime = scan.nextInt();
        int a=1000000000;
        for(int i=0;i<runtime;i++){
            int num=scan.nextInt();
            int [] array=new int[num];
            int [] array2=new int[num];
            for(int j=0;j<num;j++) array[j]=scan.nextInt();
            Arrays.sort(array);
            System.out.print(""Case #""+"" ""+(i+1)+"": "");
            int t=0;
            for(int d=0;d<array.length;d++) {
                t++;
                if (array[d]<t) {
                    t--;
                }
            }
            System.",ShuoXu
911,"class Solution
{
	public static void main (String[] args) throws java.lang.Exception
	{
		// your code goes here
	    	int i, j, k, dices;
		Scanner reader = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
		
		long cases, max, res;
		long[] setup;
		String anotherLine = """";
		
		Map<Long, Long> assoc;

		cases = Long.parseLong(reader.nextLine());
		
		for(i = 0; i < cases; i++) {
		    dices = Integer.parseInt(reader.nextLine());
		    
		    try {
		        setup = getLine(reader, dices);
		    } catch (Exception e) {
		        return;
		    }
		    
		    assoc = new HashMap<Long, Long>();
		    for(j = 0, max = setup[0]; j < dices; j++) {
		        if(setup[j] > max) max = setup[j];
		        
		        if(assoc.containsKey(setup[j])) assoc.put(setup[j], assoc.get(setup[j]) + 1l);
		        else assoc.put(setup[j], 1l);
		    }
		    
		    for(j = 0, res = 0; j < max; j++) {
		        for(k = 0; k < dices; k++) {
		            if(setup[k] < (long)(j + 1) && assoc.get(setup[k]) > 0) { assoc.put(setup[k], assoc.get(setup[k]) - 1l); res += 1l; }
		        }
		    }
		    
		    System.out.println(""Case #"" + (i + 1) + "": "" + (res + 1));
		}
		return;
	}
	
	public static long[] getLine(Scanner pipe, int num) throws java.lang.Exception
	{
	    int i = 0;
	    long[] result = null;
	    String anotherLine = """";
	    try {
	        anotherLine = pipe.nextLine();
	    } catch (Exception e) {
	        System.out.println(""Out of format"");
	        return result;
	    }
	    
	    StringTokenizer st = new StringTokenizer(anotherLine, "" "");
		if (st.countTokens() != num) {
		    System.out.println(""Out of format."");
		    return result;
		}
		
		result = new long[num];
		while (st.hasMoreTokens()) {
		    result[i++] = ",krizor
625,"public class Solution {

    private static CodeJamIO io = new CodeJamIO();

    /**
     * @param args
     */
    public static void main(String[] args) {

        try {
            init();

            int numCases = Integer.parseInt(io.readNextLine()[0]);
            for (int i=1; i <= numCases; i++) {
                io.debug(""Solving Case #"" + i + ""..."");
                solveCase(i);
                io.debug(""Case #"" + i + "" solved!"");
            }

        } catch (Exception e) {
            e.printStackTrace();
        }

    }

    /**
     * Performs initial computations
     */
    private static void init() {

    }

    /**
     * Solves a Test Case
     *
     * @param caseNum
     * @throws IOException
     */
    private static void solveCase(int caseNum) throws IOException {
        // Read input
        String[] tokens = io.readNextLine();
        int n = Integer.parseInt(tokens[0]);
        int k = Integer.parseInt(tokens[1]);
        if (k > n) {
            k = n;
        }

        // Interact
        double[] p = new double[n];
        double e = 0;
        Set<Integer> rooms = new HashSet<>();

        tokens = io.readNextLine();
        rooms.add(Integer.parseInt(tokens[0]));
        int passages = Integer.parseInt(tokens[1]);
        p[0] = passages;
        e += p[0];
        double sum = 0;

        for (int i=0; i<k-1; i++) {
            if (p[i] > i) {
                io.println(""W"");
            } else {
                io.println(""T "" + String.valueOf(pickRoom(n, rooms)));
            }
            tokens = io.readNextLine();
            rooms.add(Integer.parseInt(tokens[0]));
            passages = Integer.parseInt(tokens[1]);
            if (p[i] > i) {
                p[i+1] = passages - 1;
            } else {
                p[i+1] = passages - p[i] / (n-1);
            }
            p[i+1] -= sum / (n-1);
            e += p[i+1];
            sum += p[i];
        }
        e *= 1.0 * n / k;

        // Print results
        io.println(""E "" + String.valueOf(Math.round(e)));
    }

    private static int pickRoom(int n, Set<Integer> rooms) {
        for (int i=0; i<n; i++) {
            if (!rooms.contains(i+1)) {
                return i+1;
            }
        }
        throw new RuntimeException();
    }

    /**
     * Input and Output CodeJam style
     *
     */
    private static class CodeJamIO {
        private static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        private static PrintWriter out = new PrintWriter(System.out, true);
        private static PrintWriter err = new PrintWriter(System.err, true);

        public String[] readNextLine() throws IOException {
            String line = in.readLine();
            String[] tokens = line.split(""\\\s+"");
            return tokens;
        }

        public CodeJamIO printCase(int caseNum) { return print(""Case #"" + caseNum + "": "" ); }

        public CodeJamIO print(Object o) { out.print(o); return this; }

        public CodeJamIO print(Object o[]) { return print(concat(o)); }

        public CodeJamIO print(Object o[][]) { return print(concat(o)); }

        public CodeJamIO println() { out.println(); return this; }

        public CodeJamIO printlnCase(int caseNum) { return printCase(caseNum).println(); }

        public CodeJamIO println(Object o) { return print(o).println(); }

        public CodeJamIO println(Object o[]) { return print(o).println(); }

        public CodeJamIO println(Object o[][]) { return print(concat(o)).println(); }

        public CodeJamIO println(List<Integer[]> l) { return print(concat(l)).println(); }


        private String concat(Object[] o) {
            StringBuffer buf = new StringBuffer(10*o.length);

            String delim = """";
            for (int i=0; i < o.length; i++) {
                buf.append(delim).append(o[i]);
                delim = "" "";
            }
            return buf.toString();
        }

        private String concat(Object[][] o) {
            StringBuffer buf = new StringBuffer(100*o.length);
            for (int i=0; i < o.length; i++) {
                buf.append(concat(o[i])).append(""
"");
            }
            return buf.toString();
        }

        private String concat(List<Integer[]> list) {
            StringBuffer buf = new StringBuffer();
            String delim = """";
            for (Object[] elm : list) {
                buf.append(delim).append(concat(elm)).append(""
"");
            }
            return buf.toString();
        }

        public void debug(String message) {
            err.println(Calendar.getInstance().getTime() + "": "" + message);
        }

        public void debug(String message, Object[] o) {
            err.println(Calendar.getInstance().getTime() + "": "" + message);
            err.println(""	"" + concat(o));
        }

        public void debug(String message, Object[][] o) {
            err.println(Calendar.getInstance().getTime() + "": "" + message);
            String values = concat(o);
            err.println(""	"" + values.replaceAll(""
"", ""
	""));
        }

        public void debug(String message, List<Integer[]> list) {
            err.println(Calendar.getInstance().getTime() + "": "" + message);
            String values = concat(list);
            err.println(""	"" + values.replaceAll(""
"", ""
	""));
        }

        public void flush() {
            out.flush();
            err.flush();
        }

    }
",ddimi
180,"public class Solution {

	
	public static void main(String[] args) {
		Scanner s = new Scanner(System.in);
		int cases = s.nextInt();
		
		for(int caseIndex=0;caseIndex<cases;caseIndex++) {
			Node.ABYSS=new Node(0,0);
			int nodeCount = s.nextInt();
			Node[] nodes = new Node[nodeCount];
			for(int i=0;i<nodeCount;i++) {
				nodes[i]=new Node(i+1,s.nextLong());
			}
			
			ArrayList<Node> initiators = new ArrayList<>(Arrays.asList(nodes));
			
			for(int i=0;i<nodeCount;i++) {
				int parent = s.nextInt();

				if(parent>0) {
					initiators.remove(nodes[parent-1]);
					nodes[i].parent=nodes[parent-1];
					nodes[parent-1].children.add(nodes[i]);
				}else {
					nodes[i].parent=Node.ABYSS;
					Node.ABYSS.children.add(nodes[i]);
				}
			}
			
			ArrayList<Node> results = new ArrayList<>();
			Node.ABYSS.traverse(results);
			long maxValue = 0;
			for(Node initiator : results) {
				maxValue += initiator.validate();
				
			}
			//System.out.println(results+"":""+maxValue);

			
			
			/*long maxValue = 0;
			List<List<Node>> permutations = permute(initiators.toArray(new Node[] {}));

			for(List<Node> permutation : permutations) {
				for(Node n : nodes) {
					n.parentTaken=false;
				}
				long result = 0;
				for(Node n : permutation) {
					result += n.validate(0);
					//System.out.println(""Validating""+n);
				}
				//System.out.println(permutation+"":""+result);
				if(result>maxValue) {
					maxValue=result;
				}
			}*/
			
			System.out.println(""Case #""+(caseIndex+1)+"": ""+maxValue);
			
			
			
			
		}
		
		s.close();

	}
	
	public static List<List<Node>> permute(Node[] arr) {
        List<List<Node>> list = new ArrayList<>();
        permuteHelper(list, new ArrayList<>(), arr);
        return list;
    }
 
    private static void permuteHelper(List<List<Node>> list, List<Node> resultList, Node[] arr){
 
        // Base case
        if(resultList.size() == arr.length){
            list.add(new ArrayList<>(resultList));
        } 
        else{
            for(int i = 0; i < arr.length; i++){ 
 
                if(resultList.contains(arr[i])) 
                {
                    // If element already exists in the list then skip
                    continue; 
                }
                // Choose element
                resultList.add(arr[i]);
                // Explore
                permuteHelper(list, resultList, arr);
                // Unchoose element
                resultList.remove(resultList.size() - 1);
            }
        }
    } 
	
	public static class Node{
		long fun;
		int id;
		Node parent;
		ArrayList<Node> children = new ArrayList<>();
		public static Node ABYSS = new Node(0,0);
		boolean used = false;
		
		public Node(int id, long fun) {
			this.id=id;
			this.fun=fun;
		}
		
		
		public void traverse(ArrayList<Node> initiators) {
			
			
			if(children.isEmpty()) {
				initiators.add(this);
				return;
			}
			
			
			HashMap<Node, Long> order = new HashMap<>();
			for(Node n : children) {
				order.put(n,n.testTraverse());
			}
			
			/*List<Node> sortedNodes = 
				     order.entrySet().stream()
				    .sorted(Entry.<Node,Integer>comparingByValue().reversed())
				    .map(e->e.getKey())
				    .collect(Collectors.toList());
			
			
			for(Object n : sortedNodes) {
				((Node)n).traverse(initiators);
			}*/
			
			Map<Object, Object> sortedMap = 
				     order.entrySet().stream()
				    .sorted(Entry.comparingByValue())
				    .collect(Collectors.toMap(Entry::getKey, Entry::getValue,
				                              (e1, e2) -> e1, LinkedHashMap::new));
			
			
			for(Object n : sortedMap.keySet()) {
				((Node)n).traverse(initiators);
			}
			
			
			
		}
		
		public long testTraverse() {
			if(children.isEmpty()) {
				return fun;
			}
			
			long max=0;
			for(Node n : children) {
				long result = n.testTraverse();
				if(result>max) {
					max=result;
				}
			}
			return max;
		}
		
		public long validate() {
			used=true;
			if(this != ABYSS && !parent.used) {
				return Math.max(fun, parent.validate());
			}else {
				return fun;
			}
			
		}
		
		@Override
		public String toString() ",KovacsA22
1093,"public class Solution {

    public static void main(String[] args) {
        Scanner sc = null;
        // try {
            // sc = new Scanner(new FileInputStream(""in.txt""));
        // } catch (FileNotFoundException e) {
            // e.printStackTrace();
        // }
        sc=new Scanner(System.in);
        int T = sc.nextInt();
        for (int t = 0; t < T; t++) {
            String s = sc.next();
            if (s.length()==1){
                System.out.println(""Case #"" + (t + 1) + "": "" + s);
                continue;
            }
            String out = """";
            //System.out.println(s);
            char a = ' ';
            char b = ' ';
            for (int i = 0; i < s.length() - 1; i++) {
                a = s.charAt(i);
                int c = 1;
                b = s.charAt(i + c);
                while (b == a) {
                    if (i + c >= s.length() - 1) {
                        //b = (char) 255;
                        break;
                    }
                    b = s.charAt(i + (++c));
                }
                if (a < b) {
                    out = out + """" + a + """" + a;
                } else {
                    out = out + """" + a;
                }
            }
            out += b;
            System.",raver1975
577,"public class Solution {
    private final PrintStream out;
    Scanner scanner;

    public Solution(InputStream in, PrintStream out) {
        scanner = new Scanner(new BufferedReader(new InputStreamReader(System.in)));
        this.out = out;
    }

    public static void main(String[] args) throws IOException {
        new Solution(System.in, System.out).solve();
    }

    void solve() {
        int T = scanner.nextInt();
        for (int t = 1; t <= T; t++) {
            int n = scanner.nextInt();
            int k = scanner.nextInt();
            int r = scanner.nextInt();
            int pnum = scanner.nextInt();
            Map<Integer, Integer> map = new HashMap<>();
            map.put(r,  pnum);
            List<Integer> lst = new ArrayList<>();
            for (int i = 0; i < n; i++) {
                lst.add(i + 1);
            }
            Collections.shuffle(lst);
            int i = 0;
            int j = 0;
            while ( i < k) {
                if(j>=n) break;
                out.println(String.format(""T %d"", lst.get(j)));
                i++;
                out.flush();
                r = scanner.nextInt();
                pnum = scanner.nextInt();
                map.put(r, pnum);
                if(i>=k) break;
                if(pnum==1) {
                    out.println(""W"");
                    out.flush();
                    r = scanner.nextInt();
                    pnum = scanner.nextInt();
                    map.put(r, pnum);
                    i++;
                }

                j++;
            }

            double avg = 0;
            for(int v : map.values()) {
                avg += v;
            }
            double sum = avg;
            avg /= map.size();
            int missing = n - map.size();
            sum += missing*avg;
            sum /= 2;
            String cmd = ",bdomokos74
